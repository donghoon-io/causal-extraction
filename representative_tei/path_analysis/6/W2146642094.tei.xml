<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Pruning Infeasible Paths for Tight WCRT Analysis of Synchronous Programs</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Sidharta</forename><surname>Andalam</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Electrical and Computer Engineering</orgName>
								<orgName type="institution">University of Auckland</orgName>
								<address>
									<country key="NZ">New Zealand</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Partha</forename><forename type="middle">S</forename><surname>Roop</surname></persName>
							<email>p.roop@aucklanduni.ac.nz</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Electrical and Computer Engineering</orgName>
								<orgName type="institution">University of Auckland</orgName>
								<address>
									<country key="NZ">New Zealand</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Alain</forename><surname>Girault</surname></persName>
							<email>alain.girault@inria.fr</email>
							<affiliation key="aff1">
								<orgName type="laboratory">POP ART team</orgName>
								<orgName type="institution">INRIA Grenoble Rhône-Alpes LIG</orgName>
								<address>
									<settlement>Grenoble</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Pruning Infeasible Paths for Tight WCRT Analysis of Synchronous Programs</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.1" ident="GROBID" when="2025-10-14T19:11+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Synchronous programs execute in discrete instants, called ticks. For real-time implementations, it is important to statically determine the worst case tick length, also known as the worst case reaction time (WCRT). While there is a considerable body of work on the timing analysis of procedural programs, such analysis for synchronous programs has received less attention. Current state-of-the art analyses for synchronous programs use integer linear programming (ILP) combined with path pruning techniques to achieve tight results. These approaches first convert a concurrent synchronous program into a sequential program. ILP constraints are then derived from this sequential program to compute the longest tick length.</p><p>In this paper, we use an alternative approach based on model checking. Unlike conventional programs, synchronous programs are concurrent and state-space oriented, making them ideal for model checking based analysis. We propose an analysis of the abstracted state-space of the program, which is combined with expressive data-flow information, to facilitate effective path pruning. We demonstrate through extensive experimentation that the proposed approach is both scalable and about 67% tighter compared to the existing approaches.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I. Introduction</head><p>Synchronous programs have a formal model of computation based on the synchrony hypothesis. This facilitates formal analysis and also ensures that all correct synchronous programs satisfy determinism (safety) and reactivity (liveness) properties. This hypothesis abstracts time into discrete instants so that outputs happen instantaneously relative to the inputs. In a nutshell, this hypothesis requires that the idealized synchronous program executes infinitely fast relative to its environment. For all practical purposes, however, the synchrony hypothesis can be respected if the maximum length of computation within an instant is less than the minimum inter-arrival time of events from the environment, i.e., the system is fast enough compared to its environment. Hence, it is important to be able to statically determine the worst case execution time of any instant (also known as a tick) in order to determine whether the synchrony hypothesis can be respected for a given environment. Also, to guarantee timing repeatability for real-time systems, it is essential to fix the tick length to this worst case tick length, also known as the worst case reaction time (WCRT) <ref type="bibr" target="#b4">[6]</ref> of the system.</p><p>Unlike WCRT analysis that computes the longest tick of a synchronous program, worst case execution time (WCET) analysis is the process of determining the worst cases execution path in a given program <ref type="bibr" target="#b17">[19]</ref>. While a plethora of techniques exist for WCET analysis of procedural programs, there are only a handful of techniques for determining the WCRT of synchronous programs.</p><p>For synchronous programs, the timing analysis needs to consider the following issues. Synchronous programs are logically concurrent, have complex control flow that can be preempted, and have state-boundaries in every thread (called local ticks) that must be synchronized using some form of barrier synchronization to determine global ticks. Early work on the timing analysis of synchronous programs focused on the conventional max-plus based approaches <ref type="bibr" target="#b4">[6]</ref>, where the global tick length is computed by summing up all the maximum local tick lengths. Subsequently, ILP-based formulation has been presented in <ref type="bibr" target="#b9">[11]</ref> where a synchronous program is first converted to sequential C code using the CEC <ref type="bibr" target="#b6">[8]</ref> compiler for Esterel. ILP constraints are then derived to compute the longest tick, while also taking infeasible paths in the resulting C program into account. More recently, the same researchers noticed that synchronous programs have both variable-value based infeasible paths and state-based infeasible state combinations. Hence, they have refined their ILP formulation further to prune redundant states by imposing a further execution automation to the sequential C code <ref type="bibr" target="#b8">[10]</ref>. Our opinion is that, to compute a tight WCRT value, it is counter-intuitive to convert a concurrent program to a sequential program before superimposing additional state information for pruning of infeasible paths.</p><p>Synchronous programs, being concurrent and state-space oriented, are ideal for model checking based analysis <ref type="bibr" target="#b14">[16]</ref>, where such analysis can be done by extracting information from a concurrent intermediate format directly. Earlier model checking based analysis for WCET <ref type="bibr" target="#b14">[16]</ref> were not based on an abstraction of the program. We demonstrate that abstractionbased model checking can be scalable as well as tight. This is feasible because model checking facilitates not only effective modeling of concurrency and state-space exploration, but also techniques for computing loop bounds and infeasible path pruning. Earlier works on model checking based analysis were of exponential complexity, since either timed automaton with real-valued clocks were used <ref type="bibr" target="#b3">[5]</ref> or synchronous Kripke structures were created <ref type="bibr" target="#b12">[14]</ref>. Also, algebraic formulation of the same problem <ref type="bibr" target="#b13">[15]</ref> was also recently developed, where infeasible path pruning did not include state dependencies. The paper advances the state-of-the-art in the following ways:</p><p>(1) We propose the first model checking based efficient formulation for WCRT analysis of synchronous program that combines abstraction-based model checking with very efficient techniques for pruning infeasible paths. <ref type="bibr" target="#b0">(2)</ref> The proposed method works directly on the concurrent program description. This approach is much more natural and scalable compared to the ILP formulation on the sequential equivalent of a concurrent program. (3) Through experimentation, we demonstrate how tightness can be improved thanks to the pruning of infeasible paths, while at the same time improving scalability of model checking.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>II. Overview of PRET-C</head><p>For our analysis, we have selected a synchronous variant of C called PRET-C <ref type="bibr" target="#b0">[2]</ref>, which is similar in spirit with an earlier synchronous C variant called ReactiveC <ref type="bibr" target="#b5">[7]</ref>. We selected PRET-C over Esterel <ref type="bibr" target="#b2">[4]</ref> thanks to its support for light-weight multi-threading, causality by construction, and support for shared variables in C, making it an ideal language to design embedded systems. Compared to ReactiveC, PRET-C is essentially C thanks to its macro-based implementation, and supports a slightly different notion of thread priorities to ensure causality <ref type="bibr" target="#b1">[3]</ref>. Yet, the proposed methodology of WCRT analysis developed for PRET-C is generic and can be also applied to the analysis of Esterel and ReactiveC.</p><p>In PRET-C, threads communicate through global variables. The proposed semantics ensures that shared memory access is thread-safe by construction <ref type="bibr" target="#b0">[2]</ref>. PRET-C supports strong and weak preemptions that are similar to immediate preemptions in Esterel. PRET-C threads have fixed priority and are compiled to a single function where "multithreading" is elicited through context switching by using a barrier synchronisation statement called EOT. Each EOT marks the end of the local tick of its thread. Concurrent threads are launched with the PAR construct. A global tick elapses only when all participating threads of a PAR reach their respective EOT. In this sense, EOT is similar to the pause statement of Esterel, enforcing synchronization between threads.</p><p>Fig. <ref type="figure">1</ref> presents a PRET-C example. PRET-C macros are included from the pretc.h file. Line 2 declares a reactive input rst, which is sampled at the start of each tick. Line 3 declares a reactive output out, which is emitted to the environment at the end of the tick. Line 4 declares a global variable j for shared communication between threads T1 and T2. Thread T1 executes for three ticks before terminating, while thread T2 has a loop, and depending on the value of j, can execute for more than two ticks. The main thread spawns T1 and T2 using the PAR statement on line 36. The textual ordering gives T1 priority over T2. This PAR is nested inside a strong Abort which evaluates the preemption condition rst==j (line 37) at the beginning of every tick. If the PAR is preempted, both threads terminate. Then, the reactive output out is updated 1 #include &lt;pretc.h&gt; 2 ReactiveInput(int,rst,0); 3 ReactiveOutput(int,out,0); 4 int j=0, x,y,z; with the value of j. More details of the PRET-C language appear in <ref type="bibr" target="#b0">[2]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>III. Static timing analysis</head><p>State-of-the-art timing analysis for synchronous programs is based on ILP. Fig. <ref type="figure" target="#fig_1">2</ref> presents a comparative overview of the ILP-based timing analysis approach <ref type="bibr" target="#b8">[10]</ref>, <ref type="bibr" target="#b10">[12]</ref> and our Model Checking based approach. The ILP approach (Fig. <ref type="figure" target="#fig_1">2a</ref>) for timing analysis of Esterel relies on the CEC compiler <ref type="bibr" target="#b6">[8]</ref> to translate Esterel into sequential C code. The generated C code is then compiled into assembly. Then, the WCET analyzer extracts the temporal properties. The control information is obtained from the compiler's intermediate format Sequential Control Flow Graph (SCFG). Then, a set of ILP constraints are generated. Finally, an ILP solver is used to compute the WCRT of the program. Our approach (Fig. <ref type="figure" target="#fig_1">2b</ref>) takes as input a PRET-C program. Unlike the ILP-based approach, we do not compile away the concurrency. We first compile the PRET-C program using the gcc compiler to obtain the assembly code for the target processor (with compiler optimizations switched off). From the assembly code, we then extract the concurrent control-flow of the program along with its temporal characteristics, which are obtained through a hardware model of the processor (captured by a control-flow graph with transition costs, called the timed concurrent control flow graph, TCCFG). Fig. <ref type="figure" target="#fig_2">3</ref> shows the TCCFG of our running example. Each node of the TCCFG is annotated with the number of clock cycles that are required to execute it e.g., the "j=3" block of T1 requires two clock cycles. EOT is implemented as a macro, which invokes the scheduler for context switching; this requires 17 clock cycles. Also, processor does not use any branch prediction: every conditional node's false branch has an extra cost of five clock cycles to account for pipeline flushing (see the "j--" block of thread T2, where we have +5 to indicate the cost of pipeline flush). More details are presented in <ref type="bibr" target="#b0">[2]</ref>. As illustrated in the next section, TCCFG is an ideal input format for an abstraction-based model checking   </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Model Checking Formulation</head><p>We convert a TCCFG into a set of equivalent timed automata (TA), where execution costs is captured on the transitions between the nodes. We use the UPPAAL model checker [1] to model our automata. We do not use any clocks but only one bounded integer to capture the execution cost. This differs from earlier work on the analysis of synchronous programs, where timed automata (TA) with real-valued clocks were used <ref type="bibr" target="#b3">[5]</ref>, for which the complexity has been shown to be PSPACE-complete <ref type="bibr" target="#b11">[13]</ref>. Our choice of UPPAAL is mainly due to our familiarity with this tool, combined with its excellent user interface. Still, the proposed approach is applicable to any other model checker with support for bounded integer counters.</p><p>Fig. <ref type="figure" target="#fig_3">4</ref> presents an automaton that captures a very abstracted model of the running example. In this abstracted model, we only capture the tick boundaries of each thread. For illustration, we have only shown thread T1 and thread T2. For example, the cost of the edge between EOT6 and EOT7 in thread T2 is 28 clock cycles, which is obtained by adding the costs of all the nodes between these two tick boundaries from the TCCFG of Fig. <ref type="figure" target="#fig_2">3</ref>. Once the automata representing the program are obtained, we create a model by composing them synchronously in the model checker. Then, timing analysis can be performed by checking a CTL property, as detailed in Section III-C. In the next section, we extend the above formulation with an efficient path pruning technique that improves both the WCRT tightness and the model-checking scalability. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Improving Tightness</head><p>In order to find tight WCRT estimates, detection and pruning of infeasible paths is essential <ref type="bibr" target="#b8">[10]</ref>. A systematic classification of infeasible paths in synchronous programs has been presented in <ref type="bibr" target="#b8">[10]</ref>, <ref type="bibr" target="#b16">[18]</ref>. They are classified into the following categories: the latter three involve some value assignment to a variable followed by a test in the control flow of the program. Hence, we group types (b) to (d) into set and test type flow-analysis. In addition to set and test and the encoding of tick transitions, we must also consider loop bounds. These three types of infeasible paths are classified as types 1, 2, and 3 as shown in Table <ref type="table">I</ref>. We further extend these three classifications with types 4, 5, and 6, by introducing more complex data-flow analysis, since the latter types are much more common in C programs. The current ILP based approach can only prune infeasible paths based on simple data-flow analysis (SDFA). They can not analyse data across ticks, and can only handle very simple set and test scenarios <ref type="bibr" target="#b16">[18]</ref>. This paper presents a much more expressive data-flow analysis (EDFA), analysing more complex set and test scenarios, and analysing data across ticks for tighter timing analysis. The rest of the section explains these differences, and the summary is presented in Table <ref type="table">I</ref>. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>1) SET AND TEST</head><p>In Fig. <ref type="figure">1</ref>, line 7, thread T1 tests the condition x&lt;z. To evaluate this condition, we need to know the value of variables x and z. From line 6, we know that the value of x will be 2. This can be obtained by applying standard constant propagation to the current local tick of the same thread. However, to analyse the value of z, we need more global knowledge, i.e., T1 needs to be aware of the data-flow from the main thread. This type of pruning is classified as type-4 in Table <ref type="table">I</ref>. In the proposed approach, we assign variable z with value 3 in the main thread. Thanks to these two assignments, the model checker can evaluate the condition x&lt;z on-the-fly.</p><p>In contrast, existing ILP approach can only handle very simple set and test scenarios (type-1 in our classification) with assignments and conditions that have constants as their righthand-side expressions <ref type="bibr" target="#b16">[18]</ref>, such as:</p><formula xml:id="formula_0">x=7; if(x&gt;3){...}</formula><p>2) ENCODING OF TICK TRANSITIONS Fig. <ref type="figure" target="#fig_3">4</ref> shows the tick transitions of thread T1 and thread T2 respectively. Without taking any data-flow into account, the first column of Table <ref type="table">II</ref> shows the possible tick transitions obtained by SDFA: e.g., the pair <ref type="bibr" target="#b0">(2,</ref><ref type="bibr" target="#b4">6)</ref> means that the second tick of T1 coincides with the sixth tick of T2. SDFA already gives a tighter result than the earlier max-plus based approach <ref type="bibr" target="#b4">[6]</ref>. We classify this type of pruning as type-2. However, if we can analyse data across the ticks and also across the threads, this will make possible further pruning of infeasible tick alignments. We classify this type of pruning as type-5. Since model checking approach can handle complex data-flow, we can prune infeasible tick transitions to states <ref type="bibr" target="#b1">(3,</ref><ref type="bibr" target="#b5">7)</ref>, <ref type="bibr" target="#b2">(4,</ref><ref type="bibr" target="#b6">8)</ref>, <ref type="bibr" target="#b3">(5,</ref><ref type="bibr" target="#b5">7)</ref> and <ref type="bibr" target="#b1">(3,</ref><ref type="bibr" target="#b6">8)</ref>, as shown in the second column of Table <ref type="table">II</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>3) LOOP BOUNDS</head><p>In synchronous programs instantaneous loops are not allowed, i.e., each loop must execute at least one EOT during every iteration. Due to the need for encoding tick transitions, finding an accurate loop bound can prune many infeasible paths. Consider, for example, the for loop on line 27 of Fig. <ref type="figure">1</ref>. In the termination condition i&lt;j in T1, the value j depends on the condition evaluated on line 8 and line 14 of thread T2. Also, j value decrements with each iteration (line 29). To analyse this loop bound, one must consider data-flow across ticks and threads. We classify this type of pruning as type-6. In our approach, we assign and test variable values on-the-fly. A similar approach to dealing with loops has been presented in <ref type="bibr" target="#b7">[9]</ref>. In contrast, current ILP-based approaches assume that the loop bounds are user-guided <ref type="bibr" target="#b16">[18]</ref>. This is only reasonable for simple loops that always terminate after a fixed number of iterations. We classify this simple and less expressive loop bound analysis as type-3 in Table <ref type="table">I</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Complexity</head><p>The UPPAAL model of Fig. <ref type="figure" target="#fig_4">5</ref> is automatically obtained from the PRET-C program. This is a simple translation with linear complexity. From this UPPAAL model, we compute the WCRT of the program by model checking a property of the form AG(gtick ⇒ W CRT ≤ val), where the value of val is determined as follows. We first calculate the W CRT max of the program by summing up the maximum local tick value for every thread. Similarly, the minimum WCRT value, W CRT min , is obtained by adding the minimum local tick lengths for each thread. Our estimated WCRT value, W CRT est , will  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IV. Results</head><p>In this section, we present a set of experimental evaluations to support our qualitative claims. We compare the effectiveness of the proposed technique by comparing the earlier ILP-based method (path pruning with SDFA in Table <ref type="table">I</ref>) with this paper's method (path pruning with EDFA in Table <ref type="table">I</ref>). We then present the effect of context sensitive timing analysis <ref type="bibr" target="#b8">[10]</ref> on tightness, number of states explored, and analysis time. The benchmarks selected for the following experiments fit entirely on the onchip memory, with one clock cycle access time. This helps us to clearly compare the infeasible paths in the program without being affected by the memory hierarchy. Also, in the ILP framework of Fig. <ref type="figure" target="#fig_1">2a</ref>, the cache analysis is performed in the final stage. In this paper, we compare our approach with ILP based "WCET with program level context" stage. To get a tight estimate, existing hardware aware static timing analyses are highly tailored to a specific processor architecture. This raises the question of how to compare work quantitatively between two research groups? Interestingly, it is not only the hardware but also a difference in compiler that can affect the tightness of the analysis. This is due to the fact that compilers can introduce infeasible paths during compilation <ref type="bibr" target="#b8">[10]</ref>. Hence, it is important to use the same processor architecture and apply the same compilation process.</p><p>We have selected the MicroBlaze processor <ref type="bibr" target="#b18">[20]</ref> along with its compilation tool chain as a common platform. For a given PRET-C benchmark, we generate the assembly files with the mb-gcc compiler, and then extract the TCCFGs. Given these TCCFGs, and based on the restrictions of the ILP approach (classified in Table <ref type="table">I</ref>), we generate two different UPPAAL models: The SDFA model with the ability to eliminate simple conflicting pairs (1 to 3 of Table <ref type="table">I</ref>), and the EDFA model which can handle more complex data-flow (1 to 6 of Table <ref type="table">I</ref>). The first column of Table IV lists a set of PRET-C benchmarks followed by the number of lines of C code under analysis. Column five presents the estimated WCRT with SDFA, while column six presents the estimated WCRT using EDFA. To evaluate the observed WCRT values (third column), we first identify the worst case execution trace using UPPAAL model Fig. <ref type="figure">6</ref>. WCRT over estimation between SDFA and EDFA based pruning. checker. We then develop the test vectors to elicit this longest path. Then, we run the benchmarks using these paths to get the observed values presented in the third column. The last column shows that, on average, the WCRT estimate is about 67% tighter with EDFA than with SDFA.</p><p>We then compare the amount of overestimation. This is done by comparing the observed WCRT (column 3 of Table <ref type="table">IV</ref>) with the computed WCRT (columns 5 and 6 respectively). The percentage overestimate of the SDFA versus EDFA approach is shown in Fig. <ref type="figure">6</ref>. On an average, the SDFA approach overestimates by 89% while EDFA approach only overestimates by about 13%.</p><p>To assess the effect of tracking additional context during model checking the following experiment was performed. We randomly classified variables in each benchmarks into four categories. Then, using our tool chain (Fig. <ref type="figure" target="#fig_1">2b</ref>), we generate five different UPPAAL models. For the first model, none of the categories in Table I are tracked. The second model tracks all the variables in the first category, the third model tracks the first and the second categories, and the fourth model tracks the first, second and third categories. Finally, the fifth model tracks all the categories. Table <ref type="table">III</ref> summarizes these experimental results. For each of the five models, we present the estimated WCRT, the time taken in milliseconds, and the number of states explored. Fig. <ref type="figure" target="#fig_6">7a</ref> plots the amount of overestimation as the amount of context information increases during WCRT analysis. An increase in context information reduces the number of infeasible paths, thus reducing the over estimation. Interestingly, Fig. <ref type="figure" target="#fig_6">7b</ref> shows that the number of states explored decreases as the context information increases. This is due to the fact that the inclusion of more context means that more paths are pruned, leading to fewer number of states explored. This also reduces the time taken to analyse. This can be observed in our largest example, the robot sonar. The initial time taken without any context information is about 9.4 seconds; this significantly drops to 0.25 seconds when the entire context information is included.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>V. Conclusions</head><p>Static timing analysis of synchronous programs is critical for validating the synchrony hypothesis for a given environment. In this paper, for the first time, we have proposed an  approach that can perform WCRT analysis on a concurrent intermediate format. This differs from earlier approaches using integer linear programming (ILP), which compile away the concurrency before deriving the ILP constraints, yielding many complications. We have developed a model checking based formulation that can efficiently deal with concurrent statespaces. We have also presented a method to prune infeasible paths much more aggressively than existing approaches. In the future, we will extend our current formulation with memory hierarchy.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>(a) Integer Linear Programming (taken from<ref type="bibr" target="#b8">[10]</ref>).(b) Model Checking (this paper).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 2. Framework comparison between ILP based approach and Model Checking approach.</figDesc><graphic coords="3,78.36,64.05,225.80,132.99" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. TCCFG of the running example</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 4 .</head><label>4</label><figDesc>Fig. 4. Abstracted model that captures only tick boundaries.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 5 .</head><label>5</label><figDesc>Fig. 5. UPPAAL model of thread T1's first tick of the running example.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>lie between the interval [W CRT min , W CRT max ]. Then, we use standard binary search to find the WCRT. The overall complexity is O(|M | × |φ|), where M is the model of the program and φ is the complexity of the query. Further details are available in<ref type="bibr" target="#b15">[17]</ref>.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig. 7 .</head><label>7</label><figDesc>Fig. 7. Context sensitive information vs tightness and states explored.</figDesc></figure>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Predictable multithreading of embedded applications using PRET-C</title>
		<author>
			<persName><forename type="first">S</forename><surname>Andalam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Roop</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Girault</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM-IEEE International Conference on Formal Methods and Models for Codesign (MEMOCODE)</title>
		<meeting>ACM-IEEE International Conference on Formal Methods and Models for Codesign (MEMOCODE)</meeting>
		<imprint>
			<date type="published" when="2010-07">July, 2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">The synchronous languages 12 years later</title>
		<author>
			<persName><forename type="first">A</forename><surname>Benveniste</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Caspi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Edwards</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Halbwachs</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">Le</forename><surname>Guernic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>De Simone</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proceedings of the IEEE</title>
		<imprint>
			<biblScope unit="volume">91</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="64" to="83" />
			<date type="published" when="2003-01">Jan 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">The Esterel synchronous programming language: design, semantics and implementation</title>
		<author>
			<persName><forename type="first">G</forename><surname>Berry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Gonthier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Science of Computer Programming</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="87" to="152" />
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Taxys = Esterel + Kronos -a tool for verifying realtime properties of embedded systems</title>
		<author>
			<persName><forename type="first">V</forename><surname>Bertin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Conference on Decision and Control</title>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Worst case reaction time analysis of concurrent reactive programs</title>
		<author>
			<persName><forename type="first">M</forename><surname>Boldt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Traulsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Von Hanxleden</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Electronic Notes in Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">203</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="65" to="79" />
			<date type="published" when="2008-06">June 2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Reactive C: An extension of C to program reactive systems</title>
		<author>
			<persName><forename type="first">F</forename><surname>Boussinot</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Software Practice and Experience</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="401" to="428" />
			<date type="published" when="1991-04">April 1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Code generation in the Columbia Esterel Compiler</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">A</forename><surname>Edwards</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Zeng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">EURASIP Journal on Embedded Systems</title>
		<imprint>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
	<note>Article ID 52651</note>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Comparison of implicit path enumeration and model checking based WCET Analysis</title>
		<author>
			<persName><forename type="first">B</forename><surname>Huber</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Schoeberl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 9th International Workshop on Worst-Case Execution Time (WCET) Analysis</title>
		<meeting>the 9th International Workshop on Worst-Case Execution Time (WCET) Analysis</meeting>
		<imprint>
			<publisher>OCG</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="23" to="34" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Contextsensitive timing analysis of Esterel programs</title>
		<author>
			<persName><forename type="first">L</forename><surname>Ju</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">K</forename><surname>Huynh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Chakraborty</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Roychoudhury</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">DAC &apos;09: Proceedings of the 46th Annual Design Automation Conference</title>
		<meeting><address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="870" to="873" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Performance debugging of Esterel specifications</title>
		<author>
			<persName><forename type="first">L</forename><surname>Ju</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">K</forename><surname>Huynh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Roychoudhury</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Chakraborty</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CODES+ISSS</title>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="173" to="178" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Timing analysis of Esterel programs on general-purpose multiprocessors</title>
		<author>
			<persName><forename type="first">L</forename><surname>Ju</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">K</forename><surname>Huynh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Roychoudhury</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Chakraborty</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">DAC</title>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="48" to="51" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Model checking timed automata with one or two clocks</title>
		<author>
			<persName><forename type="first">F</forename><surname>Laroussinie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Markey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Schnoebelen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CONCUR</title>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="387" to="401" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Generating formal models for real-time verification by exact low-level runtime analysis of synchronous programs</title>
		<author>
			<persName><forename type="first">G</forename><surname>Logothetis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Schneider</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Metzler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Real-Time Systems Symposium (RTSS)</title>
		<meeting><address><addrLine>Cancun, Mexico</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="256" to="264" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">WCRT algebra and interfaces for Esterel-style synchronous processing</title>
		<author>
			<persName><forename type="first">M</forename><surname>Mendler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Hanxleden</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Traulsen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Design, Automation and Test in Europe (DATE&apos;09)</title>
		<meeting>the Design, Automation and Test in Europe (DATE&apos;09)<address><addrLine>Nice, France</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2009-04">April 2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Why model checking can improve WCET analysis</title>
		<author>
			<persName><forename type="first">A</forename><surname>Metzner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CAV</title>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="volume">3114</biblScope>
			<biblScope unit="page" from="334" to="347" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Tight WCRT analysis for synchronous C programs</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">S</forename><surname>Roop</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Andalam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Von Hanxleden</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Yuan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Traulsen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Conference on Compilers, Architecture, and Synthesis for Embedded Systems (CASES&apos;09)</title>
		<meeting>the International Conference on Compilers, Architecture, and Synthesis for Embedded Systems (CASES&apos;09)<address><addrLine>Grenoble, France</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2009-10">October 2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Efficient detection and exploitation of infeasible paths for software timing analysis</title>
		<author>
			<persName><forename type="first">V</forename><surname>Suhendra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Mitra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Roychoudhury</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">DAC &apos;06: Proceedings of the 43rd annual Design Automation Conference</title>
		<meeting><address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="358" to="363" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">The worstcase execution-time problem-overview of methods and survey of tools</title>
		<author>
			<persName><forename type="first">R</forename><surname>Wilhelm</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Engblom</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Ermedahl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Holsti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Thesing</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Whalley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Bernat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Ferdinand</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Heckmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Mitra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Mueller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Puaut</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Puschner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Staschulat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Stenström</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Trans. on Embedded Computing Sys</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="1" to="53" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">MicroBlaze Processor Reference Guide</title>
		<author>
			<persName><surname>Xilinx</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
