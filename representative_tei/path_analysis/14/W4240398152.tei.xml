<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Static and Dynamic Variable Voltage Scheduling Algorithms for Real-Time Heterogeneous Distributed Embedded Systems</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Jiong</forename><surname>Luo</surname></persName>
							<email>jiongluo@ee.princeton.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Dept. of Electrical Engineering Princeton Univ</orgName>
								<address>
									<postCode>08544</postCode>
									<settlement>Princeton</settlement>
									<region>NJ</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Niraj</forename><surname>Jha</surname></persName>
							<email>jha@ee.princeton.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Dept. of Electrical Engineering Princeton Univ</orgName>
								<address>
									<postCode>08544</postCode>
									<settlement>Princeton</settlement>
									<region>NJ</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Static and Dynamic Variable Voltage Scheduling Algorithms for Real-Time Heterogeneous Distributed Embedded Systems</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.1" ident="GROBID" when="2025-10-21T21:18+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This paper addresses the problem of static and dynamic variable voltage scheduling of multi-rate periodic task graphs (i.e., tasks with precedence relationships) and aperiodic tasks in heterogeneous distributed real-time embedded systems. Such an embedded system may contain general-purpose processors, field-programmable gate arrays (FPGAs) and applicationspecific integrated circuits (ASICs). Variable voltage scheduling is performed only on general-purpose processors. The static scheduling algorithm constructs a variable voltage schedule via heuristics based on critical path analysis and task execution order refinement. The algorithm redistributes the slack in the initial schedule and refines task execution order in an efficient manner. The variable voltage schedule guarantees all the hard deadlines and precedence relationships of periodic tasks. The dynamic scheduling algorithm is also based on an initially valid static schedule. The objective of the on-line scheduling algorithm is to provide best-effort service to soft aperiodic tasks, as well as to reduce the system power consumption by determining clock frequencies (and correspondingly supply voltages) for different tasks at run-time, while still guaranteeing the deadlines and precedence relationships of hard real-time periodic tasks.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>This paper addresses the problem of static and dynamic variable voltage scheduling of hard and soft real-time tasks in heterogeneous distributed real-time embedded systems <ref type="bibr" target="#b0">[1]</ref>, in which processing elements (PEs) can be general-purpose processors, FPGAs or ASICs. The embedded system may have both periodic tasks with hard deadlines and precedence relationships and aperiodic tasks with soft deadlines. The goal of our scheduling algorithms is to provide good response times for soft aperiodic tasks and reduce the power consumption of the system, under the constraints that the deadlines of hard realtime tasks and their precedence relationships are guaranteed. It is well-known that variable voltage scaling, which refers to varying the speed of a processor by changing the clock frequency along with the supply voltage, has a high potential for reducing both energy and power consumption. Hence, in this paper, we focus on developing a power-efficient variable voltage scheduling algorithm for heterogeneous distributed embedded systems.</p><p>There have been extensive studies in the literature on scheduling of periodic tasks, aperiodic tasks, and their combinations. The algorithm given in <ref type="bibr" target="#b2">[3]</ref> uses slack stealing, which serves aperiodic tasks by stealing all the processing time it can from the periodic tasks. The method in <ref type="bibr" target="#b1">[2]</ref> studies resource reclaiming in shared-memory real-time multiprocessor systems, where resource reclaiming refers to exploiting a PE at run-time when the actual execution time of a task is less than its Acknowledgments: This work was supported by DARPA under contract no. DAAB07-00-C-L516 . specified worst-case execution time. Some other work addressing joint scheduling of hard periodic tasks and soft aperiodic tasks can be found in <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b10">11]</ref>.</p><p>There is some work addressing variable voltage scheduling as well. The work in <ref type="bibr" target="#b11">[12]</ref> gives an off-line algorithm, which generates a minimum-energy preemptive schedule for a set of independent tasks. The work in <ref type="bibr" target="#b13">[14]</ref> provides a heuristic for a similar problem as in <ref type="bibr" target="#b11">[12]</ref> for fixed-priority static scheduling. The work in <ref type="bibr" target="#b4">[5]</ref> proposes a heuristic scheduling algorithm for non-preemptive scheduling of a set of independent tasks with arbitrary arrival times and deadlines on a variable voltage processor, which is an NP-complete problem. The work in <ref type="bibr" target="#b12">[13]</ref> uses an energy priority heuristic for non-preemptive scheduling. The work in <ref type="bibr" target="#b5">[6]</ref> presents a power-conscious fixed-priority scheduling algorithm. Other works can be found in <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b7">8,</ref><ref type="bibr" target="#b17">18,</ref><ref type="bibr" target="#b18">19]</ref>. All the above approaches target only a single processor and are applicable to only independent tasks.</p><p>In this paper, first, we address the issue of variable voltage static scheduling in a heterogeneous distributed embedded system for a set of periodic tasks with precedence relationships and hard deadlines. A valid power-efficient variable voltage schedule is constructed using heuristics based on critical path analysis and task execution order refinement. Second, we address the issue of variable voltage joint scheduling of hard periodic tasks with precedence relationships along with soft aperiodic tasks. We take a combined static and dynamic approach. The static scheduling algorithm discussed above is used to construct a valid schedule for periodic tasks with precedence relationships. The static schedule is only partially fixed such that the on-line scheduler can schedule soft aperiodic tasks with best effort. The on-line scheduler also dynamically determines the speed-reduction ratios for scheduled events whenever there are no soft aperiodic tasks pending.</p><p>The new contributions of our approach are as follows.</p><p>(1) Although a lot of previous work has been done to optimize power consumption through variable voltage scheduling of independent real-time tasks, there is only very limited work addressing variable voltage scheduling for distributed real-time embedded systems, in which precedence relationships exist among tasks <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b15">16]</ref>. In this paper, we develop an efficient heuristic for this problem motivated by the fact that the processor power consumption is normally a convex function of the clock period. Our algorithm is optimal if the problem is reduced to non-preemptive static scheduling with fixed-priority assignment on a single processor. (2) For the on-line variable voltage scheduling algorithm, we develop a unified framework, which incorporates slack stealing and resource reclaiming to provide best effort service to soft aperiodic tasks. It performs run-time analysis of processor clock speeds and voltages assigned to statically scheduled periodic tasks, by considering dynamic execution time variations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Energy Consumption Model</head><p>This section discusses the relationship between the total energy consumption for a set of hard real-time tasks with precedence relationships implemented on multiple processors and their processor execution speeds. Similar discussions can be found in <ref type="bibr" target="#b11">[12]</ref> for independent tasks on a single processor.</p><p>The periodic tasks are specified in the form of task graphs. A task graph is a directed acyclic graph in which each node is associated with a task and each edge is associated with the amount of data that must be transferred between the two connected tasks. The period associated with a task graph indicates the time interval after which it executes again. An arrival time (deadline), the time by which the task associated with the node can begin (must complete) its execution, exists for every source (sink) node. Deadlines may exist for some intermediate nodes as well. Fig. <ref type="figure">1</ref> shows two task graphs, where for simplicity both are assumed to have the same period.</p><p>The processor clock frequency, f, can be expressed in terms of the supply voltage, dd V , and threshold voltage, t V , as follows (k is a constant):</p><formula xml:id="formula_0">dd t dd V V V k f / ) ( 2 - =<label>( 1 )</label></formula><p>From (1), we can derive dd V as a function of f,</p><formula xml:id="formula_1">) ( f F , 2 2 ) 2 ( ) 2 ( ) ( t t t dd V k f V k f V f F V - + + + = =<label>(2)</label></formula><p>The processor power, p, can be expressed in terms of the frequency, f, switched capacitance, N, and the supply voltage, dd V , as:</p><formula xml:id="formula_2">2 2 ) ( 2 1 2 1 f fNF fNV p dd = =<label>( 3 )</label></formula><p>which can be proved to be a convex function of f. </p><formula xml:id="formula_3">[ ] 1 1 , i i b a , [ ] 2 2 , i i b a , …, [ ] ik ik b a ,</formula><p>, where . Based on the traditional assumption in distributed computing, the execution of intra-PE communication is assumed to take zero time. The total energy consumption for a set of tasks on different processors is: </p><formula xml:id="formula_4">i ik ik i i i i i finish b a b a b a start = ≤ ≤ ≤ ≤ ≤ = ...</formula><formula xml:id="formula_5">) ( * ) ( 1 ( k ik) to i k k k j processor on i j processor f p a b Energy ∑ ∑ ∑ ∈ ∀ ∀ - =<label>(5)</label></formula><formula xml:id="formula_6">i k ik) to i k k k f a b η = - ∑ ∈ * ) ( 1 (<label>( 8 )</label></formula><p>for task i.</p><p>In the above equations, predecessors(i) (successors(i)) refers to all the predecessors (successors) of task or communication edge i in the task graphs, and on the processors which are voltage scalable, in order to reduce the system power consumption.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Static Variable Voltage Scheduling for Multirate Periodic Task Graphs</head><p>This section presents a variable voltage static scheduling algorithm for multi-rate periodic tasks in an embedded system consisting of a network of multiple heterogeneous PEs connected by communication links. An embedded system is a multi-rate system if it contains multiple task graphs with different periods. Given an embedded system specification, a hardware-software co-synthesis system <ref type="bibr" target="#b0">[1]</ref> determines the number and type of PEs/communication links (i.e., allocation), and the assignment/scheduling of tasks/communications on different PEs/links.</p><p>Allocation/assignment and scheduling are each NP-complete for distributed systems <ref type="bibr" target="#b0">[1]</ref>. To reduce the problem complexity, assume we start with a valid PE/link allocation and task/communication assignment, as well as a valid static schedule under maximum supply voltage and processor frequency max f . In this paper, the static schedule is generated based on a listscheduling algorithm using the inverse of slack time as the task priority <ref type="bibr" target="#b19">[20]</ref>. The static schedule consists of a set of scheduled events, which can be a task, a communication event, or a preemption event. First, we discuss the critical path analysis algorithm, which redistributes the slack time in the initial valid schedule. Second, we discuss a task execution order refinement algorithm, which refines the execution order imposed by the slack-based priority assignment in the initial schedule. We want to construct a new valid variable voltage schedule in which a processor's clock frequency can be varied along with the supply voltage for different time intervals. The new schedule still guarantees all the hard deadlines and precedence relationships. It is well known that there exists a feasible schedule for the periodic task graphs if and only if there exists a feasible schedule for the hyperperiod, which is the least common multiple of all the task graph periods in a multi-rate system specification <ref type="bibr" target="#b8">[9]</ref>. Hence, the validity of the schedule can be determined along one hyperperiod.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">The critical path analysis algorithm</head><p>In this section, we present the critical path analysis algorithm for variable voltage scheduling based on an initially valid schedule. In the generated variable voltage schedule, all the scheduled events on a PE or a link maintain the same execution order as in the initial schedule (the execution order is modified later). We first create a directed graph )</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>, ( E V G</head><p>, where V is the set of vertices, containing all the scheduled events in the initial schedule, and E is the set of directed edges between vertices. An edge is inserted from one event to another if one is a direct predecessor of another in the task graphs, or if one is scheduled just ahead of another on the same PE or link. Therefore, these edges can represent all the precedence relationships in the original task graphs as well as execution ordering information in the initial schedule. Every event i can be associated with a start constraint i r or a finish constraint i d , which is initialized as i arrival or i deadline , respectively, as defined in Section 2. Each node is associated with a weight, which equals its worstcase execution time. The creation of ) , ( E V G can be illustrated through Example 1.</p><p>Example 1: Consider the embedded system specification given in the form of two task graphs in Fig. <ref type="figure">1</ref>. Fig. <ref type="figure">2</ref> shows the corresponding directed ) , ( E V G derived for the feasible schedule shown in Fig. <ref type="figure" target="#fig_2">3</ref>. The distributed system consists of two PEs, PE1 and PE2, connected by a link. The schedule is based on the worst-case execution times of tasks and communication times, assuming a supply voltage of 3.3V. We assume both PE1 and PE2 have communication buffers.</p><p>The variable voltage schedule is constructed by determining the processor speed reduction ratio for every scheduled event on processors, with ratio initialized to one. The algorithm is presented as Algorithm 1 in Fig. <ref type="figure">4</ref>. The algorithm evaluates all the paths in graph ) , ( E V G and locates the most critical one that minimizes the ratio of the total slack time on that path to the total worst-case execution time on that path. For a path j, assume that it begins with node source and ends with node destination. Then the scaling factor of path j, j scale , is defined as</p><formula xml:id="formula_7">∑ - = i i source n destinatio j exec wst r d scale _ / ) (<label>(9)</label></formula><p>where i exec wst _ is the worst-case execution time of scheduled event i on path j. The critical path is the one that minimizes the scaling factor.</p><p>The scaling factor of path j for tasks on processors, j scale task _ , is defined as , where i η is the worst-case execution cycle count of task i.</p><p>The critical path can be located in the following way. First, we locate the longest path, evaluated using the total worst-case execution times, between any source and destination pair. Then we pick the path that has the smallest scaling factor. Next, we multiply the speed reduction ratio for all the events scheduled on processors by a multiplying ratio, which can be set to be equal to j scale of critical path j. The speed reduction ratio for communication events and tasks implemented on FPGAs or ASICs remains unchanged (as they are assumed to be not variable voltage scalable). When j scale is below a threshold, we delete all the vertices on critical path j as well as their incoming and outgoing edges in</p><formula xml:id="formula_8">) , ( E V G</formula><p>, and update all the start and finish constraints of other vertices in a manner restricted by the execution length of the critical path, evaluated under new clock frequencies. In Algorithm 1, threshold is a value which is near or equal to 1.0 and is defined in a way so as to control the convergence rate with which the critical path approaches the state of being deleted, as well as to reduce the overhead of unnecessarily extending the execution time (with a ratio threshold ≤</p><p>) of tasks allocated to hardware and communication events. The above process is repeated until </p><formula xml:id="formula_9">= =</formula><p>In the case of scheduling on a single processor, ) , ( E V G is a set of vertices with an edge between any two adjacently scheduled events. We can compute the longest path length between any pair of vertices in the beginning. The threshold should be set to 1.0. The overall complexity is</p><formula xml:id="formula_10">) | (| 2 V O</formula><p>. The rationale behind Algorithm 1 includes:</p><p>1. For each critical path, distributing the free slack time evenly is optimal due to the fact that power consumption is a convex function of processor speed, as discussed in Section 1. 2. For the overall algorithm, guaranteeing an equal speed reduction ratio on the most critical path first is a step in the right direction for reducing the power consumption because it guarantees that all the other events can achieve a speed reduction ratio at least as high as on the most critical path. This is helpful in reducing the variance of the speed reduction ratios for various time intervals on other paths, therefore, reducing power consumption as well, again due to characteristics of the convex function. </p><formula xml:id="formula_11">} ); _ _ _ ( ; _ _ } } ; ; ){ _ ( ; ) ( ) ( _ { ; _ )){ , ( ( _ _ } } } } ); ( ); ( ); min( _ ); max( _ ; _ _ { _ ; ){ _ ( ); _ , _ ( ) ( ; _ * ) ( )) ( ( _ _ ) _ , _ , _ ( { | | )){ ( (</formula><formula xml:id="formula_12">= = = &lt; ∑ - = = ∈ ∀ = ∈ = ∉ ∈ = ∉ ∈ = + = = ≤ = = ∈ = ∀</formula><p>The overall algorithm is not optimal, however, because the updated start and finish constraints of other events are dependent on how the slack times are distributed on the critical path, when the critical path is deleted. However, if we reduce the problem to a non-preemptive scheduling algorithm on a single processor with fixed-priority assignment, since the execution order of all the jobs can be determined, Algorithm 1, which resembles the approach in <ref type="bibr" target="#b11">[12]</ref>, can be shown to be optimal for minimizing the power consumption. For the sake of brevity, we omit the proof. For the general case as well, Algorithm 1 performs very well, as evidenced by experimental results later.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Task execution order refinement</head><p>The scheduling priority assignment based on the inverse of slack may be a good heuristic for constructing a valid schedule to guarantee deadlines <ref type="bibr" target="#b19">[20]</ref>, but it may not be very efficient for fully exploiting the slack time for variable voltage scheduling. Therefore, we refine the task execution ordering based on the new variable voltage schedule, in which the execution time of every scheduled event is multiplied by its corresponding speed reduction ratio. The algorithm is shown in Fig. <ref type="figure">5</ref>. In Algorithm 2, j sched is the list of scheduled events on processor j in the order of their execution. Two adjacent events are interchangeable if interchanging their execution order will not violate any timing and precedence relationships in the new variable voltage schedule. In Algorithm 2, ) , ( j i e interchang interchanges the order of i and j in the list and returns a value that points to the second event after interchanging.  </p><formula xml:id="formula_13">→ = ≠ = = → = = ∀</formula><p>The new task execution order generated in this way can still guarantee schedule validity and has the potential to achieve larger power reduction because more flexibility is introduced in the schedule. Then we can apply Algorithm 1 based on the new execution order. Task execution order refinement can be repeated until the power reduction ratio between two iterations is less than some pre-specified threshold.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Illustrative example</head><p>Example 2 is used to illustrate the critical path analysis algorithm. Example 2: We compare three different schemes. In Scheme 1, we apply Algorithm 1 to the directed graph in Fig. <ref type="figure">2</ref>, assuming threshold in Algorithm 1 is defined as one. In Fig. <ref type="figure">2</ref>, the first critical path is (t1→e1→t2), with a scaling factor of 19/15 calculated by Equation ( <ref type="formula" target="#formula_7">9</ref>), and a task-scaling factor of , calculated by Equation <ref type="bibr" target="#b9">(10)</ref>. The second critical path is (t1→e1→e2→t5), with a scaling factor of 22/16. We take the minimum of 16/12 and 22/16, which is 16/12. Then all task execution times in the schedule are extended by a ratio of 16/12, as shown in Fig. <ref type="figure">6</ref>. In the next step, t1, e1 and t2 are deleted from ) , ( E V G , the start constraint of e2 and finish constraint of t4 are both updated to 11. Next, (t3→t4) is identified as the critical path, and all undeleted task execution times are extended by a ratio of 11/8, as shown in Fig. <ref type="figure">7</ref>. Finally, the execution time of t5 is extended by a ratio of 7/5.5, as shown in Fig. <ref type="figure">8</ref>.</p><p>In Scheme 2, instead of starting from the critical path, we first distribute the slack time equally on path (t3→t4→t2), which is the path with the second smallest task-scaling factor. The corresponding variable voltage schedule is shown in Fig. <ref type="figure">9</ref>. In Scheme 3, we compute the optimal speed reduction ratios for this small example, assuming the power consumption is computed based on Equation (3) and that t V is 0.8V. The power consumption during idle time on processors is assumed to be zero. The speed reduction ratios for different tasks and the overall power consumption on processors are compared in Table <ref type="table" target="#tab_8">1</ref>. The power number is normalized to the power consumption under maximum supply voltage (3.3V). The deviation of the power consumption of Scheme 1 from the optimal solution is Fig. <ref type="figure">4</ref>: Algorithm for determining speed reduction ratios for scheduled events on variable voltage processors only 0.1%, while for scheme 2 it is 5.8%. For larger examples, as shown in Section 5, our scheme has a greater impact.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">On-line Variable voltage Scheduling Algorithm</head><p>To maintain the simplicity and performance of the on-line scheduling algorithm, we use a combined static and dynamic approach. We start from an initially valid static schedule. The static schedule can be generated from critical path analysis and task execution order optimization techniques presented in the last section. This helps determine the task execution order and position the communication events such that the slack time is distributed more efficiently in a global manner for better variable voltage scheduling. However, processor clock frequencies as well as corresponding supply voltages are determined on-line in order to accommodate run-time execution time variations. The static schedule is partially fixed to guide the on-line scheduler in the following way: <ref type="bibr" target="#b0">(1)</ref> The schedule of all the communication events is kept fixed. This helps localize any dynamic decisions to each processor. Hence, no global re-scheduling is required at run-time. Also, the order of all the events scheduled on every processor and link is kept fixed. This helps maintain the precedence constraint among the tasks assigned to the same processor.</p><p>(2) A table generated off-line provides the earliest start and latest finish times for each scheduled event. This guides the online scheduler in providing best-effort service to soft aperiodic tasks without violating the timing constraints of statically scheduled events.</p><p>(3) We also determine an off-line variable voltage schedule for each processor using Algorithms 1 and 2. In applying these algorithms, the vertices in</p><formula xml:id="formula_14">) , ( E V G</formula><p>are all the scheduled events on a processor in one hyperperiod. The start constraint i r or finish constraint i d of a vertex is initialized as its earliest start time or its latest finish time, respectively. Recall that Algorithm 1 is optimal in the case of scheduling on a single processor with a fixed execution order of events. The off-line table also stores the start time and the speed reduction ratio of every scheduled event in the off-line variable voltage schedule.</p><p>The earliest start time is the earliest time by which an event can begin its execution without violating its arrival time and precedence relationships. The latest finish time is the latest time by which an event must complete its execution without violating the deadline and precedence relationships of itself as well as any other subsequent event scheduled on the same processor. They are computed in the following way. For the last event on a processor, we have </p><p>For any other event i on a PE, the latest finish time is calculated by</p><formula xml:id="formula_16">) _ min )), / ( _ _ ( , min( _ _ ) ( _ max j i edges out j next i next i i i time start f time finish latest deadline time finish latest ∈ → → - = η<label>(12)</label></formula><p>where out_edges(i) refers to all the inter-PE out-going communication edges of i, next is the event scheduled just after i on the same processor, and η is the worst-case execution cycle count of an event.</p><p>For event i on a PE, the earliest start time is calculated by</p><formula xml:id="formula_17">) _ max , max( _ _ ) ( _ j i edges in j i i time finish arrival time start earliest ∈ =<label>(13)</label></formula><p>where in_edges(i) refers to all the inter-PE in-coming communication edges of i. </p><formula xml:id="formula_18">r t3 t3 t4<label>t5</label></formula><p>4.1 On-line dispatching of soft aperiodic tasks Soft aperiodic tasks are served in first-in-first-out (FIFO) order. In order to provide best effort service to aperiodic tasks, the on-line scheduler on each PE dispatches tasks and communication events in the following way. Whenever there are soft aperiodic tasks pending, and the latest start time (derived from the latest finish time) of the current statically scheduled event has not been reached, the scheduler dispatches the aperiodic task under maximum speed. If there are no aperiodic tasks pending, and the earliest start time of the current event has been reached, the scheduler dispatches the current event and determines the clock frequency and supply voltage for it at runtime. If the current event is running and an aperiodic task arrives, the scheduler detects whether or not servicing the aperiodic task will violate the latest finish time of the current event. If not, the current event gets preempted and the incoming aperiodic task gets dispatched under maximum speed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Variable voltage scheduling</head><p>Run-time variations can come from remaining execution times reclaimed on-line, or from servicing soft aperiodic tasks. This makes off-line analysis of the optimal speed reduction ratio for each statically scheduled event on every processor no longer valid. If there are no soft aperiodic tasks pending, the speed reduction ratio for the current statically scheduled event can be computed on-line by applying Algorithm 3 in Fig. <ref type="figure">10</ref> for a sequence of adjacent events (from current to end), including the current event and all subsequent events scheduled on the same processor in the hyperperiod. In Algorithm 3, the start constraint i r or finish constraint i d of an event i is initialized as its earliest start time or its latest finish time, respectively. For the current event being dispatched, its start constraint r is initialized as the current time. First, the critical path is located for the set of adjacent events from current to end. Then the end event is updated as the event scheduled just ahead of the source node of the critical path. The finish constraint end d of event end is updated as well. The algorithm repeats until the source node of the critical path becomes the current event. The overall computation complexity of the algorithm is</p><formula xml:id="formula_19">) ( 2 m O</formula><p>, where m is the number of events the algorithm needs to look at.   For on-line variable voltage scheme scheduling, in Fig. <ref type="figure">12</ref> we also compare four different scheduling algorithms, which are based on four different initial static schedules, optimized by scheduling algorithms list-scheduling, schedule-shifting, critical-path-analysis and critical-path-analysis + executionorder-refinement, respectively. All the four on-line algorithms re-compute the speed reduction ratio at run-time for the adjacent set of events, as discussed in Section 4.2. The aperiodic task arrivals are modeled as a Poisson process. The actual execution cycle counts of statically scheduled events are uniformly distributed in the range of 60% to 100% of their worst-case execution cycle counts. The characteristics of soft aperiodic tasks are shown in Table <ref type="table" target="#tab_10">3</ref>. Figs. <ref type="figure">12(a</ref>) and (b) show the results for average response time of all soft aperiodic tasks and processor power consumption, respectively. The critical-pathanalysis + execution-order-refinement algorithm performs the best in terms of both average power consumption and average response time for soft aperiodic tasks. It reduces processor power consumption (average response time of soft tasks) by an average of 28% (37%) over the list-scheduling algorithm, and by an average of 12% (13%) over the schedule-shifting algorithm. This indicates that the heuristics based on critical path analysis and task execution order refinement not only improve the efficiency of variable voltage scaling, but also improve the slack time distribution so that soft aperiodic tasks can get served more efficiently without violating the timing constraints of statically scheduled events. List-scheduling Schedule-shifting Critical-path-analysis Critical-path-analysis+Execution-order-refinement Lower-bound Fig. <ref type="figure" target="#fig_2">13</ref> compares three different on-line schemes, all of which based on the static schedule generated by the criticalpath-analysis + execution-order-refinement algorithm. For every statically scheduled event, on-line Scheme 1 (latest-finishtime) calculates the speed reduction ratio for the currently dispatched event by extending its execution length to its latest finish time. On-line Scheme 2 (finish-time) calculates the speed reduction ratio by extending its execution length to its finish time in the off-line variable voltage schedule on each processor. On-line Scheme 3 (re-compute) re-computes the scaling ratio at run-time as discussed in Algorithm 3. We can see that Schemes latest-finish-time and finish-time both achieve a very close power consumption reduction to Scheme re-compute, while sacrificing the response times of soft aperiodic tasks. Scheme recompute achieves the best trade-off between processor power consumption and response times of soft aperiodic tasks. On-line lis t-s cheduling On-line s chedule-s hifting On-line critical-path-analys is On-line critical-path-analys is + execution-order-refinement</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Conclusions</head><p>This paper discussed efficient static and on-line variable voltage scheduling algorithms for distributed real-time embedded systems. The static scheduling algorithm is based on critical path analysis and task execution order refinement, motivated by the fact that power consumption is normally a convex function of processor clock frequency. The algorithm efficiently reduces power consumption of processors. The online algorithm utilizes a combined static and dynamic approach, with an objective of providing best-effort service to soft aperiodic tasks and reducing the system power consumption, under the constraint that hard deadline and precedence relationships of statically scheduled events are guaranteed. The static schedule optimized through critical path analysis and task execution order refinement, which the on-line algorithm is based on, also helps improve the slack distribution in the static schedule and results in a better service of soft aperiodic tasks. The on-line analysis of clock frequencies and supply voltages, incorporating both run-time variations and static hints, can achieve a better trade-off between average response time of soft aperiodic tasks and system power consumption. </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>Fig. 1: Task graphs</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 3 :</head><label>3</label><figDesc>Fig. 3: Initial valid schedule</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>}</head><label></label><figDesc></figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 5 :Fig. 8 :</head><label>58</label><figDesc>Fig. 5: Algorithm for task execution order refinement</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head></head><label></label><figDesc>On-line list-scheduling On-line schedule-shifting On-line critical-path-analysis On-line critical-path-analysis + execution-order-refinement</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Fig. 12 :Fig. 11 :</head><label>1211</label><figDesc>Fig. 12: Comparison of on-line algorithms based on four different static schedules</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8"><head>Table 1 :</head><label>1</label><figDesc>Comparison of power consumption of processors for different schemes</figDesc><table><row><cell>0</cell><cell>2</cell><cell>4</cell><cell>6</cell><cell>8</cell><cell cols="3">10 12 14 16 18 20 22</cell></row><row><cell>r t1</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>d t5</cell></row><row><cell>PE1:</cell><cell></cell><cell>t1</cell><cell></cell><cell></cell><cell></cell><cell>t5</cell></row><row><cell>Link:</cell><cell></cell><cell></cell><cell></cell><cell cols="2">e1</cell><cell>e2</cell></row><row><cell>PE2:</cell><cell>t3</cell><cell></cell><cell>t4</cell><cell></cell><cell></cell><cell>t2</cell></row><row><cell>r t3</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>d t2</cell></row><row><cell cols="8">Fig. 6: Task execution times multiplied by a ratio of 16/12</cell></row><row><cell>0</cell><cell>2</cell><cell>4</cell><cell>6</cell><cell>8</cell><cell cols="3">10 12 14 16 18 20 22</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>d t5</cell></row><row><cell>PE1:</cell><cell></cell><cell>t1</cell><cell></cell><cell></cell><cell></cell><cell>r e2</cell></row><row><cell>Link:</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>e1</cell><cell>e2</cell></row><row><cell>PE2:</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>t2</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>d t4</cell></row><row><cell></cell><cell cols="7">Fig. 7: Task execution times multiplied by a ratio of 11/8</cell></row><row><cell></cell><cell cols="7">(lightly shaded regions represent deleted events)</cell></row><row><cell>0</cell><cell>2</cell><cell>4</cell><cell>6</cell><cell>8</cell><cell cols="3">10 12 14 16 18 20 22</cell></row><row><cell>PE1:</cell><cell></cell><cell>t1</cell><cell></cell><cell></cell><cell></cell><cell>t5</cell></row><row><cell>Link:</cell><cell></cell><cell></cell><cell></cell><cell>e1</cell><cell cols="2">e2</cell></row><row><cell>PE2:</cell><cell>t3</cell><cell></cell><cell></cell><cell>t4</cell><cell></cell><cell>t2</cell></row><row><cell></cell><cell></cell><cell cols="6">Fig. 9: Variable voltage schedule for Scheme 2</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="3">Speed reduction ratio of statically scheduled tasks</cell><cell>Normalized power</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>t1</cell><cell>t2</cell><cell>t3</cell><cell>t4</cell><cell>t5</cell><cell>consumption</cell></row><row><cell></cell><cell cols="3">Scheme 1</cell><cell></cell><cell>8/6</cell><cell>8/6</cell><cell>5.5/3</cell><cell>5.5/3</cell><cell>7/3</cell><cell>0.5856</cell></row><row><cell></cell><cell cols="3">Scheme 2</cell><cell></cell><cell>6.5/6</cell><cell>9.5/6</cell><cell>4.75/3</cell><cell>4.75/3</cell><cell>8.5/3</cell><cell>0.6190</cell></row><row><cell></cell><cell cols="3">Scheme 3</cell><cell></cell><cell>7.751/6</cell><cell>8.249/6</cell><cell>11.249/6</cell><cell>11.249/6</cell><cell>6.751/3</cell><cell>0.5849</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_10"><head>Table 3 :</head><label>3</label><figDesc>Characteristics of soft aperiodic tasks</figDesc><table><row><cell>T e s t</cell><cell>1</cell><cell>2</cell><cell>3</cell><cell>4</cell><cell>5</cell></row><row><cell>Average arrival rate (No. arrivals/ms)</cell><cell>0.047</cell><cell>0.047</cell><cell>0.047</cell><cell>0.047</cell><cell>0.01</cell></row><row><cell>Average execution time (ms)</cell><cell>7</cell><cell>13</cell><cell>5</cell><cell>4</cell><cell>11.6</cell></row><row><cell>Total no. of soft tasks simulated</cell><cell>921</cell><cell>943</cell><cell>957</cell><cell>956</cell><cell>359</cell></row></table></figure>
		</body>
		<back>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Experimental Results</head><p>This section presents experimental results to verify the efficacy of the proposed methods. The experiment is performed on five different embedded systems. Their characteristics are shown in Table <ref type="table">2</ref>. Task graphs in Tests 1 to 4 are generated using TGFF <ref type="bibr" target="#b3">[4]</ref>, which is a randomized task graph generator. The task graphs in Test 5 are based on a digital signal processing example taken from <ref type="bibr" target="#b16">[17]</ref>. All the PEs in these systems are processors. However, our approach is general enough to be applied to embedded systems containing ASICs and FPGAs as well.</p><p>We first compare four different static scheduling algorithms in Fig. <ref type="figure">11</ref>. A lower bound of power consumption with the given task/communication assignment is computed by evenly extending the execution length of every scheduled event on a processor to make utilization of each processor 1.0, under the assumption that no deadlines and precedence relationships exist. The list-scheduling algorithm just uses the initial valid schedule generated based on slack-based list scheduling. The execution length of every scheduled event is extended locally by reducing its voltage and clock frequency without violating its timing constraints. The schedule-shifting algorithm tries to evenly extend the execution length of every scheduled event on a processor by using global schedule slot shifting <ref type="bibr" target="#b14">[15]</ref>. The critical-path-analysis algorithm uses Algorithm 1 to generate the speed reduction ratios for all the statically scheduled events. The critical-path-analysis + execution-order-refinement algorithm uses Algorithm 2 along with Algorithm 1 to refine the execution order of scheduled events. Since only processors are voltage scalable, all the different algorithms have the same power consumption on communication links. Hence, we only compare the power consumption on processors. The voltage can be varied from 3.3V to 1.4V. The power consumption is calculated based on Equation (2), where t V equals 0.8V, and is normalized to the power consumption under maximum supply voltage. The critical-path-analysis algorithm reduces processor power consumption by an average (maximum) of 30% (44%) over the list-scheduling algorithm, and by an average (maximum) of 9% (14%) over the schedule-shifting algorithm. The critical-path-analysis + execution-order-refinement algorithm further reduces processor power consumption by an average (maximum) of 7% (15%) over the critical-path-analysis algorithm. In all the test cases, the average (minimum) deviation of the critical-path-analysis + execution-order-refinement algorithm from the lower bound power consumption is 11% (5%). The average (minimum) deviation of the schedule-shifting algorithm from the lower bound power consumption is 32% (9%). Note that the lower bound is a loose one since it is based on assumptions that are not valid (e.g., no precedence relationships and deadlines exist). The CPU times (933Mhz Pentium III with 258MB memory) for the five tests are 2.2s, 5s, 2s, 35s and 0.4s, respectively, for the critical-path-analysis algorithm, and 11s, 30s, 8s, 211s and 0.4s, respectively, for the critical-path-analysis + execution-order-refinement algorithm.  </p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Hardware-software co-design of embedded systems</title>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">H</forename><surname>Wolf</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE</title>
		<meeting>IEEE</meeting>
		<imprint>
			<date type="published" when="1994-07">July 1994</date>
			<biblScope unit="volume">82</biblScope>
			<biblScope unit="page" from="967" to="989" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Resource reclaiming in multiprocessor real-time systems</title>
		<author>
			<persName><forename type="first">C</forename><surname>Shen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Ramamritham</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Parallel &amp; Distributed Systems</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="382" to="397" />
			<date type="published" when="1993-04">Apr. 1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">An optimal algorithm for scheduling soft-aperiodic tasks in fixed-priority preemptive systems</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">P</forename><surname>Lehoczky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Ramos-Thuel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Real-time Systems Symp</title>
		<meeting>Real-time Systems Symp</meeting>
		<imprint>
			<date type="published" when="1992-12">Dec. 1992</date>
			<biblScope unit="page" from="110" to="123" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">TGFF: Task graphs for free</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">P</forename><surname>Dick</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">L</forename><surname>Rhodes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Wolf</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int. Workshop Hardware/Software Codesign</title>
		<meeting>Int. Workshop Hardware/Software Codesign</meeting>
		<imprint>
			<date type="published" when="1998-03">Mar. 1998</date>
			<biblScope unit="page" from="97" to="101" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Power optimization of variable-voltage core-based systems</title>
		<author>
			<persName><forename type="first">I</forename><surname>Hong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Kirovski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Qu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Potkonjak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">B</forename><surname>Srivastava</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Computer-Aided Design</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="1702" to="1714" />
			<date type="published" when="1999-12">Dec. 1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Power conscious fixed priority scheduling for hard real-time systems</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Shin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Choi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Design Automation Conf</title>
		<meeting>Design Automation Conf</meeting>
		<imprint>
			<date type="published" when="1999-06">June 1999</date>
			<biblScope unit="page" from="134" to="139" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">The simulation and evaluation of dynamic voltage scaling algorithms</title>
		<author>
			<persName><forename type="first">T</forename><surname>Pering</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Burd</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Brodersen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int. Symp. Low Power Electronics and Design</title>
		<meeting>Int. Symp. Low Power Electronics and Design</meeting>
		<imprint>
			<date type="published" when="1998-08">Aug. 1998</date>
			<biblScope unit="page" from="76" to="81" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Variable voltage task scheduling algorithms for minimizing energy</title>
		<author>
			<persName><forename type="first">A</forename><surname>Manzak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Chakrabarti</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int. Symp. Low Power Electronics and Design</title>
		<meeting>Int. Symp. Low Power Electronics and Design</meeting>
		<imprint>
			<date type="published" when="2001-08">Aug. 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Scheduling periodically occurring tasks on multiple processors</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">L</forename><surname>Lawler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">U</forename><surname>Martel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information Processing Letters</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="9" to="12" />
			<date type="published" when="1981-02">Feb. 1981</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Joint scheduling of distributed complex periodic and hard aperiodic tasks in statically scheduled systems</title>
		<author>
			<persName><forename type="first">G</forename><surname>Fohler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Real-time Systems Symp</title>
		<meeting>Real-time Systems Symp</meeting>
		<imprint>
			<date type="published" when="1995-12">Dec. 1995</date>
			<biblScope unit="page" from="152" to="161" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Scheduling aperiodic and sporadic tasks in hard real-time systems</title>
		<author>
			<persName><forename type="first">S</forename><surname>Choi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">K</forename><surname>Agrawala</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1997-05">May 1997</date>
		</imprint>
		<respStmt>
			<orgName>University of Maryland, College Park, Dept. of Computer Science</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Tech. Rep. CS-TR-3794</note>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">A scheduling model for reduced CPU energy</title>
		<author>
			<persName><forename type="first">F</forename><surname>Yao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Demers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Shenker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Symp. Foundations of Computer Science</title>
		<imprint>
			<date type="published" when="1995-10">Oct. 1995</date>
			<biblScope unit="page" from="374" to="382" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Energy priority scheduling for variable voltage processors</title>
		<author>
			<persName><forename type="first">J</forename><surname>Pouwelse</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Langendoen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Sips</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int. Symp. Low-Power Electronics and Design</title>
		<meeting>Int. Symp. Low-Power Electronics and Design</meeting>
		<imprint>
			<date type="published" when="2001-08">Aug. 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Energy efficient fixed-priority scheduling for real-time systems on variable voltage processors</title>
		<author>
			<persName><forename type="first">G</forename><surname>Quan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Hu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Design Automation Conf</title>
		<meeting>Design Automation Conf</meeting>
		<imprint>
			<date type="published" when="2001-06">June 2001</date>
			<biblScope unit="page" from="828" to="833" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Power-conscious joint scheduling of periodic task graphs and aperiodic tasks in distributed real-time embedded systems</title>
		<author>
			<persName><forename type="first">J</forename><surname>Luo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">K</forename><surname>Jha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int. Conf. Computer-Aided Design</title>
		<meeting>Int. Conf. Computer-Aided Design</meeting>
		<imprint>
			<date type="published" when="2000-11">Nov. 2000</date>
			<biblScope unit="page" from="357" to="364" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Battery-aware static scheduling for distributed real-time embedded systems</title>
		<author>
			<persName><forename type="first">J</forename><surname>Luo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">K</forename><surname>Jha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Design Automation Conf</title>
		<meeting>Design Automation Conf</meeting>
		<imprint>
			<date type="published" when="2001-06">June 2001</date>
			<biblScope unit="page" from="444" to="449" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Fast allocation of processes in distributed and parallel systems</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">M</forename><surname>Woodside</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">G</forename><surname>Monforton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Parallel &amp; Distr. Syst</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="164" to="174" />
			<date type="published" when="1993-02">Feb. 1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Voltage-clock-scaling adaptive scheduling techniques for low power in hard real-time Systems</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">M</forename><surname>Krishna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L.-H</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Real Time Technology and Applications Symp</title>
		<meeting>Real Time Technology and Applications Symp</meeting>
		<imprint>
			<date type="published" when="2000-05">May 2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Voltage scheduling problem for dynamically variable voltage processors</title>
		<author>
			<persName><forename type="first">T</forename><surname>Ishihara</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Yasuura</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Int. Symp. Low Power Electronics and Design</title>
		<meeting>Int. Symp. Low Power Electronics and Design</meeting>
		<imprint>
			<date type="published" when="1998-08">Aug. 1998</date>
			<biblScope unit="page" from="197" to="202" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">MOCSYN: Multiobjective corebased single-chip system synthesis</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">P</forename><surname>Dick</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">K</forename><surname>Jha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Design Automation &amp; Test in Europe Conf</title>
		<meeting>Design Automation &amp; Test in Europe Conf</meeting>
		<imprint>
			<date type="published" when="1999-03">Mar. 1999</date>
			<biblScope unit="page" from="263" to="270" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">13: Comparison of three on-line schemes based on the same static schedule generated by the critical-path-analysis+ execution-order-refinement algorithm (b)</title>
		<author>
			<persName><surname>Fig</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
