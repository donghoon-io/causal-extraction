<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">QoS Analysis for Web Service Composition</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Huiyuan</forename><surname>Zheng</surname></persName>
							<email>hyzheng@comp.mq.edu.au</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computing Macquarie University Sydney</orgName>
								<orgName type="institution">ICT Centre CSIRO</orgName>
								<address>
									<settlement>Canberra</settlement>
									<country key="AU">Australia</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Weiliang</forename><surname>Zhao</surname></persName>
							<email>wzhao@comp.mq.edu.au</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computing Macquarie University Sydney</orgName>
								<orgName type="institution">ICT Centre CSIRO</orgName>
								<address>
									<settlement>Canberra</settlement>
									<country key="AU">Australia</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Jian</forename><surname>Yang</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computing Macquarie University Sydney</orgName>
								<orgName type="institution">ICT Centre CSIRO</orgName>
								<address>
									<settlement>Canberra</settlement>
									<country key="AU">Australia</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Athman</forename><surname>Bouguettaya</surname></persName>
							<email>athman.bouguettaya@csiro.au</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computing Macquarie University Sydney</orgName>
								<orgName type="institution">ICT Centre CSIRO</orgName>
								<address>
									<settlement>Canberra</settlement>
									<country key="AU">Australia</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">QoS Analysis for Web Service Composition</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="DOI">10.1109/SCC.2009.28</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.1" ident="GROBID" when="2025-10-21T21:08+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>The quality of service (QoS) is a major concern in the design and management of Web service composition. Existing methods for QoS calculation either do not take the probability of path execution into consideration when QoSs are provided for different execution paths, or do not take different execution paths into consideration when a single integrated QoS is provided for the whole composition. In this paper, a comprehensive QoS analysis approach is proposed that calculates the QoS probability distribution by considering both the execution probability and execution conditions of each path in the service composition. Four types of basic composition patterns in the service composition are discussed: sequential, parallel, loop and conditional. In particular, a QoS solution is provided for all types of loop structured service composition.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I. Introduction</head><p>Web service composition is emerging as a technique of choice for modelling and implementing business processes. With the fast adoption of Web services, one of the vexing challenges is analyzing and understanding the QoS of composite services <ref type="bibr" target="#b0">[1]</ref> <ref type="bibr" target="#b9">[10]</ref>.</p><p>It is important to estimate the QoS of a composite service at design time based on the quality of individual Web services to make sure that this composition can satisfy the expectations of end users. A Web service will be replaced at run time if it becomes unavailable or its performance degrades too much <ref type="bibr" target="#b4">[5]</ref>. The impact of a replacing service to the performance of the composition should be evaluated before the replacement takes place. Normally, functionally equivalent services may exist with different QoSs. A comparison is therefore necessary by analyzing the QoS of the composite service with different services.</p><p>Based on the way of the results being represented, existing QoS calculation methods can be classified into two categories: (1) Reduction method with single QoS for the service composition <ref type="bibr" target="#b5">[6]</ref>[8]; (2) Direct aggregation method with multiple QoSs for the service composition <ref type="bibr" target="#b2">[3]</ref> <ref type="bibr" target="#b10">[11]</ref>.</p><p>For the reduction method, the process of a composite service is seen as an integration of different types of basic composition patterns. Though the calculation methods are different for these patterns, the basic idea about QoS calculation is the same, which recursively merges the tasks of a composite service till one single compound task is reached.</p><p>The QoS for this single task is referred to as the QoS of the composite service.</p><p>The direct aggregation method is used in QoS driven Web service selection to calculate the QoS of each execution path of the composite service. The methods used in Web service selection make sure that the QoS of every path can satisfy the user's requirements.</p><p>Existing QoS calculation methods are not able to provide a complete picture of the QoS for a composite service. Their limitations will be illustrated through the following example.</p><p>Figure <ref type="figure" target="#fig_0">1</ref> is the process of a composite service with two paths. The execution probabilities of these two paths are p 1 = 0.6 and p 2 = 0.4 respectively. There is one task in each path. The cost and response time for task1 are C 1 and T 1 , for task2 are C 2 and T 2 . For each task, there are two functionally equivalent Web services to choose. The QoS (response time and cost) of these available Web services are shown in Table <ref type="table" target="#tab_0">I</ref>. The user specified requirements on QoS are: the response time should be less than 50 and the cost should be no more than 25.  First, we will show the limitations of using single values to represent the QoS of service composition. We adopt the method in <ref type="bibr" target="#b5">[6]</ref> (see Formulae 1 and 2) to calculate the QoS for the conditional composition pattern shown in Figure <ref type="figure" target="#fig_0">1</ref>.</p><formula xml:id="formula_0">T ime o f S ervice T = p 1 T 1 + p 2 T 2 (1) Cost o f S ervice C = p 1 C 1 + p 2 C 2<label>(2)</label></formula><p>In view of Formulae 1, 2, and Table <ref type="table" target="#tab_0">I</ref>, there are four possible compositions: However, if the detailed QoS probability distribution information is provided, e.g. for Composition 2, the response time is 10 for 60% of the time and 100 for 40% of the time; for Composition 3, the response time is 40 for 60% of the time and 60 for 40% of the time, Composition 3 is more likely to be selected. Simply because an extreme short response time as 10 is not needed and the long response time as 100 can not be tolerated.</p><p>From this example, it shows that the lack of information about execution probability and QoS for each path prevents the selection of the best execution plan in practice, and single values are not enough to represent the QoS of service compositions.</p><p>Next, we will show the limitations of the direct aggregation method. By adopting the Direct Aggregation Method, each path in Figure <ref type="figure" target="#fig_0">1</ref> should satisfy the requirements on QoS. WS1 with cost 30, WS3 with response time 60, and WS4 with response time 100 all exceed the required limits. The designed service composition can not be realized, because only WS2 can be selected for task1 and no service are suitable for task2.</p><p>The direct aggregation method overlooks the path execution probability of the composite service. There can be ups and downs in the QoS for a composite service to execute different paths. Therefore, it is only reasonable that QoS is based on statistic values. Adding constraints to every path without considering the execution probability makes the user specified requirements too difficult to be satisfied.</p><p>In this paper, a QoS calculation approach is proposed that does not only provide the QoSs of multiple paths for a service composition but also includes the execution probability of each path. Our main contributions in this paper are: (1) A service graph is defined to represent the process of a composite service; (2) QoS probability distribution is provided in the final result for the analysis of a composite service; (3) Four types of composition patterns are formally defined, and QoS and probability calculation methods for them are provided; (4) It is the first work to provide a solution to calculate the QoS for all types of loop patterns.</p><p>The remainder of the paper is organized as follows: Section II discusses four types of basic composition patterns. In the subsequent sections, the detailed process of QoS analysis will be introduced and a running example will be given. This paper ends with a discussion about the related work and the concluding remarks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>II. Building Blocks of a Composition</head><p>There are different composition patterns in the process of a composite service <ref type="bibr" target="#b7">[8]</ref>. In this paper, we consider that a composite service is composed of four basic composition patterns: sequential, parallel, conditional, and loop (see Figure <ref type="figure" target="#fig_3">3</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Preliminaries</head><p>In this paper, a composite service is represented by a directed graph which is referred to as Service Graph.</p><p>Definition 1. Service Graph: Let S be the set of Web services and D be the set of dependencies within the process of a composite service, P be the set of transition probabilities from each service to its adjacent services within the composition. A Service Graph is G = (V, A), where</p><p>• V = S are the vertices of the graph; • (v xv y , p) denoting that the arc from vertex v x to v y is a sequential-connected arc and the transition probability is p for this arc • (v x = v y , p) denoting that the arc from vertex v x to v y is a concurrent-connected arc and the transition probability is p for this arc.</p><formula xml:id="formula_1">• A = D ⊆ V × × V × P</formula><p>Definition 2. Indegree and Outdgree of a vertex: for an arc a = (v x Φ v y , p), where Φ ∈ , v x and v y are the endpoints of arc a, v y is the head endpoint of arc a, and v x is the tail endpoint of arc a. For a vertex v, the number of head endpoints adjacent to v is called the indegree of v. The number of tail endpoints is its outdegree. The indegree is denoted as deg -(v) and the outdegree as deg + (v).</p><p>For example, the process of a composite service in Figure <ref type="figure">2</ref>(a) can be represented by a Service Graph G = (V, A) in Figure <ref type="figure">2(b)</ref>, where</p><formula xml:id="formula_2">V = {v PO , v CR , v CC , v C , v S I } and A = {(v PO -v CR , 0.4), (v PO -v C , 0.6), (v CR -v CC , 1), (v CC -v CR , 0.2), (v CC -v S I , 0.8), (v C -v S I , 1)}. The indegree and outdegree of vertex v CR are: deg -(v CR ) = 2 and deg + (v CR ) = 1.</formula><p>In Figure <ref type="figure">2</ref>, only p with a probability not equal to 1 is marked out.</p><p>All the following discussion will be based on the Service Graph defined above.</p><p>Next, we will discuss the four types of composition patterns in Service Graph which will be used as building blocks of a composite service. Rather than providing a panacea for any QoS attribute, our approach only focuses on two representative QoS attributes: cost and availability. </p><formula xml:id="formula_3">G = (V, A), ∀v x , v y ∈ V, if ∃(v x -v y , 1) ∈ A deg + (v x ) = 1 deg -(v y ) = 1, then v x</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>and v y are Sequential Vertices. Vertices v x and v y form a composition of Sequential Pattern.</head><p>The transition probability of v y is</p><formula xml:id="formula_4">P y = p yi | i ∈ [1, m y ] .</formula><p>The cost of v x and v y are c x and c y respectively. The availability of them are a x and a y respectively. The transition probability (P ), cost (c ), and availability (a ) for the composition of Sequential Pattern are:  The cost of v y1 and v y2 are c y1 and c y1 respectively. The availability of them are a y1 and a y2 respectively. The transition probability (p ), cost (c ), and availability (a ) for the composition of Parallel Pattern are:</p><formula xml:id="formula_5">P = P y = p y i | i ∈ [1, m y ]<label>(3</label></formula><formula xml:id="formula_6">G = (V, A), ∀v x , v y1 , v y2 ∈ V, if ∃(v x = v y1 , p) ∈ A ∃(v x = v y2 , p) ∈ A,</formula><formula xml:id="formula_7">p = 1 (6) c = c y 1 + c y 2 (7) a = a y 1 × a y 2 (8)</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D. Conditional Pattern</head><p>Definition 5. Exclusive Vertices (see Figure <ref type="figure" target="#fig_3">3</ref>   </p><formula xml:id="formula_8">(c)): for G = (V, A), ∀v x , v y1 , v y2 ∈ V, if ∃(v x -v y1 , p 1 ) ∈ A ∃(v x - v y2 , p 2 ) ∈ A,</formula><formula xml:id="formula_9">G = (V, A), ∀v 1 , v 2 , . . . , v n ∈ V, if ∃(v 1 -v 2 , p 1 ) ∈ A ∃(v 2 -v 3 , p 2 ) ∈ A . . . ∃(v n-1 -v n , p n-1 ) ∈ A ∃(v n -v 1 , p n ) ∈ A, then v 1 , v 2 , . . .</formula><formula xml:id="formula_10">p i + mi j=1 p i j = 1 (i ∈ [1, n]). If vertex v i (i ∈ [1, n]) is just an internal vertex of the Loop, i.e. deg + v i = 1, then p i j = 0 ( j ∈ [1, m i ]). The cost of v i is c i . The availability of v i is a i .</formula><p>After it has been executed for l (l ∈ [0, +∞)) times, the Loop will be left from either of v i (i ∈ [1, n]) to its adjacent vertex that does not belong to the Loop. Based on this description, Loop Pattern can be transformed into an equivalent graph but without the Loop (see Figure <ref type="figure">4</ref>). In Figure <ref type="figure">4</ref>, the combination of vertices v 1 , v 2 , . . . , and v n (the part within the dashed ellipse) is equivalent to one time of execution of the Loop in Figure <ref type="figure" target="#fig_16">3(d)</ref>. After the combination of vertices has been executed for l (l ∈ [0, +∞)) times, finally, it will transfer from vertex v i (i ∈ [1, n]) to its adjacent vertex according to the probability p i j ( j ∈ [1, m i ]). The probability for the combination of vertices to be executed for l (l ∈ [0, +∞)) times and transferring from vertex v 1 to its adjacent vertex is (</p><formula xml:id="formula_11">n i=1 p i ) l p 1 j (l ∈ [0, +∞) , j ∈ [1, m 1 ]); transferring from vertex v k (k ∈ [2, n]) to its adjacent vertex is ( n i=1 p i ) l ( k-1 i=1 p i )p k j (l ∈ [0, +∞) , j ∈ [1, m k ]). Let p 0 = 1, the transition probability from v k (k ∈ [1, n]) to its adjacent vertex is ( n i=1 p i ) l ( k-1 i=0 p i )p k j (l ∈ [0, +∞) , j ∈ [1, m k ]). Therefore,</formula><p>statistically, the transition probability from a Cyclic Vertex to its adjacent vertex that does not belong to the Loop is:</p><formula xml:id="formula_12">p k j = +∞ l=0 ⎛ ⎜ ⎜ ⎜ ⎜ ⎜ ⎝ n i=1 p i ⎞ ⎟ ⎟ ⎟ ⎟ ⎟ ⎠ l ⎛ ⎜ ⎜ ⎜ ⎜ ⎜ ⎝ k-1 i=0 p i ⎞ ⎟ ⎟ ⎟ ⎟ ⎟ ⎠ p k j = k-1 i=0 p i p k j 1 - n i=1 p i (k ∈ [1, n] , j ∈ [1, m k ])<label>(9)</label></formula><p>The probability for the combination of vertices v 1 , v 2 , . . . , v n to be executed for l (l ∈ [0, +∞)) times, transferring to vertex v k (k ∈ [1, n]), and leaving the loop from v k is ( </p><formula xml:id="formula_13">n i=1 p i ) l ( k-1 i=0 p i )(1 -p k ).</formula><formula xml:id="formula_14">c = n k=1 +∞ l=0 ⎛ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎝ ⎛ ⎜ ⎜ ⎜ ⎜ ⎜ ⎝ n i=1 p i ⎞ ⎟ ⎟ ⎟ ⎟ ⎟ ⎠ l ⎛ ⎜ ⎜ ⎜ ⎜ ⎜ ⎝ k-1 i=0 p i ⎞ ⎟ ⎟ ⎟ ⎟ ⎟ ⎠ (1 -p k ) ⎛ ⎜ ⎜ ⎜ ⎜ ⎜ ⎝ l n i=1 c i + k i=1 c i ⎞ ⎟ ⎟ ⎟ ⎟ ⎟ ⎠ ⎞ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎠ = n k=1 k-1 i=0 p i (1 -p k ) k i=1 C i + n i=1 p i n i=k+1 C i 1 - n i=1 p i 2 (10) a = n k=1 +∞ l=0 ⎛ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎝ ⎛ ⎜ ⎜ ⎜ ⎜ ⎜ ⎝ n i=1 p i ⎞ ⎟ ⎟ ⎟ ⎟ ⎟ ⎠ l ⎛ ⎜ ⎜ ⎜ ⎜ ⎜ ⎝ k-1 i=0 p i ⎞ ⎟ ⎟ ⎟ ⎟ ⎟ ⎠ (1 -p k ) ⎛ ⎜ ⎜ ⎜ ⎜ ⎜ ⎝ n i=1 a i ⎞ ⎟ ⎟ ⎟ ⎟ ⎟ ⎠ l k i=1 a i ⎞ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎠ = n k=1 k-1 i=0 p i (1 -p k ) k i=1 a i 1 - n i=1 (p i a i )<label>(11)</label></formula><p>All the vertices in Figure <ref type="figure">4</ref> can be denoted by one vertex v in Figure <ref type="figure" target="#fig_11">5</ref>. The calculation for the transition probability, cost, and availability of vertex v is based on Formulae 9, 10, and 11 respectively. 2) Specific Loops:</p><p>• Self-Loop If there is only one vertex in a Loop Pattern, the Loop is a self-loop (see Figure <ref type="figure" target="#fig_12">6</ref>). Formally, Definition 7. Self-Loop : for a Loop Pattern defined in Definition 6, if n = 1, i.e. ∃(v 1v 1 , p 1 ) ∈ A, then Loop Pattern of this kind is called Self-Loop. For a Self-Loop, k = 1 for Formulae 9, 10, and 11. There are:</p><formula xml:id="formula_15">p 1 j = p 1 j 1 -p 1 ( j ∈ [1, m1]) (12) c = (1 -p 1 )c 1 (1 -p 1 ) 2 = c 1 1 -p 1 (13) a = (1 -p 1 )a 1 1 -p 1 a 1 (<label>14</label></formula><formula xml:id="formula_16">)</formula><p>Self-Loop can be replaced by a single vertex (see Figure <ref type="figure" target="#fig_11">5</ref>). The probability, cost, and availability for this vertex are calculated according to Formulae 12, 13, and 14.</p><p>• Dual-Vertex-Loop If there are two vertices in a Loop, the Loop is a dualvertex-loop (see Figure <ref type="figure" target="#fig_13">7</ref>). Formally, Definition 8. Dual-Vertex-Loop: for a Loop Pattern defined in Definition 6, if n=2, i.e. </p><formula xml:id="formula_17">∃(v 1 -v 2 , p 1 ) ∈ A ∃(v 2 -v 1 , p 2 ) ∈ A,</formula><formula xml:id="formula_18">p 1 j = p 1 j 1 -p 1 p 2 ( j ∈ [1, m1]) (<label>15</label></formula><formula xml:id="formula_19">)</formula><formula xml:id="formula_20">p 2 j = p 1 p 2 j 1 -p 1 p 2 ( j ∈ [1, m2]) (16) c = (1-p 1 )(c 1 + p 1 p 2 c 2 )+ p 1 (1-p 2 )(c 1 +c 2 ) (1 -p 1 p 2 ) 2 = c 1 + p 1 c 2 1-p 1 p 2 (17) a = (1 -p 1 )a 1 + p 1 (1 -p 2 )a 1 a 2 1 -p 1 p 2 a 1 a 2<label>(18)</label></formula><p>In Figure <ref type="figure" target="#fig_13">7</ref> For a Dual-Vertex-Loop with the same in and out vertex, k = 2, p 2 j = 0 and p 2 = 1 for Formulae 9, 10, and 11. There are:</p><formula xml:id="formula_21">p 1 j = p 1 j 1 -p 1 p 2 = p 1 j 1 -p 1 ( j ∈ [1, m1]) (19) c = c 1 + p 1 c 2 1 -p 1 p 2 = c 1 + p 1 c 2 1 -p 1 (20) a = (1 -p 1 )a 1 + p 1 (1 -p 2 )a 1 a 2 1 -p 1 p 2 a 1 a 2 = (1 -p 1 )a 1 1 -p 1 a 1 a 2<label>(21)</label></formula><p>A Dual-Vertex-Loop with the same in and out vertex can be replaced by a single vertex (see Figure <ref type="figure" target="#fig_11">5</ref>). The probability, cost, and availability for this vertex are calculated according to Formulae 19, 20, and 21.</p><p>In For a Dual-Vertex-Loop with different in and out vertices, k = 2, p 1 j = 0, and p 1 = 1 for Formulae 9, 10, and 11. There are:</p><formula xml:id="formula_22">p 2 j = p 1 p 2 j 1 -p 1 p 2 = p 2 j 1 -p 2 ( j ∈ [1, m2]) (22) c = c 1 + p 1 c 2 1 -p 1 p 2 = c 1 + c 2 1 -p 2 (23) a = (1 -p 1 )a 1 + p 1 (1 -p 2 )a 1 a 2 1 -p 1 p 2 a 1 a 2 = (1 -p 2 )a 1 a 2 1 -p 2 a 1 a 2<label>(24)</label></formula><p>A Dual-Vertex-Loop with different in and out vertices can be replaced by a single vertex (see Figure <ref type="figure" target="#fig_11">5</ref>). The probability, cost, and availability for this vertex are calculated according to Formulae 22, 23, and 24.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>III. QoS Analysis</head><p>In this section, we will discuss how the QoS probability distribution of a composite service is obtained.</p><p>In order to get every unique path of the composite service, a Service Graph needs to be transformed into a rooted tree. Before this transformation, all the composition patterns that do not belong to a tree structure, such as Parallel and Loop Pattern, will be replaced by equivalent vertices. Sequential Patterns will also be replaced by equivalent vertices to simplify the transformation process. The original composition patterns are recorded in their replacing vertices so that the original paths of a composite service can still be tracked from the rooted tree even after the replacement and transformation processes take place. After a rooted tree is obtained, the execution probability and QoS of different paths can be calculated. A histogram will then be presented to illustrate the QoS probability distribution for the composite service.</p><p>The process of QoS analysis is summarized as follows:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Sequential Pattern Replacement</head><p>All the Sequential Vertices within a Sequential Pattern will be replaced by a single vertex. The IDs of Sequential Vertices will be recorded in the replacing vertex so that the original information of the path will not be lost. The calculation of the replacing vertex's transition probability and QoS is based on Formulae 3, 4, and 5. The process of replacing Sequential Patterns is shown in Algorithm 1 <ref type="foot" target="#foot_1">1</ref> .  to simplify the process of discovering loop (cycle) in graph, arcs within loop that connect Cyclic Vertices together are marked with special symbols just like arcs that are sequential-connected using '-' or concurrent-connected using '=' to represent the connection way.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Parallel Pattern Replacement</head><p>All the Parallel Vertices within a Parallel Pattern will be replaced by a single vertex. The IDs of them will be recorded in the replacing vertex. The calculation of the replacing vertex's transition probability and QoS is based on Formulae 6, 7, and 8. The process of replacing Parallel Patterns is shown in Algorithm 3.</p><p>set currV to the head vertex of the table 1   First, the statuses of all the vertices in the Service Graph are marked as unaccessed. The transformation process starts from the source vertex of the Service Graph (Line 1 to 4). The process will keep visiting the current vertex's next unaccessed vertex as the current vertex till the sink vertex of the Service Graph is reached (Line 5 to 20). This is called Sequential Access Process. All the vertices that have been visited during Sequential Access Process are recorded in the rooted tree as a branch of the tree, with the previously visited vertex being the parent of the followingly visited vertex. Then this branch is revisited in a reverse order which is called Inverse Access Process (Line 21 to 28). Whenever a vertex with multiple outgoing edges (outdegree&gt;1) is reached, the Inverse Access Process will stop. Another Sequential Access Process will be invoked. Then Inverse Access Process and Sequential Access Process will be alternatively invoked until all the vertices in the Service Graph have been accessed. Finally, a rooted tree is obtained. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>E. Paths of a Composite Service</head><p>Each path of the composite service will be extracted from the rooted tree. Then the execution probability, execution conditions, and QoS for each path can be obtained.</p><p>Since every vertex except for the root has only one parent in the rooted tree, we can keep track of each branch of the tree by visiting from every leaf of the tree backward to the root. This branch is a path of the composite service in its reverse order. After reversing the order, one path of the composite service is obtained.</p><p>The detailed process of extracting paths from the rooted tree is shown in Algorithm 5. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>F. QoS Probability Distribution</head><p>For each path obtained by Algorithm 5, it is seen as a Sequential Pattern. The calculation of cost and availability for each path is based on Formulae 4 and 5. The execution probability for each path is the product of the transition probability of every arc in the path.</p><p>The IDs of the vertices within each path record the actual conditions of taking each path: the original vertices of each path and their relationships (i.e. different composition patterns).</p><p>The result will be shown in a histogram with each bar representing an execution path of a composite service, the width of the bar representing the probability of taking this path, and the height of the bar representing the QoS of this path. Other QoS information, such as the mean (which is calculated as the mathematical expectation of the QoSs of all the paths), maximum, and minimum QoS values of executing the composite service, will also be shown in the histogram. According to Section III, the process to get the QoS probability distribution for the composite service is as follows:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IV. A Running Example</head><p>• After the first five steps (shown in Figure <ref type="figure" target="#fig_17">8</ref>), a Service Graph is transformed into a rooted tree and each path of the composite service is obtained. The ID of all the paths are marked out in Figure <ref type="figure" target="#fig_17">8</ref>(e).</p><p>• At the sixth step, the execution probability and QoS of each path are calculated. The resulting QoS probability distribution histograms are shown in Figure <ref type="figure" target="#fig_20">9</ref>. Now, it can be seen from Figure <ref type="figure" target="#fig_20">9</ref> that there are seven paths in the composite service. The path number is referred to the path ID in Figure <ref type="figure" target="#fig_18">8(e)</ref>. The mean cost and availability for this process are 897.14 and 0.58 respectively which are represented by horizontal straight lines. The highest cost is 1220.00 generated by path 7 with the lowest availability of 0.491 and a probability of 0.044. The lowest cost is 360 generated by path 1 with the highest availability of 0.733 and a probability of 0.046. The cost of path 5, 6 and 7 is higher than the mean cost, and the cost of path 1, 2, 3 and 4 is lower than the mean cost. The probability is 0.175 (0.087+ 0.044 + 0.044) for the process to generate a cost higher than the mean cost, and is 0.825 (0.046 + 0.394 + 0.085 + 0.3) for the process to generate a cost lower than the mean cost. Availability information can be analyzed in a similar way.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>V. Related Work</head><p>In this section, we shall look into different methods for calculating the basic composition patterns.</p><p>For sequential patterns, the calculation method is the same in all kinds of QoS calculation methods.</p><p>For parallel patterns, <ref type="bibr" target="#b5">[6]</ref> uses the same calculation method as what is used for sequential structures except for the calculation of time related attributes such as response time and execution time. In <ref type="bibr" target="#b5">[6]</ref>, time (response time or execution time) is the maximum time of all the parallel tasks. For conditional structures, <ref type="bibr" target="#b5">[6]</ref> uses a statistical method to calculate the QoS. <ref type="bibr" target="#b3">[4]</ref>, <ref type="bibr" target="#b8">[9]</ref> and <ref type="bibr" target="#b6">[7]</ref> follow <ref type="bibr" target="#b5">[6]</ref> to calculate the QoS for parallel and conditional structures.</p><p>In <ref type="bibr" target="#b11">[12]</ref>, the path with the maximum execution duration in parallel and conditional structures is called the critical path. The execution duration of this critical path is the duration of the whole process. The calculation of availability and successful execution rate is based on the critical path. The   <ref type="bibr" target="#b1">[2]</ref>. In <ref type="bibr" target="#b2">[3]</ref>, the QoS of every path of the composite service is calculated and guaranteed to satisfy the user specified requirements.</p><p>For loop patterns, <ref type="bibr" target="#b5">[6]</ref> reduces loop patterns by recalculating the outgoing transition probability of the loop as well as the QoS of the nodes in the loop. <ref type="bibr" target="#b5">[6]</ref> only provides the solution for two types of loop patterns: Self-Loop and Dual-Vertex-Loop with the same in and out vertex. <ref type="bibr" target="#b11">[12]</ref> unfolds the loop patterns by determining the maximum number of times that the loop is taken. If a loop is taken a maximum of n times, then n+1 copies of the nodes in the loop pattern will appear in the resulting acyclic process. <ref type="bibr" target="#b3">[4]</ref> follows this method to calculate the QoS for loop patterns. <ref type="bibr" target="#b8">[9]</ref> does not deal with loop patterns.</p><p>In <ref type="bibr" target="#b7">[8]</ref>, the QoS of each type of patterns is calculated on a maximum and minmum basis. For example, the maximum and minimum execution time for conditional pattern is the execution time of the path with the maximum and minimum execution time respectively, while the maximum and minimum execution time for parallel pattern is the same which is the execution time of the path with the maximum execution time.</p><p>Our approach extends existing work by formally defining those above mentioned composition patterns and providing a QoS calculation solution for all types of loop patterns.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VI. Conclusion</head><p>The approach proposed in this paper goes beyond the existing QoS analysis methods by providing a QoS probability distribution with both the execution probability and execution conditions of each path in a service composition. The QoS analysis result shown in a histogram explicitly presents the maximum, mean, minimum QoS of a service composition and QoS execution probabilities for individual paths. Therefore the proposed approach for QoS Analysis can provide users/designers with more detailed information about QoS of a service composition.</p><p>In this paper, the QoS probability distribution is calculated based on the assumption that each task has a fixed QoS. The QoS of each task is more likely to be a continuous probability distribution in reality. As the next step of research, we will study the general method of QoS analysis for a service composition based on a continuous QoS probability distribution of tasks.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 .</head><label>1</label><figDesc>Figure 1. A Composite Service</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>1) Composition 1 : 2 ) 3 )</head><label>123</label><figDesc>WS1 and WS3 with T = 30 (T = 0.6 × 10+0.4×60 = 30) and C = 26 (C = 0.6×30+0.4×20 = 26); Composition 2: WS1 and WS4 with T = 46 and C = 22; Composition 3: WS2 and WS3 with T = 48 and C = 23; 4) composition 4: WS2 and WS4 with T = 64 and C = 19. Two of them can meet the user specified requirements, which are Composition 2 and Composition 3. Since the response time and cost of Composition 2 are both smaller than those of Composition 3, Composition 2 is a better candidate for the composite service.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>are the arcs of the graph; • = {-, =} are the two ways of connection in the graph with • '-' denoting sequential-connected way • '=' denoting concurrent-connected way • ∀a i ∈ A, a i = (v x Φv y , p) where Φ ∈ and p ∈ P with</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 3 .</head><label>3</label><figDesc>Figure 2. Service Graph of a Composition</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>) c = c x + c y (4) a = a x × a y (5) C. Parallel Pattern Definition 4. Parallel Vertices (see Figure 3(b)): for</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>then v y1 and v y2 are Parallel Vertices. Vertices v y1 and v y2 form a composition of Parallel Pattern.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>then v y1 and v y2 are Exclusive Vertices. Vertices v x , v y1 and v y2 form a composition of Conditional Pattern. In order to keep the execution probability of each path of the composite service in the final result, we do not calculate the QoS and transition probabilities for Conditional Patterns, which means that the QoS values and transition probability of each vertex in Conditional Pattern will stay the same. E. Loop Pattern 1) General Loop: Definition 6. Cyclic Vertices (see Figure 3(d)): for</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>, and v n are Cyclic Vertices within a Loop. Vertices v 1 , v 2 , . . . , and v n form a composition of Loop Pattern.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 3 (</head><label>3</label><figDesc>Figure 3(d) is a Loop Pattern which starts from v 1 and may leave the Loop from either of v 1 , v 2 ,. . . , and v n with a certain probability indicated in the figure. The relationship of these probabilities is as follows: p i +</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>1 pFigure 4 .</head><label>14</label><figDesc>Figure 4. Loop Transformation</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head></head><label></label><figDesc>At this time, the cost generated by all the Cyclic Vertices is l Therefore, statistically, the cost (c ) and availability (a ) generated by all the Cyclic Vertices within the Loop Pattern are as follows:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 5 .</head><label>5</label><figDesc>Figure 5. Loop Transformation Result Formulae 9, 10, and 11 are general formulae for all types of Loop Patterns. Next, we will demonstrate how to use them to calculate the probability, cost, and availability for specific Loop Patterns.2) Specific Loops:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Figure 6 .</head><label>6</label><figDesc>Figure 6. Self-Loop</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Figure 7 .</head><label>7</label><figDesc>Figure 7. Dual-Vertex-Loop Figure 7(a) is the general form of a Dual-Vertex-Loop with k = 2 for Formulae 9, 10, and 11. There are:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head></head><label></label><figDesc>(b), only the start vertex v 1 of the Loop can leave the Loop, i.e. Definition 9. Dual-Vertex-Loop with the same in and out vertex: for a Dual-Vertex-Loop, if deg + (v 1 ) &gt; 1 deg + (v 2 ) = 1 then it is a Dual-Vertex-Loop with the same in and out vertex.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>Figure 7 (</head><label>7</label><figDesc>c), only vertex v 2 can leave the Loop, i.e. Definition 10. Dual-Vertex-Loop with different in and out vertices: for a Dual-Vertex-Loop, if deg + (v 1 ) = 1 deg + (v 2 ) &gt; 1 then it is a Dual-Vertex-Loop with different in and out vertices.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head>Algorithm 3 :</head><label>3</label><figDesc>Parallel Pattern Replacement D. Transformation from a Service Graph to a Rooted Tree After the processes of Sequential, Parallel and Loop Pattern replacement, a Service Graph now is ready to be transformed into a rooted tree. The detailed transformation process is shown in Algorithm 4.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_17"><head>Figure 8 (</head><label>8</label><figDesc>Figure 8(a) is the Service Graph of a composite service. It includes the basic patterns that are discussed in Section II. Each vertex in it has a unique ID. The transition probability, with a default value 1, is marked beside the arc. '=' represents concurrent-connected way between vertices. The default way is sequential-connected. One execution plan is given on the right side of the figure. The ID of each vertex is followed by the cost and availability values of it. For example, 12 : 30, 0.95 represents that the cost is 30 and the availability is 0.95 for the Web service executing task 12 (represented by the vertex with ID 12 in the graph) of the composite service. Symbols '&amp;', '*', and '!' are used to represent vertices coming from Sequential, Parallel, and Loop Patterns respectively. For example, after Sequential Pattern replacement, vertices 3 and 4 in Figure 8(a) are replaced by vertex 3&amp;4 in Figure 8(b).According to Section III, the process to get the QoS probability distribution for the composite service is as follows:• After the first five steps (shown in Figure8), a Service Graph is transformed into a rooted tree and each path of the composite service is obtained. The ID of all the paths are marked out in Figure8(e).• At the sixth step, the execution probability and QoS of each path are calculated. The resulting QoS probability distribution histograms are shown in Figure9. Now, it can be seen from Figure9that there are seven paths in the composite service. The path number is referred to the path ID in Figure8(e). The mean cost and availability for this process are 897.14 and 0.58 respectively which are represented by horizontal straight lines. The highest cost is 1220.00 generated by path 7 with the lowest availability of 0.491 and a probability of 0.044. The lowest cost is 360 generated by path 1 with the highest availability of 0.733 and a probability of 0.046. The cost of path 5, 6 and 7 is higher than the mean cost, and the cost of path 1, 2, 3 and 4 is lower than the mean cost. The probability is 0.175 (0.087+</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_18"><head>Figure 8 .</head><label>8</label><figDesc>Figure 8. QoS Analysis Process</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_20"><head>Figure 9 .</head><label>9</label><figDesc>Figure 9. QoS Probability Distribution limitation of selecting Web services based on the QoS of the critical path has been discussed in<ref type="bibr" target="#b1">[2]</ref>. In<ref type="bibr" target="#b2">[3]</ref>, the QoS of every path of the composite service is calculated and guaranteed to satisfy the user specified requirements.For loop patterns,<ref type="bibr" target="#b5">[6]</ref> reduces loop patterns by recalculating the outgoing transition probability of the loop as well as the QoS of the nodes in the loop.<ref type="bibr" target="#b5">[6]</ref> only provides the solution for two types of loop patterns: Self-Loop and Dual-Vertex-Loop with the same in and out vertex.<ref type="bibr" target="#b11">[12]</ref> unfolds the loop patterns by determining the maximum number of times that the loop is taken. If a loop is taken a maximum of n times, then n+1 copies of the nodes in the loop pattern will appear in the resulting acyclic process.<ref type="bibr" target="#b3">[4]</ref> follows this method to calculate the QoS for loop patterns.<ref type="bibr" target="#b8">[9]</ref> does not deal with loop patterns.In<ref type="bibr" target="#b7">[8]</ref>, the QoS of each type of patterns is calculated on a maximum and minmum basis. For example, the maximum and minimum execution time for conditional pattern is the execution time of the path with the maximum and minimum execution time respectively, while the maximum and minimum execution time for parallel pattern is the same which is the execution time of the path with the maximum execution time.Our approach extends existing work by formally defining those above mentioned composition patterns and providing a QoS calculation solution for all types of loop patterns.</figDesc><graphic coords="8,96.24,201.50,171.36,111.17" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table I</head><label>I</label><figDesc>QoS for Available Web Services</figDesc><table><row><cell></cell><cell cols="2">Available Response</cell><cell></cell></row><row><cell>Task</cell><cell>WS</cell><cell>Time</cell><cell>Cost</cell></row><row><cell>Task1</cell><cell>WS1 WS2</cell><cell>10 40</cell><cell>30 25</cell></row><row><cell>Task2</cell><cell>WS3 WS4</cell><cell>60 100</cell><cell>20 10</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>All the Cyclic Vertices within a Loop Pattern will be replaced by a single vertex. The IDs of them will be recorded in the replacing vertex. The calculation of the replacing vertex's transition probability and QoS is based on Formulae 9, 10, and 11. The process of replacing Loop Patterns is shown in Algorithm 2 2 .</figDesc><table><row><cell>1</cell><cell cols="2">set currV to the head vertex of the table;</cell></row><row><cell>2</cell><cell cols="2">while currV has next vertex in the table do</cell></row><row><cell>3</cell><cell cols="2">if outdegree of currV is one then</cell></row><row><cell>4</cell><cell cols="2">set succV to the direct successor vertex of currV;</cell></row><row><cell>5</cell><cell cols="2">if currV and succV is sequential-connected AND indegree of</cell></row><row><cell></cell><cell cols="2">succV is one then</cell></row><row><cell>6</cell><cell cols="2">set probability of currV to probability of succV;</cell></row><row><cell>7</cell><cell cols="2">compute cost of currV as cost of currV + cost of succV;</cell></row><row><cell>8</cell><cell cols="2">compute availability of currV as availability of currV ×</cell></row><row><cell></cell><cell cols="2">availability of succV;</cell></row><row><cell>9</cell><cell cols="2">set ID of currV to ID of currV '&amp;' ID of succV;</cell></row><row><cell>10</cell><cell cols="2">set direct successor vertices of currV to direct successor</cell></row><row><cell></cell><cell cols="2">vertices of succV;</cell></row><row><cell>11</cell><cell cols="2">remove succV from the table;</cell></row><row><cell>12</cell><cell>else</cell><cell></cell></row><row><cell>13</cell><cell cols="2">set currV to the next vertex of currV in the table;</cell></row><row><cell>14</cell><cell>end</cell><cell></cell></row><row><cell>15</cell><cell>else</cell><cell></cell></row><row><cell>16</cell><cell cols="2">set currV to the next vertex of currV in the table;</cell></row><row><cell>17</cell><cell>end</cell><cell></cell></row><row><cell>18</cell><cell>end</cell><cell></cell></row><row><cell></cell><cell cols="2">Algorithm 1: Sequential Pattern Replacement</cell></row><row><cell cols="3">B. Loop Pattern Replacement</cell></row><row><cell>1</cell><cell cols="2">call FindLoopInServiceGraph(G = (V, A));</cell></row><row><cell>2</cell><cell>for each loop do</cell><cell></cell></row><row><cell>3</cell><cell cols="2">set newV to the start vertex of loop;</cell></row><row><cell>4</cell><cell>set ID to NIL;</cell><cell></cell></row><row><cell>5</cell><cell cols="2">for each vertex in loop do</cell></row><row><cell>6</cell><cell cols="2">store the probability of each arc belonging to loop in ProbList;</cell></row><row><cell>7</cell><cell cols="2">store the cost of each vertex in CostList;</cell></row><row><cell>8</cell><cell cols="2">store the availability of each vertex in AvailList;</cell></row><row><cell>9</cell><cell>end</cell><cell></cell></row><row><cell>10</cell><cell cols="2">set count to zero;</cell></row><row><cell>11</cell><cell cols="2">for each vertex in loop do</cell></row><row><cell>12</cell><cell cols="2">if outdegree of vertex is more than one then</cell></row><row><cell>13</cell><cell cols="2">for each outgoing arc of vertex except the arc belonging</cell></row><row><cell></cell><cell cols="2">to loop do</cell></row><row><cell>14</cell><cell></cell><cell>call ArcProbCalc(probability of arc, count,</cell></row><row><cell></cell><cell></cell><cell>ProbList);</cell></row><row><cell>15</cell><cell></cell><cell>add vertex's successor vertex connected by this arc</cell></row><row><cell>16</cell><cell>end</cell><cell>to newV's direct successor vertex;</cell></row><row><cell>17</cell><cell>end</cell><cell></cell></row><row><cell>18</cell><cell cols="2">set ID to ID '!' ID of vertex;</cell></row><row><cell>19</cell><cell cols="2">if vertex is not newV then</cell></row><row><cell>20</cell><cell cols="2">remove vertex from loop;</cell></row><row><cell>21</cell><cell>end</cell><cell></cell></row><row><cell>22</cell><cell cols="2">increment count;</cell></row><row><cell>23</cell><cell>end</cell><cell></cell></row><row><cell>24</cell><cell cols="2">call QoSCalculation(count, ProbList, CostList, AvailList);</cell></row><row><cell>25</cell><cell cols="2">set the cost of newV to the return of cost of QoSCalculation;</cell></row><row><cell>26</cell><cell cols="2">set the availability of newV to the return of availability of</cell></row><row><cell></cell><cell cols="2">QoSCalculation;</cell></row><row><cell>27</cell><cell cols="2">set the ID of newV to ID;</cell></row><row><cell>28</cell><cell>end</cell><cell></cell></row><row><cell></cell><cell cols="2">Algorithm 2: Loop Pattern Replacement</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_0"><p>Authorized licensed use limited to: Australian National University. Downloaded on March 02,2010 at 00:07:07 EST from IEEE Xplore. Restrictions apply.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_1"><p>all the vertices of the Service Graph are stored in a table. Each vertex has a unique ID. The source vertex (indegree=0) of the Service Graph is the first element of the table while the sink vertex (outdegree=0) is the last element of the table.</p></note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Qos for web services: Requirements and possible approaches</title>
	</analytic>
	<monogr>
		<title level="j">Technical Report</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<date type="published" when="2003-11">November 2003</date>
			<publisher>W3C Working Group</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Global and local qos guarantee in web service selection</title>
		<author>
			<persName><forename type="first">D</forename><surname>Ardagna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Pernici</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Workshop on Business Processes and Services</title>
		<imprint>
			<date type="published" when="2005">2005. 2006. 2006</date>
			<biblScope unit="volume">3812</biblScope>
			<biblScope unit="page" from="32" to="46" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Adaptive service composition in flexible processes. Software Engineering</title>
		<author>
			<persName><forename type="first">D</forename><surname>Ardagna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Pernici</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="369" to="384" />
			<date type="published" when="2007-06">June 2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">An approach for qos-aware service composition based on genetic algorithms</title>
		<author>
			<persName><forename type="first">G</forename><surname>Canfora</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Di Penta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Esposito</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">L</forename><surname>Villani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">GECCO &apos;05: Proceedings of the 2005 conference on Genetic and evolutionary computation</title>
		<meeting><address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="1069" to="1075" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Qos-aware replanning of composite web services</title>
		<author>
			<persName><forename type="first">G</forename><surname>Canfora</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Di Penta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Esposito</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">L</forename><surname>Villani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICWS &apos;05: Proceedings of the IEEE International Conference on Web Services</title>
		<meeting><address><addrLine>Washington, DC, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="121" to="129" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Quality of service for workflows and web service processes</title>
		<author>
			<persName><forename type="first">J</forename><surname>Cardoso</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sheth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Arnold</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Web Semantics</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="281" to="308" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">A probabilistic approach to modeling and estimating the qos of web-services-based workflows</title>
		<author>
			<persName><forename type="first">S.-Y</forename><surname>Hwang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Tang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Srivastava</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inf. Sci</title>
		<imprint>
			<biblScope unit="volume">177</biblScope>
			<biblScope unit="issue">23</biblScope>
			<biblScope unit="page" from="5484" to="5503" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Qos aggregation for web service composition using workflow patterns</title>
		<author>
			<persName><forename type="first">M</forename><surname>Jaeger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Rojec-Goldmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Muhl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Enterprise Distributed Object Computing Conference</title>
		<imprint>
			<date type="published" when="2004-09">2004. Sept. 2004</date>
			<biblScope unit="page" from="149" to="159" />
		</imprint>
	</monogr>
	<note>EDOC 2004. Proceedings. Eighth IEEE International</note>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Composing web services: A qos view</title>
		<author>
			<persName><forename type="first">D</forename><surname>Menasce</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Internet Computing</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="88" to="90" />
			<date type="published" when="2004-12">Nov.-Dec. 2004</date>
		</imprint>
	</monogr>
	<note>IEEE</note>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Service-oriented computing: A research roadmap</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">P</forename><surname>Papazoglou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Traverso</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Dustdar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Leymann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International Journal of Cooperative Information Systems</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="223" to="255" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Framework for web service query algebra and optimization</title>
		<author>
			<persName><forename type="first">Q</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Bouguettaya</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Web</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1" to="35" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Qos-aware middleware for web services composition. Software Engineering</title>
		<author>
			<persName><forename type="first">L</forename><surname>Zeng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Benatallah</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Ngu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Dumas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Kalagnanam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Chang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="311" to="327" />
			<date type="published" when="2004-05">May 2004</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
