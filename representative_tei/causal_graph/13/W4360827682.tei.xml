<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">On Causal Equivalence by Tracing in String Rewriting</title>
				<funder ref="#_qHPGUh2">
					<orgName type="full">EPSRC</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName><forename type="first">Vincent</forename><surname>Van Oostrom</surname></persName>
							<email>oostrom@javakade.nl</email>
						</author>
						<title level="a" type="main">On Causal Equivalence by Tracing in String Rewriting</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="DOI">10.4204/EPTCS.377.2</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.1" ident="GROBID" when="2025-10-21T20:32+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We introduce proof terms for string rewrite systems and, using these, show that various notions of equivalence on reductions known from the literature can be viewed as different perspectives on the notion of causal equivalence. In particular, we show that permutation equivalence classes (as known from the λ -calculus and term rewriting) are uniquely represented both by trace graphs (known from physics as causal graphs) and by so-called greedy multistep reductions (as known from algebra). We present effective maps from the former to the latter, topological multi-sorting TS, and vice versa, the proof term algebra .</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>We are interested in all aspects of computations as modelled by rewrite systems. Here, we are interested in finite computations 'doing the same work up to the order of the tasks performed'. This can be analysed from the perspective of causality with the idea that it is exactly the causally independent tasks that can be reordered. In <ref type="bibr" target="#b34">[35,</ref><ref type="bibr">Chapter 8]</ref> we presented five conceptually distinct ways to mathematically model causal equivalence <ref type="bibr" target="#b34">[35,</ref><ref type="bibr">Section 8.1.3]</ref> of computations in term rewriting, based on permutation, labelling, standardisation, extraction and projection, respectively, and showed them to coincide.</p><p>Though coincidence of the above five perspectives gave us confidence in having captured causal equivalence within term rewriting, at the time we failed to relate them to the further perspective put forward there based on tracing <ref type="bibr" target="#b34">[35,</ref><ref type="bibr">Section 8.6]</ref>. The problem 1 to do so resides in term rewrite rules that are non-linear. For example, consider a reduction f (a) → g(a, a) → g(b, a) → g(b, c) in the term rewrite system having rules a → b, a → c and f (x) → g(x, x), with the last rule non-linear (it copies x). The single occurrence of the symbol a in f (a) traces 2 to both occurrences of a in g(a, a), hence causes both subsequent steps. However, the fact that a was copied by the first step is not captured by tracing; f traces to neither copy of a, though the first step rewriting f is the cause of having the two further steps rewriting the copies of a, in the first place. In this paper we show that only non-linearity is problematic for tracing. More precisely, we show that for string rewriting, which is inherently linear, causal equivalence does have a simple characterisation based on tracing, namely by tragrs. 3  In Section 2 we adapt the theory of permutation equivalence of finite computations as developed in <ref type="bibr" target="#b34">[35,</ref><ref type="bibr">Chapter 8]</ref> for term rewriting, to the case of string rewriting at hand. To represent, interpret, and prove properties about, finite computations by algebraic and inductive means, we adapt proof terms <ref type="bibr" target="#b34">[35,</ref><ref type="bibr">Chapter 8]</ref> to represent the finite reductions of a string rewrite system. In Section 3 we introduce tragrs as a formalisation of Wolfram's notion of causal graph <ref type="bibr" target="#b38">[39]</ref>. We relate proof terms to tragrs by on the one hand giving an algebra interpreting proof terms as tragrs preserving permutation equivalence. and on the other hand presenting a topological multi-sorting algorithm TS mapping tragrs back to proof terms. In Section 4 we show that any proof term may be transformed, by repeatedly swapping loath pairs, <ref type="foot" target="#foot_0">4</ref> into a permutation equivalent greedy <ref type="bibr" target="#b6">[7]</ref> multistep reduction, and that the latter are in bijective correspondence to tragrs via the maps and TS. This then allows us to wrap up and conclude that tragrs (and greedy multistep reductions) serve as unique representatives of permutation equivalence classes.</p><p>Remark 1. This short paper was provoked by a remark made to me<ref type="foot" target="#foot_1">foot_1</ref> in 2020 by Jan Willem Klop, that Wolfram's causal graphs <ref type="bibr" target="#b38">[39]</ref> should characterise permutation equivalence, for string rewriting. Having followed Wolfram's physics project myself and having observed that its developments frequently ran parallel to those in <ref type="bibr" target="#b34">[35,</ref><ref type="bibr">Chapter 8]</ref>, in particular that there was a close connection between causal graphs and the trace relations in <ref type="bibr" target="#b34">[35,</ref><ref type="bibr">Section 8.6</ref>.1] discussed above, allowed me to reply immediately, confirming Klop's intuition, referring him to <ref type="bibr" target="#b34">[35,</ref><ref type="bibr">Chapter 8]</ref> and drawing Figure <ref type="figure" target="#fig_3">2</ref>. At the time I was reluctant to develop that further, as the idea was simple and did not solve the problem for the non-linear case left open in <ref type="bibr" target="#b34">[35]</ref>. Later, in 2022, <ref type="foot" target="#foot_2">6</ref> I realised that a single picture was too cryptic, and that only because the results are simple here do we entertain hope to extend them to the complex non-linear case.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Proof terms for string rewriting</head><p>We adapt the theory of permutation equivalence from term rewriting <ref type="bibr" target="#b34">[35,</ref><ref type="bibr">Chapter 8]</ref> to string rewriting, guided by that strings can be represented as terms so that extant theory for term rewriting can be adapted to string rewriting. String rewriting affords better properties than term rewriting due to linearity: whereas term rewrite steps may be non-linear as they can replicate, erase or copy, subterms of arbitrary sizes, string rewrite steps cannot do so; they are linear. We moreover forbid left-and right-hand sides of string rewrite rules to be the empty string. This restriction makes sense from the perspective of causality <ref type="bibr" target="#b36">[37]</ref> as it entails all steps being ex materia (forbidding ex nihilo steps) and having bounded causes; cf. the 4 th item of Remark 9. By imposing these (linearity and non-emptiness) restrictions, we are in a sweet spot; the resulting string rewrite systems have sufficient structure to express the different perspectives on causal equivalence mentioned in the introduction, and these perspectives can in turn be proven equivalent in a simple way due to the absence of replication. As in <ref type="bibr" target="#b34">[35,</ref><ref type="bibr">Chapter 8]</ref>, to state and prove results proof terms are our tool of choice for representing the reductions of a string rewrite system.</p><p>The usual definition of the finite strings over an alphabet Σ as the free monoid over Σ is abstract. To be able to deal with matters of representation, we instead will be concrete here. Definition 1. A term rewrite system is oudenadic if all rule and function symbols have arity 0, it has a nullary symbol ε (empty string) and a binary composition symbol • h , and terms are considered modulo ≡ M induced by the monoid laws, i.e. ε • h s = s, s • h ε = s, and (s</p><formula xml:id="formula_0">• h t) • h u = s • h (t • h u).</formula><p>Remark 2. Our terminology oudenadic is an attempt to highlight that the representation employed here associates nullary function symbols to letters, and to contrast it with the usual monadic representation, which associates a unary function symbol to each letter; cf. <ref type="bibr" target="#b34">[35,</ref><ref type="bibr">Section 3.4.4]</ref> for an account of both.</p><p>In our modelling, strings are closed oudenadic terms over the alphabet modulo the monoid laws. Uniquely representing such equivalence classes can itself be achieved by term rewriting: orienting the above monoid laws from left to right yields a complete (confluent and terminating) term rewrite system, having as normal forms strings of shape either ε or a 1 . . . a n for some n ≥ 1.</p><p>We refer to • h as horizontal composition to distinguish it from vertical composition • v below (see Definition 2), based on that we adhere to a convention of drawing strings horizontally and reductions vertically in figures. That meshes well with thinking of strings as being extended in space (1-dimensional, horizontally) and of reductions as extended in time (vertically); cf. Figure <ref type="figure" target="#fig_1">1</ref>. We assume • h is infix and right-associative and that it is left implicit, i.e. is represented by juxtaposition. To that end, we assume Σ has unique reading: if a 1 . . . a n = b 1 . . . b m for a i , b j ∈ Σ, then n = m and a k = b k for all 1 ≤ k ≤ n, cf. <ref type="bibr" target="#b35">[36]</ref>.</p><p>Example 1. The alphabet Σ := {A, B} has unique reading. Per our conventions ABAAB abbreviates the term A</p><formula xml:id="formula_1">• h (B • h (A • h (A • h B)))</formula><p>, which is closed and in normal form with respect to the monoid rules, so serves as the unique representative of the string (an ≡ M -equivalence class containing, e.g., (AB)(AA)B).</p><p>The alphabet T := {AB, B, A} does not have unique reading, e.g. ABB can be viewed as being composed of the two letters AB and B, and alternatively of the three letters A, B and B.</p><p>Concretely, a string rewrite system over an alphabet Σ is an oudenadic term rewrite system having the letters in Σ as nullary function symbols, with sources and targets of rules being nonempty strings (cf. the introduction), and steps taking place modulo ≡ M . We use a, b, . . . as variables for letters, A, B, . . . as concrete letters, and A, B for the concrete letters of our running example, as in Example 1.</p><p>We consider term rewrite systems in the sense of <ref type="bibr" target="#b34">[35,</ref><ref type="bibr">Chapters 8 and 9]</ref>, meaning that rules themselves will feature as symbols whose arity (0 for the oudenadic systems we consider here) is the number of variables in the rule, and rules come equipped with source / target functions mapping them to their lhs / rhs. This enables expressing reductions, and more generally proofs in rewrite logic <ref type="bibr" target="#b20">[21]</ref>, as proof terms <ref type="bibr" target="#b34">[35]</ref>, terms over a signature comprising the letters, the rules, and a binary composition symbol • v representing the transitivity inference rule of rewrite logic <ref type="bibr" target="#b20">[21]</ref>. In turn, this allows us to represent the key notion of this paper, the notion of causal equivalence, as an equivalence on reductions / proof terms. Definition 2. Consider for an oudenadic term rewrite system Σ, P , the extension of the oudenadic signature for Σ by the rules ρ in P as nullary symbols and the binary composition symbol • v . Proof terms are a subset of the terms over this signature defined inductively, together with source and target functions src and tgt to strings, in Table <ref type="table" target="#tab_1">1</ref>, where we use γ : s t to denote that γ is a proof term having string s as source and string t as target, and employ γ, δ , ζ , η, . . . to range over proof terms. We abbreviate vertical composition • v to •, assume it is right-associative, and that it binds weaker than horizontal composition • h / juxtaposition. Remark 3. By the vertical composition being on strings the target of γ is only required to be equivalent modulo the monoid laws to the source of δ in (transitivity). We have t : t t for every oudenadic term t.</p><formula xml:id="formula_2">(</formula><p>The name proof term for such terms is justified by that they can be viewed as a proof that their target string is reachable from their source string by using the rewrite rules. Building on Example 1, we take the following as a running example to illustrate concepts and results. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>On Causal Equivalence by Tracing in String Rewriting</head><formula xml:id="formula_3">(h-left unit) εγ = γ (v-left unit) s • γ = γ (h-right unit) γε = γ (v-right unit) γ • t = γ (h-associativity) (γδ )ζ = γ(δ ζ ) (v-associativity) (γ • δ ) • ζ = γ • (δ • ζ ) (exchange) γδ • ζ η = (γ • ζ )(δ • η)</formula><formula xml:id="formula_4">γ := ABβ • Aαβ • β AAB • Bβ AAB • αβ AAB.</formula><p>For the (vertical) compositions in these proof terms to be well-defined it is essential to work modulo the monoid laws. For instance, although the target (BAAB)AAB of β AAB and the source B(AAB)AAB of Bβ AAB are distinct as oudenadic terms, they are both represented by the string BAABAAB, allowing their vertical composition in γ.</p><p>Although in the example the proof terms γ and γ intuitively do 'the same amount of work', the latter is shorter than the former. This is due to that the former is maximally sequentialised, performing one step at the time, whereas the latter is maximally concurrent, performing steps as soon as possible as concurrency permits. Definition 3. A multistep is a proof term without vertical compositions. It is empty / a (single) step if it has no / one occurrence of a rule. A reduction (a multistep reduction) either is an empty multistep or a vertical composition, associated to the right, of steps (resp. nonempty multisteps). Permutation equivalence ≡ between proof terms is induced by the laws in Table <ref type="table" target="#tab_2">2</ref>, where the sides of the laws are restricted to proof terms, i.e. sources and targets of the proof terms γ, δ , ζ , η and the oudenadic terms s,t are assumed to match appropriately.</p><p>We use Φ, Ψ, X, . . . to range over multisteps, and φ , ψ, χ, . . . to range over steps. Observe that the source / target of the left-and right-hand side of each law in Table <ref type="table" target="#tab_2">2</ref> are the same (as strings). Remark 4. The requirements on the sources and targets in the laws of Table <ref type="table" target="#tab_2">2</ref> boil down to working in a typed algebraic structure <ref type="bibr" target="#b28">[29]</ref>. For instance, in that setting a category is a typed monoid, allowing composition of morphisms only if their sources and targets match. In Table <ref type="table" target="#tab_2">2</ref> the requirements are most prominent in the (exchange) law. For example, for rules α :</p><formula xml:id="formula_5">A → A C, α : A → A , β : B → B , β :CB → B , though we do have αβ • α β : AB A B , the expression (α • α )(β • β )</formula><p>is not even a proof term since, e.g., the target A C of α does not match the source A of α . Remark 5. Our reductions, as proof terms of a specific shape, are formally distinct from the classical notion of a reduction, as a finite sequence of steps, in rewriting <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b34">35]</ref>. However, since there is an obvious bijection between both we feel the confusion is acceptable. For instance, the proof term γ :=</p><formula xml:id="formula_6">ABβ • AαAAB • AAβ • β AAB • Bβ AAB • αAABAAB • Aβ AAB : ABAAB ABAABAAB corresponds to: ABAAB → ABBAAB → AAAAB → AABAAB → BAABAAB → BBAABAAB → AAABAAB → ABAABAAB Similarly, the proof term γ := ABβ • Aαβ • β AAB • Bβ AAB • αβ AAB</formula><p>corresponds to the following sequence of multisteps, where we employ the notation • -→ of <ref type="bibr" target="#b34">[35,</ref><ref type="bibr">Chapter 8]</ref> for multisteps:</p><formula xml:id="formula_7">ABAAB • -→ ABBAAB • -→ AABAAB • -→ BAABAAB • -→ BBAABAAB • -→ ABAABAAB</formula><p>Logicality, cf. <ref type="bibr" target="#b22">[23]</ref>, of reductions expresses that if a reachability statement holds then it is provable by a reduction that is permutation equivalent to the original proof term.</p><p>Lemma 1 (Logicality). If γ : s t for some proof term γ, then there is a reduction γ : s t with γ ≡ γ .</p><p>Proof. By induction and cases on γ.</p><p>(empty) the empty string ε is an empty reduction;</p><p>(letter) a single letter a is an empty reduction;</p><p>(rule) a single rule ρ is a single step reduction from its lhs to its rhs;</p><p>(juxtaposition) suppose we have a proof term γ := γ 1 γ 2 : s 1 s 2 t 1 t 2 with γ i : s i t i . By the IH we have reductions γ i : (transitivity) by vertically composing the reductions obtained by the IH for the constituent proof terms, possibly followed by associating to right and eliding empty reductions as before.</p><formula xml:id="formula_8">s i t i with γ i ≡ γ i . Set γ to γ 1 s 2 • t 1 γ 2 ,</formula><p>The proof is effective, transforming proof terms into reductions witnessing the same reachability. Although the logicality lemma allows to represent any proof term by a reduction, the latter is in general far from unique (up to permutation equivalence). For instance, in Example 3 we could have chosen to transform the multistep Aαβ in γ into the two step reduction ABBβ • AαBAAB instead, giving rise to a reduction permutation equivalent to γ but distinct from γ. Intuitively this is caused by that factorising a proof term into a sequence of steps forces to order steps in some (arbitrary) way even though they may be causally independent. For instance, α and β in the multistep Aαβ are concurrent / causally independent, but still must be ordered to obtain a reduction; both orders will do. Such a representation favours sequentiality over concurrency and length over width, so to speak. In the next sections we will go in the opposite direction, maximally favouring concurrency over sequentiality and width over length.</p><p>From that perspective, the proof term  (cf. Figure <ref type="figure" target="#fig_3">2 left</ref>) remedy this by eliding letters, only keeping the causal dependencies between rule symbols. This suffices, as we will show, to let causal graphs serve as unique representatives of permutation equivalence classes. To express and relate both remedies we will employ a bit of residual theory (going back to <ref type="bibr" target="#b5">[6]</ref>) for multisteps below. To avoid things becoming too heavy for this short paper, we only develop the residual theory necessary here and in an ad hoc informal fashion, referring the reader to Chapter 8 of <ref type="bibr" target="#b34">[35]</ref> in general and to Section 8.7 in particular, for background on (from the perspective of permutation equivalence) and a formal treatment of, residuation. Definition 4. For multisteps Φ, Ψ having the same source, we write Φ ⊆ Ψ to denote that Φ is contained in Ψ, meaning that Φ is obtained from Ψ by mapping some occurrences of rule symbols to their source. In that case, we denote by Ψ/Φ the residual of Ψ after Φ, that is, the multistep obtained from Ψ by mapping the other occurrences of rules (the complement of those selected for Φ ⊆ Ψ) to their target. </p><formula xml:id="formula_9">γ := ABβ • AαAAB • AAβ • β AAB • Bβ AAB • αAABAAB • Aβ AAB is a proof</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Trace graphs by proof term algebra</head><p>We give a proof term algebra into tragrs, trace graphs, based on causal graphs <ref type="bibr" target="#b37">[38]</ref>. The algebra is shown to model permutation equivalence in that it maps permutation equivalent proof terms to the same tragr. We give a procedure we dub topological multi-sorting, reading back a proof term from a tragr.</p><p>Before giving a formal treatment, we first give some underlying intuitions by means of an example that links to the intermediate informal notion of an evolution <ref type="bibr" target="#b37">[38]</ref>, and to our discussion above. Example 5. The reduction γ of Example 2 can be depicted as the evolution on the left of in Fig. <ref type="figure" target="#fig_1">1</ref> (taken from <ref type="bibr" target="#b29">[30]</ref>; based on <ref type="bibr">[38, fig. a, p.498]</ref>). To that end, we interpret steps as rows of (possibly skewed) blocks obtained by A → , B → , α → , and β → . Vertical compositions of steps are interpreted by stacking the rows of the interpretations of the steps on top of each other, interspersed with the evaluations of their sources and targets. For instance, the top three rows are the evaluations , , and of the source, step, and target of ABβ : ABAAB ABBAAB. (The interpretations of the rule symbols α, β are given next to the evolution). Looking at Figure <ref type="figure" target="#fig_1">1</ref> the correspondence between evolutions and reductions is clear though informal. Evolutions nicely illustrate the point argued above in (too large) that letters (the white and black boxes representing A and B) add nothing to the representation; the source and target strings and the causal dependencies (represented by directed edges) between the rule symbols would suffice to read back the multistep reduction γ (permutation equivalent to γ) from the evolution. That idea will be formalised below using the notion of tragr, short for trace graph, illustrated for γ / γ in Figure <ref type="figure" target="#fig_3">2</ref>. Remark 7. The book <ref type="bibr" target="#b37">[38]</ref> being intended for a general audience, causal graphs are not sufficiently formalised there to state our results here; in particular, causal graphs lack what we call below an interface (dags of the source and target strings). Tragrs are our way to overcome that deficiency. We believe that if Wolfram were to formalise his notion of causal graph, he would end up with something similar to tragrs. Definition 5. Given a string rewrite system (Σ, P), a tragr from string s to string t is a port graph <ref type="bibr" target="#b33">[34]</ref> (see also <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b33">34,</ref><ref type="bibr" target="#b24">25]</ref>). comprising the following three parts, as visualised in: • a dag, the causal graph, of nodes labelled by rule symbols ρ having (in clockwise order) as input ports the letters of the source string of ρ and as output ports the letters of (the reverse of) the target string, with each port having the type of its letter;</p><p>• the dag of target string t, as for the source string but in reverse direction, i.e. with input and output port of type * swapped.</p><p>The tragr is required to be a planar dag, to only have edges from input to output ports of the same type, and to have exactly two ports without edges, both of type * : the first input port of the source string and the first output port of the target string. (See Remark 10 for more on the planarity requirement.)</p><p>We indicate the input / output ports of a tragr by dangling edges, and refer to the dags of the source and target strings combined as its interface. Example 6. The graph on the right in Figure <ref type="figure" target="#fig_3">2</ref> is a tragr with the types of edges being indicated by color. Remark 8. Tragrs are not (too large) in the sense discussed above; letters only feature in the interface but not in the causal graph of a tragr; cf. the text below [35, Def. 8.6.17]. Definition 6. For a string rewrite system (Σ, P) the proof term algebra on tragrs, interpreting each proof term γ : s t as a tragr γ from s to t, is given by: (letter and empty) a and ε are the tragrs:</p><formula xml:id="formula_10">ε ε a a ε ε</formula><p>(rule) ρ is a tragr having the straight line dags for its source and target as interface, comprising a single rule node connected to the interface in an orderly way, illustrated for rules α and β by:</p><formula xml:id="formula_11">A α β B B B B B A A A A ε ε 1, i 2, i<label>1, o ε ε</label></formula><p>(juxtaposition) γδ is obtained from γ and δ by removing the εs from the former, and redirecting the input and output of the latter accordingly: where elision from the middle to the right is achieved by normalising with respect to the rules:</p><formula xml:id="formula_12">ε ⇒ a a ⇒ ε</formula><p>Observe that if γ : s t then γ indeed is a tragr from s to t.</p><p>Example 7. The tragrs γ and γ of the permutation equivalent γ, γ are as on the right in Figure <ref type="figure" target="#fig_3">2</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Remark 9.</head><p>• Elision ⇒ is complete: terminating because the number of nodes decreases in each step and confluent because elision can be viewed as an interaction net rule <ref type="bibr" target="#b15">[16]</ref>.</p><p>• γ is finite so that all maximal paths in it lead from its input to its output, using that nodes have at least one input / output port, by the assumption that left-and right-hand sides are non-empty.</p><p>• We modelled trace graphs, tragrs, after the trace relations of [35, Definition 8.6.17 / Figure <ref type="figure">8</ref>.37] with the main difference between both being that the latter do not allow parallel edges between the same two nodes. That makes the latter unsuitable for our purposes here; only knowing that a rule causally depends on another not how, is in general not sufficient to read back proof terms. For instance, for rules A → BBB, BB → B and BB → C, the reductions A → BBB → BB → C and A → BBB → BB → C induce the same trace relation, despite not being permutation equivalent.<ref type="foot" target="#foot_4">foot_4</ref> </p><p>• If we were to allow right-hand sides to be empty as in α : A → ε, then the number of occurrences of α that may cause the left-hand side of another rule may be unbounded as illustrated by the multisteps of shape Bα n B : BA n B BB for rule β : BB → . . . and any n ∈ N, despite that none of the As trace to the rule β (its left-hand side BB). <ref type="foot" target="#foot_5">9</ref> Swapping left-and right-hand sides in this example illustrates the problem with allowing left-hand sides to be empty.</p><p>• The algebra illustrates that horizontal and vertical composition are closely related to parallel and series composition of graphs.</p><p>We show that maps permutation equivalent proof terms to the same tragr,<ref type="foot" target="#foot_6">foot_6</ref> see Example 7, but defer showing the converse to the next section (see Theorems 1 and 2).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 2.</head><p>maps permutation equivalent proof terms to the same<ref type="foot" target="#foot_7">foot_7</ref> tragr.</p><p>Proof. We show for each law in Table <ref type="table" target="#tab_2">2</ref> its left-and right-hand sides are mapped to the same tragr by :</p><p>• For the monoid laws (h-left unit), (h-right unit) and (h-associativity) for horizontal composition, the former two follow from that the parallel composition of a tragr with ε on either side, amounts to first introducing and then immediately removing εs. Associativity holds since removing the εs and redirecting the respective input and output edges are local and independent actions.</p><p>• For the monoid laws (v-left unit), (v-right unit) and (v-associativity) for vertical composition, the former two follow from that for any string s, s is a ladder, a tragr only comprising the straight line graphs of its source and target string, each the reverse of the other. For the sequential  composition with a ladder on either side, elision amounts to the immediate removal of (the reverse of) the ladder. Associativity holds since elision is complete (confluent and terminating) and can be postponed until after connecting the respective input and output ports, which are local and independent actions.</p><p>• The (exchange) law holds by combining the reasoning in the previous two items; combining removal of εs with elision ⇒ is complete and can be postponed until after redirecting the input and output edges, which are local and independent actions;<ref type="foot" target="#foot_8">foot_8</ref> see Figure <ref type="figure" target="#fig_6">3</ref>.</p><p>We conclude this section with showing that any tragr can be read back into a multistep reduction, by means of a procedure that we dub topological multisorting, which is analogous to topological sorting but selects in each stage all minimal elements, instead of just a single one, cf. <ref type="bibr" target="#b27">[28]</ref>.</p><p>Definition 7. The topological multi-sorting function TS mapping a tragr from s to t to a multistep reduction having s as source and t as target, is defined by induction on size and cases on its causal graph.</p><p>If the causal graph is empty, planarity of tragrs dictates the tragr is a ladder (as in the Proof of Lemma 2; cf. the bottom-right of Appendix A), so we have s = t and may return the empty multistep s.</p><p>If the causal graph is non-empty, let its minimal layer M comprise its minimal nodes w.r.t. the partial order induced by (taking the reflexive-transitive closure of) the dag. To construct the multistep Φ we juxtapose, starting from the input of the tragr, the labels (letters) of nodes in the dag for s not covered by nodes in M, interspersed with the labels (rule symbols) of those covering nodes in M. Let s be the target of Φ, and consider the tragr obtained by replacing for every node labelled by some rule ρ in T the source dag of ρ by its target dag. By planarity it follows (cf. the top row of Appendix A) that the resulting tragr is from s to t. Therefore, it suffices to vertically compose Φ with the TS-image of this tragr, which exists by the IH.</p><p>In both cases, we obtain a vertical composition of multisteps having s as source and t as target, giving rise to a multistep reduction after removing a trailing empty multistep.</p><p>Example 8. Applying topological multi-sorting TS to the tragr on the right in Figure <ref type="figure" target="#fig_3">2</ref> gives rise to the 6 successive stages displayed in Appendix A.</p><p>Remark 10. Note how the planarity requirement on tragrs of Definition 5 was used in Definition 7 to guarantee that all tragrs having an empty causal graph read back as the empty multistep on their source (and target). In particular, planarity disallows 'rewirings' having crossing edges.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 3.</head><p>after TS is the identity on tragrs.</p><p>By standard residual theory <ref type="bibr" target="#b34">[35,</ref><ref type="bibr">Chapter 8]</ref>, swapping yields a pair of consecutive multisteps permutation equivalent to the original pair, as in the example. Moreover, the size (number of rule symbols) of the 2 nd multistep decreases per construction, so swapping decreases the Sekar-Ramakrishnan measure [35, Definition 8.5.17], measuring a multistep reduction by the lexicographic product of the sizes of the multisteps in it from tail to head. Since if necessary we may first transform a proof term into a permutation equivalent (single step hence multistep) reduction by the Logicality Lemma 1, we have: Lemma 4. A proof term can be transformed into a permutation equivalent greedy multistep reduction. Remark 12. To give an idea how residual theory <ref type="bibr" target="#b34">[35,</ref><ref type="bibr">Table 8</ref>.5 in Section 8.7.3] may be employed to show swapping preserves permutation equivalence, first note that Φ ⊆ X entails Φ/X is an empty multistep. Therefore, by commutativity of join X ≡ X</p><formula xml:id="formula_13">• (Φ/X) ≡ Φ • (X/Φ). Similarly, X/Φ = ψ ⊆ Ψ entails Ψ ≡ (X/Φ)•(Ψ/(X/Φ)). By combining both Φ•Ψ ≡ Φ•(X/Φ)•(Ψ/(X/Φ)) ≡ X •(Ψ/(X/Φ)) = X • (Ψ/ψ).</formula><p>Remark 13. An efficient procedure for searching for loath pairs can be based on the observation that due to linearity of string rewrite systems, an occurrence of either a source or target of a rule can be identified with a pattern in the sense of <ref type="bibr" target="#b34">[35,</ref><ref type="bibr">Definition 8.6.21]</ref>, i.e. with a convex set of positions in the tree of the string having vertices as boundary. Following the main idea of <ref type="bibr" target="#b23">[24]</ref>, to see whether Φ • Ψ is loath, it therefore suffices to check whether each pattern of a source of a rule occurring in Ψ has overlap with some target of a rule occurring in Φ. Since a pattern in a string simply is an interval, characterised by the two vertices constituting its boundary, a single top-down pass through both string-trees checking disjointness of intervals via their boundaries, suffices. If for some pattern there is no overlap, we obtain a loath pair by setting X to Φ in which the pattern was replaced by the rule. For example, see Figure <ref type="figure" target="#fig_2">4</ref>,</p><formula xml:id="formula_14">A A A B A A B ε 1 1</formula><p>Figure <ref type="figure" target="#fig_2">4</ref>: Non-overlapping patterns (in grey) and intervals (thick lines) of A and AAB in AAABAAB using underlining to indicate patterns, that αAABAAB, Aβ AAB in γ is a loath pair follows from that the pattern 13  Proof. We first show that the topological multi-sorting function maps tragrs not just to multistep reductions but to greedy such. Next we show that when restricting the domain of the interpretation to greedy multistep reductions, and TS are inverse to each other as functions from greedy multistep reductions to tragrs and conversely. From that we conclude as both the functions and TS are effective.</p><formula xml:id="formula_15">{ 2, 2 • 1, 2 • 1, 2 • 2, 2 • 2, 2 • 2 • 1, 2 • 2 • 1, 2 • 2 • 2, 2 • 2 • 2, 2 • 2 • 2 • 1, 2 • 2 • 2 • 1} in AAABAAB corresponding</formula><p>We show that when computing the TS-image of a tragr, consecutive stages yield multisteps that are not loath pairs, by induction on the number of stages. There is only something to show when there is more than one stage. So suppose TS yields a composition Φ • γ with Φ obtained from the minimal layer of rule nodes M of the tragr, and γ from its remaining nodes / causal graph R, non-empty by assumption. By the IH γ is greedy, and non-empty so has some first multistep, say Ψ, constructed from the minimal layer, say N, of R. Per definition of TS each of the nodes in N is reachable from some node in M. Since there are no edges between the nodes in a single layers, this entails that for each of the nodes in N there is an edge to it from some node in M. As a consequence, cf. Remark 13, the corresponding pair Φ • Ψ of consecutive multisteps is greedy / not loath. Thus, maps to greedy multistep reductions.</p><p>• That TS after is the identity on greedy multistep reductions, we show by induction on the length of such a reduction. We employ the no(ta)tions of Definition 7, in particular we employ M to denote the layer of minimal elements of (the causal graph of) a tragr. For the empty and single-multistep reductions this is trivial. Otherwise, the reduction has shape Φ • γ. By definition Φ • γ is the serial composition of Φ and γ and we claim that by greediness the steps in the minimal layer of the tragr Φ • γ are those of Φ , i.e. M( Φ • γ ) = M( Φ ). Then, Φ is the result of the first stage of TS and TS( Φ • γ ) = Φ • TS( γ ) = Φ • γ by the IH for γ. It remains to prove the claim that M( Φ • γ ) = M( Φ ) for a greedy multistep reduction of shape Φ • γ, so with γ non-empty. Since M( Φ • γ ) ⊇ M( Φ ) trivially holds, for arbitrary multistep reductions, suppose for a proof by contradiction that M( Φ • γ ) ⊆ M( Φ ) does not hold, for Φ • γ of minimal length. Then there must be some node in M( γ ) in M( Φ • γ ), per construction of Φ •γ as the serial composition of Φ and γ . By minimality this node must in fact be in M( Ψ ) for Ψ the first multistep of γ, with the node corresponding to, say, step ψ ⊆ Ψ. But then Φ • Ψ would be a loath pair, as it allows swapping the join of Φ with ψ. <ref type="foot" target="#foot_9">14</ref> This contradicts the assumed greediness of Φ • γ.</p><p>• The converse direction, that after TS is the identity on tragrs, follows from Lemma 3.</p><p>We can now establish our main result, that one may compute a greedy multistep reduction, unique modulo permutation equivalence, for any proof term by first evaluating into its tragr / causal graph (using ), followed by the topological multi-sort (using TS) yielding the greedy multistep reduction. Theorem 2. For every proof term γ, there exists a unique greedy multistep reduction γ such that γ ≡ γ .</p><p>Proof. Lemma 4 shows existence. To show uniqueness, consider greedy multistep reductions γ and γ both permutation equivalent to γ. By Lemma 2, γ and γ are the same tragr. Therefore, γ = TS( γ ) = TS( γ ) = γ by TS being inverse to on greedy multistep reductions by Theorem 1..</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Remark 14.</head><p>• The proof only employs one direction (the first item in the proof) of Theorem 1.</p><p>• As a consequence, using that the greedy multistep reductions are the normal forms w.r.t. swapping, we have that swapping is confluent on multistep reductions. This could alternatively be established via Newman's Lemma, using that swapping is terminating and showing local confluence. Example 10. The greedy multistep reduction γ is the unique representative of the permutation equivalence class of γ. Both are mapped to the tragr on the right in Figure <ref type="figure" target="#fig_3">2</ref> by the proof term algebra , and topological multi-sorting.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Conclusions</head><p>We have shown that Lévy's notion of permutation equivalence <ref type="bibr" target="#b17">[18]</ref> as known from term rewriting <ref type="bibr" target="#b34">[35]</ref> corresponds, after specialising it to string rewriting, to the notion of causal equivalence as employed by Wolfram in his physics project <ref type="bibr" target="#b37">[38,</ref><ref type="bibr" target="#b38">39]</ref>. This we achieved by introducing trace graphs, tragrs refining Wolfram's notion of causal graph, as representatives of permutation equivalence classes of reductions. Representing reductions as terms themselves, so-called proof terms <ref type="bibr" target="#b20">[21]</ref>, allowed us to specify the representation map, from reductions to tragrs, effectively by means of a (proof term) algebra that models permutation equivalence. To show that representatives are unique, we gave a map back from tragrs to socalled greedy multistep reductions as known from Dehornoy's work in algebra <ref type="bibr" target="#b6">[7]</ref>, using a topological multi-sorting procedure, showing both maps to be inverse to each other.</p><p>The study of causality spans all the sciences, cf. <ref type="bibr" target="#b26">[27]</ref>, hence it is no surprise that it has been discussed and mathematically modelled in many ways; to mention a few <ref type="bibr" target="#b21">[22,</ref><ref type="bibr" target="#b17">18,</ref><ref type="bibr" target="#b3">4,</ref><ref type="bibr" target="#b32">33,</ref><ref type="bibr" target="#b36">37,</ref><ref type="bibr" target="#b11">12,</ref><ref type="bibr" target="#b10">11,</ref><ref type="bibr" target="#b20">21,</ref><ref type="bibr" target="#b16">17,</ref><ref type="bibr" target="#b18">19,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b8">9,</ref><ref type="bibr" target="#b9">10,</ref><ref type="bibr" target="#b6">7,</ref><ref type="bibr" target="#b38">39]</ref>. From that point of view our results can be seen as linking models of causality known from rewriting <ref type="bibr" target="#b17">[18]</ref> (permutation equivalence), algebra <ref type="bibr" target="#b6">[7]</ref> (greedy multistep reductions) and physics <ref type="bibr" target="#b38">[39]</ref> (causal graphs), respectively. In general, we think that linking different perspectives on the same notion, as we did for causal equivalence here but also before in <ref type="bibr" target="#b34">[35,</ref><ref type="bibr">Chapter 8]</ref>, is important. Therefore we find it surprising that in the literature mentioned cross-references beyond the borders of the specific field (rewriting, algebra, physics, category theory, proof theory, concurrency theory,. . . ) of a paper, are few and far between. We hope that our short paper can contribute to creating at least some awareness of that, in our opinion unfortunate, situation for causal equivalence, and the interest in overcoming it.</p><p>Remark 15. Not being a physicist, I am not in a position to assess the potential relation of the various causal models to physics, cf. <ref type="bibr" target="#b38">[39,</ref><ref type="bibr">Section 8]</ref>. However, I do think it already methodologically interesting to see how far one can push causal models, which phenomena can or cannot be reconstructed from them. For example, in <ref type="bibr" target="#b7">[8]</ref> it is argued that time cannot be reconstructed from purely causal models (such as rewriting), as the latter fail to explain synchronicity. <ref type="foot" target="#foot_10">15</ref> That makes one wonder whether adding natural structure (think of a notion of strategy or a metric) could overcome that, could make time emergent.</p><p>The concepts and techniques developed and employed here are simple and natural. <ref type="foot" target="#foot_11">16</ref> For instance, topological multi-sorting could be easily presented in undergraduate Discrete Mathematics or Data Structures and Algorithms courses. We view this as a strength rather than as a weakness. Only because the results are simple and natural do we entertain the hope to extend them to more complex cases. In particular, we hope that the results developed here for string rewriting can serve as a stepping stone for tackling the problem, left open in <ref type="bibr" target="#b34">[35,</ref><ref type="bibr">Chapter 8]</ref> (see Remark 1), of giving a characterisation of permutation equivalence for term rewriting<ref type="foot" target="#foot_12">foot_12</ref> by tracing. Interesting (classes of) term rewrite systems to target are:</p><p>• Linear systems. In the first-order case linearity can be brought about by requiring for each rule that every variable occurs either zero or one time in both its sides. The characterisation should cover not only string rewrite systems via their monadic embedding (see Remark 2), and chemical systems <ref type="bibr" target="#b34">[35,</ref><ref type="bibr">Example 8.6.1]</ref>, but also rules like x + 0 → x. <ref type="foot" target="#foot_13">18</ref> In the higher-order case <ref type="bibr" target="#b34">[35,</ref><ref type="bibr">Chapter 11]</ref> linearity could be brought about by restricting to a linear substitution calculus <ref type="bibr" target="#b31">[32]</ref>.</p><p>• Non-linear systems. As illustrated in the introduction, the problem in the non-linear case is that the replicating effect of a non-linear term rewrite step is not represented in the term structure, so cannot be traced. One could hope this can be overcome by reifying replication (so it becomes traceable), by making the substitution calculus <ref type="bibr" target="#b25">[26]</ref> suitably explicit. Sharing graphs as known from the theory of optimal reduction <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b24">25]</ref> suggest themselves, in both the first-and higher-order cases, with Combinatory Logic and the λ β -calculus, respectively, concrete systems to try potential characterisations on.</p><p>All our results are effective and constructive, but we did not study their complexity. However, we do hope that the concrete representations of permutation equivalence classes by means of tragrs (certain graphs) and greedy multistep reduction (certain terms) could be useful for such, cf. <ref type="bibr" target="#b6">[7]</ref>.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Example 3 .Remark 6 .</head><label>36</label><figDesc>The procedure underlying the proof of Lemma 1 transforms the proof term (in fact a multistep reduction) γ of Example 2 into the reduction γ. To see this it suffices, since vertical compositions transform homomorphically, to note that the multisteps Aαβ and αβ AAB in γ are transformed into the (two-step) reductions AαAAB • AAβ and αAABAAB • Aβ AAB in γ, respectively. Logicality is the raison d'être for the field of rewriting<ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b34">35]</ref>, allowing to reduce reachability to reducibility. Cf.<ref type="bibr" target="#b20">[21,</ref> Lemma 3.6]  for the corresponding logicality result for term rewriting.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 1 :</head><label>1</label><figDesc>ABBAAB AAAAB AABAAB BAABAAB BBAABAAB AAABAAB</figDesc><graphic coords="6,117.20,70.87,181.31,154.05" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Example 4 .</head><label>4</label><figDesc>ABBAAB, ABBβ , AαAAB and Aαβ are the four multisteps contained in Aαβ in Example 2. We have, e.g., Aαβ /ABBβ = AαBAAB and Aαβ /AαAAB = AAβ . Observe that if Φ ⊆ Ψ and Φ is nonempty, then fewer rule symbols occur in Ψ/Φ than in Ψ by linearity of string rewriting.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Causal graph (left) and tragr from ABAAB to ABAABAAB (right)</figDesc><graphic coords="7,142.32,74.08,72.64,183.79" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>•</head><label></label><figDesc>dag of source string dag of target string causal graph on rules in steps ε ε the dag of source string s having for every occurrence of a letter b in s a node labelled b, having (in clockwise order) an input port of type 7 * , an output port of type * , and an output port of type b. The nodes are connected in a straight line by edges of type * , terminated by a node labelled ε having an input port of type * , and an output port of type ε.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>The tragr γ • δ is obtained from γ and δ by connecting the output of the former to the input of the latter, and subsequently eliding the intermediate interface:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Tragr illustrating (exchange)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>to the source AAB of the rule β , does not have overlap with the pattern {ε, 1, 1} in AAABAAB corresponding to the target A of the rule α. This in turn follows from that the corresponding intervals [ 2, 2 • 2 • 2] and [ε] are disjoint since ε is smaller than 2. By disjointness / non-overlap, replacing in αAABAAB the β -pattern AAB by the rule β yields the multistep αβ AAB, as desired. Theorem 1. The maps and TS constitute a(n effective) bijection between greedy multistep reductions and tragrs.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>γ 1 γ 2 : s 1 s 2 t 1 t 2 if γ i : s i t i</head><label></label><figDesc></figDesc><table><row><cell>empty)</cell><cell cols="2">ε : ε ε</cell><cell></cell></row><row><cell>(letter)</cell><cell cols="2">a : a a</cell><cell>for each letter a</cell></row><row><cell>(rule)</cell><cell>ρ :</cell><cell>r</cell><cell>for each rule ρ : → r</cell></row><row><cell>(juxtaposition) (transitivity)</cell><cell cols="2">γ • δ : s u</cell><cell>if γ : s t, and δ : t u</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 1 :</head><label>1</label><figDesc>Proof terms for string rewriting</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 2 :</head><label>2</label><figDesc>Laws inducing permutation equivalence Example 2. Let Σ, P be the string rewrite system having rules P := {α : BB → A, β : AAB → BAAB}. The proof term γ := ABβ • AαAAB • AAβ • β AAB • Bβ AAB • αAABAAB • Aβ AAB proves the reachability statement ABAAB ABAABAAB. An alternative witness to that statement is the proof term</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>where for a reduction ζ and string u, ζ u denotes the reduction obtained by suffixing each step of ζ by u, and symmetrically for u ζ . One easily verifies γ : s 1 s 2 t 1 t 2 , and also that γ ≡ γ by using (exchange) and vertical units repeatedly. Then by repeated vertical associativity applied to γ we obtain a reduction, except in case one or both of the γ i is the empty reduction in which case we conclude by eliding one such by a horizontal unit.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head></head><label></label><figDesc>of the reachability statement ABAAB ABAABAAB that is wasteful in two ways:(too long) This can be remedied by proceeding greedily<ref type="bibr" target="#b6">[7]</ref>, employing proper multisteps instead of steps. For instance, the 2 nd and 3 rd steps AαAAB•AAβ :ABBAAB AABAAB in γ can be combined into the single multistep Aαβ : ABBAAB AABAAB. Proceeding greedily, combining as many of the single steps into multisteps as possible, and as early as possible, turns γ into the shorter greedymultistep reduction γ := ABβ • Aαβ • β AAB • Bβ AAB • αβ AAB.As we will show, greedy multistep reductions may serve as unique representatives of permutation equivalence classes.</figDesc><table /><note><p><p><p><p>(too large) (Multi)steps not only represent what changes (via the rules in it) but also what does not change (via the letters in it); cf. the frame problem</p><ref type="bibr" target="#b30">[31]</ref></p>. As a consequence, in general proof terms predominantly consist of letters; this holds true in particular both for γ and γ . Causal graphs</p><ref type="bibr" target="#b37">[38]</ref> </p></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_0"><p>A loath pair intuitively is a pair of consecutive steps that are causally independent, so that the second step could have been in parallel to the first, but it was too loath to do so.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_1"><p>While employed as UniversitätsassistentIn in the Computational Logic group at the University of Innsbruck.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_2"><p>While employed as Research Associate in the Mathematical Foundations of computation group at the University of Bath.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="7" xml:id="foot_3"><p>Types serve here only to enable indicating / visualising connections between ports and edges conveniently (cf. Example 6).</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="8" xml:id="foot_4"><p>It is interesting to compute their respective tragrs and see that / how they differ.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="9" xml:id="foot_5"><p>Cf.<ref type="bibr" target="#b34">[35,</ref> Definition 8.6.64] for a hack to overcome (by reifying 'emptyiness') the problem caused by such collapsing rules.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="10" xml:id="foot_6"><p>Stated differently, we show the proof term algebra is a model (in an appropriate typed sense of [35, Definition 2.5.1(v)]) of permutation equivalence given in Table2. The proof for trace graphs follows that for trace relations<ref type="bibr" target="#b34">[35,</ref> Lemma 8.6.14].</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="11" xml:id="foot_7"><p>Formally, the same up to graph isomorphism.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="12" xml:id="foot_8"><p>For the reasoning to apply it is essential that both sides of (exchange) law are proof terms, i.e. that sources and targets of the constituting proof terms should match appropriately so that both sides indeed yield tragrs; cf. Remark 4.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="14" xml:id="foot_9"><p>More precisely, the join of Φ with the origin of ψ along the converse of Φ, which is a step acting on an interval in the dag of the source string of Φ, as observed in Remark 13. Note our reasoning would fail if rules were allowed to have empty left-or right-hand sides: If ψ were due to a rule with an empty left-hand side, or if Φ were to contain a rule with an empty right-hand side, then X might not be swappable.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="15" xml:id="foot_10"><p>Roughly: Why are two identical but independent clocks seen to be in the same state?</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="16" xml:id="foot_11"><p>This could be the reason for the observed disjointedness of the literature on causal equivalence: natural notions are likely to be developed autonomously multiple times. Therefore we think it worthwhile to (try to) link such notions.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="17" xml:id="foot_12"><p>But also other types of structured rewrite systems such as graph rewrite systems come to mind.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="18" xml:id="foot_13"><p>I expect the adaptation of the results to first-order linear term rewriting to be largely unproblematic but still interesting. For instance, trace graphs for term rewrite systems cannot be planar, unlike those for string rewrite systems here.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div><p>Acknowledgments We thank <rs type="person">Jan Willem Klop</rs> for making the initial remark, <rs type="person">Nao Hirokawa</rs> and the reviewers and participants of Termgraph 2022 in Haifa for feedback, and the reviewers for thorough reading and many helpful comments and suggestions.</p></div>
			</div>
			<div type="funding">
<div><p>* Supported by <rs type="funder">EPSRC</rs> Project <rs type="grantNumber">EP/R029121/1</rs> Typed lambda-calculi with sharing and unsharing. Most of this work was performed while employed at the <rs type="institution">University of Bath, England</rs>. <ref type="bibr" target="#b0">1</ref> Cf. the paragraph on top of page 415 in [35, Remark 8.6.74]. 2 For the trace relations presented in [35, Section 8.6.1]; see Definitions 8.</p></div>
			</div>
			<listOrg type="funding">
				<org type="funding" xml:id="_qHPGUh2">
					<idno type="grant-number">EP/R029121/1</idno>
				</org>
			</listOrg>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Proof. By induction on size and cases on the causal graph of a tragr from s to t.</p><p>If the causal graph is empty then by the observation in Definition 7 and Remark 10, the tragr is a ladder, s = t, and it is mapped to the empty multistep s. Then s is the ladder from s to s again, as follows by induction on the length of s and Definition 6, using (letter) / (empty) in the base case and (juxtaposition) in the induction step.</p><p>If the causal graph is not empty, then per the construction in Definition 7, it is obtained by (transitivity) from the tragr from s to s of its minimal layer M, and the tragr from s to t of its remaining nodes / causal graph R. We conclude by that the former is obtained from Φ for Φ : s s the multistep constructed from M in Definition 6, and by the induction hypothesis for the latter. To see the former, one proceeds as for the empty causal graph additionally using (rule) in the base case.</p><p>Remark 11. In fact, any way to transform a tragr into a proof term by repeatedly decomposing the tragr by means of the inverses of (juxtaposition) and (transitivity), mirrored by composing the corresponding proof terms by means of horizontal and vertical composition respectively, and transforming the base cases (letter), (empty) and (rule) in the natural way, will preserve the result (Lemma 3). The particular such transformation TS was chosen here because it does not just yield any proof term but a greedy multistep reduction, which will be essential for the unique representation purposes of the next section.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Greedy multistep reductions</head><p>We first give a standard algorithm for transforming a proof term into a permutation equivalent greedy one <ref type="bibr" target="#b6">[7]</ref>, and next show there is a bijection between such greedy multistep reductions and tragrs. From this we conclude, in a semantic way, that both constitute unique representatives of permutation equivalence classes of proof terms.</p><p>We give a novel description of greediness and the greedy algorithm of <ref type="bibr" target="#b6">[7]</ref>, based on the analogy with sorting and standardisation <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b34">35]</ref> in the literature. In sorting, (adjacent) inversions are consecutive elements that are out-of-order, and in term rewriting, anti-standard pairs <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b19">20]</ref> are consecutive steps in a reduction such that the latter is outside (to the left of) the former. Such pairs of out-of-order elements are of interest since they provide a local characterisation both of being sorted, i.e. the absence of such pairs, and of bringing the list / reduction closer to being sorted, by permuting the out-of-order pair. This makes both processes amenable to a rewriting approach, with bubblesort being an example for sorting and the extraction of the leftmost-contracted-redex being an example for standardisation <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b12">13,</ref><ref type="bibr" target="#b18">19,</ref><ref type="bibr" target="#b34">35,</ref><ref type="bibr" target="#b19">20,</ref><ref type="bibr" target="#b4">5]</ref>. To make the greedy algorithm fit the mould, we define loath pairs as consecutive multisteps where some rule symbol in the 2 nd is not caused by the 1 st , so may be permuted up front, signalling non-greediness. This is phrased in terms of residuation; see Definition 4. Definition 8. A proof term is greedy if it is a multistep reduction without loath pairs, where a pair Φ•Ψ of consecutive multisteps is loath if there is a step X co-initial with Φ such that Φ ⊆ X and having residual step ψ := X/Φ with ψ ⊆ Ψ. Swapping X for Φ • Ψ then results in X • (Ψ/ψ). Exhaustive swapping followed by removing trailing empty multisteps yields a greedy decomposition.  </p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">The Optimal Implementation of Functional Programming Languages</title>
		<author>
			<persName><forename type="first">A</forename><surname>Asperti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Guerrini</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1998">1998</date>
			<publisher>Cambridge University Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<author>
			<persName><forename type="first">F</forename><surname>Baader</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Nipkow</surname></persName>
		</author>
		<idno type="DOI">10.1017/CBO9781139172752</idno>
		<title level="m">Term Rewriting and All That</title>
		<imprint>
			<publisher>Cambridge University Press</publisher>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Connection Graphs</title>
		<author>
			<persName><forename type="first">A</forename><surname>Bawden</surname></persName>
		</author>
		<idno type="DOI">10.1145/319838.319868</idno>
	</analytic>
	<monogr>
		<title level="m">LFP 1986, ACM</title>
		<imprint>
			<date type="published" when="1986">1986</date>
			<biblScope unit="page" from="258" to="265" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Computational semantics of term rewriting systems</title>
		<author>
			<persName><forename type="first">G</forename><surname>Boudol</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Algebraic Methods in Semantics</title>
		<editor>
			<persName><forename type="first">M</forename><surname>Nivat</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">C</forename><surname>Reynolds</surname></persName>
		</editor>
		<imprint>
			<publisher>Cambridge University Press</publisher>
			<date type="published" when="1985">1985</date>
			<biblScope unit="page" from="169" to="236" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Equivalence of Reductions in Higher-Order Rewriting</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">J S</forename><surname>Bruggink</surname></persName>
		</author>
		<ptr target="http://dspace.library.uu.nl/handle/1874/27575" />
	</analytic>
	<monogr>
		<title level="m">Utrecht University</title>
		<imprint>
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
	<note type="report_type">Ph.D. thesis</note>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Some properties of conversion</title>
		<author>
			<persName><forename type="first">A</forename><surname>Church</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">B</forename><surname>Rosser</surname></persName>
		</author>
		<idno type="DOI">10.1090/S0002-9947-1936-1501858-0</idno>
	</analytic>
	<monogr>
		<title level="j">Transactions of the American Mathematical Society</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="page" from="472" to="482" />
			<date type="published" when="1936">1936</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<author>
			<persName><forename type="first">P</forename><surname>Dehornoy</surname></persName>
		</author>
		<author>
			<persName><surname>Alii</surname></persName>
		</author>
		<idno type="DOI">10.4171/139</idno>
	</analytic>
	<monogr>
		<title level="m">Foundations of Garside Theory</title>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">A</forename><surname>Gijsbers</surname></persName>
		</author>
		<idno type="DOI">10.1017/9781108592703.004</idno>
		<title level="m">Time and Causality across the Sciences</title>
		<imprint>
			<publisher>Cambridge University Press</publisher>
			<date type="published" when="2019">2019</date>
			<biblScope unit="page" from="49" to="71" />
		</imprint>
	</monogr>
	<note>chapter 4: On the Causal Nature of Time</note>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">A Proof Calculus Which Reduces Syntactic Bureaucracy</title>
		<author>
			<persName><forename type="first">A</forename><surname>Guglielmi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Gundersen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Parigot</surname></persName>
		</author>
		<idno type="DOI">10.4230/LIPIcs.RTA.2010.135</idno>
	</analytic>
	<monogr>
		<title level="m">RTA 2010, LIPIcs 6, Schloss Dagstuhl-Leibniz-Zentrum fuer Informatik</title>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="135" to="150" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Cartesian closed 2-categories and permutation equivalence in higher-order rewriting</title>
		<author>
			<persName><forename type="first">T</forename><surname>Hirschowitz</surname></persName>
		</author>
		<idno type="DOI">10.2168/LMCS-9(3:10)2013</idno>
	</analytic>
	<monogr>
		<title level="j">LMCS</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">3</biblScope>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Update of: Call-by-need computations in non-ambiguous linear term rewriting systems</title>
		<author>
			<persName><forename type="first">G</forename><surname>Huet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">&amp; J.-J</forename><surname>Lévy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computational Logic -Essays in Honor of Alan Robinson</title>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">L</forename><surname>Lassez</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">G</forename><forename type="middle">D</forename><surname>Plotkin</surname></persName>
		</editor>
		<imprint>
			<publisher>MIT Press</publisher>
			<date type="published" when="1979">1991. 1979</date>
			<biblScope unit="page" from="395" to="443" />
		</imprint>
	</monogr>
	<note>Computations in Orthogonal Rewriting Systems, Part I + II</note>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">The geometry of tensor calculus</title>
		<author>
			<persName><forename type="first">A</forename><surname>Joyal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Street</surname></persName>
		</author>
		<idno type="DOI">10.1016/0001-8708(91)90003-P</idno>
	</analytic>
	<monogr>
		<title level="j">I. Advances in Mathematics</title>
		<imprint>
			<biblScope unit="volume">88</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="55" to="112" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Discrete Normalization and Standardization in Deterministic Residual Structures</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Khasidashvili</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R W</forename><surname>Glauert</surname></persName>
		</author>
		<idno type="DOI">10.1007/3-540-61735-3_9</idno>
	</analytic>
	<monogr>
		<title level="m">ALP&apos;96</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1996">1996</date>
			<biblScope unit="volume">1139</biblScope>
			<biblScope unit="page" from="135" to="149" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Relating conflict-free stable transition and event models via redex families</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Khasidashvili</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R W</forename><surname>Glauert</surname></persName>
		</author>
		<idno type="DOI">10.1016/S0304-3975(01)00235-3</idno>
	</analytic>
	<monogr>
		<title level="j">TCS</title>
		<imprint>
			<biblScope unit="volume">286</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="65" to="95" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">W</forename><surname>Klop</surname></persName>
		</author>
		<title level="m">Combinatory Reduction Systems</title>
		<imprint>
			<date type="published" when="1980">1980</date>
		</imprint>
		<respStmt>
			<orgName>Rijksuniversiteit Utrecht</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Ph.D. thesis</note>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Interaction Nets</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Lafont</surname></persName>
		</author>
		<idno type="DOI">10.1145/96709.96718</idno>
	</analytic>
	<monogr>
		<title level="m">17th POPL</title>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1990">1990</date>
			<biblScope unit="page" from="95" to="108" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Distributive Evaluations of lambda-calculus</title>
		<author>
			<persName><forename type="first">C</forename><surname>Laneve</surname></persName>
		</author>
		<idno type="DOI">10.3233/FI-1994-2043</idno>
	</analytic>
	<monogr>
		<title level="j">Fundam. Informaticae</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="333" to="352" />
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">Réductions correctes et optimales dans le λ -calcul</title>
		<author>
			<persName><forename type="first">J.-J</forename><surname>Lévy</surname></persName>
		</author>
		<ptr target="http://pauillac.inria.fr/~levy/pubs/78phd.pdf" />
		<imprint>
			<date type="published" when="1978">1978</date>
		</imprint>
		<respStmt>
			<orgName>Université Paris VII</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Thèse de doctorat d&apos;état</note>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">Description Abstraite des Systèmes de Réécriture</title>
		<author>
			<persName><forename type="first">P.-A</forename><surname>Melliès</surname></persName>
		</author>
		<ptr target="http://www.irif.fr/~mellies/phd-mellies.pdf" />
		<imprint>
			<date type="published" when="1996">1996</date>
		</imprint>
		<respStmt>
			<orgName>Université Paris VII</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Thèse de doctorat</note>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Axiomatic Rewriting Theory I: A Diagrammatic Standardization Theorem</title>
		<author>
			<persName><forename type="first">P.-A</forename><surname>Melliès</surname></persName>
		</author>
		<idno type="DOI">10.1007/11601548_23</idno>
	</analytic>
	<monogr>
		<title level="m">Essays Dedicated to Jan Willem Klop</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="volume">3838</biblScope>
			<biblScope unit="page" from="554" to="638" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Conditional rewriting logic as a unified model of concurrency</title>
		<author>
			<persName><forename type="first">J</forename><surname>Meseguer</surname></persName>
		</author>
		<idno type="DOI">10.1016/0304-3975(92)90182-F</idno>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">96</biblScope>
			<biblScope unit="page" from="73" to="155" />
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">On theories with a combinatorial definition of &quot;equivalence</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">H A</forename><surname>Newman</surname></persName>
		</author>
		<idno type="DOI">10.2307/2269299</idno>
	</analytic>
	<monogr>
		<title level="j">Annals of Mathematics</title>
		<imprint>
			<biblScope unit="volume">43</biblScope>
			<biblScope unit="page" from="223" to="243" />
			<date type="published" when="1942">1942</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Sub-Birkhoff</title>
		<author>
			<persName><forename type="first">V</forename><surname>Van Oostrom</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-540-24754-8_14</idno>
	</analytic>
	<monogr>
		<title level="m">FLOPS 2004</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2004">2004</date>
			<biblScope unit="volume">2998</biblScope>
			<biblScope unit="page" from="180" to="195" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Some symmetries of commutation diamonds</title>
		<author>
			<persName><forename type="first">V</forename><surname>Van Oostrom</surname></persName>
		</author>
		<ptr target="http://iwc2020.cic.unb.br/iwc2020_proceedings.pdf" />
	</analytic>
	<monogr>
		<title level="m">IWC 2020</title>
		<imprint>
			<date type="published" when="2020">2020</date>
			<biblScope unit="page" from="1" to="7" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">Lambdascope</title>
		<author>
			<persName><forename type="first">V</forename><surname>Van Oostrom</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">J</forename><surname>Van De Looij</surname></persName>
		</author>
		<author>
			<persName><forename type="first">&amp;</forename><forename type="middle">M</forename><surname>Zwitserlood</surname></persName>
		</author>
		<ptr target="http://www.javakade.nl/research/pdf/lambdascope.pdf" />
		<editor>ALPS</editor>
		<imprint>
			<date type="published" when="2004">2004. 2004</date>
			<biblScope unit="page">9</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Weak Orthogonality Implies Confluence: The Higher Order Case</title>
		<author>
			<persName><forename type="first">V</forename><surname>Van Oostrom</surname></persName>
		</author>
		<author>
			<persName><forename type="first">&amp;</forename><forename type="middle">F</forename><surname>Van Raamsdonk</surname></persName>
		</author>
		<idno type="DOI">10.1007/3-540-58140-5_35</idno>
	</analytic>
	<monogr>
		<title level="m">LFCS&apos;94</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1994">1994</date>
			<biblScope unit="volume">813</biblScope>
			<biblScope unit="page" from="379" to="392" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<author>
			<persName><forename type="first">J</forename><surname>Pearl</surname></persName>
		</author>
		<idno type="DOI">10.1017/CBO9780511803161</idno>
		<title level="m">Causality: models, reasoning, and inference, 2nd edition</title>
		<imprint>
			<publisher>Cambridge University Press</publisher>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Teams can see pomsets</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">D</forename><surname>Plotkin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">R</forename><surname>Pratt</surname></persName>
		</author>
		<idno type="DOI">10.1090/dimacs/029/07</idno>
	</analytic>
	<monogr>
		<title level="m">Partial Order Methods in Verification, Proceedings of a DIMACS Workshop</title>
		<title level="s">DIMACS Series in Discrete Mathematics and Theoretical Computer Science</title>
		<editor>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Peled</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">V</forename><forename type="middle">R</forename><surname>Pratt</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">G</forename><forename type="middle">J</forename><surname>Holzmann</surname></persName>
		</editor>
		<meeting><address><addrLine>Princeton, New Jersey, USA</addrLine></address></meeting>
		<imprint>
			<publisher>DIMACS/AMS</publisher>
			<date type="published" when="1996-07-24">1996. July 24-26, 1996</date>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="page" from="117" to="128" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Untyping Typed Algebraic Structures and Colouring Proof Nets of Cyclic Linear Logic</title>
		<author>
			<persName><forename type="first">D</forename><surname>Pous</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-642-15205-4_37</idno>
	</analytic>
	<monogr>
		<title level="m">Computer Science Logic, 24th International Workshop, CSL 2010, 19th Annual Conference of the EACSL</title>
		<editor>
			<persName><forename type="first">A</forename><surname>Dawar</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">H</forename><surname>Veith</surname></persName>
		</editor>
		<meeting><address><addrLine>Brno, Czech Republic</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010-08-23">2010. August 23-27, 2010</date>
			<biblScope unit="volume">6247</biblScope>
			<biblScope unit="page" from="484" to="498" />
		</imprint>
	</monogr>
	<note>Proceedings</note>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">T</forename><surname>Rowland</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">W</forename><surname>Weisstein</surname></persName>
		</author>
		<ptr target="https://mathworld.wolfram.com/CausalNetwork.html" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">The Frame Problem</title>
		<author>
			<persName><forename type="first">M</forename><surname>Shanahan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The Stanford Encyclopedia of Philosophy, Spring 2016 edition</title>
		<editor>
			<persName><forename type="first">E</forename><forename type="middle">N</forename><surname>Zalta</surname></persName>
		</editor>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
		<respStmt>
			<orgName>Metaphysics Research Lab, Stanford University</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<title level="m" type="main">Optimal Sharing Graphs for Substructural Higher-order Rewriting Systems</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">L</forename><surname>Smith</surname></persName>
		</author>
		<ptr target="https://kar.kent.ac.uk/63884/" />
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
		<respStmt>
			<orgName>University of Kent</orgName>
		</respStmt>
	</monogr>
	<note>Ph.D. thesis</note>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">W</forename><surname>Stark</surname></persName>
		</author>
		<idno type="DOI">10.1016/0304-3975(89)90050-9</idno>
	</analytic>
	<monogr>
		<title level="m">Concurrent Transition Systems</title>
		<imprint>
			<date type="published" when="1989">1989</date>
			<biblScope unit="volume">64</biblScope>
			<biblScope unit="page" from="221" to="269" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Reducibility between Classes of Port Graph Grammar</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">A</forename><surname>Stewart</surname></persName>
		</author>
		<idno type="DOI">10.1006/jcss.2002.1814</idno>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Syst. Sci</title>
		<imprint>
			<biblScope unit="volume">65</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="169" to="223" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
		<author>
			<persName><forename type="first">Terese</forename></persName>
		</author>
		<title level="m">Term Rewriting Systems</title>
		<imprint>
			<publisher>Cambridge University Press</publisher>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">On the ambiguation of Polish notation</title>
		<author>
			<persName><forename type="first">A</forename><surname>Visser</surname></persName>
		</author>
		<idno type="DOI">10.1016/j.tcs.2011.01.025</idno>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">412</biblScope>
			<biblScope unit="issue">28</biblScope>
			<biblScope unit="page" from="3404" to="3411" />
			<date type="published" when="2011-01">2011. Jan Bergstra</date>
		</imprint>
	</monogr>
	<note>Festschrift in Honour</note>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">An introduction to event structures</title>
		<author>
			<persName><forename type="first">G</forename><surname>Winskel</surname></persName>
		</author>
		<idno type="DOI">10.1007/BFb0013026</idno>
	</analytic>
	<monogr>
		<title level="m">Linear Time, Branching Time and Partial Order in Logics and Models for Concurrency</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1989">1989</date>
			<biblScope unit="volume">354</biblScope>
			<biblScope unit="page" from="364" to="397" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<monogr>
		<author>
			<persName><forename type="first">S</forename><surname>Wolfram</surname></persName>
		</author>
		<ptr target="https://www.wolframscience.com/nks/" />
		<title level="m">A New Kind of Science</title>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">A Class of Models with the Potential to Represent Fundamental Physics</title>
		<author>
			<persName><forename type="first">S</forename><surname>Wolfram</surname></persName>
		</author>
		<idno type="DOI">10.25088/ComplexSystems.29.1.2</idno>
	</analytic>
	<monogr>
		<title level="j">Complex Systems</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="107" to="536" />
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
