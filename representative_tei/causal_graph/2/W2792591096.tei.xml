<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">MCI: Modeling-based Causality Inference in Audit Logging for Attack Investigation</title>
				<funder ref="#_TC4KAmE #_sg8q6EW #_VDzFXWY">
					<orgName type="full">National Science Foundation</orgName>
					<orgName type="abbreviated">NSF</orgName>
				</funder>
				<funder ref="#_fdqkXXB #_j4H24pS">
					<orgName type="full">ONR</orgName>
				</funder>
				<funder ref="#_egdVAdE">
					<orgName type="full">Sandia National Lab</orgName>
				</funder>
				<funder ref="#_h74Zv69">
					<orgName type="full">DARPA</orgName>
				</funder>
				<funder>
					<orgName type="full">Cisco Systems</orgName>
				</funder>
				<funder>
					<orgName type="full">United States Air Force</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Yonghwi</forename><surname>Kwon</surname></persName>
							<email>kwon58@cs.purdue.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Purdue University</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Fei</forename><surname>Wang</surname></persName>
							<email>feiwang@cs.purdue.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Purdue University</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Weihang</forename><surname>Wang</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Kyu</forename><forename type="middle">Hyung</forename><surname>Lee</surname></persName>
							<email>kyuhlee@cs.uga.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Purdue University</orgName>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Georgia</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Wen-Chuan</forename><surname>Lee</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Shiqing</forename><surname>Ma</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Purdue University</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Xiangyu</forename><surname>Zhang</surname></persName>
							<email>xyzhang@cs.purdue.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Purdue University</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Dongyan</forename><surname>Xu</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Purdue University</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Somesh</forename><surname>Jha</surname></persName>
							<email>jha@cs.wisc.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Purdue University</orgName>
							</affiliation>
							<affiliation key="aff2">
								<orgName type="department">Department of Computer Sciences</orgName>
								<orgName type="institution">University of Wisconsin-Madison</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Gabriela</forename><surname>Ciocarlie</surname></persName>
							<email>gabriela@csl.sri.com</email>
							<affiliation key="aff3">
								<orgName type="institution">SRI International</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Ashish</forename><surname>Gehani</surname></persName>
							<email>gehani@csl.sri.com</email>
							<affiliation key="aff3">
								<orgName type="institution">SRI International</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Vinod</forename><surname>Yegneswaran</surname></persName>
							<affiliation key="aff3">
								<orgName type="institution">SRI International</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Model</forename><surname>Constructor</surname></persName>
						</author>
						<title level="a" type="main">MCI: Modeling-based Causality Inference in Audit Logging for Attack Investigation</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="DOI">10.14722/ndss.2018.23306</idno>
					<note type="submission">Segmented Parser Context Constraint Checker Audit Logs Causality Annotated Model Generation Model Parsing Recognized Causality Recognized Models</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.1" ident="GROBID" when="2025-10-14T18:31+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>In this paper, we develop a model based causality inference technique for audit logging that does not require any application instrumentation or kernel modification. It leverages a recent dynamic analysis, dual execution (LDX), that can infer precise causality between system calls but unfortunately requires doubling the resource consumption such as CPU time and memory consumption. For each application, we use LDX to acquire precise causal models for a set of primitive operations. Each model is a sequence of system calls that have inter-dependences, some of them caused by memory operations and hence implicit at the system call level. These models are described by a language that supports various complexity such as regular, context-free, and even context-sensitive. In production run, a novel parser is deployed to parse audit logs (without any enhancement) to model instances and hence derive causality. Our evaluation on a set of real-world programs shows that the technique is highly effective. The generated models can recover causality with 0% false-positives (FP) and false-negatives (FN) for most programs and only 8.3% FP and 5.2% FN in the worst cases. The models also feature excellent composibility, meaning that the models derived from primitive operations can be composed together to describe causality for large and complex real world missions. Applying our technique to attack investigation shows that the system-wide attack causal graphs are highly precise and concise, having better quality than the state-of-the-art.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I. INTRODUCTION</head><p>Cyber-attacks are becoming increasingly targeted and sophisticated <ref type="bibr" target="#b1">[2]</ref>. A special kind of these attacks, called Advanced Persistent Threat (APT), can infiltrate into target systems in stages and reside inert for a long time to remain undetected. It is important to trace back attack steps and understand how an attack unfolds <ref type="bibr" target="#b2">[4]</ref>. In the mean time, identifying the entry point of the attack and understanding the damage to the victim can be critical to recovering the victim system from the intrusion and also preventing future compromises.</p><p>Causality analysis techniques <ref type="bibr" target="#b22">[25]</ref>, <ref type="bibr" target="#b13">[16]</ref>, <ref type="bibr" target="#b21">[24]</ref>, <ref type="bibr" target="#b23">[26]</ref>, <ref type="bibr" target="#b26">[29]</ref> are widely used in attack investigation. They analyze audit logs generated by operating system level audit logging tools (e.g., Linux Audit <ref type="bibr" target="#b14">[17]</ref>, Event Tracing for Windows <ref type="bibr" target="#b35">[38]</ref>, and DTrace [13]) and correlate system events, e.g., system calls (syscalls) to identify causal relations between system subjects (e.g., processes) and system objects (e.g., files, network sockets). Such capability is particularly important in cyber-attack investigation where causality of malicious events reveals attack provenance. For example, when an attacker exploits vulnerabilities and executes malicious payloads, causality analysis can identify such vulnerable interfaces including input channels that accept malicious inputs from the user or the network. Moreover, given a set of malicious or suspicious events, it can identify all the events that are causally related to the given set of events. Essentially, these events depict the source of the attack and/or the damage induced by the attacker. However, syscall based analysis has a major limitation: dependence explosion <ref type="bibr" target="#b29">[32]</ref>. For a long-running process, an output event (e.g., creating a malicious file) is assumed to be causally related to all the preceding input events (e.g., file read and network receive). This conservative assumption causes significant false causal relations. Some recent works <ref type="bibr" target="#b29">[32]</ref>, <ref type="bibr" target="#b34">[37]</ref>, <ref type="bibr" target="#b32">[35]</ref>, <ref type="bibr" target="#b33">[36]</ref> focus on collecting enhanced information at run-time to avoid dependence explosion and enable accurate attack investigation. For instance, BEEP <ref type="bibr" target="#b29">[32]</ref> and ProTracer <ref type="bibr" target="#b34">[37]</ref> train and instrument longrunning applications to capture information of fine-grained execution units in addition to syscalls. MPI <ref type="bibr" target="#b33">[36]</ref> asks the user to annotate important data structures in applications' source code to enable semantic aware execution partitioning. Additionally, Bates at el. <ref type="bibr" target="#b4">[6]</ref> propose a general provenanceaware framework called Linux Provenance Module (LPM) that allows users to define custom provenance rules. The major hindrance of these techniques in practice is their requirements of changing end-user systems, such as instrumenting user applications, installing new runtime support, kernel modules, and even changing the kernel itself.</p><p>Taint analysis <ref type="bibr" target="#b19">[22]</ref>, <ref type="bibr" target="#b18">[21]</ref>, <ref type="bibr" target="#b17">[20]</ref> is another approach that can track causal relations (e.g., information flow) between system components (e.g., memory objects, files, and network sockets). However, whole system tainting is too computationally expensive (over 3x slow down <ref type="bibr" target="#b16">[19]</ref>, <ref type="bibr" target="#b36">[39]</ref>) to be deployed on production systems. Additionally most taint analysis techniques cannot handle implicit flow, resulting in false-negatives.</p><p>In this paper, we propose MCI, a novel causality inference technique on audit logs. Our technique does not require any changes on the end-user system, nor any special operations during system execution. The end-user only needs to turn on the audit logger shipped with the operating system (e.g., Linux Audit, Event Tracing for Windows, and DTrace). If the user detects a security incident, she only needs to provide the syscall log and program binaries from the victim system (or a disk image) to a forensic expert.</p><p>In off-line attack investigation, which is often done by the forensic expert, MCI precisely infers causality from a given system call log by constructing causal models and parsing the log with the models. Fig. <ref type="figure">1</ref> shows a high level overview of how MCI works. MCI consists of two phases: (1) causality annotated model generation, and (2) model parsing. First, MCI generates causal models by leveraging LDX <ref type="bibr" target="#b28">[31]</ref> which is a dualexecution based system that can infer causality by mutating input syscalls and then observing output changes. In this phase, MCI takes two inputs: a program binary and typical workloads. MCI's model constructor automatically runs LDX and analyzes its results to construct models. Models are expressive and capable of representing fine-grained dependencies including invisible at the syscall level (e.g., dependencies induced by memory operations). The models can be pre-generated (for widely used applications) or generated on demand after an incident. Second, during investigation MCI identifies causal relations between events in a given syscall log collected from a victim system by parsing the log with the models. The derived precise dependencies are critical for attack investigation. In summary, we make the following contributions:</p><p>• We propose a novel technique for precise causality inference that directly works on audit logs without requiring any changes or setup on end-user systems. We only require program binaries and the audit log from the victim system after the incident. • We perform a comparative study using a real-world example to illustrate the merits and limitations of existing approaches. • We propose to leverage LDX <ref type="bibr" target="#b28">[31]</ref> to identify finegrained causality from program execution. Using the generated causality information, we construct causal models annotated with fine-grained dependencies. We study the model complexity needed to describe causalities in audit logging. shows that our models have very nice composibility such that small models can be composed together to describe complex system-wide attack behaviors. Our attack causal graphs are even more precise than those generated by a state-of-the-art system <ref type="bibr" target="#b29">[32]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>II. BACKGROUND AND MOTIVATION</head><p>In this section, we use an insider information leak attack case to illustrate the limitations of existing attack provenance analysis techniques, and then to motivate our work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Motivating Example</head><p>We use a data exfiltration of confidential company data by an employee. Insider attacks are the dominant reason for data breach incidents in 2016 <ref type="bibr" target="#b0">[1]</ref>, <ref type="bibr" target="#b15">[18]</ref>.</p><p>Assume John is a project manager who has access to confidential data. John was bribed by a competitor company and attempts to breach some confidential data. However, John's company forbids copying data to removable media such as USB stick. Furthermore, the company inspects all incoming/outgoing network traffic via deep packet inspection (DPI) <ref type="bibr" target="#b27">[30]</ref>, <ref type="bibr" target="#b41">[44]</ref>, <ref type="bibr" target="#b42">[45]</ref> to prevent exfiltration of confidential data and to block malicious network traffic from outside. To bypass the packet inspection, John decides to use the GPG encryption algorithm <ref type="bibr" target="#b24">[27]</ref> to encrypt data before sending it.</p><p>GnuPG Vim plug-in. To use GPG encryption, John installed a Vim plug-in GnuPG <ref type="bibr" target="#b5">[7]</ref>, which enables transparent editing of gpg encrypted files. When he opens a file encrypted by gpg <ref type="bibr" target="#b24">[27]</ref> which is an encryption utility supported by most operating systems with the GNU library (e.g., Linux, FreeBSD, and MacOS), the GnuPG plug-in automatically decrypts and passes the decrypted data to Vim so that the user can edit the contents of the encrypted file. The plug-in automatically encrypts the contents when the user saves the gpg file.</p><p>Attack Scenario. John uses Vim equipped with the GnuPG plug-in to open three confidential files, data1, data2, and data3. He also opens out.gpg in order to store confidential data in an encrypted format. Then he copies a few lines from data2 using the Vim command 'v' to select characters and 'y' to copy them to the clipboard buffer (i.e., Vim's default register). Then he finds out the information in data3 is more up-to-date. He thus copies lines from data3 that overwrite the contents from data2. Later, he pastes the copied lines to out.gpg, saves the file in an encrypted format and terminates Vim. Note that, when he saves out.gpg, the GnuPG plug-in actually creates a new file (inode:8) and renames it to out.gpg so that the original out.gpg file (inode:4) is replaced by a new file (inode:8). Observe that the inode numbers of the original out.gpg file and the new file are different. Finally, he sends the encrypted out.gpg to a server outside the enterprise network. This data breach incident is later detected, and a forensic analysis team starts to investigate the incident. Now, we introduce existing causal analysis based forensic techniques and discuss how they work on this attack.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Existing Approaches and Limitations</head><p>System Call based Analysis. Most causal analysis techniques use syscall logging tools to record important system events at . runtime and then analyze recorded events to identify causal relations between system subjects (e.g., process) and system objects (e.g., file or network socket). Syscall logging tools are shipped with most operating systems. For example, Linux Audit <ref type="bibr" target="#b14">[17]</ref> is a default package in Linux and MacOS distributions, DTrace [13] is available in FreeBSD, and Event Tracing for Windows (ETW) <ref type="bibr" target="#b35">[38]</ref> comes with Windows.</p><p>Syscall based analysis has been studied in a number of works <ref type="bibr" target="#b22">[25]</ref>, <ref type="bibr" target="#b13">[16]</ref>, <ref type="bibr" target="#b21">[24]</ref>, <ref type="bibr" target="#b23">[26]</ref>, <ref type="bibr" target="#b26">[29]</ref>. For instance, Back-Tracker <ref type="bibr" target="#b22">[25]</ref> and Taser <ref type="bibr" target="#b13">[16]</ref> propose backward and forward analysis techniques in order to analyze syscall logs and construct causal graphs for effective attack investigation. The constructed causal graphs show system subjects and objects that involved in attacks, and their causal relations. Fig. <ref type="figure">2-(a)</ref> shows a provenance graph generated from the syscall log collected during the data breach incident discussed in the previous section. To understand the incident in detail, a security analyst first identifies the out.gpg file (inode:8) which contains confidential data. Then the analyst finds the system components that are causally related to the file from the graph in the backward direction (time-wise). Observe that it was Vim that wrote the file <ref type="bibr">( 11 11 )</ref>. Before that, Vim read /tmp/tmpfile ( 10 10 11 10 ) which was written by "gpg" ( 9 9 ). The "gpg" process (pid:2) 9 was forked by Vim ( 8 8 ). Before the fork, Vim read /tmp/tmpfile 8 ( 7 7 ) which was written by another "gpg" process (pid:1) ( 6 6 ). 7 6 "Gpg" previously read the original out.gpg file with a different inode number (inode:4) ( 5 5 ) and the "gpg" process (pid:1) was 5 forked by Vim ( 4 4 ) as well. There are also other files that Vim 4 read, including data3 ( 3 3 ), data2 ( 2 2 ), and data1 ( 1 1 ).</p><p>3 2 1</p><p>Note that Fig. <ref type="figure">2</ref>-(a) contains many false dependencies such as dependencies between the Vim process and files data1, data2, and /tmp/.X11-unix which is a socket for XWindow. The coarse-granularity of processes leads to this false dependency problem as it simply considers an output event is dependent on all the preceding input events in the process.</p><p>Execution Unit based Analysis. False dependencies in syscall based analysis are a major obstacle for attack investigation as it often causes the dependency explosion problem <ref type="bibr" target="#b29">[32]</ref>, which is a problem of having an excessive number of dependencies, with most of them being bogus. It makes investigation challenging, often leading to wrong conclusions. To address the problem, BEEP <ref type="bibr" target="#b29">[32]</ref> and ProTracer <ref type="bibr" target="#b34">[37]</ref> propose to divide a long-running process to autonomous execution units. In this way, an output event is only dependent on the preceding input events within the same execution unit. BEEP and ProTracer also detect inter-unit dependencies introduced via memory objects. ProTracer is a variant of BEEP that can significantly reduce runtime and space overhead while the effectiveness of attack analysis remains the same because they share the same mechanism to partition a long process.</p><p>Unfortunately, BEEP and ProTracer require complex binary program analysis in order to instrument a target application for execution partitioning at runtime. To detect the inter-unit dependencies, they need to identify memory dependencies across units by analyzing training runs, and instrument the target program to monitor the relevant memory accesses in production runs. Note that identifying all relevant memory accesses that induce dependencies across execution units in complex binary programs via training is challenging. Missing memory accesses in training leads to false-negatives in attack investigation. They also generate a large number of additional syscalls to denote unit boundaries and memory accesses, increasing the storage pressure.</p><p>In addition, while BEEP can prune out some false dependencies as shown in Fig. <ref type="figure">2-(b</ref>) (e.g., between data1 and Vim) by leveraging fine-grained execution units, there are still false dependencies such as those involving data2 and /tmp/.X11unit. This is because, in this example, BEEP considers each file read/write event as a separate unit and detects dependencies between units through memory objects. For example, BEEP considers units that read data2 ( 2 2 ) and data3 ( 3 3 ) are causally 2 3 related to a unit that writes out.gpg <ref type="bibr">( 11 11 )</ref> as texts from data2 11 and data3 are copied into a buffer for copy-and-paste in Vim. However, the cross-unit dependency between the unit with data2 ( 2 2 ) and another unit with out.gpg <ref type="bibr">( 11 11</ref> ) is bogus because 2 11 the contents copied from data2 are not pasted to out.gpg. The bogus dependency is introduced because BEEP simply detects memory read and memory write events with a same memory address without checking if there is true information flow between the two. In short, while BEEP can narrow down the scope of investigation, there are still unnecessary files and events in the graph.</p><p>Taint Analysis. Taint analysis techniques <ref type="bibr" target="#b19">[22]</ref>, <ref type="bibr" target="#b18">[21]</ref>, <ref type="bibr" target="#b17">[20]</ref> track information flow between a set of system components (e.g., file, memory, and network), called taint sources, to another set of system components, called taint sinks. Given a set of input related system components to track, taint analysis keeps track of how data from the specified input components are consumed and propagated by individual instructions that operate on the data, in order to identify how they impact other system components. However, most taint tracking approaches including the state-of-the-art tools such as TaintGrind <ref type="bibr" target="#b19">[22]</ref> and libdft <ref type="bibr" target="#b18">[21]</ref> are expensive as they monitor each instruction to track information flow. Furthermore, they are often not able to track implicit flows caused by control dependencies, introducing false-negatives.</p><p>To illustrate the merits and limitation of taint analysis techniques, we use a state-of-the-art open source tool, TaintGrind, to analyze the aforementioned incident. Fig. <ref type="figure">2-(c)</ref> shows the result from TaintGrind. In this example, TaintGrind fails to identify the dependency between the data3 and /tmp/tmpfile. Note that the most important part of the attack (i.e., the leaked confidential data) is not revealed in the attack investigation due to the missing dependency. We investigate the case in depth, and find that gpg decrypts values through a table lookup operation. Unfortunately, TaintGrind is not able to handle information flow through the table lookup, resulting in missing dependencies. Fig. <ref type="figure">3</ref> shows a code snippet extracted from gpg. Specifically, the function argument from contains an piece of encrypted text. At line 3, the encrypted text is used to calculate the value of work, and TaintGrind successfully propagates taint information to the variable. However, at lines 4-7, work is used to look-up a table sbox2-8, and TaintGrind loses track of taint information at this point because it does not handle information flow via array indexing. Note that most taint analysis techniques do not track information flow through array indexing to avoid the overtainting problem. Specifically, the over-tainting problem often leads to an excessive number of taint tags, resulting in falsepositives. Hence, most taint analysis tools decide not to track such information flow. In addition to table look-up, explicit data flows through computations (e.g., bitwise and arithmetic) and implicit data flows caused by control dependency are often disregarded to avoid the over-tainting problem. Moreover, the significant overhead of taint analysis prohibits its application in practical forensic analysis that requires always-on monitoring to capture attacks in-the-wild. <ref type="bibr" target="#b28">[31]</ref> using a dynamic analysis called dual execution. For a given original execution, LDX derives a slave execution in which it mutates values of input source(s). It then compares the corresponding outputs from the original execution and the slave execution to determine whether the outputs are causally dependent on the source(s). Specifically, if the two executions have different values for an output, LDX considers that the output is causally dependent on the mutated input source(s). To address execution path divergence caused by input perturbation, LDX leverages its novel on-the-fly execution alignment scheme. Unlike dynamic taint analysis techniques (e.g., TaintGrind <ref type="bibr" target="#b19">[22]</ref> and libdft <ref type="bibr" target="#b18">[21]</ref>), LDX can detect explicit and implicit information flow and has much lower runtime overhead (about 6%). Fig. <ref type="figure">2-(d)</ref> shows the graph generated by LDX. Note that it contains only the objects and events related to the attack, without any false dependences. While LDX produces concise and accurate graphs, it requires the dual-execution framework available on the end-user system which doubles the consumption of computational resources (e.g., CPU and memory).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Causality Inference. Recently, Kwon et al. propose a lightweight causality inference technique LDX</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Goals and Our Approach</head><p>Table I presents merits and limitations of existing causality analysis approaches. In summary, syscall analysis techniques suffer from high false-positive rates due to dependence explosion. While BEEP and ProTracer mitigate the dependence explosion problem, they require complex static, dynamic binary analysis and instrumentation and incur non-trivial space overhead. MPI is efficient and effective, but requires access to source code and domain knowledge for annotation. Taint analysis techniques generally incur significant runtime and space overhead and suffer from the over-/under-tainting problems. LDX requires the dual-execution framework in production run that doubles computational resource consumption.</p><p>Our Goal. The goal of this paper is to provide a causality analysis technique with the same accuracy as LDX, but does not require any changes of end-user systems, such as instrumenting user applications, modifying the kernel or installing special runtime. Specifically, the end-user only needs to turn on the default audit logging tool that comes with their system, such as Linux Audit, Event Tracing for Windows, and DTrace to collect syscall logs. Upon a security incident, MCI can generate precise causal graphs from the raw log to explain attack causality and assess system damages. We believe such a design would substantially improve applicability.</p><p>Our Approach. As shown in Fig. <ref type="figure">1</ref>, the key idea of MCI is to use causal models to parse raw logs to derive precise causality information. Specifically, in the offline phase, we use LDX <ref type="bibr" target="#b28">[31]</ref> as the causality inference engine to construct models for the applications that will be deployed on an end-user system. A causal model is essentially a sequence of inter-dependent syscalls and their causal relations. Such causalities/dependencies can be induced by system objects, called explicit dependencies, as they can be determined by analyzing syscalls alone, or induced by memory operations and control dependences, called implicit dependences, which are not visible by analyzing syscall events. Note that LDX can detect both explicit and implicit dependencies.</p><p>During deployment, given a syscall log collected from the incident, MCI can precisely infer causality between events in the log by parsing the log using the pre-generated models.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D. MCI on Motivating Example</head><p>We demonstrate the effectiveness of MCI on investigating the incident. Assume the causal models of applications have </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Syscall Analysis</head><p>Fine-grained Analysis Taint Analysis Causality MCI <ref type="bibr" target="#b22">[25]</ref>, <ref type="bibr" target="#b23">[26]</ref>, <ref type="bibr" target="#b13">[16]</ref> BEEP <ref type="bibr" target="#b29">[32]</ref>/ProTracer <ref type="bibr" target="#b34">[37]</ref> MPI <ref type="bibr" target="#b33">[36]</ref> WinLog <ref type="bibr" target="#b32">[35]</ref> [22], <ref type="bibr" target="#b18">[21]</ref>, <ref type="bibr" target="#b17">[20]</ref> Inference: LDX <ref type="bibr">[</ref>  show the graphical representations of some models from Vim. A node is denoted by a letter which represents a syscall, with a superscript ( * ) representing a sequence of syscalls. A subscript represents the (symbolic) system object (e.g., file or socket) operated by the syscall. For example, model (a) is for the behavior of opening and decrypting a gpg file. Specifically, as shown in the legend in Fig. <ref type="figure" target="#fig_1">4</ref>, the first node of (a) r α indicates a read syscall on α which is stdin. Note that each model has its own legend for the subscript. The first node is a syscall that causes the entire behavior. Intuitively, the model represents reading from a command line that loads a gpg file. The second node, s β , represents a stat syscall on a file β (output file). The GnuPG plug-in uses a temporary file to store decrypted contents and then informs Vim to open. Subscript β symbolizes the temporary file which contains decrypted contents. The second node essentially checks whether the file exists. After that it loads a key file to prepare decryption which is represented as a third node (r * γ ). Then, it checks (stat) the output file again (s * β ). Finally, the fifth node (r * δ ) represents reading a gpg file which is an encrypted file. The sixth node (w β ) indicates that the decrypted contents are written onto the output file (β). Then, the GnuPG plug-in sends a notification to Vim via a pipe which is shown in the last node (w ). Note that symbols in subscript (e.g. α, β) can be instantiated to any concrete file handler during parsing. The same subscript β in s β and the later nodes s * β and w β dictate that these syscalls must operate on the same file. The third and fifth nodes are denoted by a superscript * , representing a sequence of read system calls (read * ) on different files γ and δ.</p><p>The directed edges between nodes represent the causality/dependency between syscalls, with the solid and dotted edges representing the explicit and implicit dependencies, respectively. For example, in (a), there are explicit dependences from s β to w β and implicit dependencies from r * γ and r * δ . The implicit dependencies are caused by memory operations that copy values from a crypto key file (γ) to encrypted contents δ that are detected and modeled by MCI. Fig. <ref type="figure" target="#fig_1">4-(f</ref>) illustrates a syscall log collected during the incident by the default Linux Audit tool <ref type="bibr" target="#b14">[17]</ref>. Given the syscall log and the models, MCI automatically parses the log and hence derives the corresponding dependencies. Each box in (f) denotes a model instance with the letter annotated on the box representing the model id. Note that we use different background colors for boxes to represent nodes belong to different models. We omit the dependences in the model instances for readability. For readability, we use superscripts to denote event timestamps.</p><p>The model instances essentially tell us that the user first opened a gpg file (i.e., out.gpg) by model (a), opened and copied a file (i.e., data2) without pasting by model (b), and opened, copied, and pasted another file (i.e., data3) by model (c). Observe that there are events that belong to multiple models, which allow us to determine causality across models and hence compose the whole attack path. For instance, event s 11  5 belongs to both models (c) and (d) (i.e., the node in the two boxes in blue and green), suggesting that the contents from data3 are copied to the previous gpg file. The subscript 5 corresponds to file viminfo that is used to indicates the state of editing. Note that model (c) does not have explicit dependencies with other models. Hence, without model (d), causality between model (c) and other models is difficult to reveal. After a few editing operations by model (d), the user finally saved the contents to a new gpg file by model (e). The event s 11 5 belonging to models (c) and (d) indicates that the new gpg file contains information from data3 (confidential data). Note that the matched instance of model (b) does not have any overlapping nodes with other model instances nor explicit dependencies, and hence no causal relations with others. This indicates that data2 is not involved in the incident. The final causal graph is shown Fig. <ref type="figure">2-(d)</ref>, which is accurate and concise, without any missing or bogus dependencies.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>III. PROBLEM DEFINITION</head><p>In this section, we introduce a number of formal definitions and the problem statement for MCI.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Definitions</head><p>Causal Model. Fig. <ref type="figure">5</ref> shows definitions for a causal model. Specifically, SysName represents syscall names such as open and read. Repetition indicates how many times a term or node repeats. It could be a constant number, a variable such as n or m, or * representing any number of repetition. Variables are needed to to denote repetition constraints across syscall events. ResourceSymbol represents a symbol for a resource handler that a system call operates on (e.g., file handler). A Term is a sequence of Nodes that could be annotated with the number of repetitions. A node N is a syscall annotated with a set of parameters denoted by SymbolicResource. A symbolic resource can be instantiated to different concrete resources during parsing. Two nodes with the same symbolic resource indicates that they have explicit dependency. An Edge denotes dependency/causality between two nodes N from and N to . Finally, a causal model is defined as a 3-tuple &lt; T , P(E) implicit , P(E) explicit &gt; where T is a sequence of terms, P(E) implicit is the set of implicit dependency edges and P(E) explicit is the set of explicit dependency edges. The definitions of two kinds of edges can be found in Sec. II.  For example, the model in Fig. <ref type="figure" target="#fig_1">4</ref> (a) can be represented as follows. First, T can be represented by a sequence: Observe the nodes in an explicit edge have the same resource symbol, indicating that they operate on the same resource. In the paper, we will use the more concise graphical representations when possible.</p><formula xml:id="formula_0">read α , stat β , read * γ , stat * β , read * δ ,</formula><p>Syscall Trace. As shown in Fig. <ref type="figure" target="#fig_4">6</ref>, a system call trace T is a sequence of trace entries TE where a trace entry is a system call name annotated with a set of ConcreteResource that represents concrete resource handlers, and a number N that represent an index of TE in T . Note that it does not contain any dependency information. The first 6 entries in Fig. <ref type="figure" target="#fig_1">4</ref> (f) are represented as TE = (read 1 0 , stat 2 1 , ..., read 3 2 , write 4 1 , ...). Note that the subscripts represent concrete resource handlers and the superscripts represents indexes. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Problem Statement</head><p>We aim to infer fine-grained causality from a syscall trace by parsing it with models. This procedure can be formally defined as a function of T and P(M ):</p><formula xml:id="formula_1">T × P(M ) → (TE → P(N × M ))</formula><p>Specifically, given a syscall trace T and a set of models P(M ), the function generates a mapping, in which a trace entry is mapped to a set of nodes N in model M . It is a set because a trace entry can be present in multiple models as shown in the motivation example in Sec. II. With the mapping, the dependencies between trace entries can be derived from the dependencies between the matched nodes in the models. For example, parsing the trace in Fig. <ref type="figure" target="#fig_1">4</ref> (f) using the models in (a)-(d) generates the following mapping. The first 4 events are mapped to model (a): 4  1 →&lt; write β , M a &gt;). Moreover, stat 11  5 belongs to two models, resulting in two mappings: (stat 11   </p><formula xml:id="formula_2">(read 1 0 →&lt; read α , M a &gt; ), (stat 2 1 →&lt; stat β , M a &gt;), (read 3 2 →&lt; read * δ , M a &gt; ), (write</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>5</head><p>→&lt; stat , M c &gt;), (stat 11  5 →&lt; stat β , M d &gt;). It entails the following concrete dependency edges &lt; read 3 2 , write 4  1 &gt; (from model edge &lt; read * δ , write β &gt; in (a) ) and &lt; stat 12  5 , stat 14  1 &gt; (from model edge &lt; stat β , stat * δ &gt; in (d)). The first edge indicates implicit dependency between the original gpg file (out.gpg) and a temp file containing its decrypted contents, and the second edge implies that the copy and paste action is related to the temp file containing the decrypted contents of the original gpg file (out.gpg). Such dependency edges lead to a causal graph as that in Fig. <ref type="figure">2-(d)</ref>.</p><p>The mapping may not be total, depending on the comprehensiveness of the models. An important feature of MCI is model composibility, meaning that a complex behavior can be composed by multiple models sharing some common nodes. For instance, a complex user behavior in Vim such as "open file, edit, copy, edit, paste, save, reopen" can be decomposed to multiple primitive models. As such, the number of models needed for regular workload is limited as shown in Sec. V.</p><p>The key challenge of MCI lies in parsing the trace that does not contain any dependencies with models that contain dependency information, which entails solving two prominent technical problems discussed next.</p><p>C. Technical Challenges: Complexity and Ambiguity 1) Language Complexity: According to our definition, a trace is a string in the trace language that does not contain dependency information, our problem is essentially to parse the string to various model instances. In the following, we use the classic language theory to understand the complexity of our problem. Note that although it seems that we could consider models as graphs and leverage the sub-graph isomorphism theory to understand our problem, there are places that can hardly be formulated in the graph theory. For instance, our trace is not a graph because it does not have implicit dependency information. Furthermore, our model may have constraints among the numbers of event repetitions (e.g., the number of close matches with the number of open while the number of repetitions may vary). Such constraints can hardly be represented in graphs.</p><p>The classical Chomsky hierarchy <ref type="bibr" target="#b7">[9]</ref>, <ref type="bibr" target="#b8">[10]</ref> defines four classes of languages characterized by the expressive power of their defining grammars: regular, context-free, contextsensitive, and recursively enumerable. More expressive grammar can describe more complex language but requires higher cost in parsing. We study some of representative causal model types observed in real-world programs. For each type, we show a sample grammar and discuss the complexity of the grammar as well as scalability of the corresponding parser. Regular Model. Fig. <ref type="figure" target="#fig_5">7</ref> shows a model from ping <ref type="bibr" target="#b37">[40]</ref>, representing a behavior "resolving a network address, sending a packet, and receiving a response."</p><p>Observe that the explicit dependencies (solid edges) are caused by the socket (β). The implicit dependencies (dotted edges) are introduced because gethostbyname() decides whether to execute socket() and sendto() meaning that they have control dependences. In particular, if gethostbyname() returns an error, the program immediately terminates. Also, sendto() is dependent on the return value of gethostname() (e.g., IP address) as the ping program composes and sends Internet Control Message Protocol (ICMP) packets that contain the returned IP address. Such dependencies are not visible at the syscall level. Note that in any model, the first node, which is always an input syscall, has dependencies leading to all other nodes. Recall that a model is acquired from LDX that mutates an input syscall and observes changes at output syscalls (e.g., the first node in Fig. <ref type="figure" target="#fig_5">7</ref> is a syscall that reads an option from the command line that leads to all the other syscalls in the model).</p><p>The model in Fig. <ref type="figure" target="#fig_5">7</ref> can be simplified by a regular grammar (e.g., regular expression) which is the simplest one in Chomsky hierarchy. A regular language parser has very good scalability. From our experience, most models (53 out of 56 models in our evaluation) fall into this type. Context-free Model. There are cases that the models need to be context-free. Fig. <ref type="figure" target="#fig_6">8</ref> shows such a model extracted from procps <ref type="bibr" target="#b6">[8]</ref>. The model represents "retrieving file system information." It first reads a file that contains information about the list of file systems. It then uses an outer loop to emit the information for individual file systems. For each file system, an inner loop is used to collect information about the file system from multiple places (e.g., different disks).</p><p>As shown in Fig. <ref type="figure" target="#fig_6">8</ref>, three symbols from the 2 nd to the 4 th (o β , r β , c β ) have explicit dependencies due to the file containing the list of file systems (β). The 5 th symbol w n γ is to emit the header information for each file system, causing the implicit dependency between the 3 rd symbol r β and the 5 th . The superscript n denotes that there are n file systems. The 6 th , 7 th , and 8 th symbols (o δ , r δ and c δ ) form a term, corresponding to the inner loop that reads m places to collect information for the n file systems. Note that m may not equal to n as multiple files may be accessed in order to collect information for a file system. After that, the 9 th symbol w n γ emits the collected information for the n file systems. Note that the number of writes in the 5 th and the 9 th symbols need to be identical (n times). The constraints on the numbers render the model cannot be transformed to an automaton that handles a regular language. It is essentially context-free. The parser for a context-free language requires some push-down mechanism, incurring higher complexity. We have encountered 2 contextfree models in our evaluation. Context-sensitive Model. In some rare cases, even contextfree models are not sufficiently expressive. Fig. <ref type="figure" target="#fig_7">9</ref> shows a model from <ref type="bibr" target="#b46">[49]</ref> which is a distributed voting application that implements the Raft consensus protocol <ref type="bibr" target="#b40">[43]</ref>. The program can exchange network messages between different number of users to get a consensus. The model describes a voting procedure. Specifically, it receives network messages from n users (n iterations of read()), and sends network messages to m users (m iterations of write()). Later, it closes the sockets for n users and then m users. The crossing-constraints between m and n ( r2 n , c n ) and ( w m , c m ) require a context-sensitive language. However, a parser for a context-sensitive language is prohibitively expensive in general (PSPACE complexity <ref type="bibr" target="#b12">[15]</ref>).</p><p>We have not encountered any models more complex than context-sensitive languages. The various language complexities pose a prominent challenge: since syscall events belonging to multiple models interleave and are often distant from each other, we cannot know which model an event belongs to until reaching the end of the model. As such, we do not know which complexity class shall be used to parse individual events. As we will show later, we develop a uniform parsing algorithm for multiple complexity classes that leverages the special characteristics of causal models.</p><p>2) Ambiguity: The strings (of syscalls) parsed by multiple models may share common parts (e.g., common prefixes). In the worst case, multiple models may accept the same string, although we have not encountered such cases for models within the same application. As a result during trace parsing, given a syscall, there may be multiple models that it can be attributed to and MCI does not know which model(s) are the right ones. We call it the ambiguity problem.</p><p>For instance, consider a trace, the ground-truth causality of the trace, and a model shown in Fig. <ref type="figure" target="#fig_8">10-(a), (b),</ref> and<ref type="figure">(c)</ref>, respectively. Observe that the model has a socket read followed by a file write. The two have implicit dependency but not explicit dependency visible at the syscall level. The three boxes in Fig. <ref type="figure" target="#fig_8">10-(b</ref>) denote the three real model instances.  When the model is used to parse the trace, due to the lack of dependencies between the two syscalls in the model, there are many possible matchings as shown in Fig. <ref type="figure" target="#fig_8">10-(d)</ref>. Note that except M 1 , the other matchings are incorrect even though they all appear possible at the syscall level. In practice, such incorrect matchings introduce false causalities which hinder attack investigation. Moreover, ambiguity may cause excessive performance overhead because MCI has to maintain numerous model instances at runtime. The root cause of the problem is that the trace does not have sufficient information. Hence, we develop a method that leverages explicit dependences to mitigate the problem. Details can be found in Sec. IV-B.</p><p>IV. SYSTEM DESIGN MCI consists of two phases: model construction and model parsing. The former is offline and the latter is meant to be deployed for production run.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Model Construction</head><p>Given an application, the forensic analyst provides a set of regular workloads. The application is executed on the LDX system with the workloads. The dependences detected by LDX, including explicit and implicit dependences, are annotated on the syscall events in the audit logs. The annotated logs are analyzed to extract inter-dependent subsequences, which are further symbolized (i.e., replacing concrete resource handlers with symbolic ones). The sequences of symbolic syscalls with dependences constitute our causal models.</p><p>In the following, we use a program snippet in Fig. <ref type="figure" target="#fig_9">11</ref> to illustrate how MCI constructs causal models. It first reads a network message (line 1) and encrypts the received message (line 2). Later, it stores the encrypted message to a file (line 3) and sends a notification to a GUI component (line 5).</p><p>while( (len = read(socket, buf, 1024)) != -1 ) { ebuf = encrypt(buf); write( file, ebuf, 4096 ); } sendmsg( wnd, "Update: " + ebuf ... ); </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>1) Dependencies Identification by LDX:</head><p>The program is executed with a typical workload on LDX <ref type="bibr" target="#b28">[31]</ref> to collect a system call log T . To identify dependencies, LDX mutates the value of input syscall read() in the slave execution. By contrasting the values of the following syscalls (e.g., the write() and sendmsg()) in the two executions, LDX identifies all the dependencies between syscalls. Fig. <ref type="figure" target="#fig_0">12</ref> shows the output generated by LDX. It includes two read()s (lines 3 and 5), one write() (line 4) and one sendmsg() (line 6) which are causally dependent on the source (i.e., read() at line 2). More specifically, the write() at line 4 and sendmsg() at line 6 are (implicitly) dependent on the source by variables buf and ebuf, and the read()s at lines 2 and 4 are explicitly dependent on the source due to the socket handler 0x11.</p><p>The generated sequence of syscalls includes all the syscalls causally dependent on the source (line 3). We hence leverage them as a sample of the model. Note that LDX also returns dependences between syscalls inside the sequence such as the dependence between lines 3 and 4.</p><p>2) Symbolization: The collected sequence of syscalls cannot be directly used as a model due to the concrete arguments. For instance, in Fig. <ref type="figure" target="#fig_0">12</ref>, syscalls have concrete values (e.g., handlers 0x11 and 0x12) which may differ across executions. Hence, we symbolize concretes values in syscalls by replacing with symbols (e.g., α and β). For instance, if two syscalls share the same argument, they are assigned the same symbol.</p><p>If the application supports repeated workload, there must be repetitions in the syscalls that need to be modeled (such as n and m in Fig. <ref type="figure">5</ref>). To do so, MCI duplicates the workload a few times and feeds the new workloads to LDX again. Subsequences that have a constant number of repetitions across workloads are annotated with the constant. Those that have varying numbers of repetitions across workloads are annotated with '*'. If there are correlations between the repetition numbers of multiple subsequences (inside the same model), variables n/m are used to model the number of repetition, such as the previous example Fig. <ref type="figure" target="#fig_6">8</ref>  Fig. <ref type="figure" target="#fig_11">13</ref> shows a symbolized log. For example, 0x11 in read() in Fig. <ref type="figure" target="#fig_0">12</ref> is replaced by a new symbol fd 1 and 0x12 in write() in Fig. <ref type="figure" target="#fig_0">12</ref> is generalized to another symbol fd 2 . 0x11 in the second read() is replaced by the previously assigned symbol fd 1 as it already appeared before. Moreover, as shown in Fig. <ref type="figure" target="#fig_11">13</ref>, all concrete return values are symbolized as either SUCCESS or FAILURE. They are part of the models in our system although our formal definitions did not describe them for brevity. The constructed model is shown in Fig. <ref type="figure" target="#fig_12">14</ref>. The formal model construction algorithm is elided due to the space limitations. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Trace Parsing with Models</head><p>In this section, we describe how MCI parses an audit log with models. As we described in Sec. III-C1, if we simply consider an audit log as a string of the trace language, we need to consider three language classes in the Chomsky hierarchy, namely, regular, context-free, and context-sensitive languages. Recursively enumerable languages are never encountered in our experience. A more expressive language requires more expensive parser. For instance, context-free language can describe almost all causal models we have encountered but context free parsers have a time complexity of n 3 where n is the length of a string (the number of events in audit log in our case), thus they are too expensive to handle real-world logs that can grow in the pace of gigabytes per day <ref type="bibr" target="#b30">[33]</ref> (corresponding to millions of events). Context-sensitive parsers have even higher computational complexity. Furthermore, our parser needs to be able to substantially mitigate the ambiguity problem in which MCI does not know which models an event should be attributed to.</p><p>Segmented Parsing. Our proposal is not to consider a trace as a simple string, but rather a sequence of symbols with explicit inter-dependences. Note that explicit dependences can be directly derived from the trace. The basic idea is hence to leverage explicit dependences to partition the sequence of terms/nodes in a model into segments, delimited by terms/nodes that are involved in some explicit dependences. Therefore, all the terms/nodes inside each segment are a string in some regular language. The essence is to leverage explicit dependences to reduce language complexity. During parsing, we first recognize (from the trace) the explicit dependences that match those of the model. These dependences partition the trace into sub-traces. Then automata are used to recognize model segment instances from the sub-traces. Since string parsing is only carried out within small sub-traces instead of the lengthy whole trace, ambiguity can be substantially suppressed. We call the technique segmented parsing. Next, we use an example to illustrate the basic idea and then explain the algorithm. Fig. <ref type="figure" target="#fig_13">15</ref> shows a sample model. Observe that there are explicit dependences between the 1 st and the 6 th nodes ( r α and w α ), and between the 4 th and the 8 th nodes ( s δ and o δ ). The sequence of terms/nodes involved in explicit dependences form the model skeleton. In our example, it is r α -s δ -w α -o δ . The skeleton partitions the model into sub-models. A sub-model is a sub-sequence of nodes/terms of the model that are delimited by explicit dependences but themselves do not have any explicit dependences. In Fig. <ref type="figure" target="#fig_13">15</ref>, three sub-models are obtained as follows: s β -r γ delimited by r α and s δ , w delimited by s δ and w α , and r ζ delimited by w α and o δ .</p><p>During parsing, we first find instances of the model skeleton. For each skeleton instance, we try to identify instances of sub-models within the trace ranges determined by the skeleton instance. Any mismatch in any sub-model indicates this is not a correct model instance and the corresponding data structures are discarded. In our example, we first locate the possible positions of r α , s δ , w α , o δ in the trace, and then look for the instances of s β -r γ in between the positions of r α and s δ , and so on. Partitioning a model to a skeleton and a set of sub-models is straightforward. Details are hence elided. Given a trace, to facilitate segmented parsing, we extract a number of trace indexes, each containing all the nodes related to the same system object (e.g., a file) and the position of the nodes in the raw trace. These indexes allow our parser to quickly locate skeleton instances in the trace. Fig. <ref type="figure" target="#fig_4">16</ref> shows an example of index extraction from a trace. Observe that all the nodes in an index have explicit dependences.  Algorithms. The parsing procedure consists of three major steps. The first one is to preprocess trace to extract indexes, which has been intuitively explained before. The second step is to locate skeleton instances in the trace and the third is to parse sub-models. In the following, we explain the algorithmic details of steps two and three.</p><p>The algorithm of locating skeleton instances is shown in Alg. 1. It takes the trace T , the indexes I that can be accessed by the concrete resource id (e.g., file handler), and a model skeleton S, and identifies all the possible instances of the skeleton. The result is stored in P . Each instance is a pair map, seq with map projecting each symbolic resource (e.g., α and β) in the skeleton to some concrete handler and seq storing the trace positions of the individual nodes in the skeleton. To simplify our discussion, we assume the skeleton does not have repetitive nodes or terms. The algorithm can be easily extended to handle such cases.</p><p>The main procedure iterates over each node N α in the skeleton (line 2) with N the syscall and α the symbolic resource. For the first node (indicated by an empty result set P ), the algorithm considers each syscall of the same type N , in the form of N h at location i in the trace, may start an instance of the skeleton, and hence instantiates α to the concrete handler h and records its position i (lines 3 and 4). If N α is not the first node, the algorithm iterates over all the skeleton candidates in P in the inner loop (lines <ref type="bibr" target="#b4">[6]</ref><ref type="bibr" target="#b5">[7]</ref><ref type="bibr" target="#b6">[8]</ref><ref type="bibr" target="#b7">[9]</ref><ref type="bibr" target="#b8">[10]</ref><ref type="bibr" target="#b9">[11]</ref><ref type="bibr" target="#b10">[12]</ref><ref type="bibr">[13]</ref><ref type="bibr" target="#b11">[14]</ref><ref type="bibr" target="#b12">[15]</ref><ref type="bibr" target="#b13">[16]</ref><ref type="bibr" target="#b14">[17]</ref><ref type="bibr" target="#b15">[18]</ref> to check if it can find a matching of the node for these candidates. If not, the skeleton candidate is invalid and hence discarded. Specifically, for each skeleton candidate denoted as map, seq , line 7 identifies the trace position of latest node i. This is needed as the algorithm looks for the match of N α in trace entries beyond position i. The condition at line 8 separates the processing to two cases with the true branch denoting the case that α has been instantiated before, that is, a node of the same symbolic resource was matched before (e.g., w α in Fig. <ref type="figure" target="#fig_13">15</ref>), the else branch otherwise (e.g., s δ in Fig. <ref type="figure" target="#fig_13">15</ref>). In the first case (lines 9-11), the algorithm looks up the index of the concrete handler associated with α, i.e., I[map[α]], to find a concrete syscall N beyond position i (line 9). If such a syscall is found, we consider the algorithm has found a match and the new position pos is appended to seq (line 11). Otherwise, the skeleton candidate is not valid and removed (line 13). Here, we have another simplification for ease of explanation. Line 9 may return multiple positions in practice while in the algorithm we assume it only returns one. The extension is straightforward.</p><p>In the else branch, the node has a new symbolic resource, the algorithm has to go through all indexes to find all instances of N and instantiate the symbolic resource accordingly. This may lead to the expansion of the candidate set P . Details are elided. To reduce search space, we use time window and other syscall arguments to limit scopes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm 2 Model Parsing</head><p>Input: trace T , skeleton instances P , sub-models S Output: the concrete syscall entries that correspond to the sub-models in the temporal order 1 procedure PARSESUBMODELS(T , P , S) 2 for all map, seq ∈ P do 3 for i from 0 to |S| - Given a set of skeleton instances for a model M , Alg. 2 parses the sub-models of M . In particular, the outer loop (lines 2-11) iterates over all the skeleton candidates identified in the previous step. If matches can be found for all sub-models regarding a skeleton instance, the matches are emitted. Otherwise, it is not a legitimate instance and discarded. Specifically, the inner loop in lines 3 and 4 iterates over individual submodels in order. In the i th iteration, it uses automata to parse sub-model S[i] in the trace range identified by the i th segment identified by the skeleton candidate, which is from seq[i] to seq[i + 1] (line 4). Automata based parsing is standard and elided. After such parsing, line 6 checks if we have found matches for all sub-models. If so, line 7 further checks that none of the concrete syscall entries that are matched with some node in a sub-model do not share the same resource (and hence have explicit dependences). This is because the model specifies that there are not explicit dependences between the corresponding nodes. Line 8 outputs the parsing results.</p><p>Handling Threaded Programs. Threading does not pose additional challenges to MCI in most cases because syscalls from different threads have different process ids so that models can be constructed independently for separate threads. Explicit dependences across threads can be easily captured by analyzing audit logs. Some programs such as Apache and Firefox use in-memory data structures (e.g., work queues) to communicate across threads, causing implicit dependences. However, it is highly complex to model and parse behaviors across threads due to non-deterministic thread interleavings. We observe that these data structures are usually protected by synchronizations, which are visible at the syscall level, and the synchronizations should follow the nature of the data structures, such as first-in-first-out for queues. Hence, MCI constructs models for individual threads including the dispatching thread and worker threads. The models include the synchronization behaviors. It then leverages the FIFO pattern to match nodes across threads. It works nicely for most of the programs we consider except transmission, whose synchronization is not visible at the system level (Sec. V).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>V. EVALUATION</head><p>In this section, we evaluate MCI with a set of real-world programs in order to answer the following research questions. RQ 1. How many models are required to infer causality for these programs in production runs (Sec. V-A1), and how much efforts are required to construct models? (Sec. V-A2) RQ 2. How effective is MCI for system wide causality inference including multiple long-running programs and various activities? (Sec. V-B) RQ 3. How effective is MCI for realistic attack investigation? (Sec. V-C) RQ 4. Is MCI scalable on large workloads for long-running programs? (Sec. V-C3) Experiment Setup. We evaluate our approach on 17 realworld programs. Table <ref type="table" target="#tab_8">II</ref> shows the programs and models we constructed. Note that 15 out of the 17 programs (except zip and Vim) are network related which is a popular channel for cyber-attacks. For each program, we construct models offline. We use typical workloads briefly described in the second column of Table <ref type="table" target="#tab_8">II</ref>. Specifically, if there are available test inputs for a program, we use them as the typical workloads. Otherwise, we construct inputs by inspecting program manuals and identifying options and commands that can trigger different functionalities, such as for proftpd, CUPS, and zip.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Model Construction</head><p>Table <ref type="table" target="#tab_8">II</ref> shows the constructed models for each program. Columns 1 and 2 show programs and model description.</p><p>Column Size shows the number of nodes in each model. The numbers in/out parentheses are for the same behaviors with/without HTTPS. The next two columns show the number of explicit and implicit dependencies in each model. The last column (Lang.) shows the language class of each model (Regular (Reg.), Context-free (C.F.), or Context-Sensitive (C.S.)).   2 : # of explicit dependencies (edges) in a model. 3 : # of implicit dependencies (edges) in a model. 4 : Language Class of a model. 5 : for HTTPS.</p><p>We have the following observations from the results. First, the size of model is relatively small (on average 10.2 nodes) and there are on average 2.4 explicit dependencies (more than 4 nodes) for each model. The strong presence of explicit dependencies allows MCI to perform segmented parsing effectively. Second, we observe three language complexity classes and most models fall into the regular class. It supports our design choice of integrating regular parsers (i.e., automata) with explicit dependency tracking.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>1) # of Models Required:</head><p>The constructed models listed in Table <ref type="table" target="#tab_8">II</ref> are sufficient to infer causality for logs from realistic scenarios described in Sec. V-C including the motivation example in Sec. II. The number of models for each program ranges from 3 to 12 which is fairly small and not difficult to obtain in practice. We observe that the primary reason why MCI is effective with a small number of models is model composibility, namely, primitive models can be used to compose complex behaviors. For instance, models for "Edit" and "Save" can compose a new model "Edit and Save".</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2) Efforts on Model Construction:</head><p>To construct models, a program is executed repeatedly on LDX. The number of runs required to construct a model depends on the number of events in the model. Specifically, we first run a program with a workload on LDX to identify all the events causally dependent on the workload. Note that the detected events constitute the bulk of the model. Assume there are n such events (nodes). For each node in the model, MCI mutates the value of the corresponding syscall to determine dependencies on the node inside the model. To figure out the repetition factors of the node (Sec. IV), MCI runs k times for the node, each execution repeats the workload for different times. In total, we run a program (k * n) + 1 times to construct a model. In our experiments, k = 10. On average, the machine time to construct a model, including LDX execution time and model extraction time, takes 4 minutes (253 seconds).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. System-wide Causality Inference</head><p>In this experiment, we apply MCI to infer causality on a system wide syscall trace collected for the system execution of a week, to demonstrate the effectiveness of causality inference for realistic programs with production runs. The trace includes syscall logs from multiple programs including those in Table <ref type="table" target="#tab_8">II</ref>. Specifically, we enable Linux Audit and use the programs in Table <ref type="table" target="#tab_8">II</ref> with typical workloads for a week. Given the collected trace, we identify all the inputs that appear in the trace (e.g., file reads, command line arguments, user interactions). Then, we build a forward causal graph from each input, i.e., identifying all other syscalls depending on the input, using MCI and compare it with the ground truth by LDX. During the experiment, we record all inputs used for the programs. Then, we re-execute the program with the recorded inputs to reproduce the same execution. To do so, we develop a lightweight record and replay system similar to ODR <ref type="bibr" target="#b3">[5]</ref>. LDX is run on top of the replay system to derive the ground truth. Note that due to the limitation of the replay system, the replayed execution may differ from the original execution. Such differences are counted as false-positives/negatives for conservativeness. The collected log consists of syscalls from multiple programs and the size of the log is around 732 GB (without compression) containing 3707 million events. We first separate the log into smaller logs per process.</p><p>Table <ref type="table" target="#tab_10">III</ref> shows results of the experiment. The second column shows # of events (syscalls) in the log for each program. The third and forth columns represent # of dependencies detected and # of models matched by MCI. For the # of dependencies, we count all those inferred by MCI via matched models and those explicit dependencies across matched models. The last column shows false-positive and false-negative rates.</p><p>For most programs, MCI precisely identifies causality with not measurable false-positives and false-negatives. There are a few exceptions: Firefox, CUPS, alpine, and transmissions. We manually inspect a subset of these false-positives/negatives and have the following observations. Our Firefox models are intended to describe browser behaviors such as following a hyperlink and opening a tab. However, logs contain a lot of syscalls generated by the page content. Some of them are not much distinguishable from browser-intrinsic behaviors, leading to mismatches. For CUPS, we identify new behaviors during the experiment which are variations of the existing models. Transmission is a threaded program with memory based synchronizations that are invisible to MCI. Hence, MCI misses some thread interdependences via memory.</p><p>Comparison with BEEP. To evaluate the effectiveness of MCI when compared with BEEP, we randomly select 100 system objects (e.g., files or network connections) accessed in the week-long experiment. For each selected system object, we construct a causal graph by BEEP and by MCI, and compare the two. Table <ref type="table" target="#tab_11">IV</ref> shows the results. First of all, we observe that MCI has fewer false-positives and false-negatives. Again, we use LDX as the ground truth. Especially, MCI reduces the falsepositive rate significantly. We investigate some of the cases that BEEP introduces false-positives, and find that many system objects accessed in a unit are included in the causal graphs while they are not causally related. Also, BEEP causes slightly more false-negatives due to missing inter-unit dependencies. We analyze the cases and find that the missing inter-unit dependencies were due to incomplete instrumentation caused by the difficulty of binary analysis in BEEP. We also manually investigate false-positive and false-negative cases from MCI. It turns out they are mostly caused by concurrent executions in transmission. Runtime/memory Overhead. We also measure runtime overhead and memory overhead of MCI. Specifically, we report how long MCI takes to parse the audit log collected from the one week experiment which contains 3707 millions events. As we discussed in Sec. IV-B, we preprocess an audit log to extract indexes so that the parser can quickly locate skeleton instances. We measure the runtime performance and memory consumption of the trace preprocessor. It takes 4 hours 47 minutes to preprocess (index) the entire log. The preprocessor occupies around 2.8 GB of memory on average. The parser first locates segments of the traces and launches automata within the identified segments. We find that the parser spend more time on parsing within the segments. In particular, the parser takes more time when it parses a wrong segment and eventually fails. Note that we parallelize the parsing within a segment to exploit multi-core processors. To parse the log, it takes around 4 days (95 hours 43 minutes), and the parser consumes around 6.2 GB of memory on average. We consider such one-time efforts reasonable given the huge log size. We leave performance optimization to our future work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Case Studies</head><p>In this section, we present a few case studies to demonstrate the effectiveness of our approach in attack investigation.</p><p>1) Phishing email and camouflaged FTP server case: In this case, we use a scenario adapted from attack cases that were created by security professionals in a DARPA program <ref type="bibr" target="#b9">[11]</ref>, to demonstrate how MCI can effectively infer causality in a realworld security incident that happens across multiple programs including PINE and Firefox.</p><p>Attack Scenario. The user regularly uses PINE to send and receive emails. At some point, the user receives a phishing email, and she opens it, finds a hyperlink that looks interesting, and hence clicks the hyperlink. PINE automatically spawns the Firefox browser and the browser navigates to the given hyperlink. The hyperlink leads her to a web-page that contains an FTP server program. As she thinks the program is useful, she downloads the program. Before she closes the Firefox browser, she navigates a few more websites and downloads other files as well. Specifically, she opened 2 more tabs and downloaded 3 more programs.</p><p>After she closed the browser, she checked a few more emails and then opened a terminal to execute the downloaded FTP server program. The FTP server is a camouflaged trojan [3]. It normally behaves as a benign FTP server, serving remote FTP requests properly. However, it contains a backdoor which allows a remote attacker to connect and execute malicious commands on the victim computer. After she ran the trojan FTP server program, it served tens of benign FTP user requests with hundreds of FTP commands. A few hours later, the attacker connects to the machine through the backdoor, and modifies an important file (e.g., financial report). Later, the company identifies that the contents of the important file is changed and then hires a forensic expert to investigate the case to identify the origin of the incident.</p><p>Investigation. Given the causal models listed in Table II and a system-wide trace collected from the user's system, the forensic expert uses MCI to infer causal relations from the changed file. By matching models over the trace, MCI successfully identifies causality from the initial phishing email to the attacker's connection in the camouflaged trojan. The investigator further identifies that the important file is touched by the FTP server process. However, the file operation does not belong to any model instance. Interestingly, this indicates that the file is not part of regular behaviors, indicating that the FTP server may be trojaned. The investigator then tries to identify how the FTP server is downloaded and executed in the system. MCI reveals that a Firefox process downloaded the FTP server binary via y.y.y.y:80 through "LoadURI" and "Download a file" models. MCI further identifies that the Firefox process was launched by a PINE process when the user clicked a link from an email stored at /var/mail/.../94368.5222 downloaded from x.x.x.x.</p><p>We also investigate the same incident with BEEP, and find out that a causal graph generated by BEEP has a number of false-positives. Specifically, as shown in Fig. <ref type="figure" target="#fig_5">17</ref>, the causal graph includes n.n.n.n:53 which is resolving the domain name, several other IP addresses from the Firefox process, which are from different tabs. Moreover, the causal graph contains other files downloaded from other tabs (../file1 and ../file2), two more sockets for internal messaging system (unix socket) and XWindow system (/tmp/.X11-unix), as well as some database files for storing browsing history (/.../places.sqlite).</p><p>In contrast, as MCI leverages accurate models generated by LDX, the graph generated by MCI is more accurate and precise without bogus dependencies. We also note that BEEP requires training and binary instrumentation on the end-user site while MCI has no requirements on the end-user site.</p><p>2) Information Theft via InfoZip (Zipsplit): In this case, we use another insider attack to demonstrate the effectiveness of MCI. Specifically, an attacker in this case intentionally uses Zipsplit to obstruct the investigation of the case as it reads and writes multiple input and output files where dependences between them are difficult to capture by existing approaches. We show how MCI can accurately identify the information flow through the program.</p><p>Attack Scenario. In this case, an insider tries to leak a secret document to a competitor company. However, the attacker's company forces all computer systems to enable audit logging system to monitor any attempts to exfiltrate important information. To avoid being exposed, he decides to use Zipsplit before sending out the secret. Specifically, he understands that the Zipsplit program can compress n files into m compressed files, and traditional audit logs are able to accurately identify causal relations if an input file is compressed to a single output file. Hence, the attacker used Zipsplit to compress a secret document, secret.pdf, as well as two nonsecret files, 1.pdf and 2.pdf, and generates four output files, c1.zip-c4.zip. In this example, the secret file is compressed and distributed into c1.zip and c2.zip, whereas c3.zip and c4.zip only contain non-secrets. Then he attached all output files to an email, but before he sent it to the competitor company, he removed c3.zip and c4.zip from the email and only sent the other two that contain the secret. After that, he deleted all emails histories and compressed files.</p><p>A few days later, the company found suspicious behaviors from the attacker's computer. They identified that the secret document was accessed by Zipsplit, and some files that may contain the secret were sent out. However, the attacker claimed that the secret document was mistakenly included in Zipsplit and he only sent the zip files that contain nonsecrets. At this point, the company started to investigate the attacker's machine to identify the source of outgoing files. Note that the investigator is not able to inspect the compressed files or email history as the attacker already deleted them.</p><p>Investigation. A forensic expert utilizes MCI to construct causal models for Zipsplit and PINE. A related model for Zipsplit is presented in Fig. <ref type="figure" target="#fig_6">18</ref>, corresponding to the "read n files and compress to an output file" behavior. Note that it is context-free as there are two groups of nodes (from the 4 th to the 6 th and from the 12 th to the 16 th ) that have the same number of repetition. The first group is for reading the meta information of the n input files and the second group is for reading the contents of the files and write to an output file. MCI matches the models over the audit log collected from the attacker's machine, and it accurately reveals the causality between the secret document and the outgoing message. Fig. <ref type="figure" target="#fig_7">19-(b</ref>) presents a causal graph generated by MCI. It shows that the c1.zip and c2.zip are derived from secret.pdf, and they are sent out via PINE. In contrast, Fig. <ref type="figure" target="#fig_7">19-(a)</ref> shows a causal graph generated by BEEP but it contains many false-positives as BEEP was not able to identify such removed attachments nor causal relations between inputs and outputs of Zipsplit. We manually inspect the program to identify the root cause of false-positives. It turns out that Zipsplit first compresses input files into a temporary file, then splits it into multiple output files. Hence, BEEP considers the temporary file is dependent on all input files, and the output files are dependent on the temporary file. In other words, BEEP considers all output files are dependent on all input files. Instead, MCI infers precise causality between each input and output file via implicit dependencies annotated in the model.</p><p>3) Long running real world applications: In the last experiment, we evaluate MCI on large scale real world workloads. In particular, we use 2 months of NASA HTTP server access logs obtained from <ref type="bibr" target="#b38">[41]</ref> as well as 3 months of our institution's HTTP server access logs (from Nov. 2015 to Jan. 2016).</p><p>To obtain audit logs from the HTTP access logs, we first emulate the web server environment by crawling all the contents of the original servers. Then, we create a script which connects and accesses the web server according to the access log so that the audit logging system on our server can regenerate logs for our analysis.  <ref type="bibr" target="#b38">[41]</ref> and our institution, respectively. Considering the size of the logs, we argue that our parser is reasonably scalable. For the accuracy test, we have 3.9% and 1.2% false-positives for the two respective logs. We analyze such cases and find that the NASA-HTTP log includes much more CGI requests than our institution's log. We find that most of the false-positive cases are from those CGI requests (e.g., PHP) that introduce noises. That is, some of the CGI behaviors are similar to the server behaviors and hence confuse our parser. We also have 0.2% and 0.1% falsenegative rates. We manually analyze such cases and find out that they are mainly caused by CGI requests and suspicious requests embedding binary payloads, which crash the webserver during the experiment. Overall, the result shows that MCI is scalable to identify causality over large scale logs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VI. RELATED WORK</head><p>Causality Tracking. There exists a line of work in tracking causal dependences for system-level attack analysis <ref type="bibr" target="#b22">[25]</ref>, <ref type="bibr" target="#b13">[16]</ref>, <ref type="bibr" target="#b21">[24]</ref>, <ref type="bibr" target="#b23">[26]</ref>, <ref type="bibr" target="#b26">[29]</ref>, <ref type="bibr" target="#b20">[23]</ref>. BackTracker <ref type="bibr" target="#b22">[25]</ref> and Taser <ref type="bibr" target="#b13">[16]</ref> propose backward and forward analysis techniques to identify the entry point of an attack and to understand the damage happened to the target system. Recently, a series of works <ref type="bibr" target="#b29">[32]</ref>, <ref type="bibr" target="#b34">[37]</ref>, <ref type="bibr" target="#b33">[36]</ref> have proposed to provide accurate and fine-grained attack analysis. Dynamic taint analysis techniques <ref type="bibr" target="#b39">[42]</ref>, <ref type="bibr" target="#b18">[21]</ref>, <ref type="bibr" target="#b17">[20]</ref> track information flow between taint sources and taint sinks. SME <ref type="bibr" target="#b10">[12]</ref> detects information flows between different security levels by running a program multiple times. LDX <ref type="bibr" target="#b28">[31]</ref> proposes a dual execution based causality inference technique. When a user executes a process, LDX automatically starts a slave execution by mutating input sources. It identifies causal dependences between input source and outputs by comparing the outputs from the original and slave executions.  These approaches have limitations, for instance, syscallbased techniques suffer from imprecisions that cause falsepositives and false-negatives, unit-based techniques require training or instrumentation on the end-user site, and dynamic taint analysis techniques cause too much runtime overhead. We discussed details of strengths and limitations of those techniques in Section II and compare them with MCI.</p><p>Program Behavior Modeling. Constructing program models that represent program's internal structures (e.g., control flow) or behaviors (e.g., system call invocations) have been extensively studied, especially in anomaly detection techniques <ref type="bibr" target="#b43">[46]</ref>, <ref type="bibr" target="#b25">[28]</ref>, <ref type="bibr" target="#b11">[14]</ref>, <ref type="bibr" target="#b45">[48]</ref>, <ref type="bibr" target="#b47">[50]</ref>, <ref type="bibr" target="#b44">[47]</ref>. Specifically, they train benign program executions to get models which are abstraction of the program behavior. Then, they use various ways such as DFA <ref type="bibr" target="#b25">[28]</ref>, FSA <ref type="bibr" target="#b43">[46]</ref>, <ref type="bibr" target="#b11">[14]</ref>, push-down automaton (PDA) <ref type="bibr" target="#b45">[48]</ref>, hidden Markov models <ref type="bibr" target="#b47">[50]</ref>, and machine learning <ref type="bibr" target="#b44">[47]</ref>, <ref type="bibr" target="#b31">[34]</ref>. However, their models are mostly control flow models that do not have dependency information. Having dependences (acquired from LDX) in our models on one hand allows us to use models in attack provenance investigation, on the other hand poses a number of new technical challenges. Due to the difficulty of static binary dependency analysis, generating precise models using static analysis is highly challenging.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VII. DISCUSSION</head><p>Kernel-level Attack. We trust audit logs collected at the victim system. Most audit logging systems including Linux Audit and Windows ETW collect and store audit logs at the kernel level, and a kernel-level attack could disable the logging system or tamper with the log. One possible solution is to integrate with LPM-Hifi <ref type="bibr" target="#b4">[6]</ref> that provides stronger security guarantees.</p><p>Limitations by LDX <ref type="bibr" target="#b28">[31]</ref>. In our off-line analysis, we leverage LDX to construct causal models, hence, the limitations in LDX are also inherited by MCI. LDX doubles the resource consumption such as memory, processor and disk storage in order to run a slave execution along with original execution. However, we argue that the limitations only apply to the offline analysis and do not apply the end-user.</p><p>Model Coverage. MCI relies on causal models generated by training with typical workloads. If an audit log includes behaviors that cannot be composed by the models in the provided workloads, MCI may not be able to infer causality precisely and could cause false-positives/negatives. Also, the FPs and FNs caused by missing models may cascade throughout the remaining MCI's parsing process. However, the cascading effect is mostly limited within a unit (e.g., each request in a server program) because MCI nonetheless starts a new model instance when it encounters an input syscall that matches with the model. Moreover, we can detect matching failures due to the incomplete models while MCI is parsing the audit log. For instance, missing models often lead to causal graphs lacking important I/O related system-objects (e.g., files/sockets), hence they are a strong indicator. Then we can enhance the model to resolve the situation by training with more workloads. Furthermore, we can fall back to a conservative strategy to assume unmatched events have inter-dependencies. Although we mitigate the ambiguity problem (Sec. III-C2), as some models may not have enough dependencies to segment traces, ambiguity is still a challenge. We plan to investigate using irrelevant events as delimiters to further partition the trace and suppress ambiguity.</p><p>Signal and Exception Handler. Signals and exceptions can be delivered to a predefined handler at anytime, interrupting a normal execution flow. Unfortunately, it is possible that system calls in the handler may affect our parser. However, we observe that in practice our models are robust enough to handle the additional system calls caused by such handlers. This is because system calls invoked in a signal or exception handler are generally distinctive from the system calls in our causal models, hence our parser is able to filter them out. Moreover, in many programs such as Lighttpd, handlers functions often do not invoke any system call. In the future, we plan to extend MCI to construct proper models for signal and exception handlers. As such, we can identify handler models from the audit log and extract them before we apply MCI's model parsing process.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VIII. CONCLUSION</head><p>We present MCI, a novel causality inference algorithm that directly works on audit logs provided from commodity systems. MCI does not require any special efforts (e.g., training, instrumentation, code annotation) or framework (e.g., enhanced logging, taint tracking) on the end-user. Our off-line analysis precisely infers causality from a given system call log by constructing causal models and identifying the models in a given audit log. We implemented a prototype of MCI and our evaluation results show that MCI is scalable to cope with large scale log from long-running applications. We also demonstrate that MCI can precisely identify causal relations in realistic attack scenarios.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .Fig. 2 .</head><label>12</label><figDesc>Fig. 1. Overview of MCI's off-line causality inference. Audit Logs and Program Binaries are provided from the end-user, workloads and input specifications are generated by an attack investigator (e.g., a forensic expert), and other components are automatically generated by MCI.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 4 -</head><label>4</label><figDesc>Fig. 4-(a), (b), (c), (d), and (e) show the graphical representations of some models from Vim.A node is denoted by a letter which represents a syscall, with a superscript ( * ) representing a sequence of syscalls. A subscript represents the (symbolic) system object (e.g., file or socket) operated by the syscall. For example, model (a) is for the behavior of opening and decrypting a gpg file. Specifically, as shown in the legend in Fig.4, the first node of (a) r α indicates a read syscall on α which is stdin. Note that each model has its own legend for the subscript. The first node is a syscall that causes the entire behavior. Intuitively, the model represents reading from a command line that loads a gpg file. The second node, s β , represents a stat syscall on a file β (output file). The GnuPG plug-in uses a temporary file to store decrypted contents and then informs Vim to open. Subscript β symbolizes the temporary file which contains decrypted contents. The second node essentially checks whether the file exists. After that it loads a key file to prepare decryption which is represented as a third node (r * γ ). Then, it checks (stat) the output file again (s * β ). Finally, the fifth node (r * δ ) represents reading a gpg file which is an encrypted file. The sixth node (w β ) indicates that the decrypted contents are written onto the output file (β). Then, the GnuPG plug-in sends a notification to Vim via a pipe which is shown in the last node (w ). Note that symbols in subscript (e.g. α, β) can be instantiated to any concrete file handler during parsing. The same subscript β in s β and the later nodes s * β and w β dictate that these syscalls must operate on the same file. The third and fifth nodes are denoted by a superscript * , representing a sequence of read system calls (read * ) on different files γ and δ.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>... w 5 ... s 5 ... s 6 w 6 ... r 0 ... r 1 w 7 ...</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 4 .Fig. 5 .</head><label>45</label><figDesc>Fig. 4. MCI on the Motivating Example. SyscallName SysName ::= open | read | write | ... Repetition R ::= 1 | 2 | 3 | ... | n | m | * SymbolicResource S ::= {α, β, γ, ...} Term T ::= N | NT | (T ) R Node N ::= SysName P(S) Edge E ::= &lt; N from , Nto &gt; Model M ::= &lt; T , P(E) implicit , P(E) explicit &gt; Fig. 5. Definition of Causal Model.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 6 .</head><label>6</label><figDesc>Fig. 6. Definition of Syscall Trace.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 7 .</head><label>7</label><figDesc>Fig.7. Regular Model from ping<ref type="bibr" target="#b37">[40]</ref>.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig. 8 .</head><label>8</label><figDesc>Fig. 8. Context-Free Model from procps [8].</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig. 9 .</head><label>9</label><figDesc>Fig. 9. Context-Sensitive Model from Raft [43].</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Fig. 10 .</head><label>10</label><figDesc>Fig. 10. Ambiguity Problem.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Fig. 11 .</head><label>11</label><figDesc>Fig. 11. Example Program.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Fig. 12 .</head><label>12</label><figDesc>Fig. 12. Causally dependent system calls from LDX.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Fig. 13 .</head><label>13</label><figDesc>Fig. 13. Symbolized syscalls.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Fig. 14 .</head><label>14</label><figDesc>Fig. 14. Constructed model from the example.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Fig. 15 .</head><label>15</label><figDesc>Fig. 15. Example for Segmented Parsing</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>2 LegendFig. 16 .</head><label>216</label><figDesc>Fig. 16. Trace Preprocessing</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>Fig. 18 .Fig. 19 .</head><label>1819</label><figDesc>Fig. 18. (Context-free) Model from Zipsplit</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>TABLE I .</head><label>I</label><figDesc>COMPARISON OF CAUSALITY ANALYSIS APPROACHES.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>Nonebeen derived offline. Note that generating models does not require any particular expert knowledge on target programs, but rather the typical user level workloads. Model generation is a one-time effort such that models generated for a program can be used for all installations of the program.</figDesc><table><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>31]</cell><cell></cell></row><row><cell>Space overhead</cell><cell>Low</cell><cell>Mid</cell><cell>Low</cell><cell>Low</cell><cell>High</cell><cell>Low</cell><cell>Low</cell></row><row><cell>Runtime overhead</cell><cell>Low</cell><cell>Low</cell><cell>Low</cell><cell>Low</cell><cell>High</cell><cell>Low</cell><cell>Low</cell></row><row><cell>Resource overhead</cell><cell>Low</cell><cell>Low</cell><cell>Low</cell><cell>Low</cell><cell>High</cell><cell>Mid</cell><cell>Low</cell></row><row><cell>False-positive</cell><cell>High</cell><cell>Mid</cell><cell>Low</cell><cell>Mid</cell><cell>Low</cell><cell>Low</cell><cell>Low</cell></row><row><cell>False-negative</cell><cell>Low</cell><cell>Low</cell><cell>Low</cell><cell>Low</cell><cell>Low-Mid</cell><cell>Low</cell><cell>Low</cell></row><row><cell>Granularity</cell><cell>Coarse</cell><cell>Mid</cell><cell>Fine</cell><cell>Mid</cell><cell>Fine</cell><cell>Fine</cell><cell>Fine</cell></row><row><cell>End-user requirements</cell><cell>None</cell><cell>Training/instrumentation</cell><cell>Code annotation</cell><cell>None</cell><cell>Tainting framework</cell><cell>Dual-execution framework</cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head></head><label></label><figDesc>.., r 1 , w 2 , w 3 , r 4 , r 5 , w 6 , w 3 , r 7 , w 8 , ... : r 1 , w 2 , w 3 , r 4 , r 5 , w 6 , w 3 , r 7 , w 8 , ... M 2 : r 1 , w 2 , w 3 , r 4 , r 5 , w 6 , w 3 , r 7 , w 8 , ... M 3 : r 1 , w 2 , w 3 , r 4 , r 5 , w 6 , w 3 , r 7 , w 8 , ... M 4 : r 1 , w 2 , w 3 , r 4 , r 5 , w 6 , w 3 , r 7 , w 8 , ... M 5 : r 1 , w 2 , w 3 , r 4 , r 5 , w 6 , w 3 , r 7 , w 8 , ... ... ..., r 1 , w 2 , w 3 , r 4 , r 5 , w 6 , w 3 , r 7 , w 8 , ...</figDesc><table><row><cell cols="4">(a) Trace M (b) Ground-truth</cell></row><row><cell></cell><cell>r α</cell><cell>w β</cell><cell>Legend</cell></row><row><cell>Explicit Dep.</cell><cell cols="2">(c) Model</cell><cell>wσ: write(σ) rσ: read(σ),</cell><cell>(d) Possible Matchings</cell></row></table><note><p><p>.</p><ref type="bibr" target="#b0">1</ref> </p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8"><head>TABLE II .</head><label>II</label><figDesc>DETAILS ON MODEL CONSTRUCTION</figDesc><table><row><cell>Program</cell><cell>Model Description</cell><cell>Size 1</cell><cell>Dexp 2</cell><cell>Dimp 3</cell><cell>Lang. 4</cell></row><row><cell></cell><cell>Tab Open/Switch/Close</cell><cell>7/9/5</cell><cell>2/2/1</cell><cell>3/4/3</cell><cell>Reg.</cell></row><row><cell>Firefox</cell><cell>Load a URI Download (Save)</cell><cell>12 15</cell><cell>2 3</cell><cell>4 5</cell><cell>Reg. Reg.</cell></row><row><cell></cell><cell>Click a link</cell><cell>9</cell><cell>2</cell><cell>3</cell><cell>Reg.</cell></row><row><cell>Apache</cell><cell>HTTP(S) resp. CGI resp.</cell><cell>17 (21) 5 26 (33) 5</cell><cell>3 (4) 5 4 (5) 5</cell><cell>8 (11) 5 11 (14) 5</cell><cell>Reg. Reg.</cell></row><row><cell>Lighttpd</cell><cell>HTTP(S) resp. CGI resp.</cell><cell>8 (11) 5 16 (19) 5</cell><cell>2 (3) 5 3 (4) 5</cell><cell>4 (6) 5 7 (9) 5</cell><cell>Reg. Reg.</cell></row><row><cell>nginx</cell><cell>HTTP(S) resp. CGI resp.</cell><cell>14 (17) 5 21 (24) 5</cell><cell>3 (4) 5 4 (5) 5</cell><cell>6 (9) 5 8 (11) 5</cell><cell>Reg. Reg.</cell></row><row><cell></cell><cell>Add printers</cell><cell>6</cell><cell>1</cell><cell>3</cell><cell>Reg.</cell></row><row><cell>CUPS</cell><cell>Remove printers Modify printers</cell><cell>5 6</cell><cell>1 1</cell><cell>3 3</cell><cell>Reg. Reg.</cell></row><row><cell></cell><cell>Print a doc.</cell><cell>7</cell><cell>2</cell><cell>4</cell><cell>Reg.</cell></row><row><cell></cell><cell>Open</cell><cell>8</cell><cell>1</cell><cell>5</cell><cell>Reg.</cell></row><row><cell></cell><cell>Edit</cell><cell>10</cell><cell>1</cell><cell>4</cell><cell>Reg.</cell></row><row><cell>vim</cell><cell>Save</cell><cell>13</cell><cell>2</cell><cell>4</cell><cell>Reg.</cell></row><row><cell></cell><cell>Save As</cell><cell>15</cell><cell>3</cell><cell>6</cell><cell>Reg.</cell></row><row><cell></cell><cell>Copy and Paste</cell><cell>14</cell><cell>3</cell><cell>6</cell><cell>Reg.</cell></row><row><cell></cell><cell>Copy</cell><cell>11</cell><cell>1</cell><cell>5</cell><cell>Reg.</cell></row><row><cell></cell><cell>Plug-in (gpg)</cell><cell>21</cell><cell>2</cell><cell>6</cell><cell>Reg.</cell></row><row><cell></cell><cell>Browse</cell><cell>11</cell><cell>3</cell><cell>6</cell><cell>Reg.</cell></row><row><cell>elinks</cell><cell>Save</cell><cell>6</cell><cell>2</cell><cell>5</cell><cell>Reg.</cell></row><row><cell></cell><cell>Upload</cell><cell>7</cell><cell>2</cell><cell>5</cell><cell>Reg.</cell></row><row><cell></cell><cell>Send emails</cell><cell>10</cell><cell>2</cell><cell>6</cell><cell>Reg.</cell></row><row><cell></cell><cell>Send files</cell><cell>13</cell><cell>3</cell><cell>7</cell><cell>Reg.</cell></row><row><cell>alpine</cell><cell>Download emails</cell><cell>9</cell><cell>2</cell><cell>6</cell><cell>Reg.</cell></row><row><cell></cell><cell>Download files</cell><cell>11</cell><cell>2</cell><cell>5</cell><cell>Reg.</cell></row><row><cell></cell><cell>Open a link</cell><cell>8</cell><cell>2</cell><cell>4</cell><cell>Reg.</cell></row><row><cell>zip</cell><cell>Compress file(s) Use encryption</cell><cell>16 6</cell><cell>8 4</cell><cell>5 3</cell><cell>C.F. Reg.</cell></row><row><cell>transmission</cell><cell>Download Add a torrent file</cell><cell>17 6</cell><cell>4 3</cell><cell>8 3</cell><cell>Reg. Reg.</cell></row><row><cell></cell><cell>Add a magnet</cell><cell>12</cell><cell>3</cell><cell>7</cell><cell>Reg.</cell></row><row><cell></cell><cell>Login</cell><cell>5/4/6</cell><cell>1/1/2</cell><cell>4/3/4</cell><cell>Reg.</cell></row><row><cell></cell><cell>Create directory</cell><cell>4/4/4</cell><cell>2/2/2</cell><cell>3/3/3</cell><cell>Reg.</cell></row><row><cell>proftpd/</cell><cell>Delete directory</cell><cell>3/4/4</cell><cell>1/2/2</cell><cell>3/3/3</cell><cell>Reg.</cell></row><row><cell>lftp/yafc</cell><cell>List directory</cell><cell>3/3/3</cell><cell>1/1/1</cell><cell>3/3/3</cell><cell>Reg.</cell></row><row><cell></cell><cell>Upload</cell><cell>7/8/18</cell><cell>2/2/3</cell><cell>5/5/9</cell><cell>Reg.</cell></row><row><cell></cell><cell>Download</cell><cell>6/7/16</cell><cell>2/2/4</cell><cell>5/6/9</cell><cell>Reg.</cell></row><row><cell>wget</cell><cell>Download (HTTP(S))</cell><cell>7</cell><cell></cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_10"><head>TABLE III .</head><label>III</label><figDesc>RESULTS FOR SYSTEM-WIDE CAUSALITY INFERENCE.</figDesc><table><row><cell>Program</cell><cell># of events</cell><cell># of causality</cell><cell># of matched models</cell><cell>FP</cell><cell>FN</cell></row><row><cell>Firefox</cell><cell>2,313 M</cell><cell>11 M</cell><cell>549 K</cell><cell>8.3%</cell><cell>3.2%</cell></row><row><cell>Apache</cell><cell>296 M</cell><cell>6.6 M</cell><cell>435 K</cell><cell>0%</cell><cell>0%</cell></row><row><cell>Lighttpd</cell><cell>125 M</cell><cell>3.3 M</cell><cell>275 K</cell><cell>0%</cell><cell>0%</cell></row><row><cell>nginx</cell><cell>187 M</cell><cell>3.8 M</cell><cell>246 K</cell><cell>0%</cell><cell>0%</cell></row><row><cell>proftpd</cell><cell>49 M</cell><cell>2.1 M</cell><cell>179 K</cell><cell>0%</cell><cell>0%</cell></row><row><cell>CUPS</cell><cell>25 M</cell><cell>918 K</cell><cell>88 K</cell><cell>0%</cell><cell>0.8%</cell></row><row><cell>vim</cell><cell>43 M</cell><cell>4 M</cell><cell>219 K</cell><cell>0%</cell><cell>0%</cell></row><row><cell>elinks</cell><cell>38 M</cell><cell>3.6 M</cell><cell>145 K</cell><cell>0%</cell><cell>0%</cell></row><row><cell>alpine</cell><cell>116 M</cell><cell>4.7 M</cell><cell>231 K</cell><cell>0%</cell><cell>0.3%</cell></row><row><cell>zip</cell><cell>5 M</cell><cell>634 K</cell><cell>36 K</cell><cell>0%</cell><cell>0%</cell></row><row><cell>transmission</cell><cell>250 M</cell><cell>6.9 M</cell><cell>479 K</cell><cell>3.8%</cell><cell>5.2%</cell></row><row><cell>lftp</cell><cell>11 M</cell><cell>438 K</cell><cell>54 K</cell><cell>0%</cell><cell>0%</cell></row><row><cell>yafc</cell><cell>9 M</cell><cell>616 K</cell><cell>43 K</cell><cell>0%</cell><cell>0%</cell></row><row><cell>wget</cell><cell>627 K</cell><cell>71 K</cell><cell>5.4 K</cell><cell>0%</cell><cell>0%</cell></row><row><cell>ping</cell><cell>2.4 k</cell><cell>1.3 K</cell><cell>241</cell><cell>0%</cell><cell>0%</cell></row><row><cell>procps</cell><cell>4 M</cell><cell>1 M</cell><cell>176 K</cell><cell>0%</cell><cell>0%</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_11"><head>TABLE IV .</head><label>IV</label><figDesc>COMPARISON WITH BEEP.</figDesc><table><row><cell></cell><cell>System subjects</cell><cell>System objects</cell><cell>Edges</cell><cell>FP / FN</cell></row><row><cell>BEEP</cell><cell>9.23</cell><cell>33.71</cell><cell>74.21</cell><cell>12.8% / 0.3%</cell></row><row><cell>MCI</cell><cell>9.18</cell><cell>25.38</cell><cell>62.87</cell><cell>0.1% / 0.1%</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_12"><head>TABLE V .</head><label>V</label><figDesc>EVALUATION ON LONG RUNNING EXECUTIONS.</figDesc><table><row><cell>Access Log</cell><cell># of req. (unique)</cell><cell>Elapsed Time</cell><cell>FP / FN</cell></row><row><cell>NASA-HTTP [41]</cell><cell>3.4M (36K)</cell><cell>19 hrs 41mins</cell><cell>3.9% / 0.2%</cell></row><row><cell>Our institution</cell><cell>5.6M (4.2M)</cell><cell>40 hrs 13mins</cell><cell>1.1% / 0.1%</cell></row><row><cell cols="4">Table V shows the result. First, our parser takes 19 hours</cell></row><row><cell cols="3">and 40 hours to parse the logs from</cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_13"><head></head><label></label><figDesc>Fig.<ref type="bibr" target="#b14">17</ref>. Causal graphs generated from BEEP and MCI for the camouflaged FTP server case. : stat(σ), tσ: time(σ), wσ: write(σ), rσ: read(σ), nσ: rename(σ), α: stdin, β: current dir, γ: output (compressed) files, ε: input files, θ: temp file</figDesc><table><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>bash</cell><cell>bash</cell></row><row><cell></cell><cell cols="2">x.x.x.x:53935</cell><cell cols="2">x.x.x.x:113</cell><cell cols="2">n.n.n.n:53</cell><cell></cell><cell></cell><cell></cell><cell>...</cell><cell>74.125.224.72:80</cell><cell>z.z.z.z:31337</cell><cell>x.x.x.x:53935</cell><cell>x.x.x.x:113</cell><cell>y.y.y.y:80</cell><cell>z.z.z.z:31337</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>y.y.y.y:80</cell></row><row><cell></cell><cell>sendmail</cell><cell></cell><cell></cell><cell cols="2">sendmail</cell><cell></cell><cell></cell><cell>pine</cell><cell></cell><cell></cell><cell>firefox</cell><cell>unix socket</cell><cell>proftpd</cell><cell>sendmail</cell><cell>sendmail</cell><cell>pine</cell><cell>firefox</cell><cell>proftpd</cell></row><row><cell></cell><cell>sendmail</cell><cell></cell><cell></cell><cell cols="2">procmail</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>/tmp/.X11-unix</cell><cell>sendmail</cell><cell>procmail</cell></row><row><cell></cell><cell cols="5">/var/mail/…/94368.5221</cell><cell></cell><cell cols="3">/…/places.sqlite</cell><cell>../file1</cell><cell>../file2</cell><cell>...</cell><cell>/home/…/proftpd</cell><cell>/home/…/doc</cell><cell>/var/mail/…/94368.5221</cell><cell>/home/…/proftpd</cell><cell>/home/…/doc</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="4">(a) Graph generated from BEEP</cell><cell>(b) Graph generated by MCI</cell></row><row><cell cols="2">Explicit</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>n</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>n</cell></row><row><cell>sα</cell><cell>sβ</cell><cell cols="2">t∅</cell><cell>sγ</cell><cell>rε</cell><cell>sε</cell><cell>t∅</cell><cell>sβ</cell><cell>t∅</cell><cell cols="2">sθ wθ sε wθ rε</cell><cell>wθ nγ</cell></row><row><cell cols="2">Implicit</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="2">Legend</cell><cell></cell></row></table><note><p>sσ</p></note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div><head>ACKNOWLEDGMENT</head><p>We thank the anonymous reviewers for their constructive comments. This research was supported, in part, by the <rs type="funder">United States Air Force</rs> and <rs type="funder">DARPA</rs> under contract <rs type="grantNumber">FA8650-15-C-7562</rs>, <rs type="funder">NSF</rs> under awards <rs type="grantNumber">1748764</rs>, <rs type="grantNumber">1409668</rs>, and <rs type="grantNumber">1320444</rs>, <rs type="funder">ONR</rs> under contracts <rs type="grantNumber">N000141410468</rs> and <rs type="grantNumber">N000141712947</rs>, and <rs type="funder">Sandia National Lab</rs> under award <rs type="grantNumber">1701331</rs>, and <rs type="funder">Cisco Systems</rs> under an unrestricted gift. Any opinions, findings, and conclusions or recommendations expressed in this material are those of the authors and do not necessarily reflect the views of the <rs type="funder">United States Air Force</rs> and <rs type="funder">DARPA</rs> or other sponsors.</p></div>
			</div>
			<listOrg type="funding">
				<org type="funding" xml:id="_h74Zv69">
					<idno type="grant-number">FA8650-15-C-7562</idno>
				</org>
				<org type="funding" xml:id="_TC4KAmE">
					<idno type="grant-number">1748764</idno>
				</org>
				<org type="funding" xml:id="_sg8q6EW">
					<idno type="grant-number">1409668</idno>
				</org>
				<org type="funding" xml:id="_VDzFXWY">
					<idno type="grant-number">1320444</idno>
				</org>
				<org type="funding" xml:id="_fdqkXXB">
					<idno type="grant-number">N000141410468</idno>
				</org>
				<org type="funding" xml:id="_j4H24pS">
					<idno type="grant-number">N000141712947</idno>
				</org>
				<org type="funding" xml:id="_egdVAdE">
					<idno type="grant-number">1701331</idno>
				</org>
			</listOrg>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<ptr target="http://crowdresearchpartners.com/wp-content/uploads/2016/09/Insider-Threat-Report-2016.pdf" />
		<title level="m">Insider threat spotlight report</title>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title/>
		<ptr target="https://www.solutionary.com/threat-intelligence/threat-reports/quarterly-threat-reports/sert-threat-report" />
	</analytic>
	<monogr>
		<title level="j">Quarterly threat report</title>
		<imprint>
			<biblScope unit="page" from="4" to="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Trends from the years&apos;s breaches and cyber attacks</title>
		<ptr target="https://www.fireeye.com/current-threats/annual-threat-report/mtrends.html" />
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Odr: Output-deterministic replay for multicore debugging</title>
		<author>
			<persName><forename type="first">G</forename><surname>Altekar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Stoica</surname></persName>
		</author>
		<idno>SOSP&apos;09</idno>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Trustworthy wholesystem provenance for the linux kernel</title>
		<author>
			<persName><forename type="first">A</forename><surname>Bates</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Tian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">R B</forename><surname>Butler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Moyer</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>In SEC&apos;15</note>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<author>
			<persName><forename type="first">M</forename><surname>Braun</surname></persName>
		</author>
		<ptr target="https://github.com/jamessan/vim-gnupg/blob/master/plugin/gnupg.vim" />
		<title level="m">Gnupg vim plugin</title>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">A</forename><surname>Cahalan</surname></persName>
		</author>
		<ptr target="http://procps.sourceforge.net/" />
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Three models for the description of language</title>
		<author>
			<persName><forename type="first">N</forename><surname>Chomsky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IRE Transactions on Information Theory</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="113" to="124" />
			<date type="published" when="1956-09">September 1956</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">On certain formal properties of grammars</title>
		<author>
			<persName><forename type="first">N</forename><surname>Chomsky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information and Control</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="137" to="167" />
			<date type="published" when="1959-06">June 1959</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title/>
		<author>
			<persName><surname>Darpa</surname></persName>
		</author>
		<ptr target="https://www.darpa.mil/program/transparent-computing" />
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
	<note>Transparent computing</note>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Noninterference through secure multiexecution</title>
		<author>
			<persName><forename type="first">D</forename><surname>Devriese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Piessens</surname></persName>
		</author>
		<idno>SP&apos;10</idno>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Anomaly detection using call stack information</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">H</forename><surname>Feng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><forename type="middle">M</forename><surname>Kolesnikov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Fogla</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Gong</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>In SP&apos;03</note>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Computers and Intractability; A Guide to the Theory of NP-Completeness</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">R</forename><surname>Garey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">S</forename><surname>Johnson</surname></persName>
		</author>
		<imprint>
			<publisher>W. H. Freeman &amp; Co</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<author>
			<persName><forename type="first">A</forename><surname>Goel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Po</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Farhadi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>De Lara</surname></persName>
		</author>
		<title level="m">The taser intrusion recovery system. SOSP&apos;05</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<author>
			<persName><forename type="first">S</forename><surname>Grubb</surname></persName>
		</author>
		<ptr target="https://people.redhat.com/sgrubb/audit/" />
		<title level="m">Redhat linux audit</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">2016 cost of data breach study</title>
		<author>
			<persName><forename type="first">P</forename><surname>Institute</surname></persName>
		</author>
		<ptr target="https://app.clickdimensions.com/blob/softchoicecom-anjf0/files/ponemon.pdf" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Shadowreplica: Efficient parallelization of dynamic data flow tracking</title>
		<author>
			<persName><forename type="first">K</forename><surname>Jee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">P</forename><surname>Kemerlis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">D</forename><surname>Keromytis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Portokalidis</surname></persName>
		</author>
		<imprint>
			<biblScope unit="page">13</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">A general approach for effciently accelerating softwarebased dynamicdata flow tracking on commodity hardware</title>
		<author>
			<persName><forename type="first">K</forename><surname>Jee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Portokalidis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">P</forename><surname>Kemerlis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Ghosh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">I</forename><surname>August</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">D</forename><surname>Keromytis</surname></persName>
		</author>
		<imprint>
			<biblScope unit="page">12</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">libdft: practical dynamic data flow tracking for commodity systems</title>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">P</forename><surname>Kemerlis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Portokalidis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Jee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">D</forename><surname>Keromytis</surname></persName>
		</author>
		<imprint>
			<biblScope unit="page">12</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">M</forename><surname>Khoo</surname></persName>
		</author>
		<author>
			<persName><surname>Taintgrind</surname></persName>
		</author>
		<ptr target="https://github.com/wmkhoo/taintgrind" />
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">Dual execution for on the fly fine grained execution comparison</title>
		<author>
			<persName><forename type="first">D</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Kwon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">N</forename><surname>Sumner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Xu</surname></persName>
		</author>
		<imprint>
			<biblScope unit="page">15</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">Intrusion recovery using selective re-execution</title>
		<author>
			<persName><forename type="first">T</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Zeldovich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">F</forename><surname>Kaashoek</surname></persName>
		</author>
		<imprint>
			<biblScope unit="page">10</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">T</forename><surname>King</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">M</forename><surname>Chen</surname></persName>
		</author>
		<title level="m">Backtracking intrusions. SOSP&apos;03</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">Enriching intrusion alerts through multi-host causality</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">T</forename><surname>King</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><forename type="middle">M</forename><surname>Mao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">G</forename><surname>Lucchetti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">M</forename><surname>Chen</surname></persName>
		</author>
		<imprint>
			<biblScope unit="page">5</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<author>
			<persName><forename type="first">W</forename><surname>Koch</surname></persName>
		</author>
		<ptr target="https://gnupg.org/" />
		<title level="m">The gnu privacy guard</title>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Intrusion detection via system call traces</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">P</forename><surname>Kosoresow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">A</forename><surname>Hofmeyr</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Softw</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">5</biblScope>
		</imprint>
	</monogr>
	<note>Sept</note>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">Trail of bytes: efficient support for forensic analysis</title>
		<author>
			<persName><forename type="first">S</forename><surname>Krishnan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">Z</forename><surname>Snow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Monrose</surname></persName>
		</author>
		<idno>CCS&apos;10</idno>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<title level="m" type="main">Algorithms to accelerate multiple regular expressions matching for deep packet inspection</title>
		<author>
			<persName><forename type="first">S</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Dharmapurikar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Crowley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Turner</surname></persName>
		</author>
		<idno>SIGCOMM&apos;06</idno>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<title level="m" type="main">Ldx: Causality inference by lightweight dual execution</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Kwon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">N</forename><surname>Sumner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Saltaformaggio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Xu</surname></persName>
		</author>
		<imprint>
			<biblScope unit="page">16</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<title level="m" type="main">High accuracy attack provenance via binary-based execution partition</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">H</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Xu</surname></persName>
		</author>
		<imprint>
			<biblScope unit="page">13</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<monogr>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">H</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Xu</surname></persName>
		</author>
		<title level="m">Loggc: garbage collecting audit log. CCS&apos;13</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<title level="m" type="main">Operational security log analytics for enterprise breach detection</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Oprea</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>In SecDev&apos;16</note>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
		<title level="m" type="main">Accurate, low cost and instrumentation-free security audit logging for windows</title>
		<author>
			<persName><forename type="first">S</forename><surname>Ma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">H</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">H</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Rhee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Xu</surname></persName>
		</author>
		<imprint>
			<biblScope unit="page">15</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
		<title level="m" type="main">MPI: Multiple Perspective Attack Investigation with Semantic Aware Execution Partitioning</title>
		<author>
			<persName><forename type="first">S</forename><surname>Ma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Zhai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">H</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Xu</surname></persName>
		</author>
		<imprint>
			<biblScope unit="page">17</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
		<title level="m" type="main">Protracer: Towards practical provenance tracing by alternating between logging and tainting</title>
		<author>
			<persName><forename type="first">S</forename><surname>Ma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Xu</surname></persName>
		</author>
		<imprint>
			<biblScope unit="page">16</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<monogr>
		<title level="m" type="main">Event tracing for windows</title>
		<ptr target="https://msdn.microsoft.com/en-us/library/windows/desktop/bb968803(v=vs.85" />
		<imprint>
			<date type="published" when="2017">2017</date>
			<publisher>Microsoft</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<monogr>
		<title level="m" type="main">Taintpipe: Pipelined symbolic taint analysis</title>
		<author>
			<persName><forename type="first">J</forename><surname>Ming</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Xiao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Liu</surname></persName>
		</author>
		<idno>SEC&apos;15</idno>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">M</forename><surname>Muuss</surname></persName>
		</author>
		<ptr target="http://ws.edu.isoc.org/materials/src/ping.c" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<monogr>
		<title level="m" type="main">Nasa-http -two months of http logs from the ksc-nasa www server</title>
		<author>
			<persName><surname>Nasa</surname></persName>
		</author>
		<ptr target="http://ita.ee.lbl.gov/html/contrib/NASA-HTTP.html" />
		<imprint>
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<monogr>
		<title level="m" type="main">Dynamic taint analysis for automatic detection, analysis, and signaturegeneration of exploits on commodity software</title>
		<author>
			<persName><forename type="first">J</forename><surname>Newsome</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">X</forename><surname>Song</surname></persName>
		</author>
		<imprint>
			<biblScope unit="page">5</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<monogr>
		<title level="m" type="main">In search of an understandable consensus algorithm</title>
		<author>
			<persName><forename type="first">D</forename><surname>Ongaro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Ousterhout</surname></persName>
		</author>
		<idno>ATC&apos;14</idno>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<author>
			<persName><forename type="first">V</forename><surname>Paxson</surname></persName>
		</author>
		<author>
			<persName><surname>Bro</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">A system for detecting network intruders in real-time</title>
		<imprint>
			<date>Dec</date>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="page" from="23" to="24" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">M</forename><surname>Roesch</surname></persName>
		</author>
		<author>
			<persName><surname>Snort</surname></persName>
		</author>
		<ptr target="https://www.snort.org/" />
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<monogr>
		<title level="m" type="main">A fast automatonbased method for detecting anomalous program behaviors</title>
		<author>
			<persName><forename type="first">R</forename><surname>Sekar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Bendre</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Dhurjati</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Bollineni</surname></persName>
		</author>
		<idno>SP&apos;01</idno>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<monogr>
		<title level="m" type="main">Unearthing stealthy program attacks buried in extremely long execution paths</title>
		<author>
			<persName><forename type="first">X</forename><surname>Shu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Yao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Ramakrishnan</surname></persName>
		</author>
		<imprint>
			<biblScope unit="page">15</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<monogr>
		<title level="m" type="main">Intrusion detection via static analysis</title>
		<author>
			<persName><forename type="first">D</forename><surname>Wagner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Dean</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>SP&apos;01</note>
</biblStruct>

<biblStruct xml:id="b46">
	<monogr>
		<title level="m" type="main">C implementation of the raft</title>
		<author>
			<persName><forename type="first">Willem</forename></persName>
		</author>
		<ptr target="https://github.com/willemt/raft" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<monogr>
		<title level="m" type="main">A sharper sense of self: Probabilistic reasoning of program behaviors for anomaly detection with context sensitivity</title>
		<author>
			<persName><forename type="first">K</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Tian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Yao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">G</forename><surname>Ryder</surname></persName>
		</author>
		<imprint>
			<biblScope unit="page">16</biblScope>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
