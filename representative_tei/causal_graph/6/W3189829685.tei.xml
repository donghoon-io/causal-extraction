<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Custom-Design of FDR Encodings: The Case of Red-Black Planning</title>
				<funder ref="#_fjetMfs">
					<orgName type="full">DFG</orgName>
				</funder>
				<funder ref="#_fw5TBFD">
					<orgName type="full">German Research Foundation (DFG)</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Daniel</forename><surname>Fišer</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Saarland University</orgName>
								<address>
									<addrLine>Saarland Informatics Campus</addrLine>
									<settlement>Saarbrücken</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="department">Faculty of Electrical Engineering</orgName>
								<orgName type="institution">Czech Technical University</orgName>
								<address>
									<settlement>Prague</settlement>
									<country key="CZ">Czech Republic</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Daniel</forename><surname>Gnad</surname></persName>
							<email>gnad@cs.uni-saarland.de</email>
							<affiliation key="aff0">
								<orgName type="institution">Saarland University</orgName>
								<address>
									<addrLine>Saarland Informatics Campus</addrLine>
									<settlement>Saarbrücken</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Michael</forename><surname>Katz</surname></persName>
							<email>michael.katz1@ibm.com</email>
							<affiliation key="aff2">
								<orgName type="institution">IBM Research</orgName>
								<address>
									<settlement>Yorktown Heights</settlement>
									<region>NY</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Jörg</forename><surname>Hoffmann</surname></persName>
							<email>hoffmann@cs.uni-saarland.de</email>
							<affiliation key="aff0">
								<orgName type="institution">Saarland University</orgName>
								<address>
									<addrLine>Saarland Informatics Campus</addrLine>
									<settlement>Saarbrücken</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Custom-Design of FDR Encodings: The Case of Red-Black Planning</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.1" ident="GROBID" when="2025-10-14T18:29+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Classical planning tasks are commonly described in PDDL, while most planning systems operate on a grounded finite-domain representation (FDR). The translation of PDDL into FDR is complex and has a lot of choice points-it involves identifying so called mutex groups-but most systems rely on the translator that comes with Fast Downward. Yet the translation choice points can strongly impact performance. Prior work has considered optimizing FDR encodings in terms of the number of variables produced. Here we go one step further by proposing to custom-design FDR encodings, optimizing the encoding to suit particular planning techniques. We develop such a custom design here for red-black planning, a partial delete relaxation technique. The FDR encoding affects the causal graph and the domain transition graph structures, which govern the tractable fragment of red-black planning and hence affects the respective heuristic function. We develop integer linear programming techniques optimizing the scope of that fragment in the resulting FDR encoding. We empirically show that the performance of red-black planning can be improved through such FDR custom design.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Classical planning tasks are usually defined in PDDL <ref type="bibr">[Mc-Dermott, 2000]</ref>, which is a lifted representation based on first-order logic. Yet, most state-of-the-are planners, in particular the systems based on Fast Downward (FD) <ref type="bibr" target="#b5">[Helmert, 2006]</ref>, use a finite-domain representation (FDR) encoding, where subsets of propositional facts are grouped into finitedomain state variables. This is possible only if reachable states make at most one of the grouped facts true, i. e., if they form a mutex group. FDR encodings are useful for a wide variety of purposes like abstraction based heuristics <ref type="bibr" target="#b4">[Haslum et al., 2007;</ref><ref type="bibr" target="#b8">Katz and Domshlak, 2010;</ref><ref type="bibr" target="#b4">Helmert et al., 2014;</ref><ref type="bibr">Seipp and Helmert, 2018]</ref>, or red-black planning heuristics <ref type="bibr" target="#b0">[Domshlak et al., 2015;</ref><ref type="bibr" target="#b4">Gnad and Hoffmann, 2015</ref>; * Contact Author <ref type="bibr" target="#b11">Katz, 2019]</ref>, where a subset of (red) variables are deleterelaxed while the rest (black) keep their true semantics.</p><p>The translation of PDDL into FDR is complex-deciding whether a set of facts forms a mutex group is as hard as planning itself. There are many choice points in identifying mutex groups and grouping facts into state variables. Systems based on Fast Downward almost universally rely on its translator <ref type="bibr" target="#b6">[Helmert, 2009]</ref> and do not question the choices made there.</p><p>Yet the translation choices can impact performance. In prior work <ref type="bibr" target="#b1">[Dvořák et al., 2013;</ref><ref type="bibr" target="#b2">Dvořák et al., 2015]</ref>, a minimization of the number of FDR variables was proposed assuming fewer variables result in more information being aggregated into them. The results show that significantly reducing the number of variables can improve the performance of FDR-based techniques. The improvements are moderate though, and there is a lot of variance depending on domain and planning technique; a consistent picture does not emerge.</p><p>Here we show that this picture can change when going one step further in the target of FDR optimization: we propose to custom-design FDR encodings, optimizing the encoding to suit particular planning techniques. <ref type="foot" target="#foot_0">1</ref> We develop such a custom design for red-black planning, which distinguishes between relaxed (red) and non-relaxed (black) variables. We focus on a polynomial-time solvable fragment of red-black planning <ref type="bibr">[Katz et al., 2013b]</ref> which uses a heuristic function based on generating a red-black plan for a given state <ref type="bibr">[Katz et al., 2013a]</ref>. The tractability of red-black planning is determined by the decision which variables are painted red or black. The state-of-the-art approach uses painting strategies <ref type="bibr" target="#b0">[Domshlak et al., 2015]</ref> assuming the FDR encoding is given and fixed, and decides only on variable colors. Here, we open up this design space and allow to custom-design the FDR variables and their painting at the same time.</p><p>The tractability of red-black planning is governed by the FDR encoding's causal graph (whose projection onto the black variables must be acyclic) and domain transition graphs (that must be invertible for the black variables). We develop techniques optimizing these explicit syntactic criteria, to be able to choose from different viable FDR encodings of tractable red-black planning tasks. The optimization itself is then formulated as an integer linear program, where the allocation of black (non-relaxed) variables is controlled by the program's objective function.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Background</head><p>A STRIPS planning task Π is specified by a tuple Π = F , O, s I , s G , where F = {f 1 , . . . , f n } is a set of facts, and </p><formula xml:id="formula_0">O = {o 1 , . . . , o m } is a set of grounded operators. A state s ⊆ F is a set of facts, s I ⊆ F is an initial state and s G ⊆ F is a goal specification. A state s is a goal state iff s G ⊆ s.</formula><formula xml:id="formula_1">i = o i s i-1 for 1 ≤ i ≤ n. The resulting state of this application is π s 0 = s n . A sequence of operators π is called a plan iff π is applicable in s I and s G ⊆ π s . A set of facts M ⊆ F is called a mutex if M ⊆ s for every reachable state s. A set of facts M ⊆ F is called a mutex group if |M ∩ s| ≤ 1 for every reachable state s, and M is called a fact-alternating mutex group (fam-group) if |M ∩ s I | ≤ 1 and |M ∩ add(o)| ≤ |M ∩ pre(o) ∩ del(o)| for every operator o ∈ O. Every fam-group is a mutex group.</formula><p>Every subset of a mutex group is a mutex group, but not every subset of a fam-group is a fam-group. Facts from every mutex group form pairwise mutexes <ref type="bibr">[Fišer and Komenda, 2018]</ref>.</p><p>Given a set of mutex groups G, M G ⊆ 2 F denotes an upper set of mutexes induced by G, i.e., for every mutex group G ∈ G and every f, f ∈ G, f = f , it holds that {f, f } ∈ M G , and for every M ∈ M G and every f ∈ F it holds that M ∪ {f } ∈ M G .</p><p>An FDR planning task P is specified by a tuple P = V, O, ψ I , ψ G . V is a finite set of variables, each variable V ∈ V has a finite domain dom(V ). A fact V, v is a pair of a variable V ∈ V and one of its values v ∈ dom(V ). A partial state p is a variable assignment over some variables vars(p) ⊆ V. We write p[V ] for the value assigned to the variable V ∈ vars(p) in the partial state p. Given a set of variables U ⊆ V, p[U ] denotes a partial state p restricted to U . We also identify p with the set of facts contained in p, i.e., </p><formula xml:id="formula_2">p = { V, p[V ] | V ∈ vars(p)}. A partial state s is a state if vars(s) = V. ψ I is an initial state. ψ G is</formula><formula xml:id="formula_3">[V ] = eff(o)[V ] for every V ∈ vars(eff(o)), and o s [V ] = s[V ] for every V ∈ V \ vars(eff(o)).</formula><p>Operator sequences and plans are defined analogously to STRIPS.</p><p>The domain transition graph (DTG) of a variable V , de-noted by D V , is an edge-labeled multi-digraph with vertices dom(V ) and with an edge from d to d induced by an operator q ∈ O and denoted by (d, q, d ) iff d = d , eff(q)[V ] = d , and either pre(q)[V ] = d or V ∈ vars(pre(q)).</p><p>Let U ⊆ V denote a subset of variables. The causal graph CG U of U is a digraph with vertices U . An edge (V, V ) is in CG U iff V = V and there exists an operator o ∈ O such that (V, V ) ∈ (vars(pre(o)) ∪ vars(eff(o))) × vars(eff(o)).</p><p>A red-black planning task Π is specified by a tuple Π = V R , V B , O, ψ I , ψ G , where V R and V B are state variables, called red variables and black variables, respectively. Black variables have the value-switching semantics as in FDR. Red variables have the value-accumulating semantics, i.e., operators "extend" the value of V ∈ V R from {x} to {x, y}. Applicability of operators, sequences of operators, and red-black plans are defined accordingly [see <ref type="bibr" target="#b0">Domshlak et al., 2015]</ref>.</p><p>Given a variable V ∈ V, an edge (d, q, d ) from D V is relaxed side effects invertible (RSE-invertible) if there exists an edge <ref type="bibr">(d , q , d)</ref> </p><formula xml:id="formula_4">such that pre(q )[V \ V ] ⊆ pre(q)[V \ V ] ∪ eff(q)[V \ V ]. V is RSE-invertible if every edge in D V is RSE-invertible.</formula><p>RSE-invertibility is a sufficient criterion for tractability in the case when the subgraph of the causal graph restricted to the black variables is acyclic <ref type="bibr">[Katz et al., 2013a]</ref>. The actual algorithm presented in that work handles only the arc-less black causal graph case. Later, an algorithm for devising redblack plans for the acyclic causal graph case was presented <ref type="bibr" target="#b8">[Katz and Hoffmann, 2014;</ref><ref type="bibr" target="#b0">Domshlak et al., 2015]</ref>. In what follows, we focus on the red-black heuristic h RB for a state s, that returns the length of a red-black plan for s, computed for that tractable fragment.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Translation from STRIPS to FDR</head><p>A concise translation from STRIPS to FDR requires mutex groups that are used for creating FDR variables from STRIPS facts. Before we formalize the translation process, we formulate an intermediate STRIPS representation where we assume the mutex groups are already inferred and the STRIPS planning task is pruned with the mutex information contained in them. Moreover, we need to preserve the DTG structure of mutex groups from which black variables are created to preserve their RSE-invertibility. For this purpose, we introduce a mapping from mutex groups to fam-groups containing these mutex groups, called fam-group map. We choose specifically fam-groups because of their simpler structure <ref type="bibr">[Fišer and Komenda, 2018]</ref>. It is not a limitation, since fam-groups are the most commonly used type of mutex groups anyway <ref type="bibr" target="#b3">[Fišer, 2020]</ref>.</p><formula xml:id="formula_5">Definition 1. Given a set of mutex groups G, γ : G → 2 F is a fam-group map if for every G ∈ G it holds that either γ(G) = ∅ or γ(G) is a fam-group such that G ⊆ γ(G).</formula><p>Definition 2. Given a STRIPS planning task Π = F , O, s I , s G , and a set of non-empty mutex groups G, and a fam-group map γ over G, E Π = Π, G, γ denotes a STRIPS planning task extended with mutex groups (MGE-STRIPS) if all of the following hold:</p><formula xml:id="formula_6">(S1) F = o∈O add(o) ∪ del(o), (S2) for every operator o ∈ O it holds that pre(o) ∈ M G and o pre(o) ∈ M G and for every f ∈ del(o) it holds that {f } ∪ pre(o) ∈ M G , (S3) s I ∈ M G and s G ∈ M G , (S4) G∈G G = F , (S5) for every G, G ∈ G, G = G it holds that G ∩ G = ∅, (S6) {f } ∈ G for every f ∈ o∈O (del(o) \ pre(o)), (S7) γ(G) = ∅ for every G ∈ G such that |G| ≥ 2.</formula><p>Condition (S1) makes sure that there are no "static" facts, i.e., facts that either do not appear in any reachable state, or that are set in the initial state and remain set in all reachable states. (S2) corresponds to pruning of unreachable operators and delete effects that are not applicable. (S3) can be false only for unsolvable tasks. (S4) ensures that the set of mutex groups cover all facts. Pairwise disjoint mutex groups (S5) ensure that each STRIPS fact is encoded only once. (S6) ensures a polynomial translation without conditional effects (for a detailed explanation see <ref type="bibr">[Helmert, 2009, Section 7.3]</ref>). The fam-group γ is used for encoding preconditions of operators in the translation to FDR, and, as we described before, we assume all mutex groups G to be based on fam-groups, i.e., each mutex group from G is either a singleton or it is mapped to some fam-group (S7).</p><p>Our formulation of the translation from MGE-STRIPS to an FDR planning task differs from the translation described by <ref type="bibr" target="#b6">Helmert [2009]</ref> in the way preconditions of operators are encoded. We use the value ⊥ G to express that none of the facts from the mutex group G is set. Whenever the fam-group map γ maps G to a non-empty fam-group and pre</p><formula xml:id="formula_7">(o) ∩ (γ(G) \ G) = ∅, we set the variable V G to ⊥ G in a precondition of operator q o , i.e., V G is set to ⊥ G only if pre(o)</formula><p>is mutex with G and we can infer this fact from the given fam-group map. Note also that if γ(G) = ∅ for every G ∈ G, then we get the same FDR encoding as <ref type="bibr" target="#b6">Helmert [2009]</ref>.</p><formula xml:id="formula_8">Definition 3. Given an MGE-STRIPS planning task E Π = Π = F , O, s I , s G , G, γ , P(E Π ) = V, O, ψ I , ψ G is an FDR planning task such that: (T1) V = {V G | G ∈ G} where dom(V G ) = G ∪ {⊥ G } for every V G ∈ V; (T2) O = {q o | o ∈ O} where (T2a) pre(q o ) = { V G , f | G ∈ G, G ∩ pre(o) = ∅, f ∈ G ∩ pre(o)} ∪ { V G , ⊥ G | G ∈ G, G ∩ pre(o) = ∅, γ(G) ∩ pre(o) = ∅}, (T2b) eff(q o ) = { V G , f | G ∈ G, G ∩ add(o) = ∅, f ∈ G ∩ add(o)} ∪ { V G , ⊥ G | G ∈ G, G ∩ del(o) = ∅, G ∩ add(o) = ∅}, (T3) ψ I = { V G , f | G ∈ G, G ∩ s I = ∅, f ∈ G ∩ s I } ∪ { V G , ⊥ G | G ∈ G, G ∩ s I = ∅} (T4) ψ G = { V G , f | G ∈ G, G ∩ s G = ∅, f ∈ G ∩ s G }</formula><p>Although encoding ⊥ G in preconditions of operators is not necessary, because this fact is true implicitly, we use it to ensure that the structure of a projection to the mutex group in STRIPS is preserved in the corresponding DTG in</p><formula xml:id="formula_9">f 1 f 2 f 3 f 4 o13 o31 o24 o42 o34 (a) f 1 f 2 ⊥ G o13 o31 o24 o42 (b) f 1 f 2 ⊥ G o13 o31 o24 o42 o42 o31 (c) Figure 1: F = {f1, f2, f3, f4} is a fam-group and G = {f1, f2} a mutex group. (a) is a projection to F ; (b) a DTG of VG if ⊥G is encoded in operator preconditions, i.e., if γ(G) = F ; (c) a DTG of VG if ⊥G is not encoded in operator preconditions, i.e., if γ(G) = ∅.</formula><p>FDR. Why we need this will become clear in the next section where we deal with RSE-invertibility. For now, see the example depicted in Figure <ref type="figure">1</ref>. The projection to the famgroup F = {f 1 , . . . , f 4 } is shown in Figure <ref type="figure">1a</ref>. Now suppose we decide to encode only a subset of F as an FDR variable, namely G = {f 1 , f 2 }. If we set γ(G) = ∅, then the resulting DTG of V G will be as depicted in Figure <ref type="figure">1c</ref>, i.e., it will have additional edges between f 1 and f 2 not present in the original projection, because the operators o 31 and o 42 have f 3 and f 4 , respectively, in their preconditions. Therefore V G is not set in pre(q o31 ) and pre(q o42 ). However, if we set γ(G) = F , then we preserve the structure, as depicted in Figure <ref type="figure">1b</ref>, because V G will be set to ⊥ G in the preconditions of q o31 and q o42 .</p><formula xml:id="formula_10">Proposition 4. Let E Π = Π = F , O, s I , s G , G, γ denote an MGE-STRIPS planning task. π = o 1 , . . . , o n is a plan for E Π iff π = q o1 , .</formula><p>. . , q on is a plan for P(E Π ).</p><p>Proof Sketch. P(E Π ) is well-defined, because (T3) assigns one value to every variable, i.e., ψ I is a state. Similarly, (T4) ensures that ψ G is a partial state, and (T2a-b) produce partial states, because only one value is assigned to each variable. Note that f ∈ s</p><formula xml:id="formula_11">I iff V G , f ∈ ψ I for every G s.t. G∩s I = {f }, and V G , ⊥ G ∈ ψ I only if s I ∩ G = ∅. Similarly, f ∈ s G iff V G , f ∈ ψ G ; and for every o ∈ O it holds that f ∈ pre(o) iff V G , f ∈ pre(q o ), and V G , ⊥ G ∈ pre(q o ) only if pre(o) ∩ G = ∅ and pre(o) ∩ γ(G) = ∅. Hence o is applicable in s I iff q o is applicable in ψ I for every o ∈ O. Furthermore, from (T2b) it follows that f ∈ o s I iff V G , f ∈ q o ψ I for every G s.t. G ∩ o s I = {f }, and V G , ⊥ G ∈ q o ψ I only if G is mutex with o s I .</formula><p>The rest follows by induction.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">RSE-Invertible Variables</head><p>Now, we show how to identify mutex groups in E Π whose counterparts form variables in P(E Π ) that are RSE-invertible. This condition is required for black variables in the tractable fragment of red-black planning we consider. First, we formulate conditions for RSE-invertibility of facts and mutex groups. Then, we show that, given a fam-group map, these conditions are both sufficient and necessary for RSEinvertibility of the resulting FDR variables.</p><p>For the rest of this section, let E Π = Π, G, γ for Π = F , O, s I , s G denote an MGE-STRIPS planning task, and let P(E Π ) = V, O, ψ I , ψ G denote an FDR planning task constructed from E Π according to Definition 3. </p><formula xml:id="formula_12">Definition 5. A fact f ∈ F is RSE-invertible if (I1) there exist o, o ∈ O such that f ∈ add(o)</formula><formula xml:id="formula_13">F ⊆ F RSE- invertible if every f ∈ F is RSE-invertible.</formula><p>For the main result of this section (Theorem 9), we need to prove several auxiliary lemmas first. We start by showing that the condition pre(o) ⊆ pre(o ) ∪ add(o ) from (I2-3) corresponds to the RSE-invertibility condition on edges in DTGs as long as we have transitions in both directions. Lemma 6. Let G ∈ G be a mutex group and o, o ∈ O be two operators with edges (x, q o , x ) and (x , q o , x) in the DTG of</p><formula xml:id="formula_14">V G . Then pre(o) ⊆ pre(o ) ∪ add(o ) iff pre(q o )[V \ V G ] ⊆ pre(q o )[V \ V G ] ∪ eff(q o )[V \ V G ]. Proof. "⇐": It is easy to see that f ∈ pre(o) iff V G , f ∈ pre(q o ), and f ∈ pre(o ) iff V G , f ∈ pre(q o ), and f ∈ add(o ) iff V G , f ∈ eff(q o ) for every G ∈ G, therefore it holds that pre(o) \ G ⊆ (pre(o ) ∪ add(o )) \ G. It remains to show that also pre(o)∩G ⊆ (pre(o )∪add(o ))∩G (because, for all G ∈ G, V G , ⊥ G is never explicitly represented as a fact in pre(o)).</formula><p>There are two cases:</p><p>(</p><formula xml:id="formula_15">1) If V G ∈ vars(pre(q o )), then pre(o)[V G ] = f = x ∈ G, because (x, q o , x</formula><p>) is an edge in the DTG of V G , therefore pre(o) = f . Moreover, since there is also an edge</p><formula xml:id="formula_16">(x , q o , f ) in the DTG of V G , it follows that eff(q o )[V G ] = f and therefore f ∈ add(o ). (2) If V G ∈ vars(pre(q o )) or pre(q o )[V G ] = ⊥ G , then G ∩ pre(o) = ∅. "⇒": For every G ∈ G s.t. G ∩ pre(o) = ∅ there exists f ∈ G s.t. f ∈ pre(o), and pre(q o )[V G ] = f , and pre(q o )[V G ] = f or eff(q o )[V G ] = f</formula><p>. So, it remains to show that the claim holds also for every H ∈ G, H = G, such that H∩pre(o) = ∅ and V H ∈ vars(pre(q o )) and therefore pre(</p><formula xml:id="formula_17">q o )[V H ] = ⊥ H . If pre(q o )[V H ] = ⊥ H , then γ(H) ∩ pre(o) = ∅. Let y γ(H) ∩ pre(o). Therefore, y ∈ pre(o ) or y ∈ add(o ). (1) If y ∈ pre(o ) then H ∩ pre(o ) = ∅, because pre(o ) is not a mutex (S2). Therefore, pre(q o )[V H ] = ⊥ H . (2) If y ∈ add(o ) then H ∩ add(o ) = ∅ (because o pre(o ) is not mutex (S2)) and there exists y ∈ pre(o ) ∩ del(o ) s.t. y ∈ γ(H) (because γ(H) is a fam-group). (2a) If y ∈ H, then eff(q o )[V H ] = ⊥ H , because H ∩ add(o ) = ∅. (2b) If y ∈ γ(H) \ H, then H ∩ pre(o ) = ∅ (because y ∈ pre(o ) and pre(o ) ∈ M G ), therefore pre(q o )[V H ] = ⊥ H .</formula><p>Now, we are ready to prove that RSE-invertibility of mutex groups implies RSE-invertibility of the corresponding FDR variables, and vice versa. We separate the case of singleton mutex groups, and larger mutex groups, which require the additional condition (S7).</p><formula xml:id="formula_18">Lemma 7. Let G = {f } be a mutex group. Then f is RSE- invertible iff V G is RSE-invertible.</formula><p>Proof. "⇒": Since dom(V G ) = {f, ⊥ G } and we need to prove that every edge in the DTG of V G is RSE-invertible, we need to investigate two cases:</p><p>(1) Let (f, q o , ⊥ G ) be an edge in the DTG of V G . Then eff(q o )[V ] = ⊥ G and either pre(q o )[V ] = f or V ∈ vars(pre(q o )). So we have f ∈ add(o) and f ∈ del(o), therefore there exists o s.t. f ∈ add(o ) and pre(o ) ⊆ pre(o)∪add(o). So, f ∈ pre(o ) because f ∈ add(o ), therefore pre(q o )[V G ] = ⊥ G or V G ∈ vars(pre(q o )), therefore there is an edge (⊥ G , q o , f ). The rest follows from Lemma 6.</p><p>(2) Let (⊥ G , q o , f ) be an edge in the DTG of V G . Then eff(q o )[V G ] = f and either pre(q o )[V G ] = ⊥ G or V ∈ vars(pre(q o )). So, we have f ∈ add(o) and therefore f ∈ pre(o) and f ∈ del(o). Therefore, there exists o ∈ O s.t. f ∈ del(o ) and pre(o ) ⊆ pre(o) ∪ add(o). Now, to prove that there is an edge (f, q o , ⊥ G ) (and therefore this lemma follows from Lemma 6), we need to show that pre</p><formula xml:id="formula_19">(q o )[V G ] = ⊥ G , i.e., pre(q o )[V G ] = f or V ∈ vars(pre(q o )). If pre(q o )[V G ] = ⊥ G , then there is f ∈ γ(G) s.t. f ∈ pre(o ) ∩ del(o ), because γ(G) is a fam- group. Therefore, {f, f } ⊆ del(o ), which is a contradiction because {f } ∪ pre(o ) is a mutex (S2). "⇐": If V G is RSE-invertible, then for every edge (x, q o , x ) in D V G there exists (x , q o , x) such that pre(q o )[V \ V G ] ⊆ pre(q o )[V \ V G ] ∪ eff(q o )[V \ V G ].</formula><p>Therefore, it follows from Lemma 6 that also pre(o ) ⊆ pre(o) ∪ add(o). Moreover, from the construction (T2b) it follows that if x = f , then f ∈ add(o) and f ∈ del(o ), and vice versa, if x = f , then f ∈ del(o) and f ∈ add(o ). Therefore, the conditions (I1-3) are satisfied.</p><p>A mutex group M ∈ G such that |M | ≥ 2 requires the fam-group map γ to map M to its superset fam-group (S7). Recall the example in Figure <ref type="figure">1</ref>. The facts f 1 and f 2 are RSEinvertible, but f 3 and f 4 are not, because of the operator o 34 . So, we would like to construct an RSE-invertible variable from G = {f 1 , f 2 }. If we set γ(G) = ∅, then the resulting DTG (Figure <ref type="figure">1c</ref>) will have edges between f 1 and f 2 that are not RSE-invertible, because the operator o 31 has f 3 as its precondition, which is not part of pre(o 42 )∪add(o 42 ). However, γ(G) = F results in the RSE-invertible DTG (Figure <ref type="figure">1b</ref>).</p><formula xml:id="formula_20">Lemma 8. Let G ∈ G be a mutex group with |G| ≥ 2 and γ(G) = ∅. Then G is RSE-invertible iff V G is RSE-invertible. Proof. "⇒": Since γ(G) is a fam-group s.t. G ⊆ γ(G) and |G| ≥ 2 and (S6), for every operator o ∈ O and every f ∈ G it holds that f ∈ del(o) implies f ∈ pre(o). Let (d, q o , d ) denote an edge in the DTG of V G . Then eff(q o )[V G ] = d and either pre(q o )[V G ] = d or V G ∈ vars(pre(q o ))</formula><p>. Now, if we show that there also exist an edge (d , q o d) for some o ∈ O s.t. pre(o ) ⊆ pre(o) ∪ add(o), then the rest follows from Lemma 6. So three cases need to be investigated.</p><p>(  </p><formula xml:id="formula_22">(q o )[V G ] = d and either pre(q o )[V G ] = ⊥ G or V G ∈ vars(pre(q o )).</formula><p>Therefore, we have an edge (⊥ G , q o , d).</p><p>(</p><formula xml:id="formula_23">) If d = ⊥ G and d ∈ G, then d ∈ add(o), there- fore there exists f ∈ γ(G) \ G s.t. f ∈ pre(o) ∩ del(o). Thus, there exists o ∈ O s.t. f ∈ add(o ) and pre(o ) ⊆ pre(o) ∪ add(o). Hence, d ∈ pre(o ) ∩ del(o ) because γ(G) ∩ pre(o ) ∩ del(o ) = ∅ (γ(G) is a fam-group) and (pre(o) ∪ add(o)) ∩ γ(G) = {f, d } and f ∈ pre(o ). There- fore, pre(q o )[V G ] = d and eff(q o )[V G ] = ⊥ G , and thus we have (d , q o , ⊥ G ). "⇐": Let (x, q o , x ) denote an edge in D V G . If x ∈ G, then x ∈ add(o) (T2b). Since γ(G) is a fam-group, either pre(q o )[V G ] = ⊥ G , or pre(q o )[V G ] = x s.t. x ∈ G. There- fore if x ∈ G, then x ∈ pre(o) ∩ del(o). Therefore, for every such q o it holds that either G∩del(o) = ∅ or G∩add(o) = ∅. Since V G is RSE-invertible, for every edge (x, q o , x ) there exist an edge (x , q o , x) s.t. pre(q o )[V \ V G ] ⊆ pre(q o )[V \ V G ] ∪ eff(q o )[V \ V G ], therefore it follows from Lemma 6 that pre(o ) ⊆ pre(o) ∪ add(o).<label>3</label></formula><p>Hence, the conditions (I1-3) are satisfied.</p><formula xml:id="formula_24">Theorem 9. Let G ∈ G be a mutex group with |G| = 1 or γ(G) = ∅. Then G is RSE-invertible iff V G is RSE-invertible.</formula><p>Proof. It follows directly from Lemma 7 and Lemma 8.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Causal Graph</head><p>Besides RSE-invertibility of black variables, the tractable fragment of red-black planning requires the black causal graph to be acyclic. To achieve that, we show how to find a causal link between mutex groups that is translated into FDR.</p><p>Definition 10. Given a mutex group G ∈ 2 F , two distinct facts f ∈ G and f ∈ G, and a fam-group map γ on 2 F , we say that there is a causal link from (G, f ) to f iff there exists an operator</p><formula xml:id="formula_25">o ∈ O such that (i) f ∈ del(o) ∪ add(o), and (ii) f ∈ pre(o) ∪ del(o) ∪ add(o), or γ(G) ∩ pre(o) = ∅.</formula><p>Theorem 11. Let E Π = Π, G, γ be an MGE-STRIPS task with operators O, A, B ∈ G be two distinct mutex groups, and CG V be the causal graph of P(E Π ). There is an edge</p><formula xml:id="formula_26">(V A , V B ) in CG V iff there exist f ∈ A and f ∈ B such that there is a causal link from (A, f ) to f . Proof. "⇐": Let o ∈ O be the operator inducing the causal link from (A, f ) to f . If f ∈ pre(o), then pre(q o )[V A ] = f . If f ∈ add(o), then eff(q o )[V A ] = f . If f ∈ del(o), then either eff(q o )[V A ] = ⊥ A or there exist x ∈ A s.t. eff(q o )[V A ] = x. If γ(A) = ∅ and γ(A)∩pre(o) = ∅, then ei- ther pre(q o )[V A ] = x for some x ∈ A, or pre(q o )[V A ] = ⊥ A .</formula><p>Therefore, V A ∈ (vars(pre(q o )) ∪ vars(eff(q o )), and for similar reasons V B ∈ vars(eff(q o )).</p><formula xml:id="formula_27">"⇒": If (V A , V B ) in CG {V A ,V B } , then there exists q o ∈ O s.t. V A ∈ (vars(pre(q o )) ∪ vars(eff(q o ))) and V B ∈ vars(eff(q o )). If pre(q o )[V A ] ∈ A or eff(q o )[V A ] ∈ A, and eff(q o )[V B ] ∈ B, then it follows trivially that A ∩ (pre(o) ∪ add(o)) = ∅ and B ∩ add(o) = ∅. So what remains is to show that (i) if pre(q o )[V A ] = ⊥ A , then γ(A) = ∅ and γ(A) ∩ pre(o) = ∅ (T2a); (ii) if eff(q o )[V A ] = ⊥ A , then A ∩ del(o) = ∅ (T2b); (iii) if eff(q o )[V B ] = ⊥ B , then B ∩ del(o) = ∅ (T2b).</formula><p>Theorem 11 shows that causal graphs in the FDR planning task P(E Π ) correspond exactly to the causal links in E Π as per Definition 10. So, extracting acyclic causal graphs needed for the tractable fragment of red-black planning require to find subsets of mutex groups consisting of facts whose causal links form an acyclic graph. In the next section, we show how to find such subsets of mutex groups.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Inference of Black Variables</head><p>We have shown how to find RSE-invertible mutex groups and what conditions must be met in order to form a causal link between FDR variables created from mutex groups. Now, we put everything together and show how to select mutex groups that can be translated into RSE-invertible FDR variables that form an acyclic causal graph, and thus can be painted black. Definition 12. Given a STRIPS planning task Π with facts F , a fam-group map γ over 2 F , and a set of mutex groups</p><formula xml:id="formula_28">K ⊆ 2 F such that for every G ∈ K it holds that either |G| = 1, or γ(G) = ∅, X(Π, K, γ) = (V, E) denotes a digraph with vertices V ⊆ K×F and edges E ⊆ V ×V , where (G, f ) ∈ V iff G ∈ K and f ∈ G, and ((G, f ), (G , f )) ∈ E iff f = f or there is a causal link from (G, f ) to f . Given a cycle c in X(Π, K), let C(c) = {G | (G, f ) ∈ c}.</formula><p>Theorem 13. Let E Π = Π, G, M G be an MGE-STRIPS planning task, K ⊆ G be a set of RSE-invertible mutex groups such that |G| = 1 or γ(G) = ∅ for every G ∈ K, and V K be the set of corresponding variables from P(E Π ). Then</p><formula xml:id="formula_29">CG V K is acyclic iff for every cycle c in X(Π, K, γ) it holds that |C(c)| = 1.</formula><p>Proof Sketch. It follows directly from Theorem 11, because if |C(c)| = 1, then every cycle of causal links is contained within one mutex group.</p><p>Algorithm 1 encapsulates the algorithm for inference of a set of RSE-invertible mutex groups K, and a fam-group map γ, that can be translated into red-black planning task as black variables. We assume we are given a STRIPS planning task Π, and a set of fam-groups H ⊆ 2 F that can be inferred by one of the algorithm proposed by <ref type="bibr" target="#b6">Helmert [2009]</ref>, <ref type="bibr">Fišer and Komenda [2018]</ref>, or <ref type="bibr" target="#b3">Fišer [2020]</ref>. In steps 1-3, we prepare RSE-invertible mutex groups and a mapping to the corresponding fam-groups. In step 1, H is constructed as a set of singletons, each corresponding to the RSE-invertible fact that is not covered by any input fam-group, i.e., these facts can be translated only to binary FDR variables. In step 2, the fam-group map is constructed in the following way: (i) each singleton from H is mapped to an empty set, and (ii) for each fam-group G containing at least one RSE-invertible fact, we Algorithm 1: Inference of RSE-invertible mutex groups forming acyclic causal graph.</p><p>Input:</p><formula xml:id="formula_30">A STRIPS planning task Π = F , O, s I , s G , a set of fam-groups H ⊆ 2 F , a set of RSE-invertible facts N ⊆ F . Output: A set of RSE-invertible mutex groups K, a fam-group map γ over K 1 H ← {{f } | f ∈ N \ G∈H G}; 2 Construct a fam-group map γ : γ (G) = ∅ for every G ∈ H , and γ (G ∩ N ) = G for every G ∈ H s.t. G ∩ N = ∅; 3 H ← H ∪ {G ∩ N | G ∈ H, G ∩ N = ∅}; 4 Construct the digraph X(Π, H , γ ) = (V, E).; 5 Find vertices V ⊆ V such that for every cycle c in the subgraph of X(Π, H , γ) induced by V it holds that |C(c)| = 1; 6 Z ← {(G, {f | (G, f ) ∈ V }) | (G, f ) ∈ V }.; 7 Construct a fam-group map γ: For every (G, X) ∈ Z, set γ(X) = ∅ if |X| = 1 and γ(X) = G otherwise; 8 K ← {X | (G, X) ∈ Z};</formula><p>map its RSE-invertible subset G ∩ N to G. In step 3, H is constructed as a set of RSE-invertible mutex groups covering all RSE-invertible facts. In step 4, the graph defined in Definition 12 is constructed, and in step 5, we find a subset of vertices having cycles only within each mutex group. Finally, in the last three steps we extract the solution.</p><p>Note that the step 5 is a variant of an NP-complete feedback vertex set problem <ref type="bibr" target="#b8">[Karp, 1972]</ref>. We decided to use a naive approach and solve this problem by an integer linear program (ILP), where each vertex from X(Π, H , γ ) corresponds to a binary variable, and each constraint corresponds to a cycle that has to be avoided. Instead of listing all cycles, we first add all cycles between pairs of vertices from different mutex groups, then we solve the problem, and check whether the resulting solution has a cycle. If we find a cycle, we add it as another constraint, solve the problem, and continue in this manner until we find a feasible solution.</p><p>As objective function of the ILP, we tried two variants. The first variant is simply a maximization of the number of facts in the resulting mutex groups. The second variant weights facts using the number of conflicts in a relaxed plan π + obtained from the FF heuristic <ref type="bibr" target="#b7">[Hoffmann and Nebel, 2001]</ref> computed on the STRIPS representation. Following prior work <ref type="bibr" target="#b0">[Domshlak et al., 2015]</ref>, we say a fact f has a conflict if there is an operator o in π + such that f ∈ pre(o) and f is not satisfied when executing π + with the non-relaxed semantics. For each mutex group M , we sum the number of conflicts from all f ∈ M , and we set the weight of each fact f ∈ M as the sum over |M |. This way we prioritize mutex groups containing facts with most conflicts in the relaxed plan.</p><p>Note that Algorithm 1 describes only the inference of RSEinvertible variables. The rest of the FDR variables, i.e., the red variables, are constructed from the remaining facts not covered by the resulting black variables by greedy approach described by <ref type="bibr" target="#b6">Helmert [2009]</ref>, i.e., we greedily maximize the size of red variables. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Experimental Evaluation</head><p>We implemented Algorithm 1 in C, used fam-groups inferred from PDDL <ref type="bibr" target="#b3">[Fišer, 2020]</ref> <ref type="foot" target="#foot_3">foot_3</ref> , and used the red-black heuristic h RB <ref type="bibr" target="#b0">[Domshlak et al., 2015]</ref> implemented in FD <ref type="bibr" target="#b5">[Helmert, 2006]</ref>. The experiments were performed on Intel(R) Xeon(R) Scalable Gold 6146 machines with CPLEX solver v12.6, and time and memory limits of 30min and 8GiB. Out of all benchmarks from International Planning Competitions of 1998 to 2018 satisficing planning tracks, we selected all tasks where no conditional effects were created and at least one variable could be painted black.</p><p>We compare the following configurations: the baseline configuration B runs the painting strategy denoted as A<ref type="foot" target="#foot_4">foot_4</ref> by <ref type="bibr" target="#b0">Domshlak et al. [2015]</ref> on the default FDR encoding <ref type="bibr" target="#b6">[Helmert, 2009]</ref>; M maximizes the number of black facts using Algorithm 1; C is the variant of Algorithm 1 using conflicts in a relaxed plan; and the "oracle" O picks the best FDR encoding and painting for each tested task. It considers B, and five best encodings (by objective value) from each of M and C, which we obtain by repeatedly solving the corresponding ILP, each time disallowing previous solutions by additional constraints. The encodings are chosen in terms of coverage, preferring tasks solved in the initial state by h RB . O serves to illustrate the potential of our customized encodings, assuming perfect knowledge about which encoding works best for a given task.</p><p>The most time-demanding part of Algorithm 1 is solving the ILP (step 5). The average and median time spent in this step was 3.3 seconds and 12 milliseconds, respectively, for both C and M. The maximum was more than six minutes, but it took more than a minute only for 15 tasks in transport, 7 tasks in visitall, and 1 task in the satellite domain. Figure <ref type="figure" target="#fig_1">2</ref> shows a comparison of running times (in seconds) of the whole translation process. Although Algorithm 1 often requires more time in comparison to the greedy approach of the baseline, it, for most cases, leaves enough time for the planner, as we describe below.</p><p>The scatter plots in Figure <ref type="figure" target="#fig_3">3</ref> show that our methods are able to increase the number of black facts by several orders of magnitude. The oracle often uses significantly less black facts than B, indicating that it is not necessarily beneficial to have more black facts. In fact, having more black variables (facts) can negatively impact heuristic computation time, without improving informativeness. Table <ref type="table" target="#tab_3">1</ref> shows the number of tasks solved (coverage) in the left, and the number of tasks solved by h RB in the initial state in the center. B clearly outperforms M which, again, shows that maximizing the number of black facts is not necessarily the best painting strategy. C and B are very similar in coverage, with strengths in different domains. C can solve six more tasks in the initial state resulting from only two domains, blocks and satellite.</p><p>The oracle variant O demonstrates the potential of our approach if we better understand how to select the best encoding for a given task. B already solves a large portion of tasks, but here we show that it is still possible to create an encoding and painting that could further increase this number by at least 25 tasks, and 14 more can be solved in the initial state. Unfortunately, it is unclear how to directly compare the quality of individual encodings for a given task without running the search. Maximizing the number of black facts turned out to be too simplistic as an optimization criterion. Considering conflicts in a relaxed plan improves the results in some domains, but it is still unclear what properties identify a good FDR encoding and painting for red-black planning.</p><p>The rightmost column in Table <ref type="table" target="#tab_3">1</ref> shows the number of tasks with a single maximal set of black variables. That is, it shows the number of tasks where different paintings can only be achieved by painting black a subset of the facts that were already painted black by C and M. In other words, both C and M created exactly the same set of black variables, but B could paint only less variables black. This is exactly what happened in the depot domain where painting less variables black proved to generate a more suitable FDR for the redblack heuristic.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Conclusion</head><p>We devised a method to custom-design FDR encodings of classical planning tasks, showcasing how a tractable fragment of red-black planning can be formulated into the translation from PDDL to FDR. By describing this translation as an integer linear program, we can explore the space of possible tractable red-black FDR encodings. Our evaluation shows an increase in the number of black facts by several orders of magnitude. Our approach is flexible, allowing to express complex properties based on, e.g., DTGs or causal graphs. Thus, custom-designed FDR encodings have the potential of benefiting planning techniques beyond red-black planning, opening up a wide range of possibilities for future research.  </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>) If d, d ∈ G, then d ∈ add(o). And since γ(G) is a fam-group, we have V G ∈ vars(pre(q o )) and d ∈ pre(o) ∩ del(o). Therefore, there exists o ∈ O s.t. d ∈ add(o ) and pre(o ) ⊆ pre(o) ∪ add(o). Thus, d ∈ pre(o ), because d ∈ pre(o ) and γ(G) ∩ (pre(o) ∪ add(o)) = {d, d }. Therefore, there exists an edge (d , q o , d).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>( 2 )</head><label>2</label><figDesc>If d ∈ G and d = ⊥ G , then add(o) ∩ G = ∅ and del(o) ∩ G = ∅, therefore d ∈ del(o), because otherwise there would exist x ∈ G, x = d, s.t. x ∈ del(o), therefore x ∈ pre(o), therefore pre(q o )[V G ] = x which is in contradiction. So we have d ∈ del(o) and also d ∈ pre(o). Therefore, there exists o s.t. d ∈ add(o ) and pre(o ) ⊆ pre(o) ∪ add(o). So since d ∈ pre(o) and add(o) ∩ G = ∅, then pre(o )∩G = ∅, therefore we have eff</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Per-task comparison of the translation time (in seconds).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Per-task comparison of the number of black FDR facts.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>An operator o is a tuple o = pre(o), add(o), del(o) , where pre(o) ⊆ F is the set of preconditions of o, and add(o) ⊆ F and del(o) ⊆ F are the sets of add and delete effects, respectively. All operators are well-formed, i.e., add(o) ∩ del(o) = ∅ and pre(o) ∩ add(o) = ∅. We assume unit costs. An operator o is applicable in a state s if pre(o) ⊆ s. The resulting state of applying an applicable operator o in a state s is the state o s = (s \ del(o)) ∪ add(o). A sequence of operators π = o 1 , . . . , o n is applicable in a state s 0 if there are states s 1 , . . . , s n such that o i is applicable in s i-1 and s</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>a partial state called goal, and a state s is a goal state iff ψ G ⊆ s. O is a finite set of operators, each operator o ∈ O has a precondition pre(o) and effect eff(o), which are partial states. An operator o is applicable in a state s iff pre(o) ⊆ s. The resulting state of applying an applicable operator o in a state s is the state o s where o s</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>and f ∈ del(o ), and (I2) for every operator o ∈ O such that f ∈ del(o) it holds that there exists an operator o ∈ O such that f ∈ add(o ) and pre(o ) ⊆ pre(o) ∪ add(o), and (I3) for every operator o ∈ O such that f ∈ add(o) it holds that there exists an operator o ∈ O such that f ∈ del(o ) and pre(o ) ⊆ pre(o) ∪ add(o). We also call a set of facts (or mutex group)</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 1 :</head><label>1</label><figDesc>Number of tasks solved (left), number of tasks solved in the initial state (center), and number of tasks with a single maximal set of black variables (right). B, M, C, and O are described in the text. Domains with identical results are summarized in "others".</figDesc><table><row><cell>others (647)</cell><cell>497 497 497 497 172 172 172 172 428</cell></row><row><cell>Σ (1 233)</cell><cell>953 933 950 978 307 190 313 321 525</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p><ref type="bibr" target="#b12">Vallati et al. [2015;</ref>  </p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_1"><p>2017] have explored domain model optimization tailored to specific planners before, but for PDDL not for FDR variable design, and changing only the ordering of artefacts in the input model (which had previously been observed to be relevant for the performance of some planners<ref type="bibr" target="#b7">[Howe and Dahlman, 2002]</ref>).Proceedings of the Thirtieth International Joint Conference on Artificial Intelligence </p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_2"><p>Proceedings of the Thirtieth International Joint Conference on Artificial Intelligence </p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_3"><p>https://gitlab.com/danfis/cpddl, branch ijcai21-fdr-red-black</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_4"><p>The painting strategy greedily paints variables red until the black causal graph is acyclic, preferring keeping variables with larger number of incident edges to black variables.Proceedings of the Thirtieth International Joint Conference on Artificial Intelligence </p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div><head>Acknowledgements</head><p><rs type="person">Daniel Gnad</rs> was supported by the <rs type="funder">German Research Foundation (DFG)</rs>, under grant <rs type="grantNumber">HO 2169/6-2</rs>, "<rs type="projectName">Star-Topology Decoupled State Space Search". Jörg Hoffmann's research group</rs> has received support by <rs type="funder">DFG</rs> grant <rs type="grantNumber">389792660</rs> as part of TRR 248 (see perspicuous-computing.science).</p></div>
			</div>
			<listOrg type="funding">
				<org type="funded-project" xml:id="_fw5TBFD">
					<idno type="grant-number">HO 2169/6-2</idno>
					<orgName type="project" subtype="full">Star-Topology Decoupled State Space Search&quot;. Jörg Hoffmann&apos;s research group</orgName>
				</org>
				<org type="funding" xml:id="_fjetMfs">
					<idno type="grant-number">389792660</idno>
				</org>
			</listOrg>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Red-black planning: A new systematic approach to partial delete relaxation</title>
		<author>
			<persName><forename type="first">Carmel</forename><surname>Domshlak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jörg</forename><surname>Hoffmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Katz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Artificial Intelligence</title>
		<imprint>
			<biblScope unit="volume">221</biblScope>
			<biblScope unit="page" from="73" to="114" />
			<date type="published" when="2015">2015. 2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Filip Dvořák, Daniel Toropila, and Roman Barták. Towards AI planning efficiency: Finitedomain state variable reformulation</title>
		<author>
			<persName><surname>Dvořák</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SARA&apos;13</title>
		<meeting>SARA&apos;13</meeting>
		<imprint>
			<date type="published" when="2013">2013. 2013</date>
			<biblScope unit="page" from="50" to="53" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Fišer and Komenda, 2018] Daniel Fišer and Antonín Komenda. Fact-alternating mutex groups for classical planning</title>
		<author>
			<persName><surname>Dvořák</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Experimental and Theoretical Artificial Intelligence</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="475" to="521" />
			<date type="published" when="2015">2015. 2015. 2018</date>
		</imprint>
	</monogr>
	<note>Journal of Artificial Intelligence Research</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Lifted fact-alternating mutex groups and pruned grounding of classical planning problems</title>
		<author>
			<persName><forename type="first">Daniel</forename><surname>Fišer</surname></persName>
		</author>
		<author>
			<persName><surname>Fišer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. AAAI&apos;20</title>
		<meeting>AAAI&apos;20</meeting>
		<imprint>
			<date type="published" when="2020">2020. 2020</date>
			<biblScope unit="page" from="9835" to="9842" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Merge &amp; shrink abstraction: A method for generating lower bounds in factored state spaces</title>
		<author>
			<persName><forename type="first">Hoffmann</forename><surname>Gnad</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniel</forename><surname>Gnad</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jörg</forename><surname>Hoffmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">;</forename><surname>Haslum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SOCS&apos;15</title>
		<editor>
			<persName><forename type="first">Malte</forename><surname>Helmert</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Patrik</forename><surname>Haslum</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Jörg</forename><surname>Hoffmann</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Raz</forename><surname>Nissim</surname></persName>
		</editor>
		<meeting>SOCS&apos;15</meeting>
		<imprint>
			<date type="published" when="2007">2015. 2015. 2007. 2007. 2014</date>
			<biblScope unit="volume">61</biblScope>
			<biblScope unit="page" from="16" to="17" />
		</imprint>
	</monogr>
	<note>Domainindependent construction of pattern database heuristics for cost-optimal planning</note>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">The Fast Downward planning system</title>
		<author>
			<persName><forename type="first">Malte</forename><surname>Helmert</surname></persName>
		</author>
		<author>
			<persName><surname>Helmert</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Artificial Intelligence Research</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="191" to="246" />
			<date type="published" when="2006">2006. 2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Concise finite-domain representations for PDDL planning tasks. Artificial Intelligence</title>
		<author>
			<persName><forename type="first">Malte</forename><surname>Helmert</surname></persName>
		</author>
		<author>
			<persName><surname>Helmert</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009">2009. 2009</date>
			<biblScope unit="volume">173</biblScope>
			<biblScope unit="page" from="503" to="535" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">The FF planning system: Fast plan generation through heuristic search</title>
		<author>
			<persName><forename type="first">Nebel</forename><surname>Hoffmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jörg</forename><surname>Hoffmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bernhard</forename><surname>Nebel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Adele</forename><forename type="middle">E</forename><surname>Howe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Eric</forename><surname>Dahlman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Artificial Intelligence Research</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page" from="1" to="3" />
			<date type="published" when="2001">2001. 2001. 2002</date>
		</imprint>
	</monogr>
	<note>Journal of Artificial Intelligence Research</note>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Pushing the limits of partial delete relaxation: Red-black DAG heuristics</title>
		<author>
			<persName><forename type="first">Richard</forename><forename type="middle">M</forename><surname>Karp</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Karp</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Carmel</forename><surname>Katz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Domshlak</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jörg</forename><surname>Katz</surname></persName>
		</author>
		<author>
			<persName><surname>Hoffmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICAPS 2014 Workshop on Heuristics and Search for Domain-Independent Planning (HSDIP&apos;14)</title>
		<meeting><address><addrLine>Boston, MA</addrLine></address></meeting>
		<imprint>
			<publisher>Katz and Hoffmann</publisher>
			<date type="published" when="1972">1972. 1972. 2010. 2010. 2014. 2014</date>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="page" from="51" to="126" />
		</imprint>
	</monogr>
	<note>Reducibility among Combinatorial Problems</note>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Red-black relaxed plan heuristics</title>
		<author>
			<persName><surname>Katz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. AAAI&apos;13</title>
		<meeting>AAAI&apos;13</meeting>
		<imprint>
			<date type="published" when="2013">2013. 2013</date>
			<biblScope unit="page" from="489" to="495" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Who said we need to relax all variables?</title>
		<author>
			<persName><surname>Katz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ICAPS&apos;13</title>
		<meeting>ICAPS&apos;13</meeting>
		<imprint>
			<date type="published" when="2013">2013. 2013</date>
			<biblScope unit="page" from="126" to="134" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Red-black heuristics for planning tasks with conditional effects</title>
		<author>
			<persName><forename type="first">Michael</forename><surname>Katz</surname></persName>
		</author>
		<author>
			<persName><surname>Katz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. AAAI&apos;19</title>
		<meeting>AAAI&apos;19</meeting>
		<imprint>
			<date type="published" when="2019-02">2019. February 2019</date>
			<biblScope unit="page" from="7619" to="7626" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Seipp and Helmert, 2018] Jendrik Seipp and Malte Helmert. Counterexample-guided Cartesian abstraction refinement for classical planning</title>
		<author>
			<persName><forename type="first">Drew</forename><surname>Mcdermott</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mauro</forename><surname>Mcdermott</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Frank</forename><surname>Vallati</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lukáš</forename><surname>Hutter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><forename type="middle">Leo</forename><surname>Chrpa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mauro</forename><surname>Mccluskey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lukás</forename><surname>Vallati</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><forename type="middle">Leo</forename><surname>Chrpa</surname></persName>
		</author>
		<author>
			<persName><surname>Mccluskey</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The 1998 AI planning systems competition. The AI Magazine</title>
		<imprint>
			<date type="published" when="2000">2000. 2000. 2018. 2015. 2017</date>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="171" to="172" />
		</imprint>
	</monogr>
	<note>Proc. SOCS&apos;17</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
