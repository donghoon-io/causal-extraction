<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">UISCOPE: Accurate, Instrumentation-free, and Visible Attack Investigation for GUI Applications</title>
				<funder ref="#_UFykUsK #_tPfJNwq #_Ak3bWZb">
					<orgName type="full">National Science Foundation</orgName>
					<orgName type="abbreviated">NSF</orgName>
				</funder>
				<funder ref="#_s7R7fmh #_a94Ra93">
					<orgName type="full">ONR</orgName>
				</funder>
				<funder ref="#_HGa3enV">
					<orgName type="full">Sandia National Lab</orgName>
				</funder>
				<funder ref="#_VXQYJPN">
					<orgName type="full">NSFC</orgName>
				</funder>
				<funder ref="#_wrUAwRw">
					<orgName type="full">DARPA</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Runqing</forename><surname>Yang</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Zhejiang University, ‡ Rutgers University</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Shiqing</forename><surname>Ma</surname></persName>
							<email>shiqing.ma@rutgers.edu</email>
						</author>
						<author>
							<persName><forename type="first">Haitao</forename><surname>Xu</surname></persName>
							<affiliation key="aff1">
								<orgName type="institution">Arizona State University, ¶ Purdue University</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Xiangyu</forename><surname>Zhang</surname></persName>
							<email>xyzhang@cs.purdue.edu</email>
						</author>
						<author>
							<persName><forename type="first">Yan</forename><surname>Chen</surname></persName>
							<email>ychen@northwestern.edu</email>
							<affiliation key="aff2">
								<orgName type="institution">Northwestern University</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">UISCOPE: Accurate, Instrumentation-free, and Visible Attack Investigation for GUI Applications</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="DOI">10.14722/ndss.2020.24329</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.1" ident="GROBID" when="2025-10-14T18:16+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Existing attack investigation solutions for GUI applications suffer from a few limitations such as inaccuracy (because of the dependence explosion problem), requiring instrumentation, and providing very low visibility. Such limitations have hindered their widespread and practical deployment. In this paper, we present UISCOPE, a novel accurate, instrumentationfree, and visible attack investigation system for GUI applications. The core idea of UISCOPE is to perform causality analysis on both UI elements/events which represent users' perspective and low-level system events which provide detailed information of what happens under the hood, and then correlate system events with UI events to provide high accuracy and visibility. Long running processes are partitioned to individual UI transitions, to which low-level system events are attributed, making the results accurate. The produced graphs contain (causally related) UI elements with which users are very familiar, making them easily accessible. We deployed UISCOPE on 7 machines for a week, and also utilized UISCOPE to conduct an investigation of 6 realworld attacks. Our evaluation shows that compared to existing works, UISCOPE introduces neglibible overhead (less than 1% runtime overhead and 3.05 MB event logs per hour on average) while UISCOPE can precisely identify attack provenance while offering users thorough visibility into the attack context.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I. INTRODUCTION</head><p>When security alerts are raised, a swift attack investigation should be conducted to determine the cause and scope of the attack so that the impact of the attack can be minimized and such attacks in the future can be prevented. Provenance tracking and causality analysis is an important technique for efficient attack investigation. Starting from a compromised system entity (e.g., file, socket, or process), investigators perform causality analysis on the collected provenance to figure out: 1) the root or origin of the entity, i.e., all the external entities (e.g., a socket connection) affecting the target entity, and 2) the causal path from the root to the entity. Such analysis facilitates identifying attack root cause, assessing damage incurred, and developing countermeasures. GUI applications (e.g., browsers), one of the most popular attack vectors <ref type="bibr" target="#b6">[7]</ref>, typically cause substantial accuracy degradation of causality analysis as they may run for a long time and process many independent tasks. In this paper, we hence focus on GUI applications.</p><p>System event (e.g., system calls) auditing is a built-in feature in mainstream operating systems and can be used for such investigation. Existing work <ref type="bibr" target="#b40">[41]</ref>, <ref type="bibr" target="#b27">[28]</ref>, <ref type="bibr" target="#b24">[25]</ref>, <ref type="bibr" target="#b29">[30]</ref>, <ref type="bibr" target="#b44">[45]</ref>, <ref type="bibr" target="#b51">[52]</ref>, <ref type="bibr" target="#b41">[42]</ref>, <ref type="bibr" target="#b36">[37]</ref> has demonstrated their great potential, but they suffer from a few major limitations.</p><p>1) Inaccurate analysis results. In many causality analysis, when a long-running process interacts with many input and output objects, each output object will be conservatively considered causally dependent on all the preceding input objects. This is known as the dependency explosion problem. Such problems lead to significantly inaccurate analysis results when there are long-running processes involved and makes the investigation impossible to move forward.</p><p>2) Requiring instrumentation on end-user systems. Some approaches try to solve the dependency explosion problem using instrumentation on source code or binary. However, instrumentation is generally not practical and prohibited in real-world production environments. Firstly, most COTS software only provides executable binaries and do not provide source code. Secondly, intrusive modification of binary code can make applications and operating system unstable. Even more, it can introduce new vulnerabilities which can be leveraged by malware <ref type="bibr" target="#b10">[11]</ref>, <ref type="bibr" target="#b8">[9]</ref>, <ref type="bibr" target="#b1">[2]</ref>. As such, Microsoft integrated the Kernel Patch Protection (KPP) into Windows to prevent patching the kernel <ref type="bibr" target="#b7">[8]</ref>. Thirdly, the party which instruments COTS executables or operating systems has to take full responsibility for all potential accidents, no matter whether the accidents are caused by instrumentation or not. Hence instrumentation is mostly prohibited in the enterprise environment.</p><p>3) Lack of visibility. Human-perceivable attack investigation report is largely preferred and would greatly facilitate security experts to understand attacks and take necessary remedies. Some existing non-instrumentation studies employ statistical analysis <ref type="bibr" target="#b28">[29]</ref>, <ref type="bibr" target="#b40">[41]</ref> (e.g., only considering causal edges that rarely happened in the past) to guide causal dependency graph pruning to address the inaccuracy in causality analysis. However, they just provide system level information (e.g., process id, file name) and cannot fully recover what happened from the user's perspective, which plays a vital role in the forensic analysis <ref type="bibr" target="#b52">[53]</ref>.</p><p>Our solution. We propose UISCOPE, a novel accurate and instrumentation-free attack investigation system which provides meaningful contextual information to enhance the visibility of forensics analysis. The basic idea of UISCOPE is to combine low-level causality analysis with high-level UI elements and events analysis to grain the advantages of both. On one hand, we leverage detailed low-level system events to fully recover what actually happens in the system. On the other hand, we attribute the system events to high-level UI elements and UI events to provide better visibility for attack forensics and solve the dependence explosion problem (i.e., attributing system events to individual UI elements instead of a single long-running process to avoid dependency explosion). By instrumentation-free, we mean that UISCOPE leverages existing built-in event logging system and does not require extra instrumentation on the end user systems.</p><p>In UISCOPE, there are two types of event collectors: the UI elements and events collector and the system events collector. For the UI elements and events collector, we leverage the accessibility service shipped with major operating systems, and for the system event collector, we leverage built-in audit systems such as Event Tracing for Windows (ETW). These systems are provided by OS vendors and thus usually have very low runtime and storage overhead. As such, we avoid instrumenting end user systems.</p><p>After collecting all UI events and system events, UISCOPE performs causality analysis on UI elements and events (through the UI event analyzer) as well as system events (the system event analyzer) to generate causal graphs for both types of logs. We devise an additional correlation analyzer, which correlates UI events and system events based on timestamp alignment and resource attribution (e.g., attributing background file accesses to the UI operation where the file resource was initialized). The details of the corresponding algorithm describing how UISCOPE deals with software background activities are presented in Section III-F2. Through the correlation algorithm, we partition a long-running process into individual UI transitions, making the result more accurate. Also, the final graph represents information in a way closely coupled with UI interactions which users are very familiar with, allowing to reconstruct the attack story from user's perspective and provide high visibility.</p><p>We deployed UISCOPE on 7 machines for a week and utilized UISCOPE to conduct investigation of 6 real-world attacks. Our evaluation shows that UISCOPE can not only accurately identify the attack path but also provide finegrained human-comprehensible contextual semantics to users. In addition, compared to existing works, UISCOPE introduces negligible extra runtime overhead (less than 1%) and extra space overhead (3.05 MB event logs per hour on average). UISCOPE does not require any end system change or instrumentation and can be deployed as an add-on to any existing threat detection system in production environments.</p><p>In summary, we make the following contributions:</p><p>• We identify a few limitations of existing attack forensics techniques in practice and propose a novel accurate and instrumentation-free attack investigation system, UISCOPE, which also provides high visibility in attack forensics. It leverages both UI information in the user space and system events in the kernel space to achieve our aforementioned design goals. • We devise a novel UI event analyzer which analyzes UI events causality, and a correlation analyzer which correlates UI events with system events to produce accurate and highly visible causal graphs. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>II. MOTIVATION</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Motivating Example</head><p>One day, an office clerk Bob tried to download a piece of software (WinSCP.exe) from a website benign.com. While waiting for the download to complete, he received an email informing that he had been selected as a winner for an iPad and asking him to claim the award on a website. It was actually a phishing email leading to a malicious website. The website uses the WordPress free host service and uses the domain name well-known.wordpress.com. It also leverages login detection techniques <ref type="bibr" target="#b9">[10]</ref> to test if the user has logged into any well-known bank website. In our attack story, Bob happened to login www.bank.com to manage his company's bank account. Hence, the malicious website launched a clickjacking attack <ref type="bibr" target="#b4">[5]</ref> by creating a transparent frame containing a transfer form with the receiver being the attacker's own bank account on top of the "Get iPad" button. Bob clicked the "Get iPad" button, which actually triggered a transfer from his bank account to the attack's bank account, without being noticed by Bob.</p><p>The good news was that Bob's company deployed protection techniques. The security system raised an abnormal transfer alert. Following this alert, forensics investigation began from the abnormal transfer socket communication, and tried to find how/when/where this happened and investigate if Bob was an insider attacker who stole money from the company.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Existing Attack Investigation Solutions</head><p>1) Low-level Events Causality Analysis: Traditional causality analysis <ref type="bibr" target="#b33">[34]</ref>, <ref type="bibr" target="#b34">[35]</ref> tracks the lineage of system objects (e.g., files and sockets) and subjects (e.g., processes) via system events (e.g., syscalls) and analyzes the causal relations among system objects and subjects to generate causal graphs. With such graphs, investigators can perform backward provenance queries with the symptom (i.e., the abnormal transfer socket) to understand the root cause of the attack or forward provenance queries to identify the effects of the attack. Fig. <ref type="figure" target="#fig_0">1</ref> (I) shows a typical dependence graph generated by traditional causality analysis for this investigation. Note that in this figure (and also the rest of the paper), we use diamond nodes to denote sockets, box nodes to denote processes, and oval nodes to denote files. Also, nodes in red represent the symptom event(s), the events which investigation starts from. Specifically, when investigators perform backward tracking to find which website is related to the abnormal transfer, they would be substantially distracted, because Chrome is a long running process and could have been used to visit hundreds of websites during an attack window (e.g., mail.google.com, benign.com, drive.google.com and many other sites in the figure), and thus the suspicious file is conservatively related to hundreds of preceding websites. This is known as the dependence explosion problem, which makes any further tracking attempt nearly impossible. This is a major limitation of traditional causality analysis.</p><p>Many previous works tried to address this problem via program analysis <ref type="bibr" target="#b36">[37]</ref>, <ref type="bibr" target="#b43">[44]</ref>, <ref type="bibr" target="#b44">[45]</ref>, <ref type="bibr" target="#b35">[36]</ref>. Some of them require source code or binary level instrumentation <ref type="bibr" target="#b36">[37]</ref>, <ref type="bibr" target="#b43">[44]</ref>, <ref type="bibr" target="#b44">[45]</ref>, which is intrusive and not practical in enterprise environments, as discussed in Section I. Taint analysis <ref type="bibr" target="#b31">[32]</ref>, <ref type="bibr" target="#b50">[51]</ref>, <ref type="bibr" target="#b32">[33]</ref> is another way to solve the dependency explosion problem. However, it causes tremendous runtime and space overhead, which makes it rarely used in production environments.</p><p>2) Statistics-based Graph Pruning: Observed that most attack-related events are abnormal and rarely occur in historical event logs of an enterprise network, PrioTracker <ref type="bibr" target="#b40">[41]</ref> and NoDoze <ref type="bibr" target="#b28">[29]</ref> proposed statistics-based attack investigation approaches to prioritize abnormal events and causal dependencies. They introduce quantitative metrics (i.e., frequency and topological features) to distinguish normal and abnormal events and present a pruned causal graph to investigators. Pri-oTracker only considers the abnormality of individual events while NoDoze takes the abnormality of event chains into consideration and thus can generate more precise causal graphs. Fig. <ref type="figure" target="#fig_0">1</ref> (II) presents the causal graph generated by NoDoze for the investigation, which is more concise than the graph generated by traditional techniques (Fig. <ref type="figure" target="#fig_0">1 (I)</ref>). However, NoDoze cannot accurately locate the IP address which is the real source of the abnormal transfer. As shown, NoDoze traces back to two benign sockets, benign.com and x.x.x.x. The reason is that visiting well-known.wordpress.com which is hosted by WordPress is a common and normal behavior (because WordPress is one of the largest blog host websites) while benign.com:80 and x.x.x.x:80 are rarely visited websites and thus deemed abnormal instead. As such, statistics based approach may produce unstable results. In other words, the qualify of the results heavily depends on the dataset used to calculate the observed distribution (e.g., which website gets more visits).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Problem Statement and UISCOPE</head><p>As discussed in the previous section, many low-level event causality analysis based approaches are not applicable in real world systems as they may suffer from the dependence explosion problem, causes heavy runtime overhead or requires instrumentation. Statistics based graph pruning has difficulty handling attacks leveraging popular (and benign) applications and/or websites. Furthermore, graphs generated by both approaches lack the user understandable high-level semantic information. Fig. <ref type="figure" target="#fig_0">1</ref> (II) shows a simplified causal graph generated by NoDoze (Note that using traditional low-level events causality analysis will introduce too many irrelevant sockets and we preclude it from our discussion). With such graphs, even if NoDoze may find the real malicious socket well-known.wordpress.com:80 by tuning thresholds or using high quality data to calculate the observed distribution, it still cannot provide sufficient information to answer the key question in the investigation: is Bob an insider (i.e., did he intentionally initialize the transfer) or an victim of social engineering (e.g., fooled by clickjacking)? Without knowing more contextual information, it is impossible to answer this type of questions. The aforementioned limitations motivate the following design goals for our own system:</p><p>• Accurate: It should produce accurate investigation results, i.e., low false positive and false negative rates. • Applicable: It requires NO extra end system change and causes low overhead so that it is deployable in an enterprise environment.</p><p>• Visible: Its output should be visible to human investigators so that they can easily understand what happened with the application level context information. Visibility plays a vital role in the forensic analysis <ref type="bibr" target="#b52">[53]</ref>.</p><p>As far as we know, existing approaches cannot achieve all the three goals. Therefore, we propose a novel investigation system, UISCOPE, which combines low-level event causality analysis with high-level user interface (UI) elements/events analysis to achieve a balance of all the aforementioned goals. That is, UISCOPE can achieve high attribution accuracy and high visibility for GUI applications while incurring trivial overhead and requiring no instrumentation. UISCOPE is orthogonal to existing non-instrumentation techniques (e.g., probabilistic solutions <ref type="bibr" target="#b40">[41]</ref>, <ref type="bibr" target="#b28">[29]</ref>). While the detailed design will be discussed in Section III, Fig. <ref type="figure" target="#fig_0">1</ref> (III) shows the UISCOPE graph for the aforementioned investigation. In this graph, we use the same shape and color to represent low-level system events as before. We also introduce a new set of nodes and edges to represent UI elements and new relations, which is defined in Section III. Specifically, hexagons represent UI elements and nodes with gray background denote UI elements operated by the user. Dashed lines show the tree structure of different UI elements pointing from the parent node to the child node, which denotes causality as well. A dotted line represents connection between a UI element and a system event and the arrow is from the action initiator. A double solid line represents connection between two UI elements and the destination is affected by the source via some user operation. For example, in Fig. <ref type="figure" target="#fig_0">1</ref> (III), hexagon H represents the Transfer button that was actually clicked by Bob; hexagon E is the Get iPad button which Bob intended to click, and hexagons C, D, E, F, G are Document Object Model (DOM) elements in the same page with the button. Bob first clicked the link in his email (node B), which led him to a new web page (whose UI elements rooted in C). After Bob clicking the transparent button over the Get iPad button (node H), a socket was created and was used to perform the unintended money transfer. The UI element nodes in this graph tell us that in the same web page, there were two clickable buttons in an identical position. If we reconstruct what was seen by Bob, we can get a graph like Fig. <ref type="figure" target="#fig_0">1</ref> (III), indicating that Bob was fooled by a clickjacking attack.</p><p>Additionally, Fig. <ref type="figure" target="#fig_0">1</ref> (III) attributes low-level system objects (e.g., detailed socket addresses and file names) to the corresponding high-level UI elements (i.e., web pages in this case), that are well partitioned and denote autonomous subexecutions. Doing so, we can accurately associate low-level system information with individual autonomous and high-level user actions. This avoids attributing all low-level events to the same process, achieving low false positive/negative rates in causality analysis, as shown by our results in Section IV-B. Details of how the attribution is done including how background events are processed will be discussed in Section III-F.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D. Threat Model</head><p>We assume that both Event Tracing for Windows (ETW) and Accessibility libraries provided by OSes (introduced in Section III) are trusted, and audit logs (i.e., system events captured with ETW and UI events by Accessibility libraries) cannot be tampered with. Attacks that can compromise these two auditing systems are beyond the scope of this study. This assumption is consistent with previous literature <ref type="bibr" target="#b28">[29]</ref>, <ref type="bibr" target="#b40">[41]</ref>, <ref type="bibr" target="#b29">[30]</ref>. In this paper, we focus on GUI-related attacks, in which user involvement is needed to initiate/trigger an attack (e.g., phishing attacks, driven-by downloads and insider attacks). For attacks which do not entail any user interactions, we apply the same methods as previous works <ref type="bibr" target="#b28">[29]</ref>, <ref type="bibr" target="#b40">[41]</ref>, <ref type="bibr" target="#b29">[30]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>III. SYSTEM DESIGN</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. System Design Overview</head><p>The overall workflow of UISCOPE is shown in Fig. <ref type="figure">2</ref>. UISCOPE has two major components: the event collector and the event analyzer. Specifically, the event collector consists of the UI element and event collector and the system event collector. The event analyzer contains the UI event analyzer, the system event analyzer and the correlation analyzer.</p><p>The overarching idea of UISCOPE is to perform both UI event causality analysis and low-level system event causality analysis independently, and then attribute groups of low-level system events to high-level UI event. In UISCOPE, we use UI events to deliver visibility to investigators and solve the dependency explosion problem in low-level causality analysis by attributing low-level events to high-level UI elements and events, which are well partitioned. Doing so, UISCOPE can generate accurate (i.e., no dependence explosion problem) and visible (i.e., through human understandable UI elements and events) results. Moreover, we do not require instrumentation or heavyweight runtime monitoring so that our technique is applicable in production systems.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Event Collector 1) UI Element and Event Collector:</head><p>We develop a UI element and event collector based on Windows UI Automation <ref type="bibr" target="#b45">[46]</ref>, to efficiently monitor interesting UI events triggered by user interactions. Windows UI Automation is an accessibility library developed by Microsoft. There are similar accessibility libraries on other platforms as well including NSAccessibility for Mac OS X <ref type="bibr" target="#b22">[23]</ref>, ATK and XAutomation for Linux <ref type="bibr" target="#b39">[40]</ref> and so on. Enforced by the federal IT Accessibility Laws and Policies <ref type="bibr" target="#b26">[27]</ref>, mainstream OSes have to develop these libraries to support accessibility features. With these features, disabled people can have more control of the user interface of electronic devices, such as 1) retrieving information about UI elements (e.g., title of a window, name of a button), 2) adjusting UI elements (e.g., customizing a screen's color, zooming in and out on a web page), and 3) getting notification of changes to UI (e.g., website content loaded, a hyperlink clicked). Essentially, Windows UI Automation provides UISCOPE the capability of logging UI events triggered by any changes to UI elements. UI Automation works by subscribing provided UI events, and UISCOPE queries the accessibility services to get the corresponding UI trees when a UI event happens. There are around 100 different UI events, falling into 5 categories, including property change, element action, structure change, global desktop change and notification <ref type="bibr" target="#b46">[47]</ref>. Among all these events, three type of events, namely Focus, Invoke, and SelectionItem_ElementSelected, are used to capture common user interactions. Specifically, • Focus events indicate that the focus of the user shifts from one element to another. For example, either clicking a hyperlink or yielding a new web page would trigger a Focus event. And at a specific time in the system, only one element can gain focus, and only that element can receive user inputs (e.g., via keyboard or mouse). • Invoke events indicate when a UI element is triggered, such as clicking a button. • SelectionItem_ElementSelected events indicate that an item (i.e., a group of elements) or an element is selected, such as an email in the Outlook or a browser tab is selected.</p><p>Besides, each UI event has a uniform format with 170 fields <ref type="bibr" target="#b47">[48]</ref>, out of which, eight fields provide wealthy semantics helpful to understand user interactions:</p><p>• ProcessId represents the process identifier (ID) of a UI element. • EventType specifies the UI event type (e.g., Focus).</p><p>• ControlType specifies the type of the UI element which triggers the event, such as a hyperlink, a document or a tab. Example. Fig. <ref type="figure" target="#fig_1">3</ref> (A) presents an example of our collected UI information of the Outlook email composition page, in which important UI elements are marked in different colored boxes. Fig. <ref type="figure" target="#fig_1">3 (B)</ref> shows the corresponding UI tree, and each node in the tree denotes a UI element. Our UI element and event collector will collect such information at runtime, and the UI can be reconstructed (during analysis) with such information. In Fig. <ref type="figure" target="#fig_1">3</ref> (C), we showcase a UI event of clicking the attachment button. As shown in the figure, we will collect event related information (C-1), process related information (C-2) and also UI element related information (C-3).</p><p>2) System Event Collector: UISCOPE uses OS built-in audit systems for system event collection. These systems are pre-installed on target systems. Without any additional configuration or optimization, they can be used in production runs. They are also of high quality and have technical support from official providers. UISCOPE leverages Event Tracing for Windows (ETW) <ref type="bibr" target="#b14">[15]</ref> to collect system events on Windows. It allows users to collect system-level events (e.g., system calls) with negligible overhead <ref type="bibr" target="#b14">[15]</ref>. ETW has been widely in both academia <ref type="bibr" target="#b28">[29]</ref>, <ref type="bibr" target="#b44">[45]</ref>, <ref type="bibr" target="#b24">[25]</ref>, <ref type="bibr" target="#b23">[24]</ref>, <ref type="bibr" target="#b41">[42]</ref> and industry <ref type="bibr" target="#b15">[16]</ref>. Similar to previous attack investigation tools <ref type="bibr" target="#b28">[29]</ref>, <ref type="bibr" target="#b40">[41]</ref>, UISCOPE only monitors security-relevant events.  Example. Fig. <ref type="figure" target="#fig_2">4</ref> shows an example ETW event entry. The first block (1) includes the basic information of the event such as the timestamp of the event (Timestamp), the event type (EventType) and so on. The second block <ref type="bibr" target="#b1">(2)</ref> shows the process and thread triggering the event and its parent process. The third block (3) lists details of the event. For instance, for a ProcessCreate event, we will have the command of the created process and the environment where the created process was executed. The last block (4) has return values. In this case, it returns the child process PID value.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Event Analyzer Definitions</head><p>The event analyzers analyze the collected UI and system logs to derive dependencies between event entries (to construct the final causal graph). In this section, we first define a number of dependencies and then explain how they are derived. UI Control Dependency. When a UI element change directly affects other UI elements, we say they have UI control dependencies. A UI element can affect another one directly by adding and removing operations. Thus, there are two types of UI Control Dependencies: AddElement (for adding a UI element) and RemoveElement (for removing a UI element. For example, after the user clicks a hyperlink on a web page and a new page is loaded to replace the current one. We will create a RemoveElement edge from the hyperlink element to the root element of the current page and an AddElement edge from the hyperlink element to the root element of the new page. It implies that all elements in this tree will be (directly or transitively) affected. In our paper, we use double solid lines to represent this type of dependency. UI Content Dependency. UI elements are organized in a tree structure. A parent tree node usually represents a larger element such as a web page, and all the child nodes represent sub-elements in this web page. The affiliation relations of UI elements introduce content dependencies. In our paper, we use dashed lines to represent this type of dependency. UI-System Dependency. A UI-system dependency is introduced if the UI element lead to the system event (e.g., creating a new socket for page loading in browsers) or the UI element is affected by the system event (e.g., loading data from a socket to refresh a web page). Such dependencies are critical for attributing low-level system events to execution structures enforced by UI elements (to avoid dependence explosion). In our paper, we use dotted lines to represent this type of dependency.</p><p>System-System Dependency. Previous literature <ref type="bibr" target="#b33">[34]</ref> clearly defined dependencies between system objects (i.e., Files,</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm 1 UI Event Analyzer</head><p>Input: L U -List of UI events in the chronological order Output: Graph -Provenance graph whose vertexes are UI elements and edges UI Control or Content Dependency. Functions: GetU IT ree(U ) -Returns the entire UI tree related to a UI event U F indRootOf AddedElements(Tcur, Tprev), F indRootOf RemovedElements(Tcur, Tprev) -Returns the root element of a set of added or removed UI elements by comparing two UI trees Graph.addV ertex(E) -Add a UI element to the graph if it is not included Graph.addEdge(Esrc, E dst , DependencyT ype) -Add a edge from Esrc to E dst if the edge does not exist and the type of edge is set by DependencyT ype GetChildren(E) -Returns a set of child nodes of UI element E in a tree Variable: T.root -the root element of the UI Tree T U.element -The UI element operated by a UI event U 1: function UIEVENTANALYZER(L U ) 2:</p><p>Ucur ← null 3:</p><formula xml:id="formula_1">Tcur ← null 4: Uprev ← L U [0]</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>5:</head><p>Tprev ← GetU IT ree(Uprev)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>6:</head><p>AddT reeT oGraph(Tprev.root, Graph) 7:</p><formula xml:id="formula_2">for i = 1; i &lt; Size(L U ); i ++ do 8: U = L U [i]</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>9:</head><p>Ucur ← U 10:</p><formula xml:id="formula_3">Tcur ← GetU IT ree(U )</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>11:</head><p>/* Build AddElement UI Control Dependency */</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>12:</head><p>E add ← F indRootOf AddedElements(Tcur, Tprev)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>13:</head><p>AddT reeT oGraph(E add , Graph)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>14:</head><p>Graph.addEdge(Ucur.element, E add , AddElement)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>15:</head><p>Set timestamp of above new added edge as the timestamp of Ucur for each E child ∈ GetChildren(Eroot) do</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>25:</head><p>/* Build UI Content Dependency Recursively */</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>26:</head><p>Graph.addV ertex(Eroot)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>27:</head><p>Graph.addV ertex(E child )</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>28:</head><p>Graph.addEdge(Eroot, E child , U IContentDependency)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>29:</head><p>AddT reeT oGraph(E child , Graph) Sockets) and subjects (i.e., Processes). We adapt the same definition and use the term System-System Dependency to represent this category of dependency in our paper. In our paper, we use solid lines to represent this type of dependency.</p><p>In addition, we use the term initial event to denote system object creation events.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D. UI Event Analyzer</head><p>The UI analyzer is to find UI control dependencies and content dependencies. The detailed analysis procedure is presented in Algorithm 1. For a list of given UI events in the chronological order and also all the related UI elements organized in trees. Our goal is to compute a provenance graph, with UI elements as nodes, connected by UI control dependency and content dependency. After initializing the variables (lines 2 to 6), the algorithm starts to examine individual UI events and related UI Trees in the queue (lines 7 to 21) to build UI Control Dependency based on temporal association. Basically, changes in the UI Tree causally depend on the UI element operated by the previous UI event, based on the fact that there exists only one human user action at a time and that UI changes following it are responding to such action. For each event, after getting the related UI tree (line 10), it finds all the associated UI elements in the newly added or removed tree and updates the graph accordingly (lines 11 to 19). Specifically, it introduces AddElement and RemoveElement types of control dependency to the root element of all added and removed UI elements, respectively. Note that, all added or removed elements only have one root element and we adopt the existing lowest common ancestor algorithm <ref type="bibr" target="#b16">[17]</ref> to find the root element. Lastly, it updates U prev and T prev to the current UI event and the current UI tree respectively (lines 20 to 21). If UI events do not add or remove elements, it simply updates the T prev and U prev without adding new edges to the graph. We use the function AddTreeToGraph(E root , Graph) to add a new tree to the existing graph (lines 24 to 29). In this function, the algorithm recursively traverses the whole UI tree starting from the root element E root , creates UI Content Dependency between parent nodes and child nodes, and adds them all to the graph.</p><p>Example. Fig. <ref type="figure" target="#fig_4">5</ref> presents an example of how Algorithm 1 works on the motivating example where Bob clicked a hyperlink in the phishing email and was attacked by clickjacking. Fig. <ref type="figure" target="#fig_4">5</ref> (I), (II), and (III) are UI events and their corresponding UI trees occurring at timestamp 2, timestamp 3, and timestamp 6, respectively. UI elements with gray background represent the ones operated by users. Fig. <ref type="figure" target="#fig_4">5</ref> (IV) is the generated graph by the event analyzer. At timestamp 2, the web page mail.google.com was loaded and a Focus event was triggered. Because this is the first UI event, UI elements A and B were added to the graph. At timestamp 3, Bob clicked the hyperlink (element B), then the previous web page mail.google.com (elements A and B) was removed from the tree and a new web page well-known.wordpress.com (elements C, D, E, F, G, H) was added. The new page was thus added to the graph, together with a RemoveElement edge from element B to the root element of the removed page (element A) and an AddElement edge from element B to the root element of the new page (element C). Note the timestamp of the edges is 3. At timestamp 6, Bob was tricked to click the Transfer button (element H) masqueraded as a Get iPad button (element E). The embedded web page www.bank.com (elements F, G, and H) was removed, thus a RemoveElement pointing from element H to the root element of the removed page (element F) was added with timestamp 6.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>E. System Event Analyzer</head><p>We follow the standard causality analysis method used in previous literature <ref type="bibr" target="#b36">[37]</ref>, <ref type="bibr" target="#b43">[44]</ref>, <ref type="bibr" target="#b44">[45]</ref>, which returns a causal graph with system subjects or objects as nodes and System-System Dependencies as edges.</p><p>F. Correlation Analyzer 1) UI-System Dependency: UI events and system events capture behaviors of the same attack from two different levels: foreground with visibility and background with fine-grained information. After acquiring the UI causal graph from the UI event analyzer and the low-level event causal graph from the system event analyzer, we analyze the correlations of the two so that low-level system events can be attributed to individual UI elements (instead of the whole process) which makes the graph both visible and accurate (more accurate than using a single node to represent the whole graph like in traditional graphs, which leads to dependency explosion).</p><p>We devise a timestamp-based attribution approach based on two observations: 1) an application has only one currently focused UI tree at a certain time; 2) system events and UI events are typically triggered by the same attack behavior at the same time. That is, the two categories of events are mostly time-aligned. There are also many background events and we will discuss them in III-F2.</p><p>System events and UI events are correlated based on two mechanisms. Firstly, for a system object that is associated with a sequence of system events such as a socket with many socket read/write events, we use the creation of system object to correlate with UI events. This is known as the initial event based correlation. Secondly, we mainly use a timestamp based alignment to correlate general system events and UI elements/events, and this is referred as the timestamp based correlation. Basically, system events occurring between two UI events chronologically would be attributed to the former UI event (or UI elements added by the UI event). The details of the attribution process is presented in Algorithm 2. After initializing variables (line 2), the algorithm generates two graphs using the UI Event Analyzer and the System Event Analyzer, respectively, and add them to the result graph (lines 3 to 6). Then it starts to examine individual processes occurring in the graph (lines 7 to 15). For each process, it first checks whether the process has GUI. If so, it extracts two sub-lists of events related to the process and attributes system objects or subjects to UI elements by invoking the function Attribute (lines 10 to 12).</p><p>The function Attribute() first orders all system and UI events chronologically in list L U (line 18). For each event</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm 2 Correlation Analyzer</head><p>Input: L S -A list of system events in the chronological order L U -A list of UI events in the chronological order Output: Graph -A complete provenance graph combining both UI and system events. Variable: Eactive -The current active UI element Minit -A key-value map of initialized objects and active UI elements U.element -The UI element operated by a UI event U S.sink, S.source -The system object pointed to or from by a system event S Function: GetP rocessV ertexes(Graph) -Return all vertexes of processes ExtractEventsByP rocess(L, process) -Extract events related to a specific process from a list of events L. AddGraphT oGraph(G f rom , Gto) -add the vertexes and edges in G f rom to Gto if those vertexes and edges do not exist in the Gto ReorderInChronologicalOrder(Listone, Listtwo) -merge two lists into a list in the chronological order F indRootOf AddedElements(E, Graph) -check whether there is AddElement dependency pointing from the element E, if yes, return the sink element of the dependency, otherwise return null.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>1: function</head><formula xml:id="formula_4">CORRELATE(L S , L U ) 2:</formula><p>Graph ← a new empty graph 3:</p><formula xml:id="formula_5">Gsystem ← SystemEventAnalyzer(L S )</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>4:</head><p>Gui ← U IEventAnalyzer(L U )</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>5:</head><p>AddGraphT oGraph(Gsystem, Graph)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>6:</head><p>AddGraphT oGraph(Gui, Graph)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>7:</head><p>for each process ∈ GetP rocessV ertexes(Gsystem) do</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>8:</head><p>if HasGU I(process) then</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>9:</head><p>/* For GUI applications*/</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>10:</head><p>SubLsystem ← ExtractEventsByP rocess(L S , process)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>11:</head><p>SubLui ← ExtractEventsByP rocess(L U , process)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>12:</head><p>Attribute(process, SubLsystem, SubLui, Graph) </p><formula xml:id="formula_6">for i = 0; i &lt; Size(Levent); i ++ do 20: event ← Levent[i]</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>21:</head><p>if IsU IEvent(event) then</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>22:</head><p>U ← event</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>23:</head><p>E add ← F indRootOf AddedElements(U.element, Graph)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>24:</head><p>if E add = null then</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>25:</head><p>/* Activate the root of the new added elements */</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>26:</head><p>Eactive ← E add 27: </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>29:</head><p>Eactive ← U.element</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>30:</head><p>else if IsSystemEvent(event) then</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>31:</head><p>S ← event</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>32:</head><p>if IsInitialEvent(S) then</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>33:</head><p>/* Timestamp-based approach */</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>34:</head><p>Minit.put(S.sink, Eactive)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>35:</head><p>Graph.addEdge(Eactive, S.sink, U ISystemDependency) in the list, it first checks the event type. If it is a UI event, it checks whether the UI event causes new elements in the UI tree. If so, it marks the root element of newly added UI elements as the current active element (lines 24 to 26). Otherwise, it marks the element operated by the current UI event as the active one (lines 27 to 29). Basically, system events occurring between two active elements chronologically will be attributed to the former element. If the event is a system event, it first tests whether the event is an initial event (line 32). If so, it records the relationship between the initialized resource and the current active element in the map M init (line 34). Then it adds a new UI-System Dependency edge pointing from the active element to the sink (line 35). Otherwise, it retrieves the UI element related to the operated resource from previous records in M init and conducts the same operations as before (lines 38 to 42). Note that the direction of the newly created edge is the same as the one of the system events. For instance, the FileRead event creates an edge pointing from a file object to a UI element while the FileWrite event creates an edge pointing from a UI element to a file object. The essence of lines 38 to 42 is as follows. We observe that the usage of a system object (e.g., socket read) may not be in the same time window of a UI event, rendering the timestamp-based alignment (lines 33-35) ineffective, while its initialization (e.g., socket creation) can be correctly aligned with the trigger of the UI event (e.g., button clicking) in most cases. Thus, for a (background) system event related to some system object, we trace back to the time when the system object was initialized and attribute the event to the active UI element at that moment.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>36:</head><p>2) Background Activities: One may question if our technique (based on timestamps and system object initialization) provides a sound solution for background activities. In the following, we discuss the possible background behaviors of popular applications and argue that our technique is highly effective in practice, which is also demonstrated by our experiment in Section IV-B. GUI programs are mostly driven by keyboard and mouse inputs. The execution trace of such a program is dominated by event processing loops and the system events that are directly or indirectly triggered by the loop body. UISCOPE captures keyboard and mouse inputs by monitoring UI events, and then uses timestamp-based correlation and initial event-based correlation to attribute system events to UI events. We classify GUI applications into two categories: static and dynamic based on if there are activities triggered in the background. For static applications(i.e., no background activity), UI events and corresponding system events are triggered synchronously and UISCOPE works well. For example, there are no background activities in Notepad PlusPlus when there are no user inputs. For dynamic applications (i.e., with background activities), using time-based correlation is not enough. For example, Chrome can download videos or other files in the background while the user is browsing in the foreground. Browser is the most common and complex dynamic application type. In the following, we will use browsers as an example to demonstrate how UISCOPE handles background activities.</p><p>The accuracy of UISCOPE for browsers is affected by 1) the types of visited websites, 2) the duration of web sessions, 3) the number of websites with background activities. We use Chrome to monitor the behaviors of 500 popular websites in an hour after being loaded. Those websites are selected from Alexa top websites <ref type="bibr" target="#b0">[1]</ref>. Foreground activities will trigger new UI events that will be captured by our system, and UISCOPE has high attribution accuracy. Thus, we focused on monitoring website behaviors that are left in the background without user interactions. Specifically, the GUI automation tool <ref type="bibr" target="#b3">[4]</ref> first triggers typical behaviors of a website (e.g., playing video on www.youtube.com) to simulate initial user activities when the website was visited. Then it does not interact with the website anymore to simulate the scenario in which the website has been put in the background. Furthermore, we only consider network events because network events in the background are much more complex and diverse than file events. For instance, the cache and cookie of all websites loaded by Chrome are stored in several deterministic files or folders (e.g., an SQLite database for cookies). Furthermore, our preliminary results on 20 minutes running of 20 background web pages show that 84% of total file events are related to 10 files, several of which are the aforementioned cache and cookie files. It indicates that file access in Chrome is simple and typical. Finally, 436 websites were successfully monitored and used in this experiment are listed in Table <ref type="table" target="#tab_11">VI</ref>. After analyzing the data, we make a few important observations.</p><p>Observation 1: Most new website activities are narrowed in a short period of time and activities in the background are not common. We monitor website activities every 10 seconds as a unit and count the total number of units the website initializes at least one new socket. The result is shown in Fig. <ref type="figure">6</ref>. The Y-axis in the graph represents the number of websites and the X-axis represent the number of active units. For example, the first bar denotes that 173 websites are active in only one unit (10 seconds). From the graph, we know that 71.11% of the 436 websites finish all the work within 1 minute and 89.44% of websites are idle for at least 55 minutes during the whole time (1 hour).</p><p>Observation 2: Most socket sessions are initialized during web page loading. Fig. <ref type="figure" target="#fig_9">7</ref> shows the average number of initialized socket sessions within 60 seconds after a website is visited. For such sockets, we observe that around 87.13% of all socket sessions are initialized within 10 seconds and 94.11% socket sessions are initialized within 20 second. Together with the analysis results in observation 1, it verifies the usefulness of our timestamp-based event attribution approach (Section III-F).  Observation 3: Background activities are usually repeated behaviors. We analyzed the socket connection destinations of all sockets, including both existing sockets and new sockets, and the results are shown in Fig. <ref type="figure" target="#fig_10">8</ref>. Blue bars are the number of both types of sockets and red bars are the number of newly created sockets. The X-axis is time, and one hour period is divided to 360 units. As we can see, there are not many new sockets after the pages are loaded, which implies that websites in the background connect to a limited set of domain names repeatedly. To further verify our finding, we manually check with source code of some of these sites. Fig. <ref type="figure" target="#fig_11">9</ref> shows 4 websites that have the maximum number of background activities. The Y-axis represents the top 10 frequent top-level domain names and X-axis shows the number of socket sessions that are related to a certain domain name. As we can see, most socket connections are related to a limited number of top-level domain names, indicating that background behaviors are largely repeated connections. This allows UISCOPE to use pattern based filters to remove such background activities.</p><p>Adaptive Adversary. In an adaptive attack scenario in which the attacker is aware of the presence of UISCOPE, the attacker may intentionally use delayed background activities that do not have the resources initialized when the UI event occurs (e.g., using a timer to postpone the creation of a socket to download a payload). Such attacks may lead to incorrect attribution of low-level events to UI operations. But we argue that 1) this is a common unsolved challenge for all existing attack investigation systems (e.g., <ref type="bibr" target="#b33">[34]</ref>, <ref type="bibr" target="#b34">[35]</ref>, <ref type="bibr" target="#b40">[41]</ref>). 2) Practically, it is very difficult to perform such attacks, and many popular attack vectors cannot be delayed. For example, about 71% attacks use phishing emails for initial compromise <ref type="bibr" target="#b6">[7]</ref>, and the adversary is not able to do delay actions in this scenario.</p><p>Example. Fig. <ref type="figure" target="#fig_12">10</ref> presents an example of how Algorithm 2 works on the motivating example. Fig. <ref type="figure" target="#fig_12">10 (I</ref>) and (II) show the graphs generated by the UI Event Analyzer and the System Event Analyzer. Fig. <ref type="figure" target="#fig_12">10</ref> (III) shows the final output graph. We use the logic time in this case to denote the order of all the events. Elements B and H were clicked at timestamps 3 and 6 respectively, which lead to two sockets being initialized at timestamps 4 and 7. According to the algorithm, the root (element C) of newly added elements and the operated element (element H) were marked as active at timestamps 3 and 6, respectively. Thus, the socket events are attributed to elements C and H, respectively. System events occurring at timestamps 5 and 9 are non-initial events and we attribute them to elements C and H through the tracing-back to initial system object method. The red dotted line in Fig. <ref type="figure" target="#fig_12">10</ref> represents UI-System Dependency defined in Section III-C. Note that benign.com:80 was initialized before those two UI events for downloading the software WinSCP.exe, thus it was attributed to previous UI elements. Furthermore, the noninitial system event related to benign.com:80 occurring at time 8 was attributed to the previous element to which the socket creation belongs to. Observe that by separating a process to different autonomous UI trees and attributing lowlevel system events to these trees, our technique achieves the effect of partitioning a long-running execution to autonomous units, which is the key to avoiding dependence explosion.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IV. EVALUATION</head><p>We evaluate UISCOPE by answering following questions.   • Q2: How accurately can UISCOPE cohere UI elements and System objects/subjects? (Section IV-B) • Q3: How effective is UISCOPE in conducting real-world attack investigation and how does it compare to the stateof-the-art? (Section IV-C) Experiment Setup. We deploy UISCOPE on 7 Windows computers and run experiments for a week to collect UI events and system events triggered. Note that we do not require those 7 users to perform any specific actions, and our purpose is to collect event traces generated by their daily usage. In addition, we simulate six real-world attacks listed in Table <ref type="table" target="#tab_11">V</ref> to evaluate the effectiveness of UISCOPE in attack investigation. A. Performance Overhead UISCOPE includes two event logging tools, the UI collector and the system event collector, for trace collection on end hosts. System event traces are deemed to be the major data source for most existing attack investigation systems. UISCOPE uses the Windows built-in audit system ETW as its system event collector. ETW has been evaluated to be quite lightweight, only imposing 0.4% ∼ 2.5% runtime overhead <ref type="bibr" target="#b41">[42]</ref>. The space overhead caused by ETW mainly depends on what event types ETW is configured to capture. We use ETW to monitor the same system event types (i.e., only the security-relevant types) as existing works <ref type="bibr" target="#b37">[38]</ref>, <ref type="bibr" target="#b56">[57]</ref>, <ref type="bibr" target="#b49">[50]</ref>, <ref type="bibr" target="#b27">[28]</ref>, <ref type="bibr" target="#b30">[31]</ref>, and thus the space overhead by ETW in UISCOPE is around 210 MB per week after deploying their system, which is reasonable. Therefore, we focus on evaluating the run-time overhead and space overhead introduced by the UI collector. 1) Runtime overhead: We evaluate the runtime overhead of UI collector in UISCOPE for 14 different GUI applications. Firstly, we collect a lot of application traces from real-world scenarios. Then, we automate these workloads in two different environments, i.e., with and without UISCOPE collecting UI events and trees. Table <ref type="table" target="#tab_5">I</ref>   the average running time of running on native environment, column 3 represents the average running time of the same user interaction with UI collector, and the column 4 is the runtime overhead. The table shows that the UI collector introduces negligible (less than 1%) runtime overhead for almost all applications. UI collector introduces 19.03% overhead for FileZilla. The reason is that the GUI of FileZilla has its own customized UI Automation APIs <ref type="bibr" target="#b12">[13]</ref>, which issues larger overhead.</p><p>2) Space overhead: Table <ref type="table" target="#tab_7">II</ref> presents the details about the collected UI event logs on each host. For each user machine, Table II lists the hardware configuration (i.e., CPU and RAM), Windows OS installed, duration of running the event collectors, number of UI events triggered by daily user behavior, and storage space for the UI events. Note that the users are free to enable or disable UISCOPE, so the duration of event logging varies from user to user.</p><p>In summary, being deployed on 7 user machines for a week (with a total active duration of 463.4 hours), UISCOPE collected 1416.62 MB UI log including 473,029 UI events and the corresponding UI trees. On average, the UI collector component on one machine generates 3.05 MB event logs per hour. Hence, the space overhead is negligible, compared to system logging.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Accuracy of Events Correlation 1) Static Applications:</head><p>To evaluate the accuracy of event correlation, it is necessary to obtain the ground truth. We did the following experiments with 12 popular applications, including editor software (Notepad PlusPlus, Sublime Text, and Notepad), communication software (Outlook and Skype), file transfer software (WinSCP and FileZilla), PDF Reader (Adobe Reader and Foxit Reader), and miscellaneous software (Explorer, Snipping Tool, and Paint). These static applications introduce no or negligible background activities (e.g., checking new versions after opening the software).</p><p>For each application, we use a UI automation tool <ref type="bibr" target="#b53">[54]</ref> to trigger a typical application specific behavior and collect system events, e.g., file opening and saving for Notepad PlusPlus. We repeat this process three times in isolated environments and extract a common set of system events from these three runs. The pairings of the used UI events and the corresponding common set of system events are considered our ground truth of one behavior.</p><p>For each application, we performed its specific behavior 10 times with different settings (e.g., opening 10 different files), and obtain the ground truth for the 10 instances. Next, for each application, we trigger all the 10 behavior instances, collect the generated system events, and use UISCOPE to perform We can see that on average 97.41% system events can be attributed to the correct UI events only based on timestamps, which is consistent with our observation in Section III-F2. 2) Dynamic Application: We evaluate UISCOPE on Chrome which is the most complex dynamic application. As mentioned in Section III-F2, the accuracy of UISCOPE for browsers is affected by 1) the types of visited websites, 2) the duration of web sessions, 3) the number of websites with background activities. We evaluated UISCOPE on Chrome over these three variables and summarized the results in Table <ref type="table" target="#tab_9">IV</ref>. To calculate the TPR and FPR, we use the same method in Section III-F2 to obtain the ground truth for 463 websites listed in Table <ref type="table" target="#tab_11">VI</ref>.</p><p>In this experiment, we randomly select a given number of websites (NumberOfWebsites, column 1) from 463 website and load them one by one. The interval of loading two different web pages is a constant number (StayTime, column 2). Then we apply UISCOPE to the collected trace and calculate the TPR and FPR by comparing with the collected ground truth data. To evaluate the significance of our two approaches (timestampbased and initial-event based), we apply the timestamp based approach (columns 3 to 5) and the timestamp plus initialization based method (columns 6 to 8). Besides FPR and TPR, we calculate the average number of unique domains involved in the false positives of each tested website (columns 5 and 8). In order to cover more types of websites, we repeat the above process 1000 times and calculate average TPR and FPR for each setting, and Table <ref type="table" target="#tab_9">IV</ref> shows the average value for each setting in each row.</p><p>From the table, we can see that 1) timestamp based approach could correctly attribute most events and initial-event based approach could further increase the TPR and decrease the FPR, which conforms to the observation 2 mentioned in Section III-F2. That is, most socket sessions are initialized during web page loading. 2) increasing NumberOfWebsites decreases the accuracy because with more background websites, the more false dependencies would be introduced to the foreground website.  Although UISCOPE cannot handle newly created socket in the background, the number of unique domains of false positives per website is relatively small (2.23 ∼ 4.98). We further explore those false positives of each website and find that they are related to many common domains, which conforms to the observation 3 mentioned in section III-F2. Fig. <ref type="figure" target="#fig_13">11</ref> shows the top 10 common attributed domains by background communication. Y-axis represents domains and X-axis represents the frequency of wrong attribution. From the figure, we can see that these domains are related to advertisement (moatads.com, rubiconproject.com, pubmatic.com, adnxs.com, adsafeprotected.com, and doubleclick.net), Google services (gstatic.com, google.com) and social media (facebook.com and yahoo.com). For those frequent domains, we can remove them to further reduce the FPR. Furthermore, we evaluate Edge and the results show that Edge has similar accuracy to Chrome. Specifically, our system achieves 94.8% TPR and 0.51% FPR when NumberOfWebsites is 10 and StayTime is 20, and 92.7% TPR and 0.25% FPR when NumberOfWebsites is 30 and StayTime is 20.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>0%</head><p>Lastly, we want to point out that UISCOPE correlates events to prune unnecessarily large investigation graphs. Thus in this context, FP cases mean that a portion of the graph cannot be pruned by UISCOPE .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Attack Investigation</head><p>We demonstrate the effectiveness of UISCOPE in attack provenance tracking by applying it to 6 real-world attacks, including Phishing email <ref type="bibr" target="#b19">[20]</ref>, Remote Code Execution <ref type="bibr" target="#b54">[55]</ref>, MS Office Macro Attack <ref type="bibr" target="#b55">[56]</ref>, Credential-based Attack <ref type="bibr" target="#b21">[22]</ref>, Watering Hole Attack <ref type="bibr" target="#b17">[18]</ref>, and Insider Attack <ref type="bibr" target="#b20">[21]</ref>. In the following, we will use the Remote Code Execution attack to 1) Case Study: Remote Code Execution: Remote Code Execution (RCE) is a vulnerability that can provide an attacker with the ability to execute malicious code and take complete control of an affected host, no matter where the host is geographically located.</p><p>Scenario. In this attack, UISCOPE and a threat detector have been installed and enabled on a user's machine. The user accidentally navigates to a malicious Flappy Bird game website with the browser Edge by clicking on a hyperlink returned from Google Search. The website asks the user to press the 'enter' key to control the bird. The website leverages CVE-2018-8495 <ref type="bibr" target="#b54">[55]</ref> to perform an attack. Once the enter key is held, the website will invoke a pop-up window asking if the user wants to start, and as soon as the enter key is released, a malicious PowerShell script gets executed on the victim's machine. While the user is thinking he is playing the game by using the enter key, he actually has been tricked to execute malicious code on his own machine.</p><p>Threat alert. Soon, the threat detector installed detects malicious PowerShell script running and thus raises an alert.</p><p>Investigation. An incident investigator starts investigation with our tool. With the given threat alert and the audit logs (UI events and system events) collected, UISCOPE could efficiently yield a semantics-rich human-comprehensible causal graph shown in Fig. <ref type="figure" target="#fig_0">12</ref>. By provenance tracking in the graph, the investigator can quickly find that the malicious PowerShell script was from the website <ref type="url" target="http://FakeWebsite.com">http://FakeWebsite.com</ref>, which was opened by clicking a link return by google.com (element B). The investigator then examines the FakeWebsite and finds that a suspicious hyperlink (element D) contains suspicious keywords (i.e., PowerShell and vbs) in its URL string. Close scrutiny of the suspicious hyperlink would reveal that the hyperlink exploits an Edge vulnerability CVE-2018-8495 <ref type="bibr" target="#b54">[55]</ref> to execute a vulnerable benign VBS program xxx.vbs which further allows the attacker to execute any PowerShell code remotely to have full control over the victim's machine. However, the vulnerability would open a pop-up window to explicitly ask for user's consent. No user would be fooled into clicking 'OK' and run the program. Then the investigator looks into other behaviors of FakeWebsite and finds that after the website was loaded, a pop-up window (element F) with the text "How do you want to open it" showed up, and an OK button (element H) in the window was focused by default. And the website asks the user to press the enter key to control the game character (element E), which causes the OK button to be pressed. This explains how the attacker acquired the permission. This case demonstrates that UISCOPE can not only assist identifying the attack provenance but also provide fine-grained human-comprehensible contextual semantics to users. Comparatively, Fig. <ref type="figure" target="#fig_1">13</ref> shows the graph generated by NoDoze. Although NoDoze contains the malicious socket fakewebsite.com:443 in the graph because fakewebsite.com was rarely visited, it misses the google.com which is frequently visited and it cannot provide context information to understand the attack or prevent similar attacks from happening again.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>V. DISCUSSION</head><p>Accuracy. UIScope works well for static GUI applications (with almost 100% accuracy) in which UI events and corresponding system events are triggered synchronously; and UIScope obtains around 90% accuracy for dynamic GUI applications (e.g., Chrome) in which system events are triggered asynchronously. If the initialization of system events and UI events do not appear close together in time, our system could result in wrong attributions. For instance, the advertisement JS code embedded in websites could use setTimeout API to update pictures after a certain time in the background. To attribute such system events accurately, existing solutions <ref type="bibr" target="#b38">[39]</ref> instrument applications to track fine-grained events while UIScope introduces around 10% wrong attributions as a trade-off to avoid instrumentation. We believe UIScope is practical in real-world scenarios for a few reasons reasons: 1) more than 71% attacks use phishing emails for initial compromise <ref type="bibr" target="#b6">[7]</ref> and the system events and UI events are typically triggered very closely in time in these scenarios; 2) UISCOPE essentially performs graph pruning, and FP cases mean that UISCOPE is not able to remove some nodes in the graph, which does not cause fatal problems in invetigation. UISCOPE filters out over 99% false positives and makes attack investigation quite effective, compared with traditional non-intrusive work <ref type="bibr" target="#b33">[34]</ref>; 3) UIScope is orthogonal to other existing instrumentation-free techniques. We could leverage probabilistic solutions <ref type="bibr" target="#b28">[29]</ref> to complement UIScopes results.</p><p>Privacy. Information collected by UISCOPE may raise potential privacy issues. We argue that 1) UISCOPE targets an enterprise environment in which employers have the right to monitor the computers owned by them in United States according to the law <ref type="bibr" target="#b5">[6]</ref>; 2) Sensitive information such as passwords cannot be retrieved due to security policy encoded in the Accessibility framework; 3) There exists a lot of work (e.g., data masking) that can be used for protecting sensitive information, which can be adopted to protect users' privacy.  Technical feasibility of UI event logging. The federal law <ref type="bibr" target="#b26">[27]</ref> requires all applications used by U.S. Federal agencies to support accessibility, and most popular applications and OSes support such UI event logging. Considering one in four US adults living with a disability <ref type="bibr" target="#b2">[3]</ref>, accessibility support is an inevitable trend. For applications not built with the underlying system GUI APIs, Windows has provided an interface <ref type="bibr" target="#b12">[13]</ref> to help them support accessibility on the Windows platform. Popular third-party GUI applications/frameworks (e.g., Qt and Chrome) have leveraged this interface to support accessibility.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VI. RELATED WORKS</head><p>Along with the previous works discussed in Section II-B, there exist other studies that are related to UISCOPE.</p><p>Attack Investigation. For Web-based attacks, JSgraph <ref type="bibr" target="#b38">[39]</ref> is able to track and reconstruct fine-grained details about the JS code. For our motivation example, JSgraph could provide details about how the website tests if a user has logged into any well-known bank website, how it creates a transparent frame, and which JS file performs the attack, which cannot be captured by UIScope. However, JSgraph only works for Chrome and needs expensive user efforts to instrument source code while UIScope is a generic and instrumentation-free solution. For non-instrumentation techniques, HOLMES <ref type="bibr" target="#b48">[49]</ref> focuses on detecting APT attacks and providing high-level APT stages (e.g., initial compromise, foothold establishment, and privilege escalation) that summarize the attackers action specific to the APT life cycle, while UIScope is a generic solution which attributes system events to UI elements to provide high-level context information. NoDoze <ref type="bibr" target="#b28">[29]</ref> and PrioTracker <ref type="bibr" target="#b40">[41]</ref> leverage statistical analysis to guide causal dependency graph pruning to address the inaccuracy in causality analysis. However, those techniques would not work on UI events because there would not be a way to differentiate anomalous from non-anomalous UI events. Furthermore, all those works only rely on system events which cannot provide visible contextual information like UISCOPE.</p><p>Log Reduction. There exists a line of work <ref type="bibr" target="#b37">[38]</ref>, <ref type="bibr" target="#b56">[57]</ref>, <ref type="bibr" target="#b49">[50]</ref>, <ref type="bibr" target="#b27">[28]</ref>, <ref type="bibr" target="#b30">[31]</ref>, <ref type="bibr" target="#b42">[43]</ref> focusing on reducing the log size of system events while preserving the dependency for provenance tracking. UISCOPE collects the same types of system events as those works and our system only reply on must-have fields of system events (e.g., timestamp), thus UISCOPE is orthogonal to these approaches and can incorporate those them to reduce the storage of system events.</p><p>Other Digital Forensic Tools. Many other digital forensic tools focus on analyzing digital artifacts (e.g., memory <ref type="bibr" target="#b13">[14]</ref> and disk <ref type="bibr" target="#b11">[12]</ref>) left in computers after an attack happened. Then security analysts manually analyze and identify causalityrelated events (e.g., timeline analysis <ref type="bibr" target="#b18">[19]</ref>, <ref type="bibr" target="#b25">[26]</ref>). Comparatively, UISCOPE starts to monitor the system before attacks and automatically correlate system and UI events to construct a dependency graph for provenance tracking. Some forensic tools could extract high-level semantics by analyzing application-specific logs, e.g., email forensic tools. However, those tools highly rely on the format of application logs. If logs are stored with an unknown format, those tools cannot works. Comparatively, UISCOPE supports capture high-level semantics of all GUI applications by monitoring UI events.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VII. CONCLUSION</head><p>We develop UISCOPE, an accurate and instrumentationfree attack investigation system with high visibility. UISCOPE highlights the critical role of user interaction with the system through GUI in partitioning system operations and tracing the provenance of attack. By leveraging user-space user interaction logs to complement kernel-level system events with humanperceivable contextual semantics, UISCOPE is able to provide accurate and visible investigation results, even to ordinary users who are not tech-savvy. UISCOPE is lightweight and efficient, incurring negligible performance overhead. UISCOPE is applicable in production environments, requiring no end system change or instrumentation. Our evaluation shows that UISCOPE can efficiently and precisely identify the provenance of real-world attacks.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>MissedFig. 1 .</head><label>1</label><figDesc>Fig. 1. Comparison between existing causality analysis solutions and our UISCOPE on the motivating example.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>•Fig. 3 .</head><label>3</label><figDesc>Fig. 3.Example of our collected UI information of the Outlook email composition page. (A) is the Outlook GUI which was seen by users, and (B) is the corresponding UI tree. (C) is a UI event raised by clicking the email attachment button highlighted in green in (A) and (B).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 4 .</head><label>4</label><figDesc>Fig. 4. Example of an ETW event.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>16:/* Build RemoveElement UI Control Dependency */17:Eremove ← F indRootOf RemovedElements(Tcur, Tprev)18:Graph.addEdge(Ucur.element, Eremove, RemoveElement)19:Set timestamp of above new added edge as the timestamp of Ucur20:Uprev ← Ucur21:Tprev ← Tcur 22: 23: function ADDTREETOGRAPH(Eroot, Graph) 24:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>FFig. 5 .</head><label>5</label><figDesc>Fig. 5. A log example of UI Event Analyzer.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>the operated element if no new element occurs */</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>else 37 : 42 :</head><label>3742</label><figDesc>/* Initial event-based approach */38:Einit ← Minit.get(S.object)39:if S.source = proc then 40:Graph.addEdge(Einit, S.sink, U ISystemDependency) Graph.addEdge(S.source, Einit, U ISystemDependency)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>0 10 20 Fig. 6 .</head><label>206</label><figDesc>Fig.6. The number of active time units is small for most websites.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Fig. 7 .</head><label>7</label><figDesc>Fig. 7. The number of initialized socket sessions within the first 60 second.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>•Fig. 8 .</head><label>8</label><figDesc>Fig. 8. The number of initialized socket for each time slice starting from 1 minute to 1 hour.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Fig. 9 .</head><label>9</label><figDesc>Fig. 9. Long-term active website examples.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Fig. 10 .</head><label>10</label><figDesc>Fig. 10. A log example of correlation analyzer.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Fig. 11 .</head><label>11</label><figDesc>Fig. 11. Frequency of domains occurring in the false positives.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head></head><label></label><figDesc>Hyperlink Text: wshfile:test/../../xxx.vbs" ; powershell -xxx" Use the enter key to control the flappy bird.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>Fig. 12 .Fig. 13 .</head><label>1213</label><figDesc>Fig. 12. Causality Graph generated by UISCOPE for the RCE scenario.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>TABLE I</head><label>I</label><figDesc></figDesc><table><row><cell>.</cell><cell cols="4">THE RUNTIME OVERHEAD OF THE UI COLLECTOR</cell></row><row><cell>App</cell><cell></cell><cell cols="3">Native (ms) UI Collector (ms) Overhead</cell></row><row><cell>Notepad</cell><cell></cell><cell>22882</cell><cell>22909</cell><cell>0.12%</cell></row><row><cell cols="2">Notepad PlusPlus</cell><cell>21458</cell><cell>21502</cell><cell>0.20%</cell></row><row><cell>Sublime Text</cell><cell></cell><cell>30386</cell><cell>30415</cell><cell>0.10%</cell></row><row><cell>Explorer</cell><cell></cell><cell>31090</cell><cell>31174</cell><cell>0.27%</cell></row><row><cell>Paint</cell><cell></cell><cell>28551</cell><cell>28713</cell><cell>0.57%</cell></row><row><cell>Snipping Tool</cell><cell></cell><cell>13785</cell><cell>13791</cell><cell>0.05%</cell></row><row><cell>Chrome</cell><cell></cell><cell>48511</cell><cell>48836</cell><cell>0.67%</cell></row><row><cell>Edge</cell><cell></cell><cell>50832</cell><cell>51184</cell><cell>0.69%</cell></row><row><cell>WinScp</cell><cell></cell><cell>32080</cell><cell>32186</cell><cell>0.33%</cell></row><row><cell>FileZilla</cell><cell></cell><cell>34511</cell><cell>41079</cell><cell>19.03%</cell></row><row><cell>Outlook</cell><cell></cell><cell>33138</cell><cell>33404</cell><cell>0.80%</cell></row><row><cell>Skype</cell><cell></cell><cell>29085</cell><cell>29336</cell><cell>0.86%</cell></row><row><cell>Adobe Reader</cell><cell></cell><cell>35356</cell><cell>35581</cell><cell>0.63%</cell></row><row><cell>Foxit Reader</cell><cell></cell><cell>36744</cell><cell>37057</cell><cell>0.85%</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head>TABLE II .</head><label>II</label><figDesc></figDesc><table><row><cell></cell><cell></cell><cell cols="4">SPACE OVERHEAD EVALUATION RESULTS</cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell>S-0</cell><cell>S-1</cell><cell>S-2</cell><cell>S-3</cell><cell>S-4</cell><cell>S-5</cell><cell>S-6</cell><cell>Total</cell></row><row><cell>CPU</cell><cell cols="6">I5-9400 I7-6500U I7-8700 I7-8700 I7-7500U I7-8550U</cell><cell>I5-7400</cell><cell>N/A</cell></row><row><cell>RAM (GB)</cell><cell>8</cell><cell>8</cell><cell>16</cell><cell>16</cell><cell>16</cell><cell>16</cell><cell>8</cell><cell>N/A</cell></row><row><cell>Windows Version</cell><cell>7</cell><cell>10</cell><cell>10</cell><cell>10</cell><cell>10</cell><cell>10</cell><cell>10</cell><cell>N/A</cell></row><row><cell>Duration (hours)</cell><cell>16.7</cell><cell>108.7</cell><cell>95.4</cell><cell>54.6</cell><cell>37.4</cell><cell>28.7</cell><cell>121.9</cell><cell>463.4</cell></row><row><cell># of UI Events/Trees</cell><cell>1,131</cell><cell>32,824</cell><cell>18,687</cell><cell>34,010</cell><cell>22,766</cell><cell cols="3">8,704 354,907 473,029</cell></row><row><cell>Size (MB)</cell><cell>14.84</cell><cell>251.44</cell><cell>55.18</cell><cell>179.86</cell><cell>81.16</cell><cell>23.78</cell><cell cols="2">753.35 1416.62</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8"><head>TABLE III .</head><label>III</label><figDesc>ATTRIBUTION ACCURACY OF STATIC APPLICATIONS</figDesc><table><row><cell>App</cell><cell>Operation</cell><cell cols="2">Timestamp</cell><cell cols="2">Timestamp + Initial Event</cell></row><row><cell></cell><cell></cell><cell>TPR</cell><cell>FPR</cell><cell>TPR</cell><cell>FPR</cell></row><row><cell></cell><cell>Open</cell><cell>100</cell><cell>0</cell><cell>100</cell><cell>0</cell></row><row><cell>Notepad</cell><cell>Save</cell><cell>100</cell><cell>0</cell><cell>100</cell><cell>0</cell></row><row><cell></cell><cell>Save as</cell><cell>100</cell><cell>0</cell><cell>100</cell><cell>0</cell></row><row><cell></cell><cell>Open</cell><cell>100</cell><cell>0</cell><cell>100</cell><cell>0</cell></row><row><cell>Notepad PlusPlus</cell><cell>Save</cell><cell>100</cell><cell>0</cell><cell>100</cell><cell>0</cell></row><row><cell></cell><cell>Save as</cell><cell>100</cell><cell>0</cell><cell>100</cell><cell>0</cell></row><row><cell></cell><cell>Open</cell><cell>100</cell><cell>0</cell><cell>100</cell><cell>0</cell></row><row><cell>Sublime Text</cell><cell>Save</cell><cell>100</cell><cell>0</cell><cell>100</cell><cell>0</cell></row><row><cell></cell><cell>Save as</cell><cell>100</cell><cell>0</cell><cell>100</cell><cell>0</cell></row><row><cell></cell><cell>Delete File</cell><cell>100</cell><cell>0</cell><cell>100</cell><cell>0</cell></row><row><cell>Explorer</cell><cell>Rename</cell><cell>100</cell><cell>0</cell><cell>100</cell><cell>0</cell></row><row><cell></cell><cell>Copy Paste</cell><cell>100</cell><cell>0</cell><cell>100</cell><cell>0</cell></row><row><cell></cell><cell>Open</cell><cell>100</cell><cell>0</cell><cell>100</cell><cell>0</cell></row><row><cell>Paint</cell><cell>Save</cell><cell>100</cell><cell>0</cell><cell>100</cell><cell>0</cell></row><row><cell></cell><cell>Save as</cell><cell>100</cell><cell>0</cell><cell>100</cell><cell>0</cell></row><row><cell></cell><cell>New</cell><cell>100</cell><cell>0</cell><cell>100</cell><cell>0</cell></row><row><cell>SnippingTool</cell><cell>Save</cell><cell>100</cell><cell>0</cell><cell>100</cell><cell>0</cell></row><row><cell></cell><cell>Save as</cell><cell>100</cell><cell>0</cell><cell>100</cell><cell>0</cell></row><row><cell></cell><cell>Login</cell><cell>100</cell><cell>0</cell><cell>100</cell><cell>0</cell></row><row><cell>WinScp</cell><cell>Download</cell><cell>81.32</cell><cell>2.21</cell><cell>100</cell><cell>0</cell></row><row><cell></cell><cell>Upload</cell><cell>90.23</cell><cell>1.13</cell><cell>100</cell><cell>0</cell></row><row><cell></cell><cell>Login</cell><cell>100</cell><cell>0</cell><cell>100</cell><cell>0</cell></row><row><cell>FileZilla</cell><cell>Download</cell><cell>85.2</cell><cell>1.63</cell><cell>100</cell><cell>0</cell></row><row><cell></cell><cell>Upload</cell><cell>80.1</cell><cell>2.17</cell><cell>100</cell><cell>0</cell></row><row><cell></cell><cell>Open Email</cell><cell>81.4</cell><cell>2.06</cell><cell>99.2</cell><cell>0.07</cell></row><row><cell>Outlook</cell><cell>Upload</cell><cell>100</cell><cell>0</cell><cell>100</cell><cell>0</cell></row><row><cell></cell><cell>Download</cell><cell>100</cell><cell>0</cell><cell>100</cell><cell>0</cell></row><row><cell>Skype</cell><cell>Upload Download</cell><cell>100 91.37</cell><cell>0 1.05</cell><cell>100 100</cell><cell>0 0</cell></row><row><cell></cell><cell>Open</cell><cell>100</cell><cell>0</cell><cell>100</cell><cell>0</cell></row><row><cell>Adobe Reader</cell><cell>Save</cell><cell>100</cell><cell>0</cell><cell>100</cell><cell>0</cell></row><row><cell></cell><cell>Save as</cell><cell>100</cell><cell>0</cell><cell>100</cell><cell>0</cell></row><row><cell></cell><cell>Open</cell><cell>100</cell><cell>0</cell><cell>100</cell><cell>0</cell></row><row><cell>Foxit Reader</cell><cell>Save</cell><cell>100</cell><cell>0</cell><cell>100</cell><cell>0</cell></row><row><cell></cell><cell>Save as</cell><cell>100</cell><cell>0</cell><cell>100</cell><cell>0</cell></row><row><cell>Average</cell><cell>-</cell><cell>97.41%</cell><cell>0.29%</cell><cell>99.97%</cell><cell>0.002%</cell></row><row><cell cols="6">the correlation. Then we compare the results with the ground</cell></row><row><cell cols="6">truth to evaluate UISCOPE. As mentioned in Section III-F,</cell></row><row><cell cols="6">we develop two attribution methods: timestamp-based and</cell></row><row><cell cols="6">initial event-based. We apply different combinations of these</cell></row><row><cell cols="6">attribution methods to the collected traces. Table III shows</cell></row><row><cell cols="6">the attribution accuracy results on the 12 popular applications</cell></row><row><cell cols="6">under different operations. The last row shows the average</cell></row><row><cell cols="6">value of True Positive Rate (TPR) and False Positive Rate</cell></row><row><cell cols="3">(FPR) for all the 12 applications.</cell><cell></cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_9"><head>TABLE IV .</head><label>IV</label><figDesc>ATTRIBUTION ACCURACY OF DYNAMIC APPLICATIONS Outlook, and it is because Outlook supports HTML emails that can load resources dynamically in the background. WinScp and FileZilla have relatively small TPR under only the timestamp-based method because file downloads/uploads happen in parallel. With two attribution methods enabled, UISCOPE can still get 100% accuracy.</figDesc><table><row><cell>NumberOfWebsites</cell><cell>StayTime</cell><cell></cell><cell cols="2">Timestamp</cell><cell cols="3">Timestamp + Initial Event</cell></row><row><cell></cell><cell></cell><cell>TPR</cell><cell>FPR</cell><cell># of unique domain of FP per website</cell><cell>TPR</cell><cell>FPR</cell><cell># of unique domain of FP per website</cell></row><row><cell>10</cell><cell>10</cell><cell>88.57%</cell><cell>1.26%</cell><cell>13.06</cell><cell>94.20%</cell><cell>0.64%</cell><cell>2.69</cell></row><row><cell>10</cell><cell>20</cell><cell>90.83%</cell><cell>1.01%</cell><cell>13.51</cell><cell>95.52%</cell><cell>0.49%</cell><cell>2.23</cell></row><row><cell>10</cell><cell>30</cell><cell>90.55%</cell><cell>1.04%</cell><cell>15.49</cell><cell>96.22%</cell><cell>0.42%</cell><cell>2.34</cell></row><row><cell>20</cell><cell>10</cell><cell>85.58%</cell><cell>0.75%</cell><cell>18.97</cell><cell>92.53%</cell><cell>0.39%</cell><cell>3.66</cell></row><row><cell>20</cell><cell>20</cell><cell>86.68%</cell><cell>0.71%</cell><cell>22.38</cell><cell>93.54%</cell><cell>0.33%</cell><cell>3.42</cell></row><row><cell>20</cell><cell>30</cell><cell>85.61%</cell><cell>0.75%</cell><cell>25.27</cell><cell>93.47%</cell><cell>0.34%</cell><cell>3.69</cell></row><row><cell>30</cell><cell>10</cell><cell>83.27%</cell><cell>0.57%</cell><cell>23.82</cell><cell>91.48%</cell><cell>0.29%</cell><cell>4.37</cell></row><row><cell>30</cell><cell>20</cell><cell>84.05%</cell><cell>0.54%</cell><cell>28.04</cell><cell>92.19%</cell><cell>0.26%</cell><cell>4.41</cell></row><row><cell>30</cell><cell>30</cell><cell>77.98%</cell><cell>0.75%</cell><cell>30.74</cell><cell>86.55%</cell><cell>0.46%</cell><cell>4.98</cell></row><row><cell cols="5">When we apply both methods at the same time, the average</cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="5">TPR improves from 97.41% to 99.97%, and the average FPR</cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="5">reduced from 0.29% to 0.002%. Overall, UISCOPE achieves</cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="5">high attribution accuracy (99.97%) and negligible false pos-</cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="5">itives. A few events were missing for the action of opening</cell><cell></cell><cell></cell><cell></cell></row><row><cell>emails with</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_11"><head>TABLE V .</head><label>V</label><figDesc>ATTACK INVESTIGATION SUMMARY ON THE REST 5 a case study and other five attacks are summarized in TableV. The first column shows the attack name and reference. The second column summarizes the attack scenario and the last column indicates if UISCOPE can find the root cause of the attack. And we can see that, UISCOPE is capable of finding all root causes of different types of attacks.</figDesc><table><row><cell></cell><cell>REAL-WORLD ATTACKS</cell><cell></cell></row><row><cell>Attacks</cell><cell>Short Description</cell><cell>Root cause by UISCOPE</cell></row><row><cell>Phishing</cell><cell></cell><cell></cell></row><row><cell>email</cell><cell>Motivating example discussed in Section II-A.</cell><cell></cell></row><row><cell>[20]</cell><cell></cell><cell></cell></row><row><cell>MS Office Macro Attack [56]</cell><cell>An malicious document was downloaded and executed as an Outlook attachment and the enclosed macro was triggered by Excel to perform malicious behaviors.</cell><cell></cell></row><row><cell>Watering</cell><cell>An malicious file was uploaded to a popular</cell><cell></cell></row><row><cell>Hole</cell><cell>forum. A victim visited the forum through</cell><cell></cell></row><row><cell>Attack</cell><cell>Google search, and downloaded and executed the</cell><cell></cell></row><row><cell>[18]</cell><cell>malicious file.</cell><cell></cell></row><row><cell>Insider</cell><cell>An insider attacker downloaded sensitive files</cell><cell></cell></row><row><cell>Attack</cell><cell>from a FTP server and compress and send out</cell><cell></cell></row><row><cell>[21]</cell><cell>such files through Outlook.</cell><cell></cell></row><row><cell>Credential-based Attack [22]</cell><cell>An attacker accessed the machine with the stolen VNC credential and transfer bank money through passwords automatically saved by Chrome.</cell><cell></cell></row></table><note><p>present</p></note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div><head>ACKNOWLEDGMENT</head><p>The authors would like to thank anonymous reviewers and our shepherd, <rs type="person">Prof. Adam Bates</rs>, for their feedback in finalizing this paper. We would also like to thank <rs type="person">Xue Leng</rs> and <rs type="person">Jiuyuan Wang</rs> for informative discussions on the submitted manuscript. This work is supported, in part, by <rs type="funder">NSFC</rs> under <rs type="grantNumber">U1936215</rs>, <rs type="funder">DARPA</rs> under <rs type="grantNumber">FA8650-15-C-7562</rs>, <rs type="funder">NSF</rs> under <rs type="grantNumber">1748764</rs>, <rs type="grantNumber">1901242</rs> and <rs type="grantNumber">1910300</rs>, <rs type="funder">ONR</rs> under <rs type="grantNumber">N000141410468</rs> and <rs type="grantNumber">N000141712947</rs>, and <rs type="funder">Sandia National Lab</rs> under award <rs type="grantNumber">1701331</rs>. Any opinions, findings, and conclusions in this paper are those of the authors only and do not necessarily reflect the views of our sponsors.</p></div>
			</div>
			<listOrg type="funding">
				<org type="funding" xml:id="_VXQYJPN">
					<idno type="grant-number">U1936215</idno>
				</org>
				<org type="funding" xml:id="_wrUAwRw">
					<idno type="grant-number">FA8650-15-C-7562</idno>
				</org>
				<org type="funding" xml:id="_UFykUsK">
					<idno type="grant-number">1748764</idno>
				</org>
				<org type="funding" xml:id="_tPfJNwq">
					<idno type="grant-number">1901242</idno>
				</org>
				<org type="funding" xml:id="_Ak3bWZb">
					<idno type="grant-number">1910300</idno>
				</org>
				<org type="funding" xml:id="_s7R7fmh">
					<idno type="grant-number">N000141410468</idno>
				</org>
				<org type="funding" xml:id="_a94Ra93">
					<idno type="grant-number">N000141712947</idno>
				</org>
				<org type="funding" xml:id="_HGa3enV">
					<idno type="grant-number">1701331</idno>
				</org>
			</listOrg>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0" />			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Alexa top websites</title>
		<ptr target="https://bit.ly/2N1rZPi" />
		<imprint>
			<date type="published" when="2019-09-10">2019-09-10</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Captain hook:pirating avs to bypass exploit mitigations</title>
		<ptr target="https://goo.gl/zVyuAL" />
		<imprint>
			<date type="published" when="2019-09-10">2019-09-10</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Cdc: 1 in 4 us adults live with a disability</title>
		<ptr target="http://bit.ly/2QWsrAU" />
		<imprint>
			<date type="published" when="2019-09-10">2019-09-10</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Chromedriver -webdriver for chrome</title>
		<idno>ac- cessed on 2019-09-10</idno>
		<ptr target="https://bit.ly/35wPgiu" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Clickjacking</title>
		<ptr target="https://bit.ly/2ZUPSxa" />
		<imprint>
			<date type="published" when="2019-09-10">2019-09-10</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Electronic communications privacy act of 1986 (ecpa)</title>
		<ptr target="http://bit.ly/33odQRz" />
		<imprint>
			<date type="published" when="2019-09-10">2019-09-10</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Internet security threat report</title>
		<ptr target="https://symc.ly/" />
		<imprint>
			<date type="published" when="2019-09">2rzm4c5. 2019-09-10</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Kernel Patch Protection</title>
		<ptr target="https://goo.gl/s4idr7" />
		<imprint>
			<date type="published" when="2019-09-10">2019-09-10</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Khobe 8.0 earthquake for windows desktop security software</title>
		<ptr target="https://goo.gl/5UhzpQ" />
		<imprint>
			<date type="published" when="2019-09-10">2019-09-10</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Login detection</title>
		<ptr target="https://bit.ly/2N0t7Cw" />
		<imprint>
			<date type="published" when="2019-09-10">2019-09-10</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Plague in (security) software drivers</title>
		<ptr target="https://goo.gl/kmycvb" />
		<imprint>
			<date type="published" when="2019-09-10">2019-09-10</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<ptr target="https://bit.ly/2sLenAS" />
		<title level="m">Sleuth kit</title>
		<imprint>
			<date type="published" when="2019-09-10">2019-09-10</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Ui automation providers</title>
		<ptr target="http://bit.ly/37Ib5hi" />
		<imprint>
			<date type="published" when="2019-09-10">2019-09-10</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Volatility: An advanced memory forensics framework</title>
		<ptr target="https://bit.ly/2s18miV" />
		<imprint>
			<date type="published" when="2019-09-10">2019-09-10</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Event tracing for windows</title>
		<ptr target="http://bit.ly/2EbzKxM" />
		<imprint>
			<date type="published" when="2019-09-10">2019. 2019-09-10</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Hidden treasure: Intrusion detection with etw</title>
		<ptr target="http://bit.ly/2VG0DUZ" />
		<imprint>
			<date type="published" when="2019-09-10">2019. 2019-09-10</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Lowest common ancestor</title>
		<ptr target="https://bit.ly/2udA2lD" />
		<imprint>
			<date type="published" when="2019-09-10">2019. 2019-09-10</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">Many watering holes, targets in hacks that netted facebook, twitter and apple</title>
		<ptr target="http://bit.ly/30otNqs" />
		<imprint>
			<date type="published" when="2019-09-10">2019. 2019-09-10</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">Plaso: super timeline all the things</title>
		<ptr target="http://bit.ly/2WP3MyC" />
		<imprint>
			<date type="published" when="2019-09-10">2019. 2019-09-10</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">Spear phishing campaign targets ukraine government and military</title>
		<ptr target="https://bit.ly/2XaiUGu" />
		<imprint>
			<date type="published" when="2019-09-10">2019. 2019-09-10</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">Target to pay $18.5m for 2013 data breach that affected 41 million consumers</title>
		<ptr target="http://bit.ly/2W77ZQU" />
		<imprint>
			<date type="published" when="2019-09-10">2019. 2019-09-10</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">Trickbot adds remote application credential-grabbing capabilities to its repertoire</title>
		<ptr target="http://bit.ly/2VubtZk" />
		<imprint>
			<date type="published" when="2019-09-10">2019. 2019-09-10</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">NSAccessibility</title>
		<author>
			<persName><forename type="first">A</forename><surname>Developer</surname></persName>
		</author>
		<ptr target="https://apple.co/" />
		<imprint>
			<date type="published" when="2019-09-10">2w2z8Ww, 2019, accessed on 2019-09-10</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Saql: A stream-based query system for realtime abnormal system behavior detection</title>
		<author>
			<persName><forename type="first">P</forename><surname>Gao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Xiao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Jee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">H</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">R</forename><surname>Kulkarni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Mittal</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">27th USENIX Security Symposium</title>
		<imprint>
			<publisher>USENIX Security</publisher>
			<date type="published" when="2018">2018</date>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="639" to="656" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">AIQL: Enabling efficient attack investigation from system monitoring data</title>
		<author>
			<persName><forename type="first">P</forename><surname>Gao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Xiao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">R</forename><surname>Kulkarni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Mittal</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2018 USENIX Annual Technical Conference (USENIX ATC</title>
		<imprint>
			<date type="published" when="2018">2018</date>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="113" to="126" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<title level="m" type="main">Timesketch: Collaborative forensic timeline analysis</title>
		<author>
			<persName><surname>Google</surname></persName>
		</author>
		<ptr target="http://bit.ly/2JmCnAT" />
		<imprint>
			<date type="published" when="2019-09-10">2019. 2019-09-10</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">It accessibility laws and policies</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">U S</forename><surname>Government</surname></persName>
		</author>
		<ptr target="http://bit.ly/2VFOwaD" />
		<imprint>
			<date type="published" when="2019-09-10">2019. 2019-09-10</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Towards scalable cluster auditing through grammatical inference over provenance graphs</title>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">U</forename><surname>Hassan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Aguse</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Aguse</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Bates</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Moyer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Network and Distributed Systems Security Symposium (NDSS 18)</title>
		<imprint>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Nodoze: Combatting threat alert fatigue with automated provenance triage</title>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">U</forename><surname>Hassan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Guo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Jee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Bates</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Network and Distributed Systems Security Symposium (NDSS 19)</title>
		<imprint>
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Sleuth: Real-time attack scenario reconstruction from cots audit data</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">N</forename><surname>Hossain</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">M</forename><surname>Milajerdi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Eshete</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Gjomemo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Sekar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">D</forename><surname>Stoller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Venkatakrishnan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">26th USENIX Security Symposium (USENIX Security</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="page" from="487" to="504" />
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Dependencepreserving data compaction for scalable forensic analysis</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">N</forename><surname>Hossain</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Sekar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">D</forename><surname>Stoller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">27th USENIX Security Symposium (USENIX Security</title>
		<imprint>
			<date type="published" when="2018">2018</date>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="1723" to="1740" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">A general approach for efficiently accelerating softwarebased dynamic data flow tracking on commodity hardware</title>
		<author>
			<persName><forename type="first">K</forename><surname>Jee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Portokalidis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">P</forename><surname>Kemerlis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Ghosh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">I</forename><surname>August</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">D</forename><surname>Keromytis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Network and Distributed Systems Security Symposium (NDSS 12)</title>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Rain: Refinable attack investigation with on-demand interprocess information flow tracking</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Ji</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Downing</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Fazzini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Orso</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2017 ACM SIGSAC Conference on Computer and Communications Security</title>
		<meeting>the 2017 ACM SIGSAC Conference on Computer and Communications Security</meeting>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="page" from="377" to="390" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Backtracking intrusions</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">T</forename><surname>King</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">M</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGOPS Operating Systems Review</title>
		<imprint>
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="223" to="236" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Enriching intrusion alerts through multi-host causality</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">T</forename><surname>King</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><forename type="middle">M</forename><surname>Mao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">G</forename><surname>Lucchetti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">M</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Network and Distributed Systems Security Symposium (NDSS 05)</title>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Mci: Modeling-based causality inference in audit logging for attack investigation</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Kwon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">H</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W.-C</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Ma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Jha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Ciocarlie</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Network and Distributed Systems Security Symposium (NDSS 18)</title>
		<imprint>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">High accuracy attack provenance via binary-based execution partition</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">H</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Xu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Network and Distributed Systems Security Symposium (NDSS 13)</title>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Loggc: garbage collecting audit log</title>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2017 ACM SIGSAC Conference on Computer and Communications Security (CCS 13)</title>
		<meeting>the 2017 ACM SIGSAC Conference on Computer and Communications Security (CCS 13)</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="1005" to="1016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Jsgraph: Enabling reconstruction of web attacks via efficient tracking of live in-browser javascript executions</title>
		<author>
			<persName><forename type="first">B</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Vadrevu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">H</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Perdisci</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NDSS</title>
		<imprint>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<monogr>
		<title level="m" type="main">ATK Package</title>
		<author>
			<persName><forename type="first">B</forename><surname>Linux</surname></persName>
		</author>
		<ptr target="http://bit.ly/2WJM92Y" />
		<imprint>
			<date type="published" when="2019-09-10">2019. 2019-09-10</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Towards a timely causality analysis for enterprise security</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Jee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Rhee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Mittal</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Network and Distributed Systems Security Symposium (NDSS 18)</title>
		<imprint>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Accurate, low cost and instrumentation-free security audit logging for windows</title>
		<author>
			<persName><forename type="first">S</forename><surname>Ma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">H</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">H</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Rhee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Xu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 31st Annual Computer Security Applications Conference (ACSAC 15)</title>
		<meeting>the 31st Annual Computer Security Applications Conference (ACSAC 15)</meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Kernel-supported cost-effective audit logging for causality tracking</title>
		<author>
			<persName><forename type="first">S</forename><surname>Ma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Zhai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Kwon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">H</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Ciocarlie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Gehani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Yegneswaran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Jha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2018 {USENIX} Annual Technical Conference</title>
		<imprint>
			<date type="published" when="2018">2018</date>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="241" to="254" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">MPI: Multiple perspective attack investigation with semantic aware execution partitioning</title>
		<author>
			<persName><forename type="first">S</forename><surname>Ma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Zhai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">H</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Xu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">26th USENIX Security Symposium</title>
		<imprint>
			<publisher>USENIX Security</publisher>
			<date type="published" when="2017">2017</date>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="page" from="1111" to="1128" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Protracer: Towards practical provenance tracing by alternating between logging and tainting</title>
		<author>
			<persName><forename type="first">S</forename><surname>Ma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Xu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Network and Distributed Systems Security Symposium (NDSS 16)</title>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<monogr>
		<title level="m" type="main">UI Automation -Windows applications</title>
		<author>
			<persName><surname>Microsoft</surname></persName>
		</author>
		<ptr target="http://bit.ly/2Q4Vn" />
		<imprint>
			<date type="published" when="2018">2018. 2019-09-10</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<monogr>
		<title level="m" type="main">UI Automation Events Overview</title>
		<ptr target="http://bit.ly/2WMJ8yQ" />
		<imprint>
			<date type="published" when="2018">2018. 2019-09-10</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<monogr>
		<title level="m" type="main">Property identifiers</title>
		<author>
			<persName><surname>Microsoft</surname></persName>
		</author>
		<idno>09-10</idno>
		<ptr target="https://bit.ly/2tCxDQO" />
		<imprint>
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">Holmes: real-time apt detection through correlation of suspicious information flows</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">M</forename><surname>Milajerdi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Gjomemo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Eshete</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Sekar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Venkatakrishnan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2019 IEEE Symposium on Security and Privacy</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">Provenance-aware storage systems</title>
		<author>
			<persName><forename type="first">K.-K</forename><surname>Muniswamy-Reddy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">A</forename><surname>Holland</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Braun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">I</forename><surname>Seltzer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2006 USENIX Annual Technical Conference (USENIX ATC 06)</title>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="43" to="56" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<monogr>
		<title level="m" type="main">Platform for architecture-neutral dynamic analysis</title>
		<author>
			<persName><surname>Panda</surname></persName>
		</author>
		<ptr target="http://bit.ly/2W5KaJc" />
		<imprint>
			<date type="published" when="2019-09-10">2019. 2019-09-10</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">HERCULE: attack story reconstruction via community discovery on correlated log graph</title>
		<author>
			<persName><forename type="first">K</forename><surname>Pei</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Gu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Saltaformaggio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Ma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Si</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Xu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 32nd Annual Computer Security Applications Conference</title>
		<meeting>the 32nd Annual Computer Security Applications Conference</meeting>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">Dscrete: Automatic rendering of forensic information from memory images via application logic reuse</title>
		<author>
			<persName><forename type="first">B</forename><surname>Saltaformaggio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Gu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Xu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">23rd USENIX Security Symposium</title>
		<imprint>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
	<note>USENIX Security 14</note>
</biblStruct>

<biblStruct xml:id="b53">
	<monogr>
		<title level="m" type="main">Simple + fast + free: Automation for everyone</title>
		<author>
			<persName><surname>Tinytask</surname></persName>
		</author>
		<ptr target="http://bit.ly/2vXwrWm" />
		<imprint>
			<date type="published" when="2019-09-10">2019. 2019-09-10</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<title level="a" type="main">Cve-2018-8495</title>
		<ptr target="http://bit.ly/30nvxjN" />
	</analytic>
	<monogr>
		<title level="m">Wikipedia contributors</title>
		<imprint>
			<date type="published" when="2019-09-10">2019. 2019-09-10</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<monogr>
		<ptr target="http://bit.ly/" />
		<title level="m">Macro virus</title>
		<imprint>
			<date type="published" when="2019-09-10">2w3W9Z2, 2019. 2019-09-10</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<analytic>
		<title level="a" type="main">High fidelity data reduction for big data security dependency analyses</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Jee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Rhee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Xiao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Jiang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2017 ACM SIGSAC Conference on Computer and Communications Security</title>
		<meeting>the 2017 ACM SIGSAC Conference on Computer and Communications Security</meeting>
		<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="504" to="516" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
