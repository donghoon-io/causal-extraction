<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Semantics for Specialising Attack Trees based on Linear Logic 1</title>
				<funder ref="#_nYXu8E3">
					<orgName type="full">MOE</orgName>
				</funder>
				<funder ref="#_e3BpGfP">
					<orgName type="full">Fonds National de la Recherche Luxembourg</orgName>
				</funder>
				<funder ref="#_z74TnSj">
					<orgName type="full">European Commissions Seventh Framework Programme</orgName>
				</funder>
				<funder ref="#_BxurYBN">
					<orgName type="full">National Research Foundation Singapore</orgName>
				</funder>
				<funder ref="#_ZEUejUZ #_E4wuGqG">
					<orgName type="full">unknown</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Ross</forename><surname>Horne</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">School of Computer Science and Engineering</orgName>
								<orgName type="institution">Nanyang Technological University</orgName>
								<address>
									<country key="SG">Singapore</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Sjouke</forename><surname>Mauw</surname></persName>
							<affiliation key="aff1">
								<orgName type="department">CSC/SnT</orgName>
								<orgName type="institution">University of Luxembourg</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Alwen</forename><surname>Tiu</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">School of Computer Science and Engineering</orgName>
								<orgName type="institution">Nanyang Technological University</orgName>
								<address>
									<country key="SG">Singapore</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Semantics for Specialising Attack Trees based on Linear Logic 1</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="DOI">10.3233/FI-2017-1531</idno>
					<note type="submission">Accepted for publication in IOS Press journal Fundamenta Informaticae March 15, 2017 CORE Metadata, citation and similar papers at core.ac.uk</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.1" ident="GROBID" when="2025-10-14T18:27+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>attack trees</term>
					<term>semantics</term>
					<term>causality</term>
					<term>linear logic</term>
					<term>calculus of structures</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Attack trees profile the sub-goals of the proponent of an attack. Attack trees have a variety of semantics depending on the kind of question posed about the attack, where questions are captured by an attribute domain. We observe that one of the most general semantics for attack trees, the multiset semantics, coincides with a semantics expressed using linear logic propositions. The semantics can be used to compare attack trees to determine whether one attack tree is a specialisation of another attack tree. Building on these observations, we propose two new semantics for an extension of attack trees named causal attack trees. Such attack trees are extended with an operator capturing the causal order of sub-goals in an attack. These two semantics extend the multiset semantics to sets of series-parallel graphs closed under certain graph homomorphisms, where each semantics respects a class of attribute domains. We define a sound logical system with respect to each of these semantics, by using a recently introduced extension of linear logic, called MAV, featuring a non-commutative operator. The non-commutative operator models causal dependencies in causal attack trees. Similarly to linear logic for attack trees, implication defines a decidable preorder for specialising causal attack trees that soundly respects a class of attribute domains.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Attack trees were introduced by Schneier <ref type="bibr" target="#b0">[1]</ref> as a means of representing the profile of an attacker. To achieve some goal such as obtaining a company secret, the proponent of an attack may proceed according to sub-goals. In the original model proposed by Schneier, there are two ways of breaking down a goal: either a goal is composed of multiple sub-goals, all of which must be achieved; or a goal can be tackled by one of several alternative subgoals, where the success of one sub-goal is sufficient. These we refer to as conjunctive and disjunctive refinements, respectively.</p><p>In this work, we consider attack trees extended with a sequential refinement <ref type="bibr" target="#b1">[2]</ref>, called causal attack trees. Sequential refinement, like conjunctive refinement, requires that all subgoals must be achieved, but furthermore some sub-goals must be achieved before other sub-goals may be tackled. For example, an attacker must first successfully enter a datacenter before attempting to install malicious hardware. Sequential refinement is distinguished from conjunctive refinement, since the latter assumes multiple sub-goals are attempted concurrently and independently by the attacker.</p><p>We build on a line of work investigating the semantics of attack trees initiated by Mauw and Oostdijk <ref type="bibr" target="#b2">[3]</ref>, that explores conditions under which two attack trees can be considered to represent the same attack. If an algorithm or security expert modifies an attack tree, a semantics is desirable to know whether properties of the attack tree are preserved in the new attack tree. A subtlety is that the appropriate semantics depend on the kind of question the attack tree is used to resolve, where questions are characterised by attribute domains. For example, for Boolean attribute domains such as "whether special equipment is required", a semantics based on classical propositional logic <ref type="bibr" target="#b3">[4]</ref> suffices. A more general semantics based on multisets <ref type="bibr" target="#b2">[3]</ref> covers a wider class of questions, called distributive attribute domains, such as "minimum cost of attack" or "maximum damage of attack".</p><p>Related work <ref type="bibr" target="#b1">[2]</ref> extends the multiset semantics to causal attack trees by using series-parallel graphs that represent not only the actions of the attack, but also causal dependencies between actions. Under the previously established equational semantics for causal attack trees, given two causal attack trees and an attribute domain sound with respect to the semantics, if two causal attack trees are equivalent then the attribute domain will always give the same answer for both trees.</p><p>In practice, however, attack trees are not static snapshots, but dynamic descriptions of a system's vulnerabilities that evolve under influence of the system's development and new insights in the adversary's capabilities. New attacks will be added over time and existing attacks will be made more specific. An equational semantics does not comply to such an incremental development of attack trees because it only allows one to compare whether two trees are exactly equivalent. This implies the need for a semantics that explicitly addresses the question of whether one attack tree is a specialisation of another attack tree. In this article, we address this need by studying various semantics that preorder attack trees, hence are suitable for specialising attack trees. This is a challenging problem, since, in particular for causal attack trees, certain attribute domains that have the same equational semantics have subtly distinct inequational semantics.</p><p>The semantics introduced in this work are based on a logical system in which implication captures specialisation. Such a logical foundation for causal attack trees has practical benefits. The logic is defined by a decidable proof calculus that can be used as the basis of tools <ref type="bibr" target="#b4">[5]</ref> to assist the security expert working with causal attack trees. Apart from the above mentioned scenario in which a dynamic attack becomes more and more specialised over time, there are other use cases for an inequational semantics. The security expert may begin with a large attack tree representing many system vulnerabilities and prune the attack tree just for an aspect of the system under consideration. Alternatively, tools may guide the security expert when constructing a large attack tree for a system, working bottom-up from a forest of attack trees which must be soundly reflected in the combined attack tree. Another use case for specialisation is when one attack tree represents the capabilities of an attacker and another attack tree represents the vulnerabilities of a system, in which case implication can be used to resolve queries such as "is the attacker capable of attacking the system?".</p><p>The logical semantics we propose is based on an extension of linear logic <ref type="bibr" target="#b5">[6]</ref> with a non-commutative operator representing sequentiality, called MAV <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b7">8]</ref>. A philosophical benefit of having a logical semantics for causal attack trees is that a logical system provides an objective justification for a choice of semantics. The rules of MAV are not designed based on human intuition, but are given canonically when investigating the proof theory of a logic with sequential composition and non-deterministic choice. Thus, not only does the logic provide a sound methodology for specialising and querying causal attack trees, but the semantics itself is fundamentally consistent.</p><p>Outline. Section 2 provides examples of causal attack trees, along with intuitive explanations for why implications between causal attack trees are of significant impact for the attack tree community. Section 3 is mainly background on attack trees with conjunctive and disjunctive refinement only. The key observation is that the established multiset semantics for attack trees coincides with a semantics based on a fragment of linear logic. The main technical contribution is in Sections 4 and 5, which explore semantics for causal attack trees. Section 4 concerns two semantics, based on sets of graphs closed under certain graph homomorphisms, and their sound and complete axiomatisations. The axiomatisations are used to identify two classes of attribute domain for which each semantics can be soundly applied. Section 5 introduces a logical system for which implication in the logic is sound with respect to the proposed semantics for causal attack trees, and thereby also sound with respect to the two classes of attribute domain identified.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">A Case for the Specialisation of Causal Attack Trees</head><p>This section intuitively discusses motivating examples of causal attack trees and associated attribute domains. An explanation is provided for how one causal attack trees may be a specialisation of another causal attack tree. A case is made for a system formalising specialisation preorders that are sound with respect to attribute domains. Formal definitions are postponed until later sections.</p><p>Consider the example of a causal attack tree in Fig. <ref type="figure" target="#fig_0">1</ref>, adapted from <ref type="bibr" target="#b8">[9]</ref>. The attack tree features three types of refinement: the root node in the example with arc between the branches represents a conjunctive refinement, the node with no arc represents a disjunctive refinement, the node with a directed arc pointing to the right represents a sequential refinement. The goal at the root of the tree is to obtain some secret data. To achieve this, an encrypted file should be obtained and a password should be obtained. The goal of obtaining the encrypted file is disjunctively refined to either bribing the sysadmin or stealing a backup. The goal of obtaining the password is sequentially refined such that the attacker must first break into the system before installing a key logger.</p><p>Under certain assumptions, the causal attack tree in Fig. <ref type="figure" target="#fig_0">1</ref> can be specialised to the causal attack tree in Fig. <ref type="figure" target="#fig_1">2</ref>. In the specialised tree, "steal backup" can only be performed after breaking into the system. Intuitively, the tree in Fig. <ref type="figure" target="#fig_1">2</ref> represents a more restricted attack pattern. In Fig. <ref type="figure" target="#fig_1">2</ref>, there is an extra dependency between the actions "break into system" and "steal backup" not present in Fig. <ref type="figure" target="#fig_0">1</ref>. Soundness with respect to attribute domains. Whether the specialisation from Fig. <ref type="figure" target="#fig_0">1</ref> to Fig. <ref type="figure" target="#fig_1">2</ref> is sound depends on the attribute domains of interest. The criterion for soundness, that is formally defined in later sections is as follows.</p><p>If one tree specialises another tree, then the specialisation is sound with respect to an attribute domain whenever there is a correlation between the values at the root of the trees, for any assignment of values to basic actions at the leaves.</p><p>If we are interested in the "minimal attack time", we expect that in the more restricted attack tree in Fig. <ref type="figure" target="#fig_1">2</ref> any attack will take at least as long as in the original tree. This is due to the implicit assumption that in Fig. <ref type="figure" target="#fig_0">1</ref> "break into system" and "steal backup" can be conducted concurrently; whereas in Fig. <ref type="figure" target="#fig_1">2</ref> the same actions are causally dependent on each other, hence must be performed sequentially. When independent actions occur concurrently the minimum attack time is the maximum of the times assigned to the sub-goals; whereas when causally dependent actions occur in sequence the minimum attack time should be the sum of the minimum attack time of each sub-goal.</p><p>Suppose the minimum times to achieve each basic action are assigned as follows.</p><formula xml:id="formula_0">§ ¦ ¤ ¥ bribe sysadmin → 25 § ¦ ¤ ¥ steal backup → 5 § ¦ ¤ ¥ break into system → 9 § ¦ ¤ ¥ install keylogger → 2</formula><p>For the above assignment the tree in Fig. <ref type="figure" target="#fig_1">2</ref> has a higher minimum attack time, as verified by the following calculations. The formula on the left is the minimum attack time for Fig. <ref type="figure" target="#fig_0">1</ref> and the formula on the right is the minimum attack time for Fig. <ref type="figure" target="#fig_1">2</ref>. max{min{25, 5}, 9</p><formula xml:id="formula_1">+ 2} = 11 ≤ 14 = min{max{25, 9 + 2}, 9 + max{2, 5}}</formula><p>Indeed, for any assignment of non-negative times, the minimum attack time will always be at least as high for the attack tree in Fig. <ref type="figure" target="#fig_1">2</ref> compared to Fig. <ref type="figure" target="#fig_0">1</ref>. Thereby an attacker constrained according to Fig. <ref type="figure" target="#fig_1">2</ref> will never be capable of attacking quicker than an attacker following the profile in Fig. <ref type="figure" target="#fig_0">1</ref>. Two natural questions, clarified in this work, are: (i) how do we determine when one causal attack tree is a sound specialisation of another causal attack tree; and (ii) what attribute domains are soundly preserved with respect to such specialisations. These questions contrast to previous work on causal attack trees <ref type="bibr" target="#b1">[2]</ref>, where only equivalence and the preservation of equality with respect to attribute domains is considered. With respect to equality, we can say nothing about the relationship between the two example trees in Fig. <ref type="figure" target="#fig_0">1</ref> and<ref type="figure" target="#fig_1">2</ref>.</p><p>Distinct classes of attribute domain. Not all attribute domains have the same algebraic properties, hence one specialisation preorder does not fit all purposes. We contrast the "minimum attack time" attribute domain to other attribute domains that are also sound for the specialisations between Fig. <ref type="figure" target="#fig_0">1</ref> and<ref type="figure" target="#fig_1">2</ref>, but unsound for other specialisations.</p><p>Now suppose that we are interested in the "minimum number of experts required to conduct an attack". For this attribute domain, the same expert can conduct actions in sequence, hence sequential composition is interpreted using max. However, if actions are conducted independently and concurrently then the total number of experts required is the sum of the number of experts required for each concurrent sub-goal. For this domain we assume that for conjunctive refinements the experts must be prepared to conduct actions independently and concurrently.</p><p>For the "minimum number of experts" attribute domain we can guarantee that the causal attack tree in Fig. <ref type="figure" target="#fig_0">1</ref> always requires at least as many experts compared to the causal attack tree in Fig. <ref type="figure" target="#fig_1">2</ref>. Hence specialising Fig. <ref type="figure" target="#fig_0">1</ref> to Fig. <ref type="figure" target="#fig_1">2</ref> is sound with respect to the "minimum number of experts" attribute domain. Consider the same causal attack trees and consider the following assignment of values to basic actions under the "minimum number of experts" attribute domain.</p><formula xml:id="formula_2">§ ¦ ¤ ¥ bribe sysadmin → 3 § ¦ ¤ ¥ steal backup → 1 § ¦ ¤ ¥ break into system → 2 § ¦ ¤ ¥ install keylogger → 1</formula><p>For the above assignment of values, the number of attackers required for the trees in Fig. <ref type="figure" target="#fig_0">1</ref> and Fig. <ref type="figure" target="#fig_1">2</ref> can be compared by the following calculation. The formulas on the left and right represent the minimum number of experts for Fig. <ref type="figure" target="#fig_0">1</ref> and Fig. <ref type="figure" target="#fig_1">2</ref>, respectively.</p><formula xml:id="formula_3">min{3, 1} + max{2, 1} = 3 ≥ 2 = min{3 + max{2, 1}, max{2, 1 + 1}}</formula><p>For the specialisation from Fig. <ref type="figure" target="#fig_0">1</ref> to Fig. <ref type="figure" target="#fig_1">2</ref>, for both attribute domains discussed, the values at the root nodes are correlated for any assignment of values to basic actions at the leaves. Thereby both attribute domains discussed are sound for this specialisation, although the numerical order for each of the two attribute domains is opposite to the other: the specialised attack in Fig. <ref type="figure" target="#fig_1">2</ref> always requires at least as much time, but never more experts.</p><p>In the body of this paper, a formal logical system is introduced that can be used to decide whenever such sound specialisations exist, without requiring to manually check soundness for each new combination of specialisation and attribute domain. Without a supporting decision procedure, it may not be immediately obvious when specialisations are sound for one attribute domain but not another.</p><p>Consider the causal attack trees in Fig. <ref type="figure" target="#fig_2">3</ref>. According to the "minimum number of experts" attribute domain, the causal attack tree in Fig. <ref type="figure" target="#fig_2">3</ref>(a) is a sound specialisation of the causal attack tree in Fig. <ref type="figure" target="#fig_1">2</ref>. Any assignment of values will lead to at least as many experts being required for Fig. <ref type="figure" target="#fig_2">3</ref> attack time" attribute domain, there exist distinct assignments of values to basic actions at the leaves that result in both smaller and greater times for Fig. <ref type="figure" target="#fig_2">3</ref>(a) compared to Fig. <ref type="figure" target="#fig_1">2</ref>. Given the first assignment of attack times provided above, the minimum attack time for Fig. <ref type="figure" target="#fig_2">3</ref>(a) would be max{5, 9 + 2} = 11 which is less than the minimum attack time of 14 for Fig. <ref type="figure" target="#fig_1">2</ref>. However if all assignments of values are kept the same except the time to steal a backup, which is increased such that § ¦ ¤ ¥ steal backup → 35, then the minimum attack time for Fig. <ref type="figure" target="#fig_2">3</ref>(a) becomes max{35, 9 + 2} = 35 and the minimum attack time for Fig. <ref type="figure" target="#fig_1">2</ref> becomes min{max{25, 9 + 2}, 9 + max{35, 2}} = 25. Hence, in general, there is no correlation between the minimum attack times in Fig. <ref type="figure" target="#fig_2">3</ref>(a) and Fig. <ref type="figure" target="#fig_1">2</ref>. This example demonstrates that, for a specialisation that is unsound for an attribute domain, assignments of values in the attribute domain may give answers in one tree uncorrelated with answers for the other tree.</p><p>A similar story applies for the causal attack tree in Fig. <ref type="figure" target="#fig_2">3</ref>(b), which is a sound specialisation of Fig. <ref type="figure" target="#fig_0">1</ref> for the "minimum attack time" attribute domain. According to the "minimum attack time" attribute domain, for any assignment of non-negative times to actions, the minimum attack time for Fig. <ref type="figure" target="#fig_2">3</ref>(b) will always be greater than the minimum attack time for Fig. <ref type="figure" target="#fig_0">1</ref>. In contrast, for the "minimum number of experts" attribute domain, assignments of values to basic actions in Fig. <ref type="figure" target="#fig_2">3</ref>(b) and Fig. <ref type="figure" target="#fig_0">1</ref> give uncorrelated answers.</p><p>This work focusses on two specialisation preorders that are sound with respect to each of two attribute domains discussed so far. Other attribute domains are also sound with respect to these specialisation preorders. For example, when the "minimum number of experts" increases between Fig. <ref type="figure" target="#fig_1">2</ref> and Fig. <ref type="figure" target="#fig_2">3</ref>(a), the "minimum amount of time to make all attacks possible" decreases. As a guideline, both specialisation preorders covered in this work are sound with respect to classes of attribute domains that involve non-deterministic choices. For instance, the "minimum attack time" attribute domain assumes that whenever there is a choice, only the branch taking the least time need be considered. Thus the two classes of attribute domain in this work do not cover all useful attribute domains. For example, attribute domains that involve probabilities, such as <ref type="bibr" target="#b8">[9]</ref>, have finer algebraic properties than the attribute domains covered in this work; hence demand finer specialisation preorders. For probabilistic attribute domains, answers may depend partially on multiple branches of a choice, rather than on non-deterministic choices. This highlights further the importance of understanding which semantics and techniques are relevant for a particular choice of attribute domain.</p><p>Manually verifying the soundness of each potential specialisation for each attribute domain is a laborious and error-prone task. Fortunately, we can devise procedures for deciding whether one tree is a sound specialisation of the other for a class of attribute domains. The decision procedure works by reducing specialisation to implication in a logical system. We will return to the above motivating examples in Section 5 where the logical system is introduced.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Denotational, Logical and Algebraic Semantics for Attack Trees</head><p>This section introduces attack trees <ref type="bibr" target="#b0">[1]</ref> and connects three equivalent formulations of the multiset semantics <ref type="bibr" target="#b2">[3]</ref> for attack trees. The multiset semantics is typically used to identify when two attack trees represent the same attack while being sensitive to the possibility that some resources, such as cash or one-time access codes, are not reusable once spent.</p><p>The three semantics presented can be classified as denotational, logical and algebraic. The denotational semantics is based on sets of multisets denoting normal forms for attack trees. The logical semantics is based on a fragment of linear logic <ref type="bibr" target="#b5">[6]</ref>, from which decision procedures can be extracted. The algebraic semantics highlights the commutative idempotent semiring structure of the multiset semantics, which can be used to check whether quantities assigned to attributes called attribute domains respect the multiset semantics.</p><p>Most of this section is background material introducing attack trees and linear logic. The novelty is a characterization of the multiset semantics through linear logic, which allows us to establish a new proof that the multiset semantics and algebraic semantics coincide. The connection with linear logic justifies generalisations made in later sections.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.">The Syntax of Attack Trees and Action Refinement</head><p>The syntax for attack trees is defined by the following grammar.</p><formula xml:id="formula_4">t £ ¢ ¡ a basic action | t t conjunctive refinement | t t disjunctive refinement</formula><p>The atoms £ ¢ ¡ a are drawn from a set of basic actions, which represent possible attacks by the proponent, such as "disrupt security training" or "set up back door admin account". Conjunctive and disjunctive refinement are used to break down basic actions into sub-goals, to be more precise about attacks of the proponent. For conjunctive refinement , the proponent must perform both actions for the attack to be successful. For disjunctive refinement , the proponent has two possible avenues of attack, but only one need be completed for the attack to be successful.</p><p>In graphical representations of attack trees, such as in Fig. <ref type="figure" target="#fig_3">4</ref>, a node with an arc represents a conjunctive refinement, while a node with no arc represents disjunctive refinement. This graphical convention is used in supporting tools for attack trees <ref type="bibr" target="#b4">[5]</ref>.</p><p>The attack trees in Fig. <ref type="figure" target="#fig_3">4</ref>, model part of a scenario where all employees must undergo online training in security practices of the company. Now suppose that an attacker aims to target an employee, such as a newly appointed VP, who is yet to undergo training. To increase the chances of the new VP not adhering sufficiently to best security practices, perhaps storing unencrypted company secrets, the attacker begins with the basic action: "disrupt security training". This basic action can be disjunctively refined to two basic actions "fake test" and "compromise server for training". In the former case, the attack can be refined further to two actions that the attacker can perform to fake the test, say "intercept training email" and "complete test on behalf of employee". Further refinements are possible to indicate how the various goals are achieved. The two refinements steps are captured graphically in the trees in Fig. <ref type="figure" target="#fig_3">4</ref>.</p><p>The tree on the right in Fig. <ref type="figure" target="#fig_3">4</ref> is a graphical representation of the following term.</p><formula xml:id="formula_5">§ ¦ ¤ ¥ intercept training email § ¦ ¤ ¥ complete test § ¦ ¤ ¥ compromise server for training</formula><p>Notice that the labels at the non-leaf nodes are not recorded in the syntax. The labels at these nodes simply recall the basic action that was refined, assisting the domain expert when they recall the intuition behind each refinement step. For example, "fake test", a basic action in the tree on the left, is disjunctively refined in the tree on the right. Thus the following mapping from basic actions to attack trees can also be recovered from the diagram in Fig. <ref type="figure" target="#fig_3">4</ref>.</p><formula xml:id="formula_6">§ ¦ ¤ ¥ disrupt security training → £ ¢ ¡ fake test § ¦ ¤ ¥ compromise server for training £ ¢ ¡ fake test → § ¦ ¤ ¥ intercept training email § ¦ ¤ ¥ complete test</formula><p>We refer to such mappings as action refinements, to avoid confusion with specialisation which we introduce in this paper. All semantics in this work respect action refinement, in the sense that if two trees are related in the semantics then they have the same relation after applying the same action refinement to both trees.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.">An Established Multiset Semantics for Attack Trees</head><p>In original work on the semantics of attack trees <ref type="bibr" target="#b2">[3]</ref>, attack trees are given a denotational semantics based on sets of multisets. This semantics is expressed using a distributive product as follows.</p><p>Definition 1. Given two sets of multisets V and W, define their distributive product as follows, where is multiset union.</p><p>V W = {v w : v ∈ V, w ∈ W}</p><p>The multiset semantics for attack trees is defined by the following function • M that maps terms representing attack trees to sets of multisets.</p><formula xml:id="formula_7">£ ¢ ¡ a M = {|a| } t u M = t M ∪ u M t u M = t M u M</formula><p>Notice that is associative and commutative, and distributes over set union, as follows.</p><formula xml:id="formula_8">U (V ∪ W) = (U V) ∪ (U W) .</formula><p>The above distributivity property allows disjunctive refinement to distribute over conjunctive refinement. Thereby the following attack trees are equivalent in the multiset semantics.</p><formula xml:id="formula_9">£ ¢ ¡ fake test § ¦ ¤ ¥ compromise server for training £ ¢ ¡ steal ID M = £ ¢ ¡ fake test £ ¢ ¡ steal ID § ¦ ¤ ¥ compromise server for training £ ¢ ¡ steal ID M</formula><p>Intuitively, two avenues of attack are presented. In both attacks, stealing the ID documents of the employee is necessary. Both attack trees represent the same attack scenario and have the same multiset-based denotation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.">A Brief Overview of Multiplicative Additive Linear Logic</head><p>A key observation enabling this paper is that implication in linear logic <ref type="bibr" target="#b5">[6]</ref> can systematise the multiset semantics. Linear logic was designed to control the use of assumptions in proof search. In classical logic, since "P and P" is equivalent to P, assumptions can be reused during proof search, formalised by the contraction rule. Also, not all assumptions need be used, formalised by the weakening rule.</p><formula xml:id="formula_10">Γ P, P, ∆ Γ P, ∆ Γ, P, P ∆ Γ, P ∆ contraction Γ ∆ Γ, P ∆ Γ ∆ Γ P, ∆<label>weakening</label></formula><p>Rules here are expressed in the sequent calculus, where a sequent of the form Γ ∆ consists of two multisets of propositions Γ and ∆. The standard interpretation of a sequent is that if we assume that the conjunction of every proposition left of the turnstile holds, the disjunction of the formulae right of the turnstile must hold.</p><p>In contrast to classical logic, linear logic forbids both contraction and weakening. A consequence is that linear negation, indicated by an over line, becomes a synthetic operator distinct from classical negation. This leads to distinct types of conjunction and disjunction in linear logic. Multiplicative conjunction, P⊗Q (called "times"), has De Morgan dual multiplicative disjunction, P Q = P ⊗ Q (called "par"). Additive disjunction, P ⊕ Q (called "plus"), has a De Morgan dual additive conjunction, The multiplicative-additive fragment of linear logic we consider is called MALL. Propositions in MALL are given by the following grammar, where a ranges over basic actions.</p><formula xml:id="formula_11">P &amp; Q = P ⊕ Q (called "with"). a a id Γ P, ∆ Γ, P ∆ neg Γ, P ∆ Γ P, ∆ neg Γ 1 ∆ 1 Γ 2 ∆ 2 Γ 1 , Γ 2 ∆ 1 , ∆ 2 mix Γ, P, Q ∆ Γ, P ⊗ Q ∆ ⊗ L Γ 1 P, ∆ 1 Γ 2 Q, ∆ 2 Γ 1 , Γ 2 P ⊗ Q, ∆ 1 , ∆ 2 ⊗ R Γ ∆, P P, Γ ∆ Γ, Γ ∆, ∆ cut Γ, P ∆ Γ, Q ∆ Γ, P ⊕ Q ∆ ⊕ L Γ P i , ∆ Γ P 1 ⊕ P 2 , ∆ ⊕ R , i ∈ {1, 2}</formula><formula xml:id="formula_12">P a | P | P ⊗ P | P 1 ⊕ P 2</formula><p>The proof system for MALL is given in Figure <ref type="figure" target="#fig_4">5</ref>, formalised in the sequent calculus. The identity axiom (id) states that a basic action can be derived from itself. The two negation rules express the duality of the propositions to the right of the turnstile (in a disjunctive context) and propositions to the left of the turnstile (in a conjunctive context). To understand the rules of MALL, contrast to the classical case with contraction and weakening. In the classical setting, the multiplicative and additive conjunctions P ⊗ Q and P ⊕ Q coincide, as do the disjunctions P ⊕ Q and P ⊗ Q. However, since contraction and weakening are omitted from linear logic, the multiplicative and additive operators are distinguished. For more details on MALL, we recommend the paper on MAV [8], the logical system used later in this paper, which begins by introducing MALL. The mix rule is not essential for plain attack trees, but enables conservative extensions introduced in later sections.</p><p>A rule is said to be admissible whenever any proposition provable in a system using the rule can also be proven without using the rule. A central established result in linear logic, is that the cut rule is admissible for MALL. This established result is due to Girard <ref type="bibr" target="#b5">[6]</ref>.</p><p>Theorem 2 <ref type="bibr" target="#b5">(Girard 1987)</ref>. The cut rule is admissible.</p><p>Cut elimination is the corner stone of a proof calculus, with consequences including the transitivity of entailment and the consistency of the logical system. Furthermore, the sequent calculus has the property that the cut-free system has a finite search space, hence proof search is suited to implementing decision procedures. Left-introduction rules, indicated by the subscript L, are invertible, meaning that applying them eagerly does not affect provability; while their right-introduction rules, indicated by subscript R, are non-invertible meaning they trigger branching in proof search.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4.">Correspondence between the Multiset and Linear Logic Semantics</head><p>We show here an embedding of attack trees into positive linear logic propositions, i.e., propositions without negation, that preserves the multiset semantics. The embedding is defined as follows.</p><formula xml:id="formula_13">£ ¢ ¡ a L = a t u L = t L ⊕ u L t u L = t L ⊗ u L</formula><p>For an example of how entailment in linear logic is useful, consider for example the attack tree for disrupting the security training of new employees in Fig. <ref type="figure" target="#fig_3">4</ref>. The attack tree</p><formula xml:id="formula_14">§ ¦ ¤ ¥ intercept email § ¦ ¤ ¥ complete test is a specialisation of § ¦ ¤ ¥ intercept email § ¦ ¤ ¥ complete test § ¦ ¤ ¥</formula><p>compromise server , in the sense that the former has less choice between avenues of attack. In the former, the proponent does not attempt to compromise the server directly. In the multiset semantics, this specialisation is captured by the following subset inclusion. {|intercept email, complete test| } ⊆ {|intercept email, complete test| }, {|compromise server| } In the linear logic semantics the specialisation is captured by the following entailment. intercept email ⊗ complete test intercept email ⊗ complete test ⊕ compromise server An advantage of entailment is a decision procedure can be extracted from the sequent calculus presentation of rules. A derivation for the above example is provided below. intercept email intercept email id complete test complete test id</p><formula xml:id="formula_15">intercept email, complete test intercept email ⊗ complete test ⊗ R intercept email, complete test intercept email ⊗ complete test ⊕ compromise server ⊕ R intercept email ⊗ complete test intercept email ⊗ complete test ⊕ compromise server ⊗ L</formula><p>To establish the correspondence between the linear logic embedding and sets of mulisets, we show that positive propositions, i.e., propositions without negation using only ⊕ and ⊗, can be interpreted as a set of multisets of propositional atoms.</p><p>Definition 3. The following function maps positive propositions to sets of multisets:</p><formula xml:id="formula_16">m(a) = {|a| } m(P ⊕ Q) = m(P) ∪ m(Q) m(P ⊗ Q) = m(P) m(Q)</formula><p>Using cut elimination, the next lemma can be easily proven with structural induction on P. Its proof exploits the existence of focused proofs <ref type="bibr" target="#b9">[10]</ref> for valid linear logic formulae, where invertible rules are applied (reading the proof bottom up) before the non-invertible rules.</p><p>Lemma 4. For any positive propositions P 1 , . . . , P n , P, where n ≥ 1, if P 1 , . . . , P n P is provable, then m(P 1 )</p><formula xml:id="formula_17">• • • m(P n ) ⊆ m(P) .</formula><p>Proof. By induction on the height of the proof Π of P 1 , . . . , P n P, where invertible rules are applied eagerly. In the case where all P i 's are atomic, we prove this lemma using Lemma ??. Otherwise, the proof Π must end with either ⊕ L or ⊗ L . Assume without loss of generality that the last rule of Π applies to P 1 .</p><p>• Suppose P 1 = P 1 ⊗ P 1 and Π is Π P 1 , P 1 , . . . , P n P P 1 ⊗ P 1 , . . . , P n P ⊗ L .</p><p>By Definition 3 and the induction hypothesis, we have</p><formula xml:id="formula_18">m P 1 ⊗ P 1 • • • m(P n ) = m P 1 m P 1 • • • m(P n ) ⊆ m(P) .</formula><p>• Suppose P 1 = P 1 ⊕ P 1 and Π is Π 1 P 1 , . . . , P n P Π 2 P 1 , . . . , P n P P 1 ⊕ P 1 , . . . , P n P ⊕ L By the induction hypotheses, we have:</p><formula xml:id="formula_19">m P 1 • • • m(P n ) ⊆ m(P) and m P 1 • • • m(P n ) ⊆ m(P)</formula><p>and therefore</p><formula xml:id="formula_20">m P 1 ⊕ P 1 • • • m(P n ) = (m P 1 ∪ m P 1 ) • • • m(P n ) = m P 1 • • • m(P n ) ∪ m P 1 • • • m(P n ) ⊆ m(P) .</formula><p>The next lemma expresses the converse of Lemma 4.</p><p>Lemma 5. If {|a 1 , . . . , a n | } ∈ m(P) for some positive proposition P then a 1 , . . . , a n P is provable.</p><p>Proof. By structural induction on P.</p><p>• If P = a for some atomic proposition a, then {|a 1 , . . . , a n | } = {|a| }. In this case, the proof can be constructed by an application of the id rule.</p><p>• Suppose P = P 1 ⊗ P 2 . Then m(P) = m(P 1 ) m(P 2 ) . In this case, {|a 1 , . . . , a n | } can be partitioned into {|a i 1 , . . . , a i k | } ∈ m(P 1 ) and {|a j 1 , . . . , a j m | } ∈ m(P 2 ). By the induction hypotheses, we have that a i 1 , . . . , a i k m(P 1 ) and a j 1 , . . . , a j k m(P 1 ) are provable, and . . .</p><formula xml:id="formula_21">a i 1 , . . . , a i m P 1 . . . a i 1 , . . . , a i m P 1 a 1 , . . . , a n P 1 ⊗ P 2 ⊗ R</formula><p>• Suppose P = P 1 ⊕ P 2 . Then m(P) = m(P 1 ) ∪ m(P 2 ) . If {|a 1 , . . . , a n | } ∈ m(P 1 ) then we construct the proof as follows:</p><p>. . .</p><formula xml:id="formula_22">a 1 , . . . , a n P 1 a 1 , . . . , a n P 1 ⊕ P 2 ⊕ R</formula><p>where the premise is provable by the induction hypothesis. The other case where {|a 1 , . . . , a n | } ∈ m(P 2 ) can be proved similarly.</p><p>Lemma 6. For positive propositions, if m(P 1 ) • • • m(P n ) ⊆ m(P) then P 1 , . . . , P n P.</p><p>Proof. Given a proposition Q, let |Q| denote its size, i.e., the number of symbols occurring in Q. This lemma is proved by induction on the multiset of proposition sizes:</p><formula xml:id="formula_23">{| |P 1 | , . . . , |P n | | }.</formula><p>In the case where every P i is an atomic proposition, this lemma follows immediately from Lemma 5. If at least one P i is not atomic, then we proceed by induction as follows (assume w.l.o.g. i = 1):</p><p>• P 1 = P 1 ⊗ P 1 . In this case, we have</p><formula xml:id="formula_24">m(P 1 ) • • • m(P n ) = m P 1 m P 1 • • • m(P n ) ⊆ m(P) .</formula><p>The proof is then constructed as follows:</p><p>. . . where the premise is provable by the induction hypothesis.</p><formula xml:id="formula_25">P</formula><p>• P 1 = P 1 ⊕ P 1 . In this case, we have</p><formula xml:id="formula_26">m(P 1 ) • • • m(P n ) = m P 1 • • • m(P n ) ∪ m P 1 • • • m(P n ) ⊆ m(P) .</formula><p>That is, we have m P  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5.">An Algebraic Semantics and Attribute Domains</head><p>In the previous sections, we directly established the equivalence of a semantics for attack trees based on multisets and a semantics based on positive propositions in linear logic. We now present an algebraic semantics that also coincides with the multiset semantics for attack trees.</p><p>The algebraic characterisation is in terms of a particular class of semirings. A semiring is two semigroups with (associative) binary operators and such that is commutative and distributes over . When additionally is idempotent and is commutative, we call such a structure a commutative idempotent semiring. Axioms for commutative idempotent semirings are presented in Fig 6 . A preorder over semirings is defined such that t u if and only if t u u.</p><p>The fact that (the positive fragment of) MALL conservatively extends a commutative idempotent semiring is folklore. The proof relies on Theorem 37. Proof. For each equation v w in Fig. <ref type="figure">6</ref>, we have v L w L . Since the entailment relation is a pre-congruence, and is both reflexive and transitive, it follows that for every equation v w derivable from the equations in Fig. <ref type="figure">6</ref> we have v L w L . Now assume that t u u hence t L ⊕ u L u L is provable, and observe that t L t L ⊕ u L is directly provable; hence by an application of the cut rule, we have t L u L . For the converse direction, proceed by induction over the structure of a proof of t L u L to establish that u t u holds in the algebra, where t and u are attack trees. Most cases are immediate, except the case for ⊗ R .</p><p>Consider the case where, t 1 L , . . .</p><formula xml:id="formula_27">t m L , u 1 L , . . . u n L t L ⊗ u L follows, by rule ⊗ R , from t 1 L , . . . t m L t L and u 1 L , . . . u n L u L .</formula><p>By assuming the induction hypothesis, (t 1 . . . t m ) t t and (u 1 . . . u n ) u u, from which the following equality can be derived, as required.</p><formula xml:id="formula_28">t u ((t 1 . . . t m ) t) u by induction (t 1 . . . t m u) (t u) distributivity (t 1 . . . t m ((u 1 . . . u n ) u)) (t u) by induction (t 1 . . . t m u 1 . . . u n ) (t 1 . . . t m u) (t u) distributivity (t 1 . . . t m u 1 . . . u n ) (((t 1 . . . t m ) t) u) distributivity (t 1 . . . t m u 1 . . . u n ) (t u)</formula><p>by induction</p><p>Hence by induction on the size of the proof if t L u L then t u.</p><p>Commutative idempotent semirings are ubiquitous structures in computer science arising as part of the algebraic theory of various metrics including min-plus, max-plus semirings, and the distributive lattices of classical propositional logic. Such semirings can be used to specify attribute domains over attack trees, where an attribute domain is an assignment of values in a domain to basic actions and functions over the domain to refinement operators. Definition 11. Suppose D = (D, f, g) is an attribute domain with two binary operators over D. Assume also that ϑ is a valuation mapping basic actions to D. The interpretation function I D ϑ ( • ) from attack trees to D is defined as follows.</p><formula xml:id="formula_29">I D ϑ £ ¢ ¡ a = ϑ( £ ¢ ¡ a ) I D ϑ (t u) = f (I D ϑ (t) , I D ϑ (u)) I D ϑ (t u) = g(I D ϑ (t) , I D ϑ (u))</formula><p>An attribute domain D ordered by ≤ D is sound with respect to specialisation order , whenever for all attack trees t and u and valuations ϑ, if t u then I D ϑ (t)</p><formula xml:id="formula_30">≤ D I D ϑ (u).</formula><p>Although often implicitly defined, attribute domains occur frequently in the attack trees literature (for an extensive literature overview see <ref type="bibr" target="#b10">[11]</ref>). As an example, consider the domain B = (R, min, max), where ϑ is a valuation assigning the estimated time to perform a basic action in an attack. The interpretation function I B ϑ ( • ) calculates the "minimum time to perform an attack", assuming actions in a conjunctive refinement can be performed concurrently. The soundness of specialisation, defined using entailment in linear logic, with respect to this "minimum time to perform an attack" attribute domain is established as follows.</p><p>Proposition 12. For all attack trees t and u and all ϑ,</p><formula xml:id="formula_31">if t L u L then I B ϑ (t) ≥ I B ϑ (u).</formula><p>To see why the direction of implication is opposite to the order over real numbers in the above soundness property, observe the following. Since t u only if t u u and since is interpreted by min, in this domain if t u, then min</p><formula xml:id="formula_32">I B ϑ (t) , I B ϑ (u) = I B ϑ (u), which holds if and only if I B ϑ (t) ≥ I B ϑ (u)</formula><p>. Attribute domains such as (R, min, +) representing the "minimal cost of an attack" do not depend on whether actions in a conjunctive refinement are performed concurrently. In contrast, notice that the "minimum time to perform an attack" attribute domain (R, min, max) depends on sub-goals in a conjunctive refinement being performed concurrently and independently. However, it is clearly not always the case that sub-goals can be performed concurrently and independently. For example, in Fig. <ref type="figure" target="#fig_3">4</ref> it may be that "intercept email" must be achieved before "complete test". Attribute domains sensitive to causal dependencies between actions demand the semantics in the next section.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">An Extension of Attack Trees Respecting Causality</head><p>Attack trees have various extensions for elaborating on the attack scenario profiled. The extension we consider in this section is for attack trees with a specialisation of conjunctive refinement called sequential refinement. Sequential refinement explicitly indicates where there are causal dependencies between actions of an attacker, thus actions cannot be performed concurrently. For example, an attacker may hijack a TCP session before attempting to access a company database. Due to the causal dependencies between events that must be performed sequentially, we call such attack trees with sequential refinement causal attack trees.</p><p>As highlighted at the end of Section 3 some quantitative questions, such as those involving timing or conflicting resources, are sensitive to whether or not there are causal dependencies between actions. A finer semantics than the multiset semantics is required to distinguish sequential refinement from conjunctive refinement, and to recover soundness with respect to such attribute domains. Semantics proposed in related work <ref type="bibr" target="#b1">[2]</ref> assume that sequential and conjunctive refinement are unrelated, in the sense that there is no property like distributivity defining the interaction between the two operators. We discover in this section, when sequential refinement specialises conjunctive refinement, more than one semantics may be appropriate depending on the relevant class of attribute domain.</p><p>The grammar of attack trees is extended with sequential refinement as follows.</p><formula xml:id="formula_33">t £ ¢ ¡ a basic action | t t conjunctive refinement | t t disjunctive refinement | t • t sequential refinement</formula><p>Sequential refinement is sometimes called "sequential and" <ref type="bibr" target="#b1">[2]</ref>. However we avoid this terminology, since in later sections we reveal that the operator can be interpreted by a self-dual operator, hence is neither strictly conjunctive nor strictly disjunctive in logical nature.</p><p>In this section, we introduce two semantics for causal attack trees based on sets of graphs closed under certain graph homomorphisms.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.">Preliminaries on Series-Parallel Graphs</head><p>We proceed with the preliminaries for our proposed semantics for causal attack trees. Causal attack trees are denoted by particular sets of graphs, called labelled series-parallel graphs <ref type="bibr" target="#b11">[12]</ref>. Series-parallel graphs are DAGs constructed from single vertices, labelled with basic actions, using graph constructors composing graphs in series and parallel. For parallel composition, no new edges are added between two disjoint graphs; and for sequential composition, new directed edges are added from every node in one graph to every node in the other graph, modelling causal dependencies.</p><p>A labelled digraph is defined as follows. Labels range over basic actions in this work.</p><p>Definition 13. A labelled digraph is a triple (V, E, µ) where V is a set of vertices E ⊆ V × V is a set of edges and µ is a function from V to a set of labels.</p><p>We require the definition of disjoint union and sequential composition of labelled digraphs. The sequential composition is the least digraph extending the disjoint union such that there is an edge from every vertex in the left graph to every vertex in the right graph.</p><formula xml:id="formula_34">Definition 14. If G = (V 0 , E 0 , µ 0 ) and H = (V 1 , E 1 , µ 1 ) are labelled digraphs then their disjoint union G H is the labelled digraph (V, E, µ), where V = V 0 × {0} ∪ V 1 × {1}, E ⊆ V × V is the least set such that if (x, y) ∈ E 0 then ((x, 0), (y, 0)) ∈ E and if (x, y) ∈ E 1 then ((x, 1</formula><p>), (y, 1)) ∈ E, and µ is such that for all x ∈ V 0 , µ((x, 0)) = µ 0 (x) and for all x ∈ V 1 , µ((x, 1)) = µ 1 (x). The sequential composition of G and H is defined by the labelled digraph</p><formula xml:id="formula_35">(V, E ∪ ((V 0 × {0}) × (V 1 × {1})) , µ) and denoted GH.</formula><p>A series-parallel graph is a labelled digraph that can be constructed from smaller graphs by composing them in series and parallel, where parallel composition is disjoint union (hence there are no new edges between the graphs) and sequential composition is defined as above.</p><p>Definition 15. A labelled series-parallel graph is a digraph (V, E, µ) that can be constructed as follows.</p><p>• The empty digraph (∅, ∅, ∅) is a series-parallel graph, denoted by .</p><p>• The singleton digraph with label £ ¢ ¡ a denoted ({x} , ∅, µ), where µ : x → £ ¢ ¡ a for some vertex x is a series-parallel graph. This singleton graph is denoted by G a .</p><p>• If G = (V 0 , E 0 , µ 0 ) and H = (V 1 , E 1 , µ 1 ) are series-parallel graphs, then their disjoint union G H and sequential composition GH are series-parallel graphs.</p><p>By construction, a series-parallel graph is acyclic and transitively closed.</p><p>The semantics for causal attack trees proposed by Jhawar et al. <ref type="bibr" target="#b1">[2]</ref> is based on sets of labelled series-parallel graphs, inspired by an axiomatisation of pomsets due to Gischer <ref type="bibr" target="#b12">[13]</ref>. Established definitions <ref type="bibr" target="#b1">[2]</ref> are in terms of graphs with labelled edges rather than vertices; which can always be transformed to series-parallel graphs of the above form using an algorithm due to Valdes et al. <ref type="bibr" target="#b11">[12]</ref>. Gischer <ref type="bibr" target="#b12">[13]</ref> also provides a more "permissive" semantics for pomsets, which can be captured by using morphisms called smoothing homomorphisms <ref type="bibr" target="#b13">[14]</ref>. A smoothing homomorphism is a label-preserving bijection between the vertices of two graphs that preserves the set of edges. Thereby the structure of the graph is preserved but new directed edges may be added to the target graph. We employ denotations based on sets of series-parallel graphs that are closed with respect to smoothing homomorphisms, called ideals and filters. Ideals are defined using smoothing homomorphisms such that, if a graph is in an ideal, then all graphs with the same structure as a graph and possibly more edges are also in the ideal. Definition 17. An ideal is a set of labelled digraphs S such that if H ∈ S and G is a labelled digraph such that there exists a smoothing homomorphism from H to G, then G ∈ S . The ideal closure of a set of labelled digraphs T is the least ideal S such that T ⊆ S denoted ι(T ).</p><formula xml:id="formula_36">Definition 16. Consider two labelled digraphs G = (V 0 , E 0 , µ 0 ) and H = (V 1 , E 1 , µ 1 ). A smoothing homomorphism f from G to H is a bijection between V 0 and V 1 such that for all vertices x, y ∈ V 0 , µ 0 (x) = µ 1 ( f (x)), and if (x, y) ∈ E 0 then ( f (x), f (y)) ∈ E 1 . Sequential refinement defines a semigroup: t • (u • v) (t • u) • v Sequential refinement distributes over : t • (u v) (t • u) (t • v) (t u) • v (t • v) (u • v)</formula><p>For filters the direction of smoothing homomorphisms are reversed compared to ideals. If a graph is in a filter then all graphs with the same structure as a graph with fewer edges are also in the filter, as defined using smoothing homomorphism in the following. Definition 18. A filter is a set of labelled digraphs S such that if H ∈ S and G is a labelled digraph such that there exists a smoothing homomorphism from G to H, then G ∈ S . The filter closure of a set of labelled digraphs T is the least filter S such that T ⊆ S denoted φ(T ).</p><p>Isomorphisms, defined next, characterise when two graphs have the same structure. By identifying graphs with their equivalence classes the identity of vertices are abstracted away. We also extend disjoint union and parallel composition point-wise to sets of graphs. Definition 19. Two labelled digraphs are isomorphic whenever there is a bijection f between vertices such that both f and its inverse f -1 define smoothing homomorphisms. For G a , the equivalence class of all isomorphic graphs is denoted</p><formula xml:id="formula_37">[G a ].</formula><p>The distributive product of two sets of series-parallel graphs S T , is defined as the point-wise disjoint union {G H : G ∈ S , H ∈ T }. Point-wise sequential composition of two sets of series-parallel graphs S T is defined as</p><formula xml:id="formula_38">{GH : G ∈ S , H ∈ T }.</formula><p>The distributive product of filters, naturally extending the distributive product of multisets, is a filter. In contrast, the distributive product of ideals is not an ideal. The following proposition clarifies which constructions preserve ideals and filters.</p><p>Proposition 20. The equivalence class [G a ] of all singleton graphs with label a is a filter and an ideal. If S and T are filters then the distributive product S T is a filter and S ∪ T is a filter. If S and T are ideals then the point-wise sequential composition S T is an ideal and S ∪ T is an ideal.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.">Limitations of an Intermediate Semantics regarding Specialisation</head><p>The definitions in the previous section are sufficient to introduce several graph-based semantics. An intermediate semantics for causal attack trees, established in related work <ref type="bibr" target="#b1">[2]</ref>, is defined as follows.</p><p>Definition 21 (intermediate semantics). The intermediate semantics is defined by the following embedding from causal attack trees to sets of labelled series-parallel graphs.</p><formula xml:id="formula_39">£ ¢ ¡ a M = [G a ] t u M = t M ∪ u M t u M = t M u M t • u M = t M u M</formula><p>Omitting sequential refinement, the above semantics coincides with the multiset semantics for attack trees in Def. 1. This is because edges are used for sequential refinement only and equivalence classes of labelled digraphs with no edges coincide with multisets. Thus, by Proposition 12, conjunctive and disjunctive refinement form an idempotent commutative semiring as defined by for attack trees in Fig. <ref type="figure">6</ref>. For sequential refinement, the equations in Fig. <ref type="figure" target="#fig_5">7 hold</ref>, making sequential refinement a semi-group that distributes over disjunctive refinement. Indeed this algebraic characterisation is sound and complete for the intermediate semantics, as follows. Theorem 22 <ref type="bibr" target="#b1">(Jhawar et al. 2015)</ref>. For causal attack trees t and u, t M = u M if and only if t = u by the equations in Fig. <ref type="figure">6</ref> and<ref type="figure" target="#fig_5">7</ref>.</p><p>A limitation of the above intermediate semantics is that it does not accommodate relationships between causal attack trees that are not equivalent, as required for a specialisation preorder.</p><p>For example, we argue that the causal attack trees in Fig. <ref type="figure" target="#fig_6">8</ref> should be related by a specialisation preorder. Notice the exchange of the conjunctive and sequential refinements. The second tree in Fig. <ref type="figure" target="#fig_6">8</ref> represents a specialisation of the first tree. For the first tree, the attacker must "cut the WAN link" before "disrupting the main site" and also should "corrupt a technician" before "disabling a replica". In contrast, the second tree in Fig. <ref type="figure" target="#fig_6">8</ref> implies that both "cutting the WAN link" and "corrupting a technician" are both prerequisites for "disrupting the main site" and also for "disabling a replica". Thus the second tree of Fig. <ref type="figure" target="#fig_6">8</ref> represents strictly more causal dependencies than the first tree, and thereby greater synchronisation between sub-goals.</p><p>Smoothing homomorphisms, Def. 16, are used to accommodate specialisations of the form of Fig. <ref type="figure" target="#fig_6">8</ref>. There is a smoothing homomorphism from the series-parallel graph denoting the first tree to the series-parallel graph denoting the second tree. This smoothing homomorphism, adding two directed edges, is represented below.</p><formula xml:id="formula_40">£ ¢ ¡ cut WAN link / / § ¦ ¤ ¥ disrupt main site § ¦ ¤ ¥ corrupt technician / / § ¦ ¤ ¥ disable replica smoothing £ ¢ ¡ cut WAN link / / ( ( § ¦ ¤ ¥ disrupt main site § ¦ ¤ ¥ corrupt technician / / 6 6 § ¦ ¤ ¥ disable replica</formula><p>The series-parallel graphs above are represented up to graph isomorphism classes leaving only labels.</p><p>By definition, ideals and filters are closed under smoothing homomorphisms. Consequently, if we close the intermediate semantics in Def. 21 for filters, then the two example trees in Fig. <ref type="figure" target="#fig_6">8</ref> are ordered by subset inclusion. In the following, φ is the filter closure operator from Def. 18.</p><formula xml:id="formula_41">φ £ ¢ ¡ cut WAN link • § ¦ ¤ ¥ disrupt main site § ¦ ¤ ¥ corrupt technician • § ¦ ¤ ¥ disable replica M ⊆ φ £ ¢ ¡ cut WAN link § ¦ ¤ ¥ corrupt technician • § ¦ ¤ ¥ disrupt main site § ¦ ¤ ¥ disable replica M</formula><p>If we close the intermediate semantics in Def. 21 for ideals, then the reverse subset inclusion holds. In the following, ι is the ideal closure operator from Def. 17.</p><formula xml:id="formula_42">ι £ ¢ ¡ cut WAN link § ¦ ¤ ¥ corrupt technician • § ¦ ¤ ¥ disrupt main site § ¦ ¤ ¥ disable replica M ⊆ ι £ ¢ ¡ cut WAN link • § ¦ ¤ ¥ disrupt main site § ¦ ¤ ¥ corrupt technician • § ¦ ¤ ¥ disable replica M 4.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Two Semantics for Specialising Causal Attack Trees</head><p>Notice that, by Proposition 20, point-wise sequential composition preserves ideals and the distributive product preserves filters. However, the point-wise sequential composition of filters is not necessarily a filter. Similarly, the distributive product of ideals is not necessarily an ideal. Therefore, to obtain a filter extending the point-wise sequential composition of filters, the filter closure function φ must be applied to close the set of graphs. to obtain an ideal extending the distributive product of ideals, the ideal closure function ι is applied.</p><p>The above observations lead us to the following two denotational semantics for causal attack trees.</p><p>Definition 23 (ideal semantics). The ideal semantics is defined by the following mapping from causal attack trees to ideals.</p><formula xml:id="formula_43">£ ¢ ¡ a I = [G a ] t u I = t I ∪ u I t u I = ι ( t I u I ) t • u I = t I u I</formula><p>Definition 24 (filter semantics). The filter semantics is defined by the following mapping from causal attack trees to filters.</p><formula xml:id="formula_44">£ ¢ ¡ a F = [G a ] t u F = t F ∪ u F t u F = t F u F t • u F = φ t F u F</formula><p>The ideal semantics is an established process model <ref type="bibr" target="#b12">[13]</ref>, whereas the filter semantics is new. In the filter semantics, the reversing of the direction of a smoothing homomorphism compared to the ideal semantics affects how and • exchange with each other, as in Fig. <ref type="figure" target="#fig_6">8</ref>.</p><p>The difference between the ideal and filter semantics is clarified by considering a sound and complete axiomatisation for each semantics. To accommodate the specialisations due to smoothing homomorphisms, define F and I to be the least precongruences satisfying the equations in Fig. <ref type="figure">6</ref> and Fig. <ref type="figure" target="#fig_5">7</ref>, and the inequations in Fig. <ref type="figure" target="#fig_7">9</ref>. Congruences over filters and ideals are related to respective precongruences such that t F u whenever t u F u and t I u whenever t u I u. Notice that in Fig. <ref type="figure" target="#fig_7">9</ref> the filter and ideal semantics differ only in the direction in which sequential and conjunctive refinement exchange with each other.</p><p>The significance of the above mentioned difference between the ideal and filter semantics, was discussed in the motivation, Section 2. For some attribute domains sequential and conjunctive refinement exchange in one direction, but for others the direction is opposite. This is discussed more formally in the next section, when defining attribute domains for causal attack trees.</p><p>Note the rules defining how conjunctive and sequential refinement are related are instances of the first rule, i.e.</p><formula xml:id="formula_45">(t • v) (u • w) F (t u) • (v w)</formula><p>for the filter semantics, without certain sub-goals. It is semantically neat to add an attack tree that is the unit for both conjunctive and sequential refinement, denoted by { } and representing the sub-goal that automatically succeeds. However, unit attack trees are avoided in the literature, hence are also avoided in the current work.</p><p>For ideals, the axiomatisation given by I or I , using Fig. <ref type="figure">6</ref>, Fig. <ref type="figure" target="#fig_5">7</ref> and Fig. <ref type="figure" target="#fig_7">9</ref>, is sound and complete with respect to the ideal semantics. This result was established for pomsets <ref type="bibr" target="#b12">[13]</ref>, and is formally stated below for causal attack trees.</p><p>Theorem 25 <ref type="bibr" target="#b12">(Gischer 1988)</ref>. For causal attack trees t and u, t I ⊆ u I if and only if t I u.</p><p>The proof of the corresponding soundness and completeness result for the filter semantics, with respect to I or I , is similar to the soundness and completeness result for ideals. The difference is that the switch of direction for smoothing homomorphisms in the definition of filters requires that some cases must be revisited.</p><p>Theorem 26 (Soundness). For causal attack trees t and u, if t F u then t F ⊆ u F . Proof. Most cases are immediate, we consider two cases that differ compared to that of Gischer <ref type="bibr" target="#b12">[13]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Exchange in the ideal semantics</head><formula xml:id="formula_46">(t u) • (v w) I (t • v) (u • w) (t u) • w I t (u • w) u • (v w) I v (u • w) t • u I t u Exchange in the filter semantics (t • v) (u • w) F (t u) • (v w) t (u • w) F (t u) • w v (u • w) F u • (v w) t u F t • u</formula><p>Consider the equation (t</p><formula xml:id="formula_47">• u) • v F t • (u • v). Observe that if G ∈ (t • u) • v F</formula><p>then there exist graphs H, J, K, L and smoothing homomorphisms such that H ∈ t • u F and J ∈ v F and f : G → HJ, and K ∈ t F and L ∈ u F and g : J → KL. Furthermore, H (KL) is isomorphic to (HK) L; hence we can construct a smoothing homomorphism h : G → (HK) L. Hence, since (HK)</p><formula xml:id="formula_48">L ∈ t • (u • v) F , by definition, G ∈ t • (u • v) F . The converse direction is symmetric, hence (t • u) • v F = t • (u • v) F .</formula><p>Consider the soundness of (t</p><formula xml:id="formula_49">• v) (u • w) F (t u) • (v w). If G ∈ (t • u) (v • w) F then G = H J such that H ∈ t • u F and J ∈ v • w F .</formula><p>Hence there exist labelled series-parallel graphs K, L, M and N and smoothing homomorphisms f : H → KL and g : J → MN such that K ∈ t F , L ∈ u F , M ∈ v F and N ∈ w F . Hence there is a smoothing homomorphisms from G to (KL) (MN). Observe that the function on vertices defined such that ((v, x), y) → ((v, y), x) is a smoothing homomorphism from (KL) (MN) to (K M) (L N). Hence there exists a smoothing homomorphism from</p><formula xml:id="formula_50">G to (K M) (L N). Since, K M ∈ t u F and L N ∈ v w F , we have that (K M) (L N) ∈ (t u) • (v w) F . Hence G ∈ (t u) • (v w) F . Thereby (t • v) (u • w) F F (t u) • (v w) F .</formula><p>For completeness, we require the following lemma. This lemma concerns restricted trees called codot terms <ref type="bibr" target="#b12">[13]</ref>. Codot terms are formed from the grammar t £ ¢ ¡ a | t t | t•t using only conjunctive and sequential refinement, without disjunctive refinement. The direction of smoothing homomorphisms in this lemma is opposite to the corresponding case for the established construction for ideals, accounting for the direction of smoothing homomorphisms in the definition of filters.</p><p>Lemma 27. For codot terms t and v, there exist labelled series-parallel graphs G and H such that φ({G}) = t F and φ({H}) = v F . Furthermore, if t F ⊆ v F then there exists a smoothing homomorphism from G to H.</p><p>The above lemma is used in the proof of the following result that also concerns only codot terms. Other than the direction of smoothing homomorphisms in the above lemma, the details of the proof are identical to the proof of the corresponding lemma for the ideal construction <ref type="bibr" target="#b12">[13]</ref>.</p><p>Lemma 28. If t and v are codot terms, if t F ⊆ v F then either t F = v F or there exists a codot term u such that t F ⊆ u F and u F ⊂ v F and u F v.</p><p>Completeness of the filter semantics follows from the above lemma by the following argument. In the following,</p><formula xml:id="formula_51">1≤i≤m t i represents t 1 t 2 . . . t m .</formula><p>Theorem 29 (Completeness). Given two causal attack trees t and u, if t F ⊆ u F then t F u.</p><p>Proof. Consider causal attack trees such that t F ⊆ u F . Observe that, due to the distributivity of over both and •, there exist codot terms t i , for 1 ≤ i ≤ m and u j for 1 ≤ j ≤ n such that t F 1≤i≤m t i and u = 1≤ j≤n u j and 1≤i≤m t i F ⊆ 1≤ j≤n u j F . For each i, t i F ⊆ 1≤i≤n t i F = t F hence t i F ⊆ u F . Observe, that by Lemma 27 there exists labelled series-parallel graph G such that φ({G}) = t i F hence, since</p><formula xml:id="formula_52">t i F ⊆ u F clearly G ∈ u F =</formula><p>1≤ j≤n u j F = 1≤ j≤n u j F ; thereby there exists j such that G ∈ u j F . Since G ∈ u j F clearly φ({G}) ⊆ u j F since u j F is a filter, by Lemma 20; hence t i F ⊆ u j F . By applying Lemma 28 repeatedly, there exists a sequence of terms</p><formula xml:id="formula_53">v i 1 , v i 2 , . . . v i k i such that v i F ⊂ v i +1 F</formula><p>and v i 1 = t i and v i k i = u j and v i F v i +1 . The sequence is finite, since u j is finite and at least one edge is removed at each step. Hence t i F u j , from which </p><formula xml:id="formula_54">t i 1≤k≤n u k F t i u j 1≤k≤n u k F u j 1≤k≤n u k F 1≤k≤n u k , forall i,</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4.">Soundness of Specialisations for Classes of Attribute Domain</head><p>Attribute domains can be checked for soundness with respect to the specialisation preorder defined by the filter and ideal semantics. The choice of semantics depends on how the direction of the preorder for specialising attack trees exchange sequential and conjunctive refinement and also how the interpretation of disjunctive refinement affects the direction of the preorder.</p><p>Attribute domains and interpretation functions are extended to include sequential refinement according to the following definitions.</p><p>Definition 30. Suppose D = (D, f, g, h) is an attribute domain with three binary operators over D. Assume also that ϑ is a valuation mapping basic actions to D. The interpretation function I D ϑ ( • ) from attack trees to D is defined as follows.</p><formula xml:id="formula_55">I D ϑ £ ¢ ¡ a = ϑ( £ ¢ ¡ a ) I D ϑ (t u) = f (I D ϑ (t) , I D ϑ (u)) I D ϑ (t u) = g(I D ϑ (t) , I D ϑ (u)) I D ϑ (t • u) = h(I D ϑ (t) , I D ϑ (u))</formula><p>As for attack trees, we say that a semantics given by a specialisation preorder is sound with respect to an attribute domain D ordered by ≤ D , whenever for all causal attack trees t and u and valuations ϑ, if t u then I D ϑ (t)</p><formula xml:id="formula_56">≤ D I D ϑ (u).</formula><p>Now consider the attribute domain A = (N, min, +, max), which can represent the minimum number of experts required to perform an attack. This attribute domain assumes concurrent actions must be performed independently by separate experts, as indicated by the interpretation of conjunctive refinement as addition. Observe that the interpretation of sequential and conjunctive refinement distribute over each other as follows:</p><formula xml:id="formula_57">I A ϑ ((t • u) (v • w)) = max I A ϑ (t) , I A ϑ (u) + max I A ϑ (v) , I A ϑ (w) ≥ max I A ϑ (t) + I A ϑ (v) , I A ϑ (u) + I A ϑ (w) = I A ϑ ((t v) • (u w))</formula><p>Also notice that, for numbers m and n, m ≥ n whenever min(m, n) = n. Hence, since t F u is defined such that t u F u, clearly I A ϑ (t u) = I A ϑ (u), if and only if min</p><formula xml:id="formula_58">I A ϑ (t) , I A ϑ (u) = I A ϑ (u), if and only if I A ϑ (t) ≥ I A ϑ (u)</formula><p>. This leads us to the following property, indicating that attribute domain A is sound with respect to the filter semantics.</p><p>Proposition 31. For causal attack trees t and u, for all ϑ, if t F u then I A ϑ (t) ≥ I A ϑ (u).</p><p>In contrast, the attribute domain B = (R, min, max, +) is sound with respect to the ideal based semantics. This domain can represent the minimum time required to complete some attack, where instead sequential refinement is interpreted using +. Consequently, the direction in which sequential and conjunctive refinement distribute over each other is reversed with respect to the numerical ordering as follows</p><formula xml:id="formula_59">I B ϑ ((t v) • (u w)) ≥ I B ϑ ((t • u) (v • w))</formula><p>. This leads us to the following property, indicating that attribute domain B is sound with respect to the ideal semantics.</p><p>Proposition 32. For causal attack trees t and u, for all ϑ, if t I u then</p><formula xml:id="formula_60">I B ϑ (u) ≥ I B ϑ (t).</formula><p>Notice that in both attribute domains the interpretation of disjunctive refinement can be switched to max, to obtain two further domains. The domain C = (N, max, +, max) can be used to measure the "required number of experts on duty to counter any attack". This attribute domain is sound with respect to the ideal semantics, but with respect to reverse numerical order as follows.</p><p>Proposition 33. For causal attack trees t and u, for all ϑ, if t</p><formula xml:id="formula_61">I u then I C ϑ (t) ≤ I C ϑ (u).</formula><p>Similarly, the domain E = (R, max, max, +) could represent the "time required to make all attacks possible", and is sound with respect to the filter semantics, as follows.</p><p>Proposition 34. For causal attack trees t and u, for all ϑ, if t F u then</p><formula xml:id="formula_62">I E ϑ (t) ≤ I E ϑ (u).</formula><p>Action refinement in terms of sound attribute domains. Recall that nodes in a causal attack tree represent the refinement of a basic action into multiple sub-goals. Therefore, any semantics for causal attack trees should accommodate what is known as action refinement <ref type="bibr" target="#b14">[15]</ref> in the process calculus literature. Action refinement can be expressed as a special attribute domain T = (T, , , •), where the domain T is the space of all causal attack trees and each of conjunctive, disjunctive and sequential refinement are interpreted using themselves. Each valuation in this attribute domain defines an action refinement. Thereby, soundness of a semantics with respect to action refinement is expressed as follows.</p><p>Proposition 35. For any causal attack trees t and u and valuation ϑ mapping basic actions to T, if t u then I T ϑ (t) I T ϑ (u), where ∈ { F , I }.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Logical Systems for Specialising Causal Attack Trees</head><p>For attack trees, the multiset semantics coincide with implication for an embedding of attack trees in linear logic. A natural extension of this observation is to consider whether the ideal and filter semantics, introduced in the previous section for causal attack trees, have an underlying logical system. A logical system sound with respect to each of the ideal and filter semantics is indeed enabled by an extension of linear logic with a non-commutative operator, called MAV <ref type="bibr" target="#b7">[8]</ref>. We briefly introduce the system MAV, which is expressed using a generalisation of the sequent calculus, called the calculus of structures. We then return to motivating examples from earlier in the paper, and demonstrate how the logical system can be used to decide whether one causal attack tree specialises another causal attack tree.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.">A Conservative Extension of MALL with Sequential Composition</head><p>MAV is an extension of MALL with a non-commutative operator called seq (";"). Seq was introduced in the system BV <ref type="bibr" target="#b6">[7]</ref>, which is a subsystem of MAV. The following grammar defines propositions. Observe that we write propositions in negation normal form, where linear negation is pushed to the atomic propositions. The operators and &amp; are de Morgan dual to ⊗ and ⊕ respectively, while seq and the unit are self-dual, as defined by the following function from propositions to propositions.</p><formula xml:id="formula_63">a = a I = I (P ⊗ Q) = P Q (P Q) = P ⊗ Q P ; Q = P ; Q (P ⊕ Q) = P &amp; Q (P &amp; Q) = P ⊕ Q</formula><p>The semantics of MAV is defined by a term rewriting system modulo an equational theory. The rewrite rules and equational theory are presented in Fig. <ref type="figure" target="#fig_9">10</ref>. All rules can be applied in any context, where a context C{ } is a proposition with one hole { • } in which any proposition can be plugged, as defined by the following grammar: C{ } { • } | P C{ } | C{ } P, where ∈ {;, , ⊗, ⊕, &amp;}. We also have the following congruence relation that serves a similar role to the exchange rule in the sequent calculus. The main difference compared to sequents is that structural rules reordering propositions can be applied deep within any context. The equational system ensures that (P, ;, I) is a monoid, and both (P, , I) and (P, ⊗, I) are commutative monoids.</p><formula xml:id="formula_64">(P Q) R ≡ P (Q R) P Q ≡ Q P P I ≡ P (P ⊗ Q) ⊗ R ≡ P ⊗ (Q ⊗ R) P ⊗ Q ≡ Q ⊗ P P ⊗ I ≡ P (P ; Q) ; R ≡ P ; (Q ; R) I ; P ≡ P P ; I ≡ P</formula><p>In the calculus of structures, a proof is a derivation that reduces to the unit, where the unit represents a successfully completed proof. Rewrite relation -→ denotes its own reflexive and transitive closure.</p><p>I &amp; I -→ I tidy a a -→ I atomic interaction Definition 36. A derivation P -→ Q is any sequence of Fig. <ref type="figure" target="#fig_9">10</ref>, modulo the structural congruence ≡. For any proposition P, if there exists a derivation of the form P -→ I, then we write P, and say that P is provable. Linear implication in MAV, written P Q, is defined by P Q.</p><formula xml:id="formula_65">(P ⊗ Q) R -→ P ⊗ (Q R) switch (P ; Q) (R ; S ) -→ (P R) ; (Q S ) sequence P ⊕ Q -→ P left P ⊕ Q -→ Q right (P &amp; Q) R -→ (P R) &amp; (Q R) external (P ; Q) &amp; (R ; S ) -→ (P &amp; R) ; (Q &amp; S ) medial</formula><p>An established result <ref type="bibr" target="#b7">[8]</ref>, is a generalisation of cut elimination to the setting of MAV, which implies the transitivity of implication and consistency of MAV.</p><p>Theorem 37 (Cut elimination, Horne 2015). For any proposition P, if C P ⊗ P , then C{ I }.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.">Embeddings of Causal Attack Trees in Non-Commutative Logic</head><p>The logical system MAV provides us with methods for deciding whether one tree is a specialisation of another according to the ideal and filter semantics. Recall that a fragment of MALL coincides with the multiset semantics for attack trees. Since MAV is a conservative extension of MALL with a sequential operator, which models the causal order of events, MAV is a natural setting for systematising the semantics for causal attack trees. This section highlights that the two semantics for causal attack trees, the ideal and filter semantics, can be systematised soundly by two fragments of MAV. The first logical system, which will be used to systematise the ideal semantics for causal attack trees, is defined as follows.</p><p>Definition 38 (ideal system). The ideal system is defined by the following function from causal attack trees to propositions.</p><formula xml:id="formula_66">£ ¢ ¡ a LI = a t u LI = t LI ⊕ u LI t u LI = t LI u LI t • u LI = t LI ; u LI</formula><p>The systematisation of filters expressed using MAV is defined as follows. Notice that the operator ⊗ is used for filters, as opposed to in the system for ideals, to interpret conjunctive refinement.</p><p>Definition 39 (filter system). The filter system is defined by the following function from causal attack trees to propositions.</p><formula xml:id="formula_67">£ ¢ ¡ a LF = a t u LF = t LF ⊕ u LF t u LF = t LF ⊗ u LF t • u LF = t LF ; u LF</formula><p>Before proving that the ideal and filter systems are sound for their respective semantics, we provide some examples. These examples demonstrate how the logical system can be used to check when one causal attack tree soundly specialises another.</p><p>Recall the motivating examples in Section 2. In Section 2, we claim that the attack tree in Fig. <ref type="figure" target="#fig_1">2</ref> is a specialisation of Fig. <ref type="figure" target="#fig_0">1</ref> for both attribute domains presented. The causal attack tree from Fig. <ref type="figure" target="#fig_0">1</ref> is recalled below, using the syntax of causal attack trees.</p><formula xml:id="formula_68">£ ¢ ¡ bribe £ ¢ ¡ steal £ ¢ ¡ break in • £ ¢ ¡ install</formula><p>For convenience, we also recall the causal attack tree from Fig. <ref type="figure" target="#fig_1">2</ref>.</p><formula xml:id="formula_69">£ ¢ ¡ bribe £ ¢ ¡ break in • £ ¢ ¡ install £ ¢ ¡ break in • £ ¢ ¡ steal £ ¢ ¡ install</formula><p>Notice we abbreviate the labels for basic actions to aid the readability of propositions below.</p><p>By Proposition 32 the ideal semantics is sound with respect to the "minimum attack time" attribute domain. Thus, to check the soundness of the specialisation of Fig. <ref type="figure" target="#fig_0">1</ref> to Fig. <ref type="figure" target="#fig_1">2</ref> for the "minimum attack time" attribute domain, it is sufficient to establishing the following implication between embedding of Fig. <ref type="figure" target="#fig_1">2</ref> and Fig. <ref type="figure" target="#fig_0">1</ref> according to the ideal system.</p><p>(bribe (break in ; install)) ⊕ (break in ; (steal install))</p><p>(bribe ⊕ steal) (break in ; install)</p><p>The proof of the above implication, as a derivation using the rules of MAV to I, is presented in Fig. <ref type="figure" target="#fig_10">11</ref>.</p><p>(  The motivating section also claims that Fig. <ref type="figure" target="#fig_0">1</ref> soundly specialises Fig. <ref type="figure" target="#fig_1">2</ref> with respect to the "minimum number of experts" attribute domain. By Proposition 31, the filter semantics is sound with respect to the "minimum number of experts" attribute domain. Hence we can formally verify the claim using the filter system, by establishing the following implication.</p><p>(bribe ⊕ steal) ⊗ (break in ; install) (bribe ⊗ (break in ; install)) ⊕ (break in ; (steal ⊗ install))</p><p>Observe that the order of the implication between the embedding of the trees is opposite to the direction for the ideal semantics. This is reflected in the reversal of the preorder of the "minimum number of experts" attribute domain compared to the "minimum attack time" attribute domain in the worked example in Section 2. Furthermore, the proof of the implication is quite different, hence this implication holds for different reasons for the filter system compared to the ideal system. Recall that the tree in Fig. <ref type="figure" target="#fig_2">3</ref>(a) is a sound specialisation of Fig. <ref type="figure" target="#fig_1">2</ref> with respect to the "minimum number of experts" attribute domain. This is verified by the following implication, between the filter embeddings of the trees in Fig. <ref type="figure" target="#fig_2">3(a)</ref> and Fig. <ref type="figure" target="#fig_1">2</ref>. steal ⊗ (break in ; install) (bribe ⊗ (break in ; install)) ⊕ (break in ; (steal ⊗ install))</p><p>In contrast, there is no sound specialisation, in either direction, between the embedding of the same trees according to the ideal system. However, Fig. <ref type="figure" target="#fig_2">3</ref>(b) does soundly specialise Fig. <ref type="figure" target="#fig_0">1</ref> according to the "minimum attack time" attribute domain. This is verified by the following implication, between the ideal embedding of the trees in Fig. <ref type="figure" target="#fig_2">3</ref>(b) and Fig. <ref type="figure" target="#fig_0">1</ref>.</p><p>(bribe ⊕ steal) (break in ; install) break in ; (steal install)</p><p>Notice that there is no proof in MAV of either implication between the filter embedding of Fig. <ref type="figure" target="#fig_2">3</ref>(b) and Fig. <ref type="figure" target="#fig_0">1</ref>. Since MAV is decidable, a decision procedure can be extracted from the deductive system, which can be used as the basis of a tool for automatically checking such scenarios.</p><p>Soundness of each logical system. Each logical embedding of attack trees is sound with respect to its corresponding semantics. To establish the soundness of the filter semantics we require the following lemmas. The proof exploits the fact that a derivation beginning with a linearly negated embedding of a causal attack tree in the filter system uses only rules that are sound with respect to the filter semantics; hence is established by induction over the length of a deriation.</p><p>Lemma 40. If t LF -→ Q, then there exists u such that Q ≡ u LF and t F ⊆ u F .</p><p>Proof. Proceed by induction over the length of the derivation. The base case, t LF ≡ Q follows since conjunctive refinement is associative and commutative, sequential refinement is associative, and all units can be removed from to obtain an embedding of a causal attack trees. For the inductive cases, the only rules of MAV (from Fig. <ref type="figure" target="#fig_9">10</ref>) that can be applied in a derivation are the sequence, external and medial rules.</p><formula xml:id="formula_70">Assume that s LF -→ C{ (t • u) (v • w) } LF = C t LF ; u LF v LF ; w LF holds such that s F ⊆ C{ (t • u) (v • w) } F . Suppose that the sequence rule is applied as follows. C t LF ; u LF v LF ; w LF -→ C t LF v LF ; u LF ; w LF = C{ (t v) • (u w) } LF Since C{ (t • u) (v • w) } F C{ (t v) • (u w) } and preorder F is sound with respect to the filter semantics the inclusion C{ (t • u) (v • w) } F ⊆ C{ (t v) • (u w) } F holds. Thereby s F ⊆ C (t v) • (u w) LF F as required.</formula><p>The three other cases for the sequence rule are similar, except that unit propositions are introduced then removed when deriving the remaining inequalities relating conjunctive and sequential refinement.</p><p>Assume</p><formula xml:id="formula_71">s LF -→ C (t u) v LF = C t LF &amp; u LF v LF and s F ⊆ C (t u) v LF F</formula><p>. Suppose that the external rule is applied as follows.</p><formula xml:id="formula_72">C t LF &amp; u LF v LF -→ C t LF v LF &amp; u LF v LF = C{ (t v) (u v) } LF Since C (t u) v LF F C{ (t v) (u v)</formula><p>} holds and F is sound with respect to the filter semantics the inclusion C (t u) v LF F ⊆ C{ (t v) (u v) } F holds. Thereby s F ⊆ C{ (t v) (u v) } F as required. The case for the medial rule follows similarly, observing that (t • v) (v • w) F (t u) • (v w) is derivable using the distributivity of • and idempotency of .</p><p>The proof of the following lemma is similar to the above except that for the ideal embedding only the sequence, left and right rules need to be considered. All three rules respect the converse of subset inclusion for ideals.</p><p>Lemma 41. If t LI -→ Q, there exists u such that Q ≡ u LI and t I ⊆ u I .</p><p>The proofs rely on the following definition and lemma, which is used for proving cut elimination for MAV (Theorem 37) proven in related work <ref type="bibr" target="#b7">[8]</ref>.</p><p>Definition 42. An n-ary killing context T { } is a context with n holes such that:</p><formula xml:id="formula_73">• if n = 1, then T { } = { • } where { • }</formula><p>is a hole into which any proposition can be plugged;</p><p>• if m ≥ 1 and n ≥ 1, then if T 0 { } is an m-ary killing context and T 1 { } is an n-ary killing context, then</p><formula xml:id="formula_74">T 0 { } &amp; T 1 { } is an (m + n)-ary killing context.</formula><p>The following lemma is used to reorganise proofs to simulate the application of rules as in the sequent calculus, in the more general setting of the calculus of structures. This lemma is required to guide the induction in the theorems that follow.</p><p>Lemma 43 (Splitting). The following statements hold.</p><p>• If (P ⊗ Q) R, then there exist propositions V i and W i such that P V i and Q W i , where 1 ≤ i ≤ n, and n-ary killing context</p><formula xml:id="formula_75">T { } such that R -→ T { V 1 W 1 , . . . , V n W n }.</formula><p>• If (P ; Q) R, then there exist propositions V i and W i such that P V i and Q W i , where 1 ≤ i ≤ n, and n-ary killing context T { } such that R -→ T { V 1 ; W 1 , . . . , V n ; W n }.</p><p>• If (P ⊕ Q) R, then there exist propositions V i such that either P V i or Q V i , where 1 ≤ i ≤ n, and n-ary killing context T { } such that R -→ T { V 1 , . . . , V n }.</p><p>• If a U, then there exists n-ary killing context T { } such that U -→ T { a, . . . , a }.</p><p>• If a U, then there exists n-ary killing context T { } such that U -→ T { a, . . . , a }.</p><p>• If (P &amp; Q) R then both P R and Q R hold.</p><p>The soundness result for the logical embedding • LF with respect to the filter semantics, is established by the following theorem. The proof idea is that, since causal attack trees are encoded using only ⊗, ⊕ and ;, we can always apply a technique called splitting, developed to prove Theorem 37, to reorganise a proof around the structure of the causal attack tree, such that the soundness of the attack tree depends on the soundness of smaller sub-trees. Furthermore, Lemma 40 ensures that the steps taken to reorganise the proof are also sound. Thereby the proof proceeds by induction on the structure of the attack tree in the conclusion of the implication.  </p><formula xml:id="formula_76">⊆ £ ¢ ¡ a £ ¢ ¡ a . . . £ ¢ ¡ a F . Now £ ¢ ¡ a £ ¢ ¡ a . . . £ ¢ ¡ a F = £ ¢ ¡ a F from</formula><formula xml:id="formula_77">i F ⊆ u F or w i F ⊆ v F hence w i F ⊆ u F ∪ v F = u v F ,</formula><p>for all i, and thereby w 1 w 2 . . . w n F ⊆ u v F . From the above t F ⊆ u v F as required. This covers all constructs, thereby the result follows by induction on the structure of the causal attack tree in the conclusion of the linear implication.</p><p>The soundness result for the logical embedding This covers all constructs, thereby the result follows by induction on the structure of the causal attack tree in the conclusion of the linear implication.</p><p>Partial distribution of seq over disjunctive refinement. The two logical systems, defined using embeddings of causal attack trees as propositions in MAV, are subtly finer than their respective graph-based semantics. The logical systems can be regarded as a semantics for causal attack trees, while the graph-based semantics can, by Theorems 44 and 45, be considered to be sound attribute domains for the respective logical semantics.</p><p>Although the logical systems are not complete for their corresponding graph-based semantics in this paper, tighter graph-based semantics can be devised. Objectively speaking, MAV is fundamentally consistent, due to cut elimination (Theorem 37); whereas we are unaware of an objective justification for the graph-based semantics in Defs. 23 and 24. Subjectively speaking, an operational interpretation of attack trees, discussed in this section, justifies the partial distributivity properties.</p><p>To see why partial distributivity is desirable, consider the following attack:</p><formula xml:id="formula_78">£ ¢ ¡ descend into vault • § ¦ ¤ ¥ override using laptop £ ¢</formula><p>¡ smash with hammer which suggests that the attacker descends into the vault and then decides whether to access a safe by either using a laptop or a hammer. Contrast the above intuition to the following specialised causal attack tree. The causal attack tree above suggests that the attacker commits to packing either a laptop or a hammer, but not necessarily both, when they set off to descend into the vault. The subtlety in these scenarios is, when reading operationally, the point at which choices are made between disjunctively refined sub-goals affect the success of the attack. The reader familiar with branching time equivalences, such as bisimulation, will observe a similarity in reasoning. Observe that the above argument works both backwards and forwards along the causal link indicated by the sequential operator.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Future Work</head><p>We have demonstrated that the logical system MAV can be used to provide a semantics for specialising causal attack trees. This observation opens up several avenues of investigation regarding the semantics of variants of attack trees using fragments and extensions of MAV.</p><p>Attack-defense trees not only capture the goals of attackers, but also countermeasures to defend against an attack, and possibly further counterattacks. Attack-defense trees have been provided with a multiset semantics <ref type="bibr" target="#b15">[16]</ref>, that, as for attack trees, coincides with the positive propositions in linear logic. Thus the multiset semantics for attack-defense trees can be captured using linear logic. However, attack-defense trees can be equipped with a wide range of attribute domains <ref type="bibr" target="#b10">[11]</ref>, some of which could benefit from a different fragment of linear logic than the positive fragment only. We envision a thorough analysis of the relationship between attack-defense trees with various assignments of linear logic operators to nodes, and attributes that are compatible with such assignments. Related work <ref type="bibr" target="#b16">[17]</ref>, exploring attack-defense trees with sequential refinement operators, would be suited to a semantics using MAV.</p><p>The study of the system MAV was instigated when investigating provenance diagrams with a "was derived from" relation <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b17">18]</ref>. The "was derived from" relation in provenance diagrams indicates "artefacts" that were used to produce another artefact. For example, in a database transaction, a value written may depend on other values that were read. The "was derived from" relation should respect causality, since only artefacts that contributed to the creation of an artefact should be indicated, rather than recording a snapshot of the state of the entire system. The semantics for causal attack trees in this work are also relevant as semantics for provenance diagrams. Both "why" provenance and "how" provenance <ref type="bibr" target="#b18">[19]</ref> can be captured, where "why" provenance is given by "was derived from" corresponding to sequential refinement, and "how" provenance is given by provenance semirings <ref type="bibr" target="#b19">[20]</ref> captured by conjunctive and disjunctive refinement. Attack trees and provenance diagrams are closely related, since both profile processes. Future work includes establishing the common semantic foundations and applications for attack trees and provenance diagrams.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Conclusion</head><p>This work introduces two semantics for causal attack trees, which are attack trees extended with sequential refinement. The limitation of semantics previously proposed based on sets of series-parallel graphs is that, while equality of causal attack trees can be assessed, such a semantics is not suitable for defining a preorder over causal attack trees. A preorder is useful for scenarios where two trees are not equivalent, but one is a specialisation of the other. This work identifies the notion of specialising attack trees as being central to attack tree methodology: attack trees evolve as more knowledge is gathered; or are pruned for more specific scenarios.</p><p>More than one semantics for specialising causal attack trees is required since different attribute domains can give rise to distinct algebraic properties. The semantics proposed in this paper are referred to as the ideal semantics and filter semantics for specialisation. Both semantics proposed in this paper close sets of series-parallel graphs using "smoothing" homomorphisms, Def. 16, that permit causal dependencies to be strengthened. Both semantics have a sound and complete axiomatisation, given by Theorems 25, 26 and 29. The first theorem is an established result for pomsets, while the later two are technical contributions of this paper.</p><p>For both semantics a logical system is introduced. Each logical system is shown to be sound with respect to the corresponding semantics, by Theorems 44 and 45. The definitions, algebra and logical systems corresponding to each of the two semantics are summarised in the table below.</p><p>name of class semantics sound and complete algebra sound logical system ideal semantics I Def. 23 I Thm. 25 LI Def. 38 Thm. 45 filter semantics F Def. 24 F Thms. 26 and 29 LF Def. 39 Thm. 44 The above results are key for recommending the methodology of specialising attack trees. Given two causal attack trees, a tool can be used to embed the trees in the logical system and thereby determine whether they are related. For example, in the case of the ideal semantics, for causal attack trees t and u, if t LI u LI holds, then by Theorem 45 and Theorem 25, both t I u and t I ⊆ u I hold. Thus t is a sound specialisation of u for attribute domains respecting the ideal semantics. For instance, t is a sound specialisation of u for both the attribute domains "minimum attack time" and "guards to counter all attacks". Examples of attribute domains that are sound for each semantics are presented in the table below. ideal semantics filter semantics "minimum attack time" Prop. 32 "minimum number of experts required" Prop. 31 "guards to counter attacks" Prop. 33 "time to make attacks possible" Prop. 34 The above list of attribute domains respecting the ideal and filter semantics is far from being exhaustive. Note, for some useful attribute domains, such as those involving probabilities, finer algebraic properties hold, emphasising the need for a sound methodology for specialising attack trees.</p><p>Both logical systems are defined using fragments of MAV, which extends linear logic with a non-commutative operator modelling causal dependencies. Thus the results summarised in the tables above are natural extensions of observations regarding the multiset semantics for attack trees (Definition 1), linear logic (Theorem 7) and commutative idempotent semirings (Proposition 12). All semantics in this work permit action refinement (Proposition 35). Action refinement is central to the attack tree methodology, permitting a basic action to be replaced with a tree of sub-goals.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Attack tree for accessing encrypted data.</figDesc><graphic coords="3,120.48,148.14,354.33,117.76" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Specialised causal attack tree where the backup can only be stolen from inside the system.</figDesc><graphic coords="3,119.56,413.59,356.14,138.41" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Two causal attack trees: (a) is a sound specialisation of Fig. 2 with respect to "minimum number of experts"; (b) is a sound specialisation of Fig. 1 with respect to "minimum attack time".</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Example of evolving attack tree, indicating two refinement steps for goal "disrupt security training".</figDesc><graphic coords="6,279.08,114.69,198.00,92.34" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Sequent calculus for MALL</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: Equational axioms for sequential refinement.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 8 :</head><label>8</label><figDesc>Figure 8: Causal attack trees unrelated by the intermediate semantics, but related for ideals ( I ) and filters ( F ).</figDesc><graphic coords="15,188.48,223.59,298.02,99.53" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 9 :</head><label>9</label><figDesc>Figure 9: Inequational axioms for the exchange of conjunctive and sequential refinement.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>P</head><label></label><figDesc>I | a | a | P P | P ⊗ P | P ⊕ P | P &amp; P | P ; P</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 10 :</head><label>10</label><figDesc>Figure 10: Term rewriting system modulo an equational theory for MAV.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 11 :</head><label>11</label><figDesc>Figure 11: Derivation establishing that Fig. 2 specialises Fig. 1 in the ideal semantics.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>Figure 6: The identities of a commutative idempotent semiring ( ) closed under congruence.Lemmas 4 and 6 establish that, for positive propositions, the multiset semantics coincides with entailment in linear logic, as summarised by the following theorem.Theorem 7. Given attack trees t and u, t M ⊆ u M if and only if t L u L .Proof. Firstly, establish m t L = t M by structural induction over the attack tree. Thereby, for any two attack trees t and u, t M ⊆ u M holds if and only if m t</figDesc><table><row><cell></cell><cell cols="3">defines a semigroup: (t u) v t (u v)</cell></row><row><cell cols="4">defines a commutative semigroup: (t u) v t (u v)</cell><cell>t u u t</cell></row><row><cell></cell><cell cols="3">distributes over : (t u) v (t v) (u v)</cell></row><row><cell cols="4">is commutative and is idempotent: t u u t</cell><cell>t t t</cell></row><row><cell></cell><cell cols="2">• • • m(P n ) ⊆ m(P) and m P 1</cell><cell>• • • m(P n ) ⊆ m(P). The proof in this case is</cell></row><row><cell>constructed as follows:</cell><cell>. . . P 1 , . . . , P n P</cell><cell cols="2">. . . P 1 , . . . , P n P</cell></row><row><cell></cell><cell cols="3">P 1 ⊕ P 1 , . . . , P n P</cell></row><row><cell cols="4">where the premises are provable by applying the induction hypothesis.</cell></row></table><note><p>L ⊆ m u L , where m( • ) is as in Definition 3. By Lemma 4 and Lemma 6, m t L ⊆ m u L if and only if t L u L . Corollary 8. Given attack trees t and u, t M = u M if and only if t L u L and u L t L .</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>Proposition 9. For attack trees t and u, t L u</figDesc><table /><note><p>L if and only if t u. Corollary 10. For attack trees t and u, t L u L and u L t L if and only if t u.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head></head><label></label><figDesc>by definition of F . Furthermore,</figDesc><table><row><cell>1≤i≤k+1 t i</cell><cell>u =</cell><cell>1≤i≤k t i</cell><cell>t k+1 u F</cell><cell>1≤i≤k t i</cell><cell>u and</cell><cell>1≤i≤1 t i</cell><cell>u = t 1 u</cell><cell>u, hence by induction</cell></row><row><cell>1≤i≤m-1 t</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table><note><p>i u u. Therefore t F u.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head></head><label></label><figDesc>↓ by switch rule bribe bribe ⊗ break in ; install (break in ; install) &amp; break in ; steal ⊗ install steal (break in ; install) ↓ by sequence rule bribe bribe ⊗ break in break in ; install install &amp; break in break in ; steal ⊗ install steal install ↓ by switch rule bribe bribe ⊗ break in break in ; install install &amp; break in break in ; steal steal ⊗ install install ↓ by atomic interaction rule I</figDesc><table><row><cell cols="3">bribe (break in ; install)) ⊕ (break in ; (steal install))</cell><cell>(bribe ⊕ steal) (break in ; install)</cell></row><row><cell></cell><cell></cell><cell cols="2">= by de Morgan dualities and definition of implication</cell></row><row><cell cols="3">bribe ⊗ break in ; install &amp; break in ; steal ⊗ install</cell><cell>(bribe ⊕ steal) (break in ; install)</cell></row><row><cell></cell><cell></cell><cell cols="2">↓ by external rule</cell></row><row><cell>bribe ⊗ break in ; install</cell><cell cols="3">(bribe ⊕ steal) (break in ; install) &amp; break in ; steal ⊗ install</cell><cell>(bribe ⊕ steal) (break in ; install)</cell></row><row><cell></cell><cell></cell><cell cols="2">↓ by left and right rules</cell></row><row><cell cols="2">bribe ⊗ break in ; install</cell><cell cols="2">bribe (break in ; install) &amp; break in ; steal ⊗ install</cell><cell>steal (break in ; install)</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head></head><label></label><figDesc>Theorem 44. For causal attack trees t and u, if t LF u LF in MAV then t F ⊆ u F .</figDesc><table><row><cell>Proof. Consider the base case when t LF</cell><cell>£ ¢ ¡ a</cell></row></table><note><p><p>LF</p>, where a is an atomic proposition. By definition, t LF a, hence by Lemma 43, there exists killing context T { } such that t LF -→ T { a, a, . . . , a }. By Lemma 40, t F</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head></head><label></label><figDesc>LF . By definition t LF u LF ⊕ v LF holds hence by Lemma 43 there exist propositions S i such that either S i u LF or S i v LF , for 1 ≤ i ≤ n; and killing context T { } such that the following derivation holds: t LF -→ T S 1 , S 2 , . . . , S n . Hence, there exist w i such that w i LF ≡ S i and w 1 w 2 . . . w n LF ≡ T S 1 , S 2 , . . . , S n , by Lemma 40; and furthermore t F ⊆ w 1 w 2 . . . w n F . As the induction hypothesis, assume that either w</figDesc><table><row><cell>Consider the case when</cell><cell>t LF</cell><cell>u v</cell></row><row><cell></cell><cell></cell><cell>the definitions. Hence t F ⊆</cell><cell>£ ¢ ¡ a</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8"><head></head><label></label><figDesc>• LI with respect to the ideal semantics is established by a similar technique to the above theorem. Notice that there are no &amp; operators in t LI and no rule of MAV can introduce &amp; operators during proof search. This simplifies the proof, since splitting is applied with respect to the trivial context with one hole and no &amp; operators. Theorem 45. For causal attack trees t and u, if t LI u LI in MAV then t I ⊆ u I . LF a and observe that there are no &amp; operators in t LF . Hence, by Lemma 43, t LF -→ a. By Lemma 41, LF . By definition, t LF u LF ⊗ v LF , hence by Lemma 43 there exist propositions R 1 and R 2 such that R 1 u LF and R 2 v LF , for 1 ≤ i ≤ n, and the following derivation holds: tLF -→ R 1 R 2 .Hence, by Lemma 41, there exist w 1 and w 2 such that w 1 LF = R 1 and w 2 LF = R 2 and R 1 R 2 ≡ w 1 w 2 LF and furthermore w 1 w 2 I ⊆ t I . As the induction hypothesis, assume that u I ⊆ w 1 I and v I ⊆ w 2 I . Thereby we have that u v I ⊆ w 1 w 2 I . Thereby u • v I ⊆ t I , as required. The case for sequential refinement is similar. LF holds. As the induction hypothesis, assume that both u I ⊆ t I and v I ⊆ t I . Thereby u v I = u I ∪ v I ⊆ t I , as required.</figDesc><table><row><cell cols="3">Proof. Consider the base case when t LF as required.</cell><cell>£ ¢ ¡ a</cell><cell></cell><cell>£ a ¢ ¡</cell><cell>I</cell><cell>⊆ t I ,</cell></row><row><cell cols="5">Consider the case when u v Consider the case when t LF t LF u v LF . By definition</cell><cell>t LF</cell><cell>u LF &amp; v LF holds hence by</cell></row><row><cell>Lemma 43 there</cell><cell>t LF</cell><cell>u LF or</cell><cell>t LF</cell><cell>v</cell></row></table><note><p><p>LF</p>, where a is an atomic proposition. By definition, t</p></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>c</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2016" xml:id="foot_1"><p>This manuscript version is made available under the CC-BY-NC-ND 4.0 license. This is a technical report supporting journal article: Semantics for Specialising Attack Trees based on Linear Logic. Fundamenta Informaticae 153 (2017) 57-86. DOI:10.3233/FI-2017-1531. IOS Press. Corresponding author: Ross Horne.Email address: rhorne@ntu.edu.sg (Ross Horne)</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div><head>Acknowledgment</head><p>Horne and Tiu receive support from <rs type="funder">MOE</rs> <rs type="grantNumber">Tier 2</rs> grant <rs type="grantNumber">MOE2014-T2-2-076</rs>. Tiu receives support from the <rs type="funder">National Research Foundation Singapore</rs> under its <rs type="programName">National Cybersecurity R&amp;D Program</rs> (Award No. <rs type="grantNumber">NRF2014NCR-NCR001-30</rs>). Mauw received funding from the <rs type="funder">Fonds National de la Recherche Luxembourg</rs>, grant <rs type="grantNumber">C11/IS/1183245</rs> (<rs type="grantNumber">ADT2P</rs>), and the <rs type="funder">European Commissions Seventh Framework Programme</rs> (FP7/2007-2013) under grant agreement number <rs type="grantNumber">318003</rs> (TREsPASS).</p></div>
			</div>
			<listOrg type="funding">
				<org type="funding" xml:id="_nYXu8E3">
					<idno type="grant-number">Tier 2</idno>
				</org>
				<org type="funding" xml:id="_BxurYBN">
					<idno type="grant-number">MOE2014-T2-2-076</idno>
					<orgName type="program" subtype="full">National Cybersecurity R&amp;D Program</orgName>
				</org>
				<org type="funding" xml:id="_e3BpGfP">
					<idno type="grant-number">NRF2014NCR-NCR001-30</idno>
				</org>
				<org type="funding" xml:id="_ZEUejUZ">
					<idno type="grant-number">C11/IS/1183245</idno>
				</org>
				<org type="funding" xml:id="_z74TnSj">
					<idno type="grant-number">ADT2P</idno>
				</org>
				<org type="funding" xml:id="_E4wuGqG">
					<idno type="grant-number">318003</idno>
				</org>
			</listOrg>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Hence, by Lemma 40, there exist w i 1 and w i 2 such that w i</p><p>for all 1 ≤ i ≤ n, and the following equivalence holds.</p><p>. As the induction hypothesis, assume that w i </p><p>Hence, by Lemma 40, there exist w i 1 and w i 2 such that w i</p><p>for all 1 ≤ i ≤ n, and the following equivalence holds.</p><p>. As the induction hypothesis, assume that w i </p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Attack trees. Dr Dobb&apos;s journal</title>
		<author>
			<persName><forename type="first">B</forename><surname>Schneier</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="page" from="21" to="29" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Attack trees with sequential conjunction</title>
		<author>
			<persName><forename type="first">R</forename><surname>Jhawar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Kordy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Mauw</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Radomirović</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Trujillo-Rasua</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IFIPSec&apos;15</title>
		<meeting>IFIPSec&apos;15</meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="volume">455</biblScope>
			<biblScope unit="page" from="339" to="353" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Foundations of attack trees</title>
		<author>
			<persName><forename type="first">S</forename><surname>Mauw</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Oostdijk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ICISC&apos;05</title>
		<meeting>ICISC&apos;05</meeting>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="volume">3935</biblScope>
			<biblScope unit="page" from="186" to="198" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Runtime Monitoring and Dynamic Reconfiguration for Intrusion Detection Systems</title>
		<author>
			<persName><forename type="first">M</forename><surname>Rehák</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. RAID&apos;09</title>
		<meeting>RAID&apos;09</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="volume">5758</biblScope>
			<biblScope unit="page" from="61" to="80" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">ADTool: Security Analysis with Attack-Defense Trees</title>
		<author>
			<persName><forename type="first">B</forename><surname>Kordy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Kordy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Mauw</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Schweitzer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. QEST&apos;13</title>
		<meeting>QEST&apos;13</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="volume">8054</biblScope>
			<biblScope unit="page" from="173" to="176" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Linear logic. Theoretical computer science</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">Y</forename><surname>Girard</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1987">1987</date>
			<biblScope unit="volume">50</biblScope>
			<biblScope unit="page" from="1" to="101" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">A system of interaction and structure</title>
		<author>
			<persName><forename type="first">A</forename><surname>Guglielmi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Computational Logic</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page">1</biblScope>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">The Consistency and Complexity of Multiplicative Additive System Virtual</title>
		<author>
			<persName><forename type="first">R</forename><surname>Horne</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Scientific Annals of Computer Science</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page">245</biblScope>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Serial Model for Attack Tree Computations</title>
		<author>
			<persName><forename type="first">A</forename><surname>Jürgenson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Willemson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ICISC&apos;09</title>
		<meeting>ICISC&apos;09</meeting>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="volume">5984</biblScope>
			<biblScope unit="page" from="118" to="128" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Logic programming with focusing proofs in linear logic</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Andreoli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Logic and Computation</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="297" to="347" />
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Quantitative questions on Attack-Defense Trees</title>
		<author>
			<persName><forename type="first">B</forename><surname>Kordy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Mauw</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Schweitzer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ICISC&apos;12</title>
		<meeting>ICISC&apos;12</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="volume">7839</biblScope>
			<biblScope unit="page" from="49" to="64" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">The recognition of series parallel digraphs</title>
		<author>
			<persName><forename type="first">J</forename><surname>Valdes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">E</forename><surname>Tarjan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">L</forename><surname>Lawler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. STOC&apos;79</title>
		<meeting>STOC&apos;79</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1979">1979</date>
			<biblScope unit="page" from="1" to="12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">The equational theory of pomsets</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">L</forename><surname>Gischer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theor Comput Sci</title>
		<imprint>
			<biblScope unit="volume">61</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="199" to="224" />
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">A provenance tracking model for data updates</title>
		<author>
			<persName><forename type="first">G</forename><surname>Ciobanu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Horne</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. FOCLASA&apos;12</title>
		<meeting>FOCLASA&apos;12</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="volume">91</biblScope>
			<biblScope unit="page" from="31" to="44" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Refinement of actions and equivalence notions for concurrent systems</title>
		<author>
			<persName><forename type="first">R</forename><surname>Van Glabbeek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Goltz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Acta Informatica</title>
		<imprint>
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="issue">4-5</biblScope>
			<biblScope unit="page" from="229" to="327" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Attack-Defense trees</title>
		<author>
			<persName><forename type="first">B</forename><surname>Kordy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Mauw</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Radomirović</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Schweitzer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Logic and Computation</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="55" to="87" />
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Quantitative Verification and Synthesis of Attack-Defence Scenarios</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Aslanyan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Nielson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Parker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CSF&apos;16</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="105" to="119" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Provenance as dependency analysis</title>
		<author>
			<persName><forename type="first">J</forename><surname>Cheney</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Ahmed</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><forename type="middle">A</forename><surname>Acar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Mathematical Structures in Computer Science</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="1301" to="1337" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">Provenance in Databases: Why, How, and Where. Foundations and Trends in Databases</title>
		<author>
			<persName><forename type="first">J</forename><surname>Cheney</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Chiticariu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">C</forename><surname>Tan</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="379" to="474" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Provenance semirings</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">J</forename><surname>Green</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Karvounarakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Tannen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. PODS&apos;07</title>
		<meeting>PODS&apos;07</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="31" to="40" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
