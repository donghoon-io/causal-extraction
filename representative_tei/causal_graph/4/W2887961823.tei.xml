<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">A greedy feature selection algorithm for Big Data of high dimensionality</title>
				<funder ref="#_FFu3bAu #_ntNrZ7p">
					<orgName type="full">European Research Council</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability  status="unknown">
					<licence/>
				</availability>
				<date type="published" when="2018-08-07">7 August 2018</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Ioannis</forename><surname>Tsamardinos</surname></persName>
							<email>tsamard.it@gmail.com</email>
							<idno type="ORCID">0000-0002-2492-959X</idno>
							<affiliation key="aff1">
								<orgName type="department">Computer Science Department</orgName>
								<orgName type="institution">University of Crete</orgName>
								<address>
									<settlement>Heraklion</settlement>
									<country key="GR">Greece</country>
								</address>
							</affiliation>
							<affiliation key="aff2">
								<orgName type="institution">Gnosis Data Analysis PC</orgName>
								<address>
									<settlement>Heraklion</settlement>
									<country key="GR">Greece</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Giorgos</forename><surname>Borboudakis</surname></persName>
							<idno type="ORCID">0000-0001-7355-8871</idno>
							<affiliation key="aff1">
								<orgName type="department">Computer Science Department</orgName>
								<orgName type="institution">University of Crete</orgName>
								<address>
									<settlement>Heraklion</settlement>
									<country key="GR">Greece</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Pavlos</forename><surname>Katsogridakis</surname></persName>
							<affiliation key="aff1">
								<orgName type="department">Computer Science Department</orgName>
								<orgName type="institution">University of Crete</orgName>
								<address>
									<settlement>Heraklion</settlement>
									<country key="GR">Greece</country>
								</address>
							</affiliation>
							<affiliation key="aff3">
								<orgName type="department">Institute of Computer Science</orgName>
								<orgName type="institution">Foundation for Research and Technology -Hellas</orgName>
								<address>
									<settlement>Heraklion</settlement>
									<country key="GR">Greece</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Polyvios</forename><surname>Pratikakis</surname></persName>
							<email>polyvios@ics.forth.gr</email>
							<affiliation key="aff1">
								<orgName type="department">Computer Science Department</orgName>
								<orgName type="institution">University of Crete</orgName>
								<address>
									<settlement>Heraklion</settlement>
									<country key="GR">Greece</country>
								</address>
							</affiliation>
							<affiliation key="aff3">
								<orgName type="department">Institute of Computer Science</orgName>
								<orgName type="institution">Foundation for Research and Technology -Hellas</orgName>
								<address>
									<settlement>Heraklion</settlement>
									<country key="GR">Greece</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Vassilis</forename><surname>Christophides</surname></persName>
							<email>vassilis.christophides@inria.fr</email>
							<affiliation key="aff1">
								<orgName type="department">Computer Science Department</orgName>
								<orgName type="institution">University of Crete</orgName>
								<address>
									<settlement>Heraklion</settlement>
									<country key="GR">Greece</country>
								</address>
							</affiliation>
							<affiliation key="aff4">
								<orgName type="institution">INRIA</orgName>
								<address>
									<settlement>Paris</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">Ioannis Tsamardinos</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">A greedy feature selection algorithm for Big Data of high dimensionality</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2018-08-07">7 August 2018</date>
						</imprint>
					</monogr>
					<idno type="DOI">10.1007/s10994-018-5748-7</idno>
					<note type="submission">Received: 14 August 2017 / Accepted: 18 July 2018 /</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.1" ident="GROBID" when="2025-10-14T18:16+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Feature selection</term>
					<term>Variable selection</term>
					<term>Forward selection</term>
					<term>Big Data</term>
					<term>Data analytics</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We present the Parallel, Forward-Backward with Pruning (PFBP) algorithm for feature selection (FS) for Big Data of high dimensionality. PFBP partitions the data matrix both in terms of rows as well as columns. By employing the concepts of p-values of conditional independence tests and meta-analysis techniques, PFBP relies only on computations local to a partition while minimizing communication costs, thus massively parallelizing computations. Similar techniques for combining local computations are also employed to create the final predictive model. PFBP employs asymptotically sound heuristics to make early, approximate decisions, such as Early Dropping of features from consideration in subsequent iterations, Early Stopping of consideration of features within the same iteration, or Early Return of the winner in each iteration. PFBP provides asymptotic guarantees of optimality for data distributions faithfully representable by a causal network (Bayesian network or maximal ancestral graph). Empirical analysis confirms a super-linear speedup of the algorithm with increasing sample size, linear scalability with respect to the number of features and processing cores. An extensive comparative evaluation also demonstrates the effectiveness of PFBP against other algorithms in its class. The heuristics presented are general and could potentially be employed to other greedy-type of FS algorithms. An application on simulated Single Nucleotide Polymorphism (SNP) data with 500K samples is provided as a use case.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>algorithms need to scale not only to millions of training instances (samples, examples) but also millions of predictive quantities (interchangeably called features, variables, or attributes) <ref type="bibr" target="#b88">(Zhao et al. 2013;</ref><ref type="bibr" target="#b86">Zhai et al. 2014;</ref><ref type="bibr">Bolón-Canedo et al. 2015a, b)</ref>. A common way to reduce the data dimensionality consists of selecting only a subset of the original features that retains all of the predictive information regarding an outcome of interest T . Specifically, the objective of the Feature Selection (FS) problem can be defined as identifying a feature subset that is of minimal-size and collectively (multivariately) optimally predictive<ref type="foot" target="#foot_0">foot_0</ref> w.r.t. T .<ref type="foot" target="#foot_1">foot_1</ref> By removing irrelevant as well as redundant (related to the concept of weakly relevant) features <ref type="bibr" target="#b34">(John et al. 1994)</ref>, FS essentially facilitates the learning task. It results in predictive models with fewer features that are easier to inspect, visualize, understand, and faster to apply. Thus, FS provides valuable intuition on the data generating mechanism and is a primary tool for knowledge discovery; deep connections of the solutions to the FS with the causal mechanisms that generate the data have been found <ref type="bibr">(Tsamardinos and Aliferis 2003;</ref><ref type="bibr" target="#b36">Koller and</ref><ref type="bibr">Sahami 1996, Pearl 1988)</ref>. Indeed, FS is often the primary task of an analysis, while predictive modeling is only a by-product.</p><p>Designing a FS algorithm is challenging because by definition it is a combinatorial problem; the FS problem is NP-hard even for linear regression problems <ref type="bibr" target="#b80">(Welch 1982</ref>). An exhaustive search of all feature subsets is impractical except for quite small sized feature spaces. Heuristic search strategies and approximating assumptions are required to scale up FS, ranging from convex relaxations and parametric assumptions such as linearity [e.g., the Lasso algorithm <ref type="bibr" target="#b69">(Tibshirani 1996)</ref>] to causally-inspired, non-parametric assumptions, such as faithfulness of the data distribution to a causal model <ref type="bibr" target="#b56">(Pearl and Verma 1995;</ref><ref type="bibr" target="#b67">Spirtes et al. 2000)</ref>.</p><p>Specifically, in the context of Big Data featuring both high dimensionality and/or high sample volume, computations become CPU-intensive as well as and data-intensive and cannot be handled by a single machine. <ref type="foot" target="#foot_2">3</ref> The main challenges arising in this context are (a) how can data be partitioned both horizontally (over samples) and vertically (over features), called hybrid-partitioning, so that computations can be performed locally in each block and combined globally with a minimal communication overhead; <ref type="bibr">(b)</ref> what heuristics can quickly (e.g., without the need to go through all samples) and safely (providing theoretical guarantees of correctness) eliminate irrelevant and redundant features. Hybrid partitioning over both data samples and learned models <ref type="bibr" target="#b83">(Xing et al. 2016;</ref><ref type="bibr" target="#b42">Lee et al. 2014</ref>) is an open research issue in Big ML algorithms while safe FS heuristics has been proposed only for sparse Big Data <ref type="bibr" target="#b66">(Singh et al. 2009;</ref><ref type="bibr" target="#b60">Ramrez-Gallego et al. 2017)</ref>, i.e., for data where a large percentage of values are the same (typically zeros).</p><p>To address these challenges we introduce the Parallel, Forward-Backward with Pruning (PFBP) algorithm for Big Volume Data. PFBP does not rely on data sparsity and is generally applicable to both dense and sparse datasets; in the future, it could be extended to include optimizations specifically designed for sparse datasets. PFBP is based on statistical tests of conditional independence and it is inspired by statistical causal modeling that represents the joint probability distribution as a causal model and specifically the theory of Bayesian networks and maximal ancestral graphs <ref type="bibr" target="#b55">(Pearl 2000;</ref><ref type="bibr" target="#b67">Spirtes et al. 2000;</ref><ref type="bibr" target="#b61">Richardson and Spirtes 2002)</ref>.</p><p>To tackle parallelization with hybrid partitioning (challenge (a) above), PFBP decisions rely on p-values and log-likelihoods returned by the independence tests computed locally on each data partition; these values are then combined together using statistical meta-analysis techniques to produce global approximate p-values<ref type="foot" target="#foot_3">foot_3</ref> and log-likelihoods. This technique essentially minimizes PFBP's communication cost, as only local p-values and log-likelihoods need to be communicated from workers to the master node in a cluster of machines at each iteration of the algorithm. The idea of combining local statistics to global statistics can also be applied to combining local predictive models trained on the currently selected features, to provide global predictive models. This type of constructing a global predictive modeled is evaluated in the experimental section in the context of logistic regression models.</p><p>To reduce the number and workload of iterations required to compute a FS solution (challenge (b) above), PFBP relies on several heuristics. First, it adapts for Big Data a heuristic called Early Dropping recently introduced in <ref type="bibr" target="#b10">Borboudakis and Tsamardinos (2017)</ref>. Early Dropping removes features from subsequent iterations thus significantly speeding up the algorithm. Then, PFBP is equipped with two new heuristics for Early Stopping of consideration of features within the same iteration, and Early Returning the current best feature for addition or removal. The three heuristics are implemented using Bootstrap-based statistical tests. They are applied on the set of currently available local p-values and log-likelihoods to determine whether the algorithm has seen enough samples to make safely (i.e., with high probability of correctness) early decisions.</p><p>PFBP is proven to compute the optimal feature set for distributions faithful <ref type="bibr" target="#b67">(Spirtes et al. 2000)</ref> [also called stable distributions <ref type="bibr" target="#b56">(Pearl and Verma 1995)</ref>] to a causal network represented as a Bayesian network or a maximal ancestral graph <ref type="bibr" target="#b67">(Spirtes et al. 2000;</ref><ref type="bibr" target="#b61">Richardson and Spirtes 2002)</ref>. These are data distributions whose set of conditional independencies coincides with the set of independencies entailed by a causal graph and the Markov Condition <ref type="bibr" target="#b56">(Pearl and Verma 1995;</ref><ref type="bibr" target="#b67">Spirtes et al. 2000)</ref>. Assuming faithfulness of the data distribution has led to algorithms that have been proven competitive in practice <ref type="bibr" target="#b47">(Margaritis and Thrun 2000;</ref><ref type="bibr" target="#b3">Aliferis et al. 2003;</ref><ref type="bibr">Tsamardinos et al. 2003a, b;</ref><ref type="bibr" target="#b58">Peña et al. 2007;</ref><ref type="bibr" target="#b2">Aliferis et al. 2010;</ref><ref type="bibr" target="#b41">Lagani and Tsamardinos 2010;</ref><ref type="bibr" target="#b40">Lagani et al. 2013</ref><ref type="bibr" target="#b39">Lagani et al. , 2017;;</ref><ref type="bibr" target="#b10">Borboudakis and Tsamardinos 2017)</ref>. We should also note that all PFBP computations are not bound to specific data-types; by supplying different conditional independence tests PFBP becomes applicable to a wide variety of data types and target variables (continuous, ordinal, nominal, right-censored time-to-event a.k.a. survival analysis, zero inflated, percentage, time-course, repeated measurements, and others; see our R package MXM <ref type="bibr" target="#b39">(Lagani et al. 2017)</ref> for algorithms that can handle this palette of outcomes by just providing them with different conditional independence tests). Furthermore, PFBP could potentially handle data with non-linear dependencies, as long as an appropriate conditional independence test is provided [e.g., a kernel-based test <ref type="bibr" target="#b87">(Zhang et al. 2011)</ref> or the G 2 test for multinomial, discrete data <ref type="bibr" target="#b0">(Agresti 2002)</ref>].</p><p>PFBP is first evaluated on a range of simulated data to assess its scalability properties. The data are simulated from randomly generated Bayesian networks (thus, simulating a rich dependency structure) in order to incorporate a complex dependency structure among the variables and include not only irrelevant features, but also redundant features. PFBP is found to scale super-linearly with the available sample size as its heuristics allow it to make early decisions before examining all available samples. It scales linearly with the number of features and available cores. PFBP is compared on a set of real datasets spanning a range of feature and sample sizes against the main forward-selection algorithms in the literature devised for Big Data architectures. PFBP is found more computationally efficient and scalable than the state-of-the-art, selecting fewer features, without sacrificing predictive performance. The algorithm is also evaluated against several variants of information-theoretic feature selection algorithms. The latter are specialized for discrete and sparse data. PFBP is less computational efficient in this case, as it is not customized for discrete data, but exhibits a higher predictive performance. In all tasks in the evaluation, the predictive performance is assessed with models constructed with the standard logistic regression model in MLlib of the Spark distribution (hereafter SparkLR), as well as the combined predictive model constructed from the local logistic regressions ones, as proposed above <ref type="bibr">(hereafter, CombLR)</ref>. The experiments suggest that in several cases SparkLR fails to converge and one obtains a model that is significantly worse than random guessing (e.g., 45% accuracy of SparkLR versus 85% accuracy for random guessing). In contrast, CombLR is never worse than the trivial model more than 0.02%. While the focus of the paper is on FS, these results indicate that methods for combining local statistics and models may serve a more general purpose in Big Data analytics.</p><p>The paper is organized as follows. In Sect. 2 we provide a brief introduction to the basic concepts required to introduce our FS algorithm. The PFBP algorithm is introduced in Sect. 3. In Sect. 4 we explain the heuristics used by PFBP in detail, and show to how to implement them using bootstrap-based tests. Guidelines for setting the hyper-parameter values for the data partitioning used by PFBP are presented in Sect. 5. In Sect. 6 we list some implementation details of PFBP, which are required for a fast and robust implementation. The theoretical properties of PFBP are presented in Sect. 7. A high-level theoretical comparison of PFBP to alternative feature selection algorithms, as well as an overview of feature selection methods for Big Data is given in Sect. 8. Finally, in Sect. 9 we evaluate PFBP on synthetic data, and compare it to alternative forward-selection algorithms on 13 binary classification datasets.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Background and preliminaries</head><p>In this section, we provide the basic notation used throughout the paper, and present the core algorithmic and statistical reasoning techniques exploited by the proposed FS algorithm. Random variables are denoted using upper-case letters (e.g. X), while sets of random variables are denoted using bold upper-case letters (e.g. Z). We use |Z| to refer to the number of variables in Z. The outcome (or target) variable will be denoted as T . A summary of acronyms, terms and notation is given in Table <ref type="table" target="#tab_0">1</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Forward-Backward feature selection</head><p>The Forward-Backward Selection algorithm (FBS) is an instance of the stepwise feature selection algorithm family <ref type="bibr" target="#b38">(Kutner et al. 2004;</ref><ref type="bibr" target="#b79">Weisberg 2005)</ref>. It is also one of the first and most popular algorithms for causal feature selection <ref type="bibr" target="#b47">(Margaritis and Thrun 2000;</ref><ref type="bibr" target="#b73">Tsamardinos et al. 2003b)</ref>. In each forward Iteration, FBS selects the feature that provides the largest increase in terms of predictive performance for T , and adds it to the set of selected variables, denoted with S hereon, starting from the empty set. The forward Phase ends when no feature further improves performance or a maximum number of selected features has been reached. In each Iteration of the backward Phase, the feature that most confidently does not reduce performance is removed from S. The backward Phase stops when no feature can be removed without reducing performance. We use the terms Phase to refer to the forward and backward To determine whether predictive performance is increased or decreased when a single feature is added or removed in a greedy fashion, FBS uses conditional independence tests. <ref type="foot" target="#foot_4">5</ref> An important advantage of methods relying on conditional independence tests is that it allows one to adapt and apply the algorithm to any type of outcome for which an appropriate statistical test of conditional independence exists. This way, the same feature selection algorithm can deal with different data types. <ref type="foot" target="#foot_5">6</ref>Conditional independence of X with T given S implies that P(T |S, X ) = P(T |S), whenever P(S) &gt; 0 (S is allowed to be the empty set). Thus, when conditional independence holds, X is not predictive of T when S (and only S) is known. A conditional independence test assumes the null hypothesis that feature X is probabilistically independent of T (i.e., redundant) given a set of variables S. The test returns a p-value, which corresponds to the probability that one obtains deviations from what is expected under the null hypothesis as extreme or more extreme than the deviation actually observed with the given data. When the p-value is low, the null hypothesis can be safely rejected: the value of X does provide predictive information for T when the values of S are known. In practice, decisions are made using a threshold α (significance level) on the p-values; the null hypothesis is rejected if the p-value is below α.</p><p>In the context of feature selection, the p-values returned by statistical hypotheses tests of conditional independence are employed not only to reject or accept hypotheses, but also to rank the features according to the predictive information they provide for T given S. Intuitively, this can be justified by the fact that everything else being equal (i.e., sample size, type of test) the p-values of such tests in case of dependence have (on average) the reverse ordering with the conditional association of the variables with T given S. So, the basic variant of the algorithm selects to add (remove) the feature with the lower (higher) p-value in each Forward (Backward) Iteration. The Forward-Backward Selection algorithm using conditional independence tests is summarized in Algorithm 1. We use V D to denote the set of variables contained in dataset D (excluding the target T ). The Pvalue(T , X |S) function performs a conditional independence test of T and X given S and returns a p-value.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Implementing independence tests using the likelihood ratio technique</head><p>There are several methods for assessing conditional independence. Examples include likelihood-ratio based tests <ref type="bibr" target="#b82">(Wilks 1938)</ref> [or asymptotically equivalent approximations thereof like score tests and Wald tests <ref type="bibr" target="#b23">(Engle 1984)</ref>] or kernel-based tests <ref type="bibr" target="#b87">(Zhang et al. 2011)</ref>. We focus on likelihood-ratio based tests hereafter, mostly because they are general and can be applied for different data types, although the main algorithm is not limited to such tests but can be applied with any type of test.</p><p>To construct a likelihood-ratio test for conditional independence of T with X given S one needs a statistical model that maximizes the log-likelihood of the data LL(D; θ) ≡ log P(D|θ) over a set of parameters θ . Without loss of generality, we assume hereafter T is binary and consider the binary logistic regression model. For the logistic regression, the parameters θ are weight coefficients for each feature in the model and an intercept term. Subsequently, two statistical models have to be created for T : (i) model M 0 using only variables S, and (ii) model M 1 using S and X resulting in corresponding log-likelihoods LL 0 and LL 1 . The null hypothesis of independence now becomes equivalent to the hypothesis that both log-likelihoods are equal asymptotically. The test statistic function D of the test is defined as</p><formula xml:id="formula_0">D ≡ -2 × (LL 0 -LL 1 )</formula><p>Notice that, the difference in the logs of the likelihoods corresponds to the ratio of the likelihoods, hence the name likelihood-ratio test. The test statistic is known to follow asymptotically a χ 2 distribution with P 1 -P 0 degrees of freedom <ref type="bibr" target="#b82">(Wilks 1938)</ref>, where P 1 and P 0 are degrees of freedom of models M 1 and M 0 respectively.<ref type="foot" target="#foot_6">foot_6</ref> When X is a continuous feature, only one more parameter is added to θ so the difference in degrees of freedom is 1 for this case. Categorical predictors can be used by simply encoding them as K -1 dummy binary features, where K is the number of possible values of the original feature. In this case, the difference in degrees of freedom is K -1. Knowing the theoretical distribution of the statistic allows one to compute the p-value of the test: p = 1cdf (D, d f ), where cdf is the cumulative probability distribution function of the χ 2 distribution with degrees of freedom d f and D the observed statistic. Likelihood-ratio tests can be constructed for any type of data for which an algorithm for maximizing the data likelihood exists, such as binary, multinomial or ordinal logistic regression, linear regression and Cox regression to name a few.</p><p>Likelihood-ratio tests are approximate in the sense that the test statistic has a χ 2 distribution only asymptotically. When sample size is low, the asymptotic approximation may return inaccurate p-values. Thus, to apply approximate tests it is important to ensure a sufficient number of samples is available. This issue is treated in detail in the context of PBFP and the logistic test in "Appendix A". Note that, the aforementioned models and the corresponding independence tests are only suited for identifying linear dependencies; certain types of nonlinear dependencies may also be identifiable if one also includes interaction terms and feature transformations in the models.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Combining p-values using meta-analysis techniques</head><p>A set of p-values stemming from testing the same null hypothesis (e.g. testing the conditional independence of X and Y given Z) can be combined using statistical meta-analysis techniques into a single p-value. Multiple such methods exist in the literature <ref type="bibr" target="#b45">(Loughin 2004</ref>). Fisher's combined probability test <ref type="bibr" target="#b25">(Fisher 1932</ref>) is one such method that has been shown to work well across many cases <ref type="bibr" target="#b45">(Loughin 2004)</ref>. It assumes that the p-values are independent and combines them into a single statistic using the formula</p><formula xml:id="formula_1">Statistic ≡ -2 K i=1 log( p i )</formula><p>where K is the number of p-values, p i is the ith p-value, and log is the natural logarithm. The statistic is then distributed as a χ 2 random variable with 2 • K degrees of freedom, from which a combined p-value is computed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Bootstrap-based hypothesis testing</head><p>The bootstrap procedure <ref type="bibr" target="#b22">(Efron and Tibshirani 1994</ref>) can be used to compute the distribution of a statistic of interest. Bootstrapping is employed in the PFBP algorithm for making early, probabilistic decisions. Bootstrapping is a general-purpose non-parametric resampling-based procedure which works as follows: (a) resample with replacement from the input values a sample of equal size, (b) compute the statistic of interest on the bootstrap sample, (c) repeat steps (a) and (b) many times to get an estimate of the bootstrap distribution of the statistic. The bootstrap distribution can then be used to compute properties of the distribution such as confidence intervals, or to compute some condition of the statistic. A simple example application on the latter follows; more examples can be found in <ref type="bibr" target="#b22">Efron and Tibshirani (1994)</ref>.</p><p>Let μ X denote the mean of random variable X and let μX denote the estimate of the mean of X given a sample of X . Assume we are given a sample of size n of random variable X and we want to compute the probability that the mean of X is larger than 10, P(μ X &gt; 10). That probability is a Bernoulli random variable, and the statistic in this case is a binary valued variable (i.e., taking a value of 0 or 1 with probability P(μ X &gt; 10)). Using bootstrapping, P(μ X &gt; 10) can be estimated as follows: (a) sample with replacement n values of X and create the bth bootstrap sample X b , (b) estimate the mean of X b , denoted as μb X , and compute I ( μb X &gt; 10), where I is the indicator function returning 1 if the inequality holds and 0 otherwise, and (c) repeat (a) and (b) B times (e.g. B = 1000). P(μ X &gt; 10) is then computed as</p><formula xml:id="formula_2">P(μ X &gt; 10) = I ( μX &gt; 10) + B i=1 I ( μb X &gt; 10) B + 1</formula><p>Note that, we also compute the statistic on the original sample (which is sample from the bootstrap distribution), and thus divide by B + 1.<ref type="foot" target="#foot_7">foot_7</ref> </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5">Probabilistic graphical models and Markov blankets</head><p>In this section, we give a brief overview of Bayesian networks and maximal ancestral graphs, which will be used later on to present the theoretical properties of the proposed algorithm. A more extensive exposition and rigorous treatment can be found in <ref type="bibr" target="#b67">Spirtes et al. (2000)</ref>, <ref type="bibr" target="#b61">Richardson and Spirtes (2002)</ref> and <ref type="bibr" target="#b2">Aliferis et al. (2010)</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5.1">Bayesian networks</head><p>A Bayesian network B = G, P consists of a directed acyclic graph G over a set of vertices V and a joint distribution P, over random variables that correspond one-to-one to vertices in V (thus, no distinction is made between variables and vertices). The Markov condition has to hold between G and P: every variable X is conditionally independent of its non-descendants in G, given its parents, denoted by Pa(X ). The Markov condition leads to a factorization of the joint probability P(V ) = i P(X i |Pa(X i )). Those are not all the independencies that hold in the distribution: the Markov condition (along with the other probability axioms) implies some additional conditional independencies. A Bayesian network is called faithful if all and only the conditional independencies in P are entailed by the Markov condition. Conceptually, this faithfulness condition means that all independencies in the distribution of the data are determined by the structure of the graph G and not the actual parameterization of the distribution. A distribution P is called faithful (to a Bayesian network) if there is a graph G such that B = G, P is faithful. Under the Markov and faithfulness assumptions, a graphical criterion called d-separation <ref type="bibr" target="#b75">(Verma and Pearl 1988;</ref><ref type="bibr" target="#b54">Pearl 1988</ref>) can be used to read off dependencies and independencies encoded in a Bayesian network. To define dseparation the notion of colliders is used, which are triplets of variables X , Y , Z with X and Z having directed edges into Y . Two variables X and Y are d-connected by a set of variables Z if and only if there exists a (not necessarily directed) path p between X and Y such that (i) for each collider V on p, V is either in Z or some descendant of V is in Z, and (ii) no non-collider on p is in Z. In case no such path exists, X and Y are d-separated given Z. Thus, the Markov and faithfulness conditions imply that if two variables X and Y are d-separated (d-connected) given Z, then they are conditional independent (dependent) given Z.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5.2">Maximal ancestral graphs</head><p>A distribution class strictly larger than the set of faithful distributions to Bayesian networks, is the set of distributions that are marginals of faithful distributions. Unfortunately, marginals of faithful distributions are not always faithful to some Bayesian network. Thus, marginalization over some variables loses the faithfulness property: the marginal distribution cannot always be faithfully represented by a Bayesian network. However, marginals of faithful distributions can be represented by another type of graph called directed maximal ancestral graph <ref type="bibr" target="#b61">(Richardson and Spirtes 2002)</ref> or DMAG. DMAGs include not only directional edges, but also bi-directional edges. DMAGs are extensions of Bayesian networks for marginal distributions and are closed under marginalization. The representation of a marginal of a faithful (to a Bayesian network) distribution is again faithful (this time to a maximal ancestral graph though, not necessarily a Bayesian Network) in the sense that all and only the conditional independencies in the distribution are implied by the Markov condition. The set of conditional independencies entailed by a DMAG is provided by a criterion similar to d-separation, now called m-separation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5.3">Markov blankets in probabilistic graphical models</head><p>A Markov blanket of T with respect to a set of variables V is defined as a minimal set S such that V\S⊥T | S, where X⊥T | S denotes the conditional independence of X with T given S. Thus, a Markov blanket of T is any minimal set that renders all other variables conditionally independent. An important theorem connects the Markov blanket of T with the feature selection problem for T : under broad conditions <ref type="bibr" target="#b47">(Margaritis and Thrun 2000;</ref><ref type="bibr">Tsamardinos and Aliferis 2003)</ref> a Markov blanket of T is a solution to the feature selection problem for T . When the distribution is faithful to a Bayesian network or DMAG, the Markov blanket of T is unique.<ref type="foot" target="#foot_8">foot_8</ref> In other words, for faithful distributions, the Markov Blanket of T has a direct graphical interpretation. The Markov blanket consists of all vertices adjacent to T , and all vertices that are reachable from T through a collider path, which is a path where all vertices except the start and end vertices are colliders <ref type="bibr" target="#b10">(Borboudakis and Tsamardinos 2017)</ref>. For Bayesian networks, this corresponds to the set of parents (vertices with an edge to T ), children (vertices with an edge from T ), and spouses (parents of children) of T in G. An example of the Markov blanket of T in a Bayesian network and a maximal ancestral graph are shown in Fig. <ref type="figure" target="#fig_0">1</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Massively parallel Forward-Backward algorithm</head><p>We provide an overview of our algorithm, called Parallel, Forward-Backward with Pruning (PFBP), an extension of the basic Forward-Backward Selection (FBS) algorithm (see Sect. 2.1 for a description). We will use the terminology introduced for FBS: a forward The nodes in the Markov blanket are shown with solid lines, and the remaining ones with dashed lines. In both cases, the Markov blanket contains all adjacent nodes (parents and children) and X 5 (spouse of T ). In addition, in the maximal ancestral graph X 9 and X 10 are also contained, as they are connected with T through a collider path (T → X 8 ↔ X 9 ← X 10 ) (backward) Phase refers to the forward (backward) loops of FBS, and an Iteration refers to each loop iteration that decides which variable to select (remove) next. PFBP is presented in "evolutionary" steps where successive enhancements are introduced in order to make computations local or reduce computations and communication costs; the complete algorithm is presented in Sect. 3.4. To evaluate predictive performance of candidate features we use the p-values of conditional independence tests, as described in Sect. 2.1. We assume the data are provided in the form of a 2-dimensional matrix D where rows correspond to training instances (samples) and columns to features (variables), and one of the variables is the target variable T . Physically, the data matrix is partitioned in sub-matrices D i, j and stored in a distributed fashion in workers in a cluster running Spark <ref type="bibr" target="#b85">(Zaharia et al. 2010)</ref> or similar platform. Workers perform in parallel local computations on each D i, j and a master node performs the centralized, global computations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Data partitions in blocks and groups and parallelization strategy</head><p>We now describe the way D is partitioned in sub-matrices to enable parallel computations. First, the set of available features (columns) F is partitioned to about equal-sized Feature Subsets {F 1 , . . . , F nf }. Similarly, the samples (rows) are randomly partitioned to about equalsized Sample Subsets {S 1 , . . . , S ns }. The row and column partitioning defines sub-matrices called Data Blocks D i, j with rows S i and features F j . Sample Subsets are assigned to Q Group Samples {G q } C 1 of size C each, where each group sample G q is a set {S q 1 , . . . , S q n } (i.e., the set of Sample Subsets is partitioned). The Data Blocks D i, j with samples within a group sample S i ∈ G q belong in the same Group. This second, higher level of grouping is required by the bootstrap tests explained in Sect. 4. Data Blocks in the same Group are processed in parallel in different workers (provided enough are available). However, Groups are processed sequentially, i.e., computation in all Blocks within a Group has to complete to begin computations in the Blocks of the next Group. Obviously, if workers are more than the Data Blocks, there is no need for defining Groups. The data partitioning scheme is shown in Fig. <ref type="figure" target="#fig_1">2</ref>: Left. Details of how the number of Sample Sets ns, the number of Feature Subsets nf , and the number C of Group Samples are determined are provided in Sect. 5.  The sets R and A are updated accordingly. In this example, X 2 , X 5 and X 6 are Dropped, X 3 is stopped, and only X 1 and X 4 remain Alive. Notice that always A ⊆ R. e The second Group is processed in parallel (by workers) containing Blocks D 3,1 , D 3,2 , D 2,1 , D 2,2 . f New local p-values for all features still Alive are appended to Π . If G 2 was the last Group, global p-values for the Alive features would be computed and the one with the minimum value (in this example X 1 ) would be selected for inclusion in S. g In case, X 1 and X 4 are deemed almost equally predictive (based on their log-likelihoods) the current best is Early Returned</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Approximating global p-values by combining local p-values using meta-analysis</head><p>Recall that Forward-Backward Selection uses p-values stemming from conditional independence tests to rank the variables and to select the best one for inclusion (forward Phase) or exclusion (backward Phase). Extending the conditional independence tests to be computed over multiple Data Blocks is not straightforward, and may be computationally inefficient. For conditional independence tests based on regression models (e.g. logistic or Cox regression), a maximum-likelihood estimation over all samples has to be performed, which typically does not have a closed-form solution and thus requires the use of an iterative procedure (e.g. Newton descent). Due to its iterative nature, it results in a high communication cost rendering it computationally inefficient, especially for feature selection purposes on Big Data where numerous models have to be fit at each Iteration. Instead of fitting full (global) regression models, we propose to perform the conditional independence tests locally on each data block, and to combine the resulting p-values using statistical meta-analysis techniques. Specifically, the algorithm computes local p-values denoted by π i,k for candidate feature X k from only the rows in S i of a data block D i, j , where F j contains the feature X k . This enables massive parallelization of the algorithm, as each data block can be processed independently and in parallel by a different worker (Fig. <ref type="figure" target="#fig_1">2b</ref>). The local p-values π i,k are then communicated to the master node of the cluster, and are stored in a matrix Π (Fig. <ref type="figure" target="#fig_1">2c</ref>); we will use π i,k to refer to the elements of matrix Π, corresponding to the local p-value of X k computed on a data block containing samples in sample set S i . Using the p-values in matrix Π, the master node combines the p-values to global p-values for each feature X k using Fisher's combined probability test <ref type="bibr" target="#b25">(Fisher 1932</ref>) (Fig. <ref type="figure" target="#fig_1">2c</ref>).<ref type="foot" target="#foot_9">foot_9</ref> Finally, we note that this approach is not limited to regression-based tests, but can be used with any type of conditional independence test, and is most appropriate for tests which are hard to parallelize, or computationally expensive [e.g. kernel-based tests <ref type="bibr" target="#b87">(Zhang et al. 2011)</ref>].</p><p>Using Fisher's combined probability test to combine local p-values does not necessarily lead to the same p-value as the one computed over all samples. There are no guarantees how close those p-values will be in case the null hypothesis of conditional independence holds, except that they are uniformly distributed between 0 and 1. In case the null hypothesis does not hold however (the dependency holds), one expects to reject the null hypothesis using either method in the sample limit. What is important for PFBP is to make the same decision at each Iteration, that is, that the top ranked variable given by either p-value computation method is the same. However, even if the top ranked variable is not the same one, PFBP may still perform well, as long as some other informative variable is ranked first. In "Appendix A" we investigate in experiments on synthetic data how both approaches compare when the task is to select the best variable at a given Iteration. We show that, if the sample size per data block is sufficiently large, combined p-values and p-values obtained from tests on all samples lead to the same choice with high probability.</p><p>For the computation of the local p-values on D i, j , samples S i of the selected features S are required, and thus the data need to be broadcast to every worker processing D i, j whenever S is augmented, i.e., in the end of each Forward Iteration. In total, the communication cost of the algorithm is due to the assembly of all local p-values π i,k to determine the next feature to include (exclude), as well as the broadcast of the data for the newly added feature in S at the end of each forward Iteration. We would like to emphasize that the bulk of computation of the algorithm is the calculation of local p-values that require expensive statistical tests and it takes place in the workers in parallel. The central computations in the master are minimal.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Speeding-up PFBP using pruning heuristics</head><p>In this section, we present 3 pruning heuristics used by PFBP to speed-up computation. Implementation details of the heuristics using locally computed p-values are presented in Sect. 4.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.1">Early Dropping of features from subsequent iterations</head><p>The first addition to PFBP is the Early Dropping (ED) heuristic, first introduced in Borboudakis and Tsamardinos (2017) for a non-parallel version of Forward-Backward Selection. Let R denote the set of remaining features, that is, the set of features still under consideration for selection. Initially, R = F\S, where F is the set of all available features and S is the set of selected features, which is initially empty. At each forward Iteration, ED removes from R all features that are conditionally independent of the target T given the set of currently selected features S. Typically, just after the first few Iterations of PFBP, only a very small proportion of the features will still remain in R, leading to orders of magnitude of efficiency improvements even in the non-parallel version of the algorithm <ref type="bibr" target="#b10">(Borboudakis and Tsamardinos 2017)</ref>. When the set of variables R becomes empty, we say that PFBP finished one Run. Unfortunately, the Early Dropping heuristic without further adjustments may miss important features which seem uninformative at first, but provide information for T when considered with features selected in subsequent Iterations. Features should be given additional opportunities to be selected by performing more Runs. Each additional Run calls the forward phase again but starts with the previously selected variables S and re-initializes the remaining variables to R = F\S. By default, PFBP uses 2 Runs, although a different number of Runs may be used. Typically a value of 1 or 2 is sufficient in practice, with larger values requiring more computational time while also giving stronger theoretical guarantees; the theoretical properties of PFBP with ED are described in Sect. 7 in detail; in short, assuming no statistical errors in the conditional independence tests, PFBP with 2 runs returns the Markov Blanket of T is distributions faithful to a Bayesian network. Overall, by discarding variables at each Iteration, the Early Dropping heuristic allows the algorithm to scale with respect to the number of features.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.2">Early Stopping of features within the same iteration</head><p>The next addition to the algorithm regards Early Stopping (ES) of consideration of features within the same Iteration, i.e., in order to select the next best feature to select in a forward Iteration or to remove in a backward Iteration. To implement ES we introduce the set A of features still Alive (i.e., under consideration) in the current Iteration, initialized to A = R at the beginning of each Iteration (see Fig. <ref type="figure" target="#fig_1">2a</ref>). As the master node gathers local p-values for a feature X k from several Data Blocks, it may be able to determine that no more local p-values need to be computed for X k . This is the case if these p-values are enough to safely decide that with high probability X k is not going to be selected for inclusion (Forward Phase) or exclusion (Backward Phase) in this Iteration (see Sect. 4 for a bootstrap-based procedure that performs this test). In this case, X k is removed from the set of alive features A, and is not further considered in the current Iteration (see Fig. <ref type="figure" target="#fig_1">2d</ref>). This allows PFBP to quickly filter out variables which will not be selected at the current Iteration. Thus, ES leads to a super-linear speed-up of the feature selection algorithm with respect to the sample size: even if the sample size is doubled, the same features will be Early Stopped; p-values will not be computed for these features on the extra samples.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.3">Early Return of the winning feature</head><p>The final heuristic of the algorithm is called Early Return (ER). Recall that Early Dropping will remove features conditionally independent of T given S from this and subsequent Iterations while Early Stopping will remove non-winners from the current Iteration. However, even using both heuristics, the algorithm will keep producing local p-values for features X j and X k that are candidates for selection and at the same time are informationally indistinguishable (equally predictive given S) with regards to T (this is the case when the residuals of X j and X k given S are almost collinear). When two or more features are both candidates for selection and almost indistinguishable, it does not make sense to go through the remaining data: all choices are almost equally good. Hence, Early Return terminates the computation in the current Iteration and returns the current best feature X j , if with high probability it is not going to be much worse than the best feature at the end of the Iteration (see Fig. <ref type="figure" target="#fig_1">2g</ref>).</p><p>Again, the result is that computation in the current Iteration may not process all Groups. The motivation behind Early Return is similar to Early Stopping, in that it tries to quickly determine the next feature to select. The difference is that, Early Return tries to quickly determine whether a variable is "good enough" to be selected, in contrast to Early Stopping which discards unpromising variables.</p><p>A technical detail is that judging whether two features X i and X j are "equally predictive" is implemented using the log-likelihoods λ i and λ j of the models with predictors S∪{X i } and S ∪ {X j } instead of the corresponding p-values. The likelihoods are part of the computation of the p-values, thus incur no additional computational overhead.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">The parallel Forward-Backward with pruning algorithm</head><p>We present the proposed Parallel Forward-Backward with Pruning (PFBP) algorithm, shown in Algorithm 2. To improve readability, several arguments are omitted from function calls. PFBP takes as input a dataset D and the target variable of interest T . Initially the number of Sample Sets ns and number of Feature Sets nf are determined as described in Sect. 5. Then, (a) the samples are randomly assigned to Sample Sets S 1 , . . . , S ns , to avoid any systematic biases (see also Sect. S ← BackwardIteration(D, T , S) 26: end while 27: return S in order of occurrence in the dataset, and (d) the dataset D is partitioned into data blocks D i, j , with each such block containing samples and features corresponding to sample set S i and feature set F j respectively. The selected variables S are initialized to the empty set. The main loop of the algorithm performs up to maxRuns Runs, as long as the selected variables S change. Each such Run executes a forward and a backward Phase.</p><p>The OneRun function takes as input a set of data blocks D, the target variable T , a set of selected variables S, and a limit on the number of variables to select maxVars. It initializes the set of remaining variables R to all non-selected variables F\S. Then, it executes the forward and backward Phases. The forward (backward) Phase executes forward (backward) Iterations until some stopping criteria are met. Specifically, the forward Phase terminates if the maximum number of variables maxVars has been selected, or until no more variable can be selected, while the backward Phase terminates if no more variables can be removed from S.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm 3 ForwardIteration</head><p>Input: Data Blocks D, Target T , Selected Variables S, Remaining Variables R Output: Selected Variables S, Remaining Variables R 1: A ← R //Initialize Alive Variables 2: Π //Array of log-p-values, initially empty 3: Λ //Array of log-likelihoods, initially empty 4: q ← 1 //Initialize current Group counter 5: Q ← #Groups //Set Q to the total number of Groups 6: 7: while q ≤ Q do 8:</p><p>//Process the alive features A for all data blocks containing sample sets in G q (denoted as D q ) in parallel in workers for the given T , S and A, compute sub-matrices Π q and Λ q from each block, and append results to Π and Λ 9:</p><p>Π q , Λ q ← TestParallel(D q , T , S, A) 10: R, A ← EarlyDropping(Π , R, A) 11:</p><p>A ← EarlyStopping(Π , A) 12:</p><p>A ← EarlyReturn(Λ, A) </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm 4 BackwardIteration</head><p>Input: Data Blocks D, Target T , Selected Variables S Output: Selected Variables S, Remaining Variables R 1: A ← S //Initialize Alive Variables 2: Π //Array of log-p-values, initially empty 3: q ← 1 //Initialize current Group counter 4: Q ← #Groups //Set Q to the total number of Groups 5: 6: while q ≤ Q do 7:</p><p>//Process the alive features A for all data blocks containing sample sets in G q (denoted as D q ) in parallel in workers for the given T , S and A, compute sub-matrix Π q from each block, and append it to Π 8:</p><p>Π q ← TestParallel(D q , T , S, A) 9:</p><p>A ← EarlyStoppingBackward(Π , A) 10:</p><p>Update The forward and backward Iteration procedures are shown in Algorithms 3 and 4. ForwardIteration takes as input the data blocks D, the target variable T as well as the current sets of remaining and selected variables, performs a forward Iteration and outputs the updated sets of selected and remaining variables. It uses the variable set A to keep track of all alive variables, i.e. variables that are candidates for selection. The arrays Π and Λ contain the local log p-values and log-likelihoods, containing ns rows (one for each sample set) and |A| columns (one for each alive variable). The values of Π and Λ are initially empty, and are filled gradually after preprocessing each Group. We use D q to denote all data blocks which corresponds to Sample Sets contained in Group G q . Similarly, accessing the values of Π and Λ corresponding to Group q and variables X is denoted as Π q and Λ q .</p><p>In the main loop, the algorithm iteratively processes Groups in a synchronous fashion, until all Groups have been processed or no alive variable remains. The TestParallel function takes as input the data blocks D q corresponding to the current Group G q , and performs all necessary independence tests in parallel in workers. The results, denoted as Π q and Λ q are then appended to the Π and Λ matrices respectively. After processing a Group, the tests for Early Dropping, Early Stopping and Early Return are performed, using all local p-values computed up to Group q; details about the implementation of the EarlyDropping, EarlyStopping and EarlyReturn algorithms when data have only been partially processed are given in Sect. 4. The values of non-alive features are then removed from Π and Λ (see also Fig. <ref type="figure" target="#fig_1">2f</ref> for an example). If only a single alive variable remains, processing stops. Note that, this is not checked in the while loop condition, in order to ensure that at least one Group has been 123 processed if the input set of remaining variables contains a single variable. Finally, the best alive variable (if such a variable exists) is selected if it is conditionally dependent with T given the selected variables S. Conditional dependence is determined by using the p-value resulting from combining all local p-values available in Π. BackwardIteration is similar to ForwardIteration with the exception that (a) the remaining variables are not needed, and thus no dropping is performed, (b) no early return is performed, and (c) the tests are reversed, i.e. the worst variable is removed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">Massively-parallel predictive modeling</head><p>The technique of combining locally computed p-values to global ones to massively parallelize computations, can be applied not only for feature selection, but also for predictive modeling. At the end of the feature selection process one could obtain an approximate predictive model with no additional overhead! We exploit this opportunity in the context of independence tests implemented by logistic regression. During the computation of local p-values π i,k a (logistic) model for T using all selected features S is produced from the samples in S i . Such a model computes a set of coefficients β i that weighs each feature in the model to produce the probability that T = 1. We used the weighted univariate least squares (WLS) approach <ref type="bibr" target="#b31">(Hedges and Vevea 1998)</ref>, with equal weights for each model; equal weights were used as the sample size of each partition is (approximately) the same. The WLS method with equal weights combines the N local models to a global one β by just taking the average of the coefficient vectors of the model , i.e., β = 1 N N i=1 β i . Thus, the only change to the algorithm is to cache each β i and average them in the master node this way. By default, PFBP uses the WLS method to construct a predictive model at each forward Iteration. Other multivariate methods for combining multiple models, which also consider the co-variance of the estimated coefficients are described in <ref type="bibr" target="#b5">Becker and Wu (2007)</ref>. Such methods could also be applied in our case without any significant computational overhead, but were not further considered in this work.</p><p>Using the previous technique, one could obtain a model at the end of each Iteration without extra computations and assess its predictive performance (e.g., accuracy) on a holdout validation set. Constructing for instance the graph of the number of selected features versus achieved predictive performance on the hold-out set could visually assist data analysts <ref type="bibr" target="#b37">(Konda et al. 2013)</ref> in determining how many features to include in the final selections; an example application on SNP data is given in the experimental section in Fig. <ref type="figure">5</ref>. An automated criterion for selecting the best trade-off between the number of selected features and the achieved predictive performance could also be devised, although this is out of the scope of this paper, as multiple testing has to be taken into consideration.</p><p>Before proceeding with the details, we provide the notation used hereafter. Let Π and Λ be 2-dimensional arrays containing K local log p-values and log-likelihoods for all alive variables in A and for all Groups already processed. The matrices reside on the master node, and are updated each time a Group is processed. Let π i, j and λ i, j denote the ith value of the jth alive variable, denoted as X j . Recall that those values have been computed locally on the Data Block containing samples from Sample Set S i . For the sake of simplicity, we will use π j and λ j (l j ) to denote the combined p-value and sum of log-likelihoods (likelihood) respectively of variable X j . The vectors π and λ will be used to refer to the combined pvalues and sum of log-likelihoods for all alive variables respectively. Also, let X best be the variable that would have been selected if no more data blocks were evaluated, that is, the one with the currently lowest combined p-value, denoted as π best .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Bootstrap tests for early probabilistic decisions</head><p>In order to make early probabilistic decisions, we test: (a) P(π j ≥ α) &gt; P drop for Early Dropping of X j (i.e., the probability of the jth feature deemed independent at significance level α at the end of the Iteration is larger than a threshold), (b) P(π best &lt; π j ) &gt; P stop for Early Stopping of X j (i.e., the probability of the current best feature having a smaller "better" p-value than feature j is larger than a threshold), and (c) ∀X j , (P(l best /l j ≥ t) &gt; P return ) for Early Return of X best (the likelihood ratio l best /l j indicate how close is the model with the currently best feature and the mode with feature l j ; if all ratios with all alive features are above a certain threshold with high probability, then the current best choice is close to optimal). The t is a tolerance parameter that determines how close the compared models should be. It takes values between 0 and 1; the closer it is to 1, the closer it is guaranteed that the current best model will be to all other ones in consideration in terms of likelihood. By taking the logarithm, (c) can be rewritten as ∀X j , P(λ best -λ j ≥ lt), where lt = log(t).</p><p>We employed bootstrapping to test the above. A bootstrap-sample b of Π (Λ), denoted as Π b (Λ b ), is created by sampling with replacement K rows from Π (Λ). Then, for each such sample, the Fisher's combined p-values (sum of log-likelihoods) are computed, by summing over all respective values for each alive variable; we refer to the vector of combined p-values (log-likelihoods) on bootstrap sample b as π b (λ b ), and the ith element is referred to as π b i (λ b i ). By performing the above B times, probabilities (a), (b) and (c) can be estimated as:</p><formula xml:id="formula_3">P(π j ≥ α) = I(π j ≥ α) + B b=1 I(π b j ≥ α) B + 1 (Early Dropping) P(π j &gt; π best ) = I(π j &gt; π best ) + B b=1 I(π b j &gt; π b best ) B + 1 (Early Stopping) P(λ best -λ j ≥ lt) = I(λ best -λ j ≥ lt) + B b=1 I(λ b best -λ b j ≥ lt) B + 1 (Early Return)</formula><p>where I is the indicator function, which evaluates to 1 if the inequality holds and to 0 otherwise. For all of the above, the condition is also computed on the original sample, and the result is divided by the number of bootstrap iterations B plus 1. Note that, for Early Return the above value is computed for all features X j . Algorithms 5, 6 and 7 show the procedures in more detail. For all heuristics, a vector named cnts is used to keep track of how often the inequality is satisfied for each variable.</p><p>To avoid cluttering, the indicator function I performs the check for multiple variables and returns a vector of values in each case, containing one value for each variable. The function BootstrapSample creates a bootstrap sample as described above, function Combine uses Fisher's combined probability test to compute a combined p-value, and SumRows sums over all rows of the log-likelihoods contained in Λ, returning a single value for each alive variable.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm 5 EarlyDropping</head><formula xml:id="formula_4">Π b ← BootstrapSample(Π ) 6: π b ← Combine(Π b ) //Combine</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Implementation details of bootstrap testing</head><p>We recommend using the same sequence of bootstrap indices for each variable, and for each bootstrap test. The main reasons are to (a) simplify implementation, (b) avoid mistakes and (c) ensure results do not change across different executions of the algorithms. This can be done by initializing the random number generator with the same seed. Next, note that ED, ES and ER do not necessarily have to be performed separately, but can be performed simultaneously (i.e,. using the same bootstrap samplings). This allows the re-usage of the sampled indices for all tests and variables, saving some computational time. Another important observation for ED and ES is that the actual combined p-values are not required. It suffices to compare statistics instead, which are inversely related to p-values: larger statistics correspond to lower p-values. For the ED test, the statistic has to be compared to the statistic corresponding to the significance level α, which can be computed using the inverse χ 2 cumulative distribution. This is crucial to speed-up the procedure, as computing log p-values is computationally expensive. Finally, note that it is not always necessary to perform all bootstrap iterations to decide if the probability is below the threshold. This can be done by keeping track of an upper bound of the estimated probabilities, and to stop the bootstrap procedure if that bound is below the threshold, further reducing the computational cost. For example, let P drop = 0.99 and B = 999. Then, in order to drop a variable X i , the number of times cnts i where the p-value of X i exceeds α has to be at least 990. If after K iterations (B -K ) + cnts i is less than 990, one can determine that X i will not be dropped; even if in all remaining bootstrap iterations its p-value is larger than α, cnts i + B -K will always be less than 990, and thus the probability P(π i ≥ α) will be less than the threshold P drop = 0.99.</p><p>Finally, we note that, in order to minimize the probability of wrong decisions, large values for the ED, ES and ER thresholds should be used. We found that values of 0.99 for P drop and P stop , and values of P return = 0.95 and tol = 0.9 work well in practice. Furthermore, the number of bootstraps B should be as large as possible, with a minimum recommended value of 500. By default, PFBP uses the above values.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Tuning the data partitioning parameters of the algorithm</head><p>The main parameters for the data partitioning to determine are (a) the sample size s of each Data Block, (b) the number of features f in each Data Block, and (c) the number of Sample Subsets C in each Group; the latter determines how many new p-values per feature are computed in each Group. Notice that s determines the horizontal partitioning of the data matrix and f the vertical partitioning of data matrix. In this section, we provide detailed guidelines to determine those parameters, and show how those values were set for the special case of PFBP using conditional independence tests based on binary logistic regression. Selecting the data partitioning parameters needs to consider both statistical phenomena, as well as the hardware architecture. A trade-off exists between accuracy of statistical estimation of p-values and the bootstrap tests and the induced parallelism.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Determining the required sample size s for conditional independence tests</head><p>For optimal computational performance, the number of Sample Sets should be as large as possible to increase parallelism, and each Sample Set should contain as few samples as possible to reduce the computational cost for performing the local conditional independence tests. On the other hand, there should be enough samples per Sample Set so that the local tests have enough statistical power.</p><p>Various rules of thumb have appeared in the literature to choose a sufficient number of samples for linear, logistic and Cox regression <ref type="bibr" target="#b57">(Peduzzi et al. 1996;</ref><ref type="bibr" target="#b30">Harrell 2001;</ref><ref type="bibr" target="#b76">Vittinghoff and McCulloch 2007)</ref>. We focus on the case of binary logistic regression hereafter. For binary logistic regression, it is recommended to use at least s = c/ min( p 0 , p 1 ) • d f samples, where p 0 and p 1 are the proportion of negative and positive classes in T respectively, d f is the number of degrees of freedom in the model (that is, the total number of parameters, including the intercept term) and c is usually recommended to be between 5 and 20, with larger values leading to more accurate results. This rule is based on the events per variable (EPV) <ref type="bibr" target="#b57">(Peduzzi et al. 1996)</ref>, and will referred to as the EPV rule hereafter.</p><p>Rules like the above can be used to determine the number of samples s in each Sample Set, by setting the minimum number of samples in each Data Block in a way that the locally computed p-values are valid for the type of test employed in the worst case. The worst case scenario occurs if the maximum number of features maxVars have been selected. If all features are continuous, then the maximum number of parameters of a model is d f = maxVars + 1. This can easily be adapted for the case of categorical features, by considering the maxVars variables with the most categories, and setting d f appropriately. By considering the worst case scenario, the required number of samples can be computed by plugging the values of d f , c, p 0 and p 1 into the EPV rule. We found out that, although the EPV rule works reasonably well, it tends to overestimate the number of samples required for skewed class distributions. As a result, it may unnecessarily slow down PFBP in such cases. Ideally for a given value of c the results should be equally accurate irrespective of the class distribution and the number of model parameters.</p><p>To overcome the drawbacks of the EPV rule, we propose another rule, called the STD rule, which is computed as</p><formula xml:id="formula_5">s = d f • c/ √ p 0 • p 1 .</formula><p>For balanced class distributions the result is identical to the EPV rule, while for skewed distributions the value is always smaller. We found that a value of c = 10 works sufficiently well, and recommend to always set c to a minimum of 10; higher values could lead to more accurate results, but will also increase computation time. Again, the number of samples per Sample Set is determined as described above. A comparison of both rules is given in "Appendix A". We show that the STD rule behaves better across different values of d f and class distributions of the outcome than the EPV rule.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Setting the number of sample sets C per group</head><p>We now discuss the determination of the C value, the number of Sample Sets in each Group.</p><p>The value of C determines how many Sample Sets are processed in parallel and thus, how many additional local p-values for each feature are added to matrix Π at the end of processing each Group. In other words, before invoking the next round of bootstrap tests that decide on Early Dropping, Stopping or Return, C additional p-values will be available to these tests. We recommend a minimal value for C to be at least 15, otherwise the first round of bootstrap tests becomes unreliable. The value of C determines how often the workers stop and await the master to perform the bootstrap tests, which should not be too often. In our experiments we have set C = 30, without extensive tuning. In addition, whenever there is no progress made by any of the heuristics (when the "easy-to-determine" features have already been stopped or dropped), the value of C is doubled dynamically for that Iteration. This trick avoids stopping too often without any progress made. C is then reset in the next iteration.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Determining the number of features per data block</head><p>At this point, we assume we have chosen the sample size s of each data block D i, j . We also assume we have decided upon the value of C, i.e., the number of Sample Sets in each Group. In other words, we have selected the horizontal partitioning of the data at two levels: first, the partitioning of samples to Sample Sets and then to samples that belong to the same Group. Next, we need to decide the vertical partitioning to nf equal-size Feature Sets. The number of blocks per group will then become C × nf . In a system with M available workers that can process the blocks in parallel, it makes sense to determine nf so that M ≈ C × nf . Specifically, we set nf = M/C . In the extreme case where a data block does not fit in the main memory of a machine, nf has be to increased and the data to be physically partitioned to different machines.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Practical considerations and implementation details</head><p>In this section, we discuss several important details for an efficient and accurate implementation of PFBP. The main focus is on PFBP using conditional independence tests based on binary logistic regression, which is the test used in the experiments, although most details regard the general case or can be adapted to other conditional independence tests.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Accurate combination of local p-values using Fisher's method</head><p>In order to apply Fisher's combined probability test, the data distributions of each data block should be the same for the test to be valid. There should be no systematic bias on the data or the combining process may exacerbate this bias [see <ref type="bibr" target="#b74">Tsamardinos and Mariglis (2009)</ref>]. Such bias may occur if blocks contain data from the same departments, stores, or branches, or in consecutive time moments and there is time-drift on the data distribution. This problem is easily avoided if before the analysis the partitioning of samples to blocks is done randomly, as done by PFBP.</p><p>Another important detail to observe in practice, is to directly compute the logarithm of the p-values for each conditional independence test instead of first computing the p-value and then taking the logarithm. As p-values tend to get smaller with larger sample sizes (in case the null hypothesis does not hold), they quickly reach the machine epsilon, and will be rounded to zero. If this happens, then sorting and selecting features according to p-values breaks down and PFBP will select an arbitrary feature. This behavior is further magnified in case of combined p-values, as a single zero local p-value leads to a zero combined pvalue no matter the values of the remaining p-values. The R language provides the option to directly compute the logarithm of the p-value (using the option log. p = T ). Next, we give pointers to our implementation, since there was no other implementation available for Spark. For the χ 2 distribution, the p-value can be computed as Γ (k/2,x/2) Γ (k/2) , where x is the test statistic, k the degrees of freedom, Γ (•, •) the incomplete gamma function and Γ (•) the gamma function. Formulas for computing the incomplete gamma function can be found in <ref type="bibr" target="#b15">Chaudhry and Zubair (2001)</ref> (equation 2.27 for k/2 = n +1/2, n = 0, 1, 2, . . . and corollary 2.1 for positive integer values of k/2). By careful computation of the terms of the sums, the logarithm of the p-value can be computed with very high accuracy (even 10 -1000000 ).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Implementation of the conditional independence test using logistic regression for binary targets</head><p>The conditional independence test is the basic building block of PFBP, and thus using a fast and robust implementation is essential. Next, we briefly review optimization algorithms used for maximum likelihood estimation, mainly focusing on binary logistic regression, and in the context of feature selection using likelihood-ratio tests.</p><p>A comprehensive introduction and comparison of algorithms for fitting (i.e., finding the β that maximizes the likelihood) binary logistic regression models is provided in <ref type="bibr" target="#b52">Minka (2003)</ref>. Three important classes of optimization algorithms are Newton's method, conjugate gradient descent and quasi-Newton methods. Out of those, Newton's method is the most accurate and typically converges to the optimal solution in a few tens of iterations. The main drawback is that each such iteration is slow, requiring O(n • d 2 ) computations, where n is the sample size and d the number of features. Conjugate gradient descent and quasi-Newton methods on the other hand require O(n • d) and O(n • d + d 2 ) time per iteration, but may take much longer to converge. Unfortunately, there are cases were those methods fail to converge to an optimal solution even after hundreds of iterations. This not only affects the accuracy of feature selection, but also leads to unpredictable running times. Most statistical packages include one or multiple implementations of logistic regression. Such implementations typically use algorithms that can handle thousands of predictors, with quasi-Newton methods being a popular choice. For feature selection however, one is typically interested to select a few tens or hundreds of variables. In anecdotal experiments, we found that for this case Newton's method is usually faster and more accurate, especially with fewer than 100-200 variables. Because of that, and because of the issues mentioned above, we used a fine-tuned, custom implementation of Newton's method.</p><p>There are some additional, important details. First of all, there are cases where the Hessian is not invertible.<ref type="foot" target="#foot_11">foot_11</ref> If this the case, we switch to conjugate gradient descent using the fixed Hessian as a search direction for that iteration, as described in <ref type="bibr" target="#b52">Minka (2003)</ref>. Finally, as a last resort, in case the fixed Hessian is not invertible we switch to simple gradient descent. Next, for all optimization methods there are cases in which the computed step-size has to be adjusted to avoid divergence, whether it is due to violations of assumptions or numerical issues. One way to do this is to use inexact line-search methods, such as backtracking-Armijo line search <ref type="bibr" target="#b4">(Armijo 1966)</ref>, which was used in our implementation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Score tests for the univariate case</head><p>In the first step of forward selection where no variable has been selected, one can use a score test (also known as Lagrange multiplier test) instead of a likelihood-ratio test to quickly compute the p-value without having to actually fit logistic regression models. The statistic of the Score test equals <ref type="bibr" target="#b32">(Hosmer et al. 2013</ref>)</p><formula xml:id="formula_6">Statistic ≡ n j=1 X j (T j -T ) T (1 -T ) n j=1 (X j -X ) 2</formula><p>where n is the number of samples, T is the binary outcome variable (using a 0/1 encoding), and X is the variable tested for independence. Note that, such tests can also be derived for models other than binary logistic regression, but it is out of the scope of the paper. The score test is asymptotically equivalent to the likelihood ratio test, and in anecdotal experiments we found that a few hundred samples are sufficient to get basically identical results, justifying its use in Big Data settings. Using this in place of the likelihood ratio test reduces the time of the univariate step significantly and is important for an efficient implementation, as the first step is usually the most computationally demanding one in the PFBP algorithm, as a large portion of the variables will be dropped by the Early Dropping heuristic.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Optimality of PFBP on distributions faithful to Bayesian networks and maximal ancestral graphs</head><p>Assuming an oracle of conditional independence, it can be shown that the standard Forward-Backward Selection algorithm is able to identify the optimal set of features for distributions faithful to Bayesian networks or maximal ancestral graphs <ref type="bibr" target="#b47">(Margaritis and Thrun 2000;</ref><ref type="bibr" target="#b73">Tsamardinos et al. 2003b;</ref><ref type="bibr" target="#b10">Borboudakis and Tsamardinos 2017)</ref>. Unfortunately, the Early Dropping (ED) heuristic (without further adjustments) may compromise the optimality of the method. ED may remove features that are necessary for optimal prediction of T . Intuitively, these features provide no predictive information for T given S (are conditionally independent) but become conditionally dependent given a superset of S, i.e., after more features are selected. This problem can be overcome by using multiple Runs of the Forward-Backward Phases. Recall that, each Run reinitializes the remaining variables with R = F\S. Thus, each subsequent Run provides each feature with another opportunity to be selected, even if it was Dropped in a previous one. The heuristic has a graphical interpretation in the context of probabilistic graphical models such as Bayesian networks and maximal ancestral graphs <ref type="bibr" target="#b55">(Pearl 2000;</ref><ref type="bibr" target="#b67">Spirtes et al. 2000;</ref><ref type="bibr" target="#b61">Richardson and Spirtes 2002)</ref> inspired by modeling causal relations. A rigorous treatment of the Early Dropping heuristic and theorems regarding its optimality for distributions faithful to Bayesian networks and maximal ancestral graphs is provided in <ref type="bibr" target="#b10">Borboudakis and Tsamardinos (2017)</ref>; for the paper to be self-sustained, we provide the main theorems along with proofs next. We assume that PFBP has access to an independence oracle that determines whether a given conditional dependence or independence holds. Furthermore, we assume that the 123 Markov and faithfulness conditions hold, which allow us to use the terms d-separated/mseparated and independent (dependent) interchangeably. We will use the the weak union axiom, one of the semi-graphoid axioms <ref type="bibr" target="#b55">(Pearl 2000)</ref> about conditional independence statements, which are general axioms holding in all probability distributions. The weak union axiom states that X⊥Y ∪ W | Z ⇒ X⊥Y | Z ∪ W holds for any such sets of variables.</p><p>Theorem 1 If the distribution can be faithfully represented by a Bayesian network, then PFBP with two Runs identifies the Markov blanket of the target T . Proof In the first run of PFBP, all variables that are adjacent to T (that is, its parents and children) will be selected, as none of them can be d-separated from T by any set of variables. In the next run, all variables connected through a collider path of length 2 (that is, the spouses of T ) will become d-connected with T , since the algorithm conditions on all selected variables (including its children), and thus spouses will be selected as at least a d-connecting path is open: the path that goes through the selected child. The resulting set of variables includes the Markov blanket of T , but may also include additional variables. Next we show that all additional variables will be removed by the backward selection phase. Let MB(T ) be the Markov blanket of T and S ind = S\MB(T ) be all selected variables not in the Markov blanket of T . By definition, T ⊥X | M B(T ) holds for any set of variables X not in MB(T ), and thus also for variables S ind . By applying the weak union graphoid axiom, one can infer that ∀S i ∈ S ind , T ⊥S i | M B(T ) ∪ S ind \S i holds, and thus some variable S j will be removed in the first iteration. Using the same reasoning and the definition of a Markov blanket, it can be shown that all variables in S ind will be removed from MB(T ) at some iteration. To conclude, it suffices to use the fact that variables in MB(T ) will not be removed by the backward selection, as they are not conditionally independent of T given the remaining variables in MB(T ).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 2 If the distribution can be faithfully represented by a directed maximal ancestral graph, then PFBP with no limit on the number of Runs identifies the Markov blanket of the target T .</head><p>Proof In the first run of PFBP, all variables that are adjacent to T (that is, its parents, children and variables connected with T by a bi-directed edge) will be selected, as none of them can be m-separated from T by any set of variables. After each run additional variables may become admissible for selection. Specifically, after k runs all variables that are connected with T by a collider path of length k will become m-connected with T , and thus will be selected; we prove this next. Assume that after k runs all variables connected with T by a collider path of length at most k -1 have been selected. By conditioning on all selected variables, all variables with edges into some selected variable connected with T by a collider path will become m-connected with T . This is true because conditioning on a variable Y in a collider X , Y , Z m-connects X and Z . By applying this on each variable on some collider path, it is easy to see that its end-points become m-connected. Finally, after applying the backward selection phase, all variables that are not in the Markov blanket of T will be removed; the proof is identical to the one used in the proof of Theorem 1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Related work</head><p>In this section we provide an overview of related parallel feature selection methods, focusing on methods for MapReduce-based systems (such as Spark), as well as causal-based methods, and compare them to PFBP. An overview of feature selection methods can be found in <ref type="bibr" target="#b28">Guyon and Elisseeff (2003)</ref> and <ref type="bibr" target="#b43">Li et al. (2017)</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.1">Parallel univariate feature selection and parallel Forward-Backward selection</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>UFS and FBS rank features according to p-values of independence tests. UFS computes</head><p>the p-values of the unconditional test between a feature and the target, while FBS performs conditional tests given the already selected features. UFS statically ranks features, while FBS updates the ranking with every newly selected feature. The algorithms stop when the maximum number of features has been selected, or the p-values are below some significance threshold. Both UFS and FBS can be parallelized at the level of the underlying statistical test employed. Specifically, the Spark machine learning library MLlib <ref type="bibr" target="#b50">(Meng et al. 2016</ref>) offers parallel implementations of Pearson and Spearman correlation coefficients for continuous data, and the chi-square test of independence for discrete data. For conditional independence, tests can be constructed using the likelihood ratio technique by fitting statistical models. MLlib offers parallelized binomial, multinomial, and linear regression models to this end. We employed these parallelized statistical tests to implement UFS and FBS in the experimental section.</p><p>The main advantages of PFBP over UFS and FBS are that (a) PFBP does not require specialized distributed implementations of independence tests, as it only relies on local computations and thus can use existing implementations. Local fitting and combining is also much faster than fitting full models over all samples, and (b) PFBP employs the Early Dropping, Early Stopping and Early Return heuristics, allowing it to scale both with number of features and samples. Perhaps, most importantly (c) UFS will not necessarily identify the Markov Blanket of T even in faithful distributions; the solution by UFS will have false positives (e.g., redundant features) as well as false negatives (missed Markov Blanket features).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.2">Single feature optimization</head><p>The Single Feature Optimization algorithm (SFO) <ref type="bibr" target="#b66">(Singh et al. 2009</ref>) is a Map-Reducebased extension of the standard forward selection algorithm using binary logistic regression. In essence, SFO employs an efficiency trick to approximate the parallel computation of the criterion to select the next best feature, when the binary logistic regression test is employed. Thus, the algorithm is specific to classification tasks and cannot be tivially generalized to other types of classifiers in place of the logistic regression.</p><p>In more detail, SFO (a) employs a heuristic that ranks the features at each step without the need to fit a full logistic regression model (that is, one over all samples) for all variables, and (b) uses a parallelization scheme to perform parallel computation over samples and features.</p><p>We proceed by describing the ranking heuristic used by SFO. Let S be the selected features up to some point and R = F\S be all candidate variables for selection, and assume that a full logistic regression model M for T using S is available. SFO creates an approximate model for each variable R i ∈ R by fixing the coefficients of S using their coefficients in M, and only optimizing the coefficient of R i . This problem is much simpler than fitting full models for each remaining variable, significantly reducing running time. Then, the best variable R * is chosen based on those approximate models (using some performance measure such as the log-likelihood), and a full logistic regression model M * with S ∪ R * is created. Thus, at each iteration only a single, full logistic regression model needs to be created. By default, SFO uses a maximum number of variables to select as a stopping criterion. Alternatively, to decide whether R * should be selected a likelihood-ratio test could be used, in which case the test is performed on M and M * , and R * is selected if the p-value is below a threshold α; we used this in our implementation of SFO in the experiments. The parallelization over samples is performed in the map phase, in which one value p j is computed for each sample j, which equals</p><formula xml:id="formula_7">p j = e β•S j 1 + e β•S j</formula><p>where β are the coefficients of S in M and S j are the values of S in the jth sample. The values of p j , the values of the outcome T and all of candidate variables R are then sent to workers to be processed in the reduce phase. Note that, this incurs a high communication cost, as essentially the whole dataset has to be exchanged among workers over the network. Finally, in the reduce phase, all workers fit in parallel over all variables R the approximate logistic regression models.</p><p>Although SFO significantly improves over the standard forward selection algorithm in terms of running time, it has three main drawbacks compared to PFBP: (a) it has a high communication cost, in contrast to PFBP which only requires minimal information to be communicated, (b) to select a variable all non-selected variables have to be considered, while PFBP employs the Early Dropping heuristic that significantly reduces the number of remaining variables, and (c) SFO always uses all samples, while PFBP uses Early Stopping and Early Return allowing it to scale sub-linearly with number of samples. Finally, (d) SFO does not provide any theoretical guarantees of correctness.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.3">Information theoretic feature selection for Big Data</head><p>Information theoretic feature selection (ITFS) <ref type="bibr" target="#b12">(Brown et al. 2012</ref>) methods have been extended to Big Data settings <ref type="bibr" target="#b60">(Ramrez-Gallego et al. 2017</ref>) and implemented for Spark.<ref type="foot" target="#foot_12">foot_12</ref> They are applicable only for discrete features and outcomes; non-discrete data would have to be discretized. ITFS relies on estimations of the mutual information and the conditional mutual information (CMI), and many variations have appeared in the literature <ref type="bibr" target="#b12">(Brown et al. 2012)</ref>; we provide a brief description next. The criterion J of several ITFS methods <ref type="foot" target="#foot_13">13</ref> for evaluating feature X k can be expressed as</p><formula xml:id="formula_8">J (X k ) = I (T ; X k ) -β X j ∈S I (X j ; X k ) + γ X j ∈S I (X j ; X k |T )</formula><p>where β and γ are parameters taking values in [0, 1], and I denotes the mutual or conditional mutual information. The intuition for J (X k ) above, is that J increases with the information X k directly provides for the target T (the first term), decreases with the information the other selected features already provide for X k (second group of terms), and increases when X k interacts with the selected features, i.e., one provides information for the other features conditioned on T (third group of terms). ITFS methods also perform a greedy type of forward selection, adding a feature at a time, albeit with a different selection criterion than PFBP. The next best feature is chosen as the one maximizing J with respect to the current set of selected variables S.</p><p>Specifically, for the implementations examined in this paper, ITFS estimate CMIs assuming a multinomial model of the joint between (discrete) features. In this case, the estimated MI</p><formula xml:id="formula_9">I (X ; Y ) = 1 2 G 2 (X ; Y ), where G 2 (X ; Y ) is the test statistic of a G 2 likelihood ratio test.</formula><p>In other words, the estimations correspond to using a G 2 likelihood ratio test of conditional independence in statistical-based FS algorithm <ref type="bibr" target="#b0">(Agresti 2002)</ref>. In contrast, the current implementation of PFBP uses a logistic regression test that imposes a linear dependence of the probabilities of the joint to the values of the features.</p><p>The main advantage of the specific implementation of ITFS over PFBP's is that estimating the (conditional) mutual informations for discrete data under the multinomial assumption, does not require fitting any model; it only requires counting and constructing the contingency tables of the joint. This can be done in one pass of the data and can thus trivially exploit the sparsity of the data. In Big Data settings it can be easily parallelized. However, ITFS methods do not have the same theoretical properties of PFBP, which can be shown to be optimal for distributions that can be faithfully represented by Bayesian networks and maximal ancestral graphs. This stems from the fact that PFBP solves an inherently harder problem, as it conditions on all selected features (creates a model with all selected features) at each iteration in order to select the next feature, while ITFS only conditions on one feature at a time. Furthermore, ITFS methods are not as general as PFBP, which can be applied to various data types as long as an appropriate conditional independence test is available. For example, it is not clear if and how ITFS can be applied to time-to-event outcome variables or time-course data. Instead, appropriate statistical tests for these cases are available and put in use within statistical-based methods similar to PFBP <ref type="bibr" target="#b39">(Lagani et al. 2017)</ref>. Last but not least, as currently implemented, ITFS variants are only applicable to discrete data. Thus, in case of continuous variables, a discretization method has to be applied before feature selection, possibly losing information <ref type="bibr" target="#b35">(Kerber 1992;</ref><ref type="bibr" target="#b20">Dougherty et al. 1995)</ref>. This not only increases computational time but also may require extra tuning to find a good discretization of features.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.4">Lasso, Orthogonal Matching Pursuit, Least Angle Regression, and Forward Stagewise Regression</head><p>Given that the problem of FS in general is NP-Hard, it is natural that any algorithm that scales to high-dimensional data employs some approximations or heuristics that are sound only in a restricted class of distributions. A large class of algorithms, namely the Lasso <ref type="bibr" target="#b69">(Tibshirani 1996)</ref>, Least Angle Regression <ref type="bibr" target="#b21">(Efron et al. 2004)</ref>, Forward Stagewise Regression <ref type="bibr" target="#b21">(Efron et al. 2004</ref>) and Orthogonal Matching Pursuit <ref type="bibr" target="#b53">(Pati et al. 1993;</ref><ref type="bibr" target="#b18">Davis et al. 1994</ref>) are all greedy-like versions of the basic Forward-Backward FS. A detailed comparison between Lasso, Least Angle Regression and Forward Stagewise Regression can be found in <ref type="bibr" target="#b21">Efron et al. (2004)</ref>, a comparison between Least Angle Regression and Orthogonal Matching Pursuit is given in <ref type="bibr" target="#b29">Hameed (2012)</ref>, while a comparison between Orthogonal Matching Pursuit and Forward Selection (called Orthogonal Least Squares) can be found in <ref type="bibr" target="#b7">Blumensath and Davies (2007)</ref>.</p><p>We proceed with a brief high-level comparison of the above with the Forward Selection algorithm. All of the above algorithms select the next feature using some selection criterion and are equipped with a stopping criterion. On an intuitive level, they select as the next feature to include the feature that provides the most information (highest correlation) for the errors (residuals) of the current model. In contrast, Forward Selection and PFBP select the feature that provides the most additional information for the target (given all other selected features). In Lasso, the Forward-Backward phases are interleaved. When a feature is selected for inclusion forward selection, PFBP, and Orthogonal Matching Pursuit construct a new unrestricted model that includes the newly selected feature. Lasso, Least Angle Regression and Forward Stagewise Regression also create a new model, but constrain the coefficients of the newly selected features. Lasso has a special stopping criterion based on the L1-norm of the coefficients of the current selections. Given this synthetic view and connections between the algorithms, we would like to note that the ideas, techniques, and heuristics presented, could be translated for use with several other prominent FS algorithms.</p><p>We now focus in more detail on Lasso <ref type="bibr" target="#b69">(Tibshirani 1996)</ref>, which is perhaps one of the most widely used FS algorithm. The feature selection problem is expressed as a global optimization problem using an L 1 penalty on the feature coefficients. Let D(θ ) be the deviance of a (generalized linear) model using n parameters θ . The optimization problem Lasso solves can be expressed as</p><formula xml:id="formula_10">min θ ∈R n D(θ ) + λ θ 1</formula><p>where θ 1 is the L 1 norm and λ ≥ 0 is a regularization parameter. The solutions Lasso returns are sparse, meaning that most coefficients are set to zero, thus implicitly performing feature selection. The regularization parameter λ controls the number of non-zero coefficients in the solution, with larger values leading to sparser solutions. This problem formulation is a convex approximation of the more general best subset selection (BSS) problem <ref type="bibr" target="#b51">(Miller 2002)</ref>, defined as follows to match the Lasso optimization formulation min θ ∈R n D(θ ) + λ θ 0 where θ 0 is the 0-norm (i.e., the total number of variables with non-zero coefficients). The BSS problem has been shown to be NP-hard <ref type="bibr" target="#b80">(Welch 1982)</ref>, and thus most approaches, such as Lasso and forward selection, rely on some type of approximation to solve it. <ref type="foot" target="#foot_14">14</ref> A sufficient condition for optimality of PFBP and FBS to solving the BSS (equivalent to finding the Markov Blanket) is that distributions can be faithfully represented by Bayesian networks or maximal ancestral graphs (see Sect. 7). Conditions for optimal feature selection with Lasso are given in <ref type="bibr" target="#b49">Meinshausen and Bühlmann (2006)</ref>. While Lasso is defined as a global optimization problem, it has been proven that many problems can be solved with a greedy Forward-Backward procedure [e.g., for linear regression <ref type="bibr" target="#b21">(Efron et al. 2004)</ref>].</p><p>Comparing Lasso with algorithms related to PFBP, we note that in extensive simulations it has been shown that causally-inspired feature selection methods are competitive in terms of predictive performance with Lasso on classification and survival analysis tasks on many real datasets <ref type="bibr" target="#b2">(Aliferis et al. 2010;</ref><ref type="bibr" target="#b41">Lagani and Tsamardinos 2010;</ref><ref type="bibr" target="#b40">Lagani et al. 2013</ref><ref type="bibr" target="#b39">Lagani et al. , 2017))</ref>. Furthermore, the non-parallel version of PFBP (called Forward-Backward Selection with Early Dropping) as well as the standard Forward-Backward Selection algorithm have been shown to perform as well as Lasso when restricted to select the same number of variables <ref type="bibr" target="#b10">(Borboudakis and Tsamardinos 2017)</ref>. Finally, we note that in contrast to forward selection using conditional independence tests, Lasso is not easily extensible for different tasks, and requires specialized algorithms for different data types <ref type="bibr" target="#b48">(Meier et al. 2008;</ref><ref type="bibr" target="#b63">Schelldorfer et al. 2011;</ref><ref type="bibr" target="#b33">Ivanoff et al. 2016)</ref>, whose objective function may be non-convex <ref type="bibr" target="#b63">(Schelldorfer et al. 2011)</ref> or computationally demanding <ref type="bibr" target="#b24">(Fan et al. 2010)</ref>. For example, for time-course data, the Lasso problem is not convex and does not scale up, while causal-based FS methods do <ref type="bibr" target="#b70">(Tsagris et al. 2018)</ref>.</p><p>Coming back to Big Data settings, the Lasso has been parallelized for single machines and shared-memory clusters <ref type="bibr" target="#b11">(Bradley et al. 2011;</ref><ref type="bibr" target="#b89">Zhimin et al. 2013;</ref><ref type="bibr" target="#b44">Li et al. 2016</ref>). These approaches only parallelize over features and not samples (i.e. consider vertical partitioning).</p><p>Naturally, ideas and techniques presented in those works could be adapted or extended for Spark or related systems. An implementation of Lasso linear regression is provided in the Spark MLlib library <ref type="bibr" target="#b50">(Meng et al. 2016)</ref>. A disadvantage of that implementation is that it requires extensive tuning of its hyper-parameters (like the regularization parameter λ and several parameters of the optimization procedure), rendering it impractical as typically many different hyper-parameter combinations have to be tried to obtain the optimal settings. Unfortunately, we were not able to find any Spark implementation of Lasso for logistic regression, or any work dealing with the problem of efficient parallelization of Lasso on Spark.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.5">Other approaches</head><p>In addition to forward-selection based, information theoretic and Lasso based methods, there also exist other parallel feature selection methods which can't directly be categorized into one of the above but are worth mentioning. However, none of those methods has actually been applied to Big Data, which may contain millions of samples and/or features. Furthermore, all of the methods perform virtual partitioning of the data, and thus only parallelize over features and not over samples, in contrast to PFPB which parallelizes over both.</p><p>Bolón-Canedo et al. ( <ref type="formula">2017</ref>) introduced a method which uses vertical partitioning to distribute computations across workers. The method focuses mainly on DNA microarray data, whose number of features is much larger than the number of samples, although it is not limited to those cases. It can be applied using any feature selection method that ranks features, like the ITFS methods described previously, or even forward selection type algorithms using as a ranking the order of selection of variables. The main idea is to rank variables on each worker independently and to combine the partial rankings into a complete one. In order to be able to combine the rankings, each variable may be distributed to multiple workers in order to have some kind of overlap between the partial rankings, allowing them to be merged into one. Although the method is quite general, as it can be used in combination with any method that produces a ranking of the features, its theoretical properties are not explored in the paper, making it hard to compare theoretically against other methods.</p><p>Zhou et al. ( <ref type="formula">2014</ref>) introduced a general, parallel feature selection method for classification tasks that is based on group testing theory. The idea is to select a collection of tests (i.e., a subset of the input variables), with each variable being present with some probability p. This implicitly creates multiple datasets, one for each test. Those datasets can be processed independently in parallel, producing a score using some scoring function for each dataset corresponding to how predictive the respective variables are of the outcome of interest. Then, variables are ranked based on the scores attained on the datasets they participated in. The authors show that, for specific values of p, if the number of tests is large enough and if the scoring function satisfies some properties (i.e., it is what the authors call C-separable), the proposed algorithm is able to select the best features with high probability. However, it is not clear how those results are related to the theoretical properties of other feature selection algorithm (such as PFBP or Lasso), nor how they can be used in practice, especially given that the authors do not propose any way to tune the hyper-parameters of their method. <ref type="bibr" target="#b78">Wang et al. (2016)</ref> proposed a method that also uses vertical partitioning for parallelization. It is method that can be used with any penalized regression method, both for feature selection and for model fitting. Given a dataset, it is partitioned vertically into multiple datasets, and a decorrelation step is performed on each new dataset that tries to minimize the dependencies between all datasets. Then, each dataset can be analyzed independently across multiple workers, and the results are combined into a final one on the master machine. It is shown 123 that the convergence rate of the proposed method is nearly minimax optimal under weakly sparse assumptions on the model parameters. Furthermore, it is shown that the algorithms retains those properties irrespective of the number of partitions. In experiments, the method is shown to perform similarly to lasso while exhibiting lower running time. In contrast to PFBP, the method is specialized only to specific cases (penalized regression methods with continuous predictors), and thus is not easily extensible to other cases.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.6">Connections to Markov blanket based feature selection</head><p>Several algorithms have appeared in the literature that apply tests of conditional independence to select features. The theoretical properties of these algorithms often rely on the theory of Bayesian networks and the Markov blanket. The GS <ref type="bibr" target="#b47">(Margaritis and Thrun 2000;</ref><ref type="bibr" target="#b46">Margaritis 2009</ref>) and the IAMB <ref type="bibr" target="#b73">(Tsamardinos et al. 2003b</ref>) algorithms, were some of the first to present the Forward-Backward selection algorithm in the context of Bayesian networks and the Markov blanket and prove correctness for faithful distributions. These algorithms perform tests of independence conditioning each time on the full set S of selected features and can guarantee to identify the Markov blanket for faithful distributions asymptotically. However, the larger the conditioning set, the more samples are required to obtain valid results. Thus, these algorithms are not well-suited for problems with large Markov blankets relative to the available sample size.</p><p>Another class of such algorithms includes HITON-PC <ref type="bibr" target="#b3">(Aliferis et al. 2003)</ref>, MMPC <ref type="bibr">(Tsamardinos et al. 2003a)</ref>, and more recently SES <ref type="bibr" target="#b39">(Lagani et al. 2017)</ref> for multiple solutions. The main difference in this class of algorithms is that they condition on subsets of the selected features S, not the full set. They do not guarantee to identify the full Markov blanket, but only a superset of the parents and children of T . Recent extensive experiments have concluded that they perform well in practice <ref type="bibr" target="#b2">(Aliferis et al. 2010</ref>). These algorithms remove from consideration any features that become independent of T conditioned on some subset of the selected features S. This is similar to the Early Dropping heuristic and renders the algorithms quite computationally efficient and scalable to high-dimensional settings.</p><p>PFBP combines the advantages of these two classes of algorithms: those that condition on subsets, drop features from consideration and achieve scalability, and those that condition on the full set of selected features and guarantee identification of the full Markov blanket.</p><p>We made every reasonable effort to include all candidate competitors. These alternatives constitute algorithms specifically designed for MapReduce architectures (i.e., SFO), standard FS algorithms using parallel implementations of the conditional independence tests (i.e., UFS and FBS) and ITFS. The only Lasso implementation for Spark available in the Spark MLlib library <ref type="bibr" target="#b50">(Meng et al. 2016</ref>) (a) is for continuous targets, and thus is not suitable for binary classification tasks, and (b) required tuning of 5 hyper-parameters; as no procedure has been suggested by the authors for their tuning, it was excluded from the comparative evaluation. Additionally, for the comparative evaluation, final predictive models were build using the selected features by each algorithm using:</p><p>1. The logistic regression implementation in the Spark machine learning library MLlib, hereafter denoted as SparkLR 2. The logistic regression model stemming from combining local logistic models using our own implementation (ee Sect. 3.5), hereafter denoted as CombLR</p><p>The reason for including both types of modeling is because we noticed that SparkLR often fails to converge and produces models that are worse than the trivial classifier classifying to the most common class. This last comparison provides evidence that not only local pvalues can be combined using meta-analysis techniques, but also model coefficients and other estimated quantities.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.1">Experimental setup</head><p>For the scalability experiments of PFBP (Sect. 9.2) and the proof-of-concept application on SNP data (Sect. 9.4) we used a cluster with 5 machines, 1 acting as a master and 4 as workers, connected to a 1 Gigabit network, with each machine having 2 Intel Xeon E5-2630 v3 CPUs with 8 physical cores each and 256 GB of RAM (a total of 64 cores and 1 TB of RAM). For the comparative evaluation of PFBP with other feature selection algorithms we used a cluster with 5 workers, connected to a 14 Gigabit network, with each machine having 4 Intel Xeon E5-4650 v2 CPUs with a total of 80 cores and 400 GB of RAM (a total of 320 cores and 1.6 TB of RAM). In all cases, 2 cores per worker were left out for other tasks (e.g. the operating system). The first cluster is running Spark 2.1.0 while the second is running Spark 2.0.2, and both are using the HDFS file system. All algorithms were implemented in Java 1.7 and Scala 2.11. The significance level α was set to 0.01 for all algorithms,<ref type="foot" target="#foot_15">foot_15</ref> and PFBP was executed with 2 Runs. For the bootstrap tests used by PFBP, we used the default parameter values as described in Sect. 4.2. For each feature selection method we produced two predictive models: (a) using the approach described in Sect. 3.5 that combines multiple locally learned models into a single one, and (b) using the logistic regression implementation in the Spark machine learning library MLlib <ref type="bibr" target="#b50">(Meng et al. 2016)</ref>. Parameter values related to the number of Group Samples, Sample Sets and Feature Sets were determined using the STD rule, and by setting the maximum number of variables to select to maxVars (the exact value is given for each specific experiment later); see Sect. 5 for more details. We note that, none of the experiments required a physical partitioning to Feature Sets, and thus each Block contains all features (i.e., the number of Features Sets nf is 1).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.2">Scalability of PFBP with sample size, feature size and number of workers</head><p>We investigated the scalability of PFBP on dense synthetic datasets in terms of sample size, variable size and number of workers used. The data were sampled from randomly generated Bayesian networks, which are probabilistic models that can encode complicated dependency structures among features. Such simulated data contain not only features necessary for optimal prediction [strongly relevant in the terminology of <ref type="bibr" target="#b34">John et al. (1994)</ref>] and irrelevant, but also redundant features [weakly relevant <ref type="bibr" target="#b34">(John et al. 1994)</ref>]. This is a novelty in the Big Data FS literature as far as we know, making the synthetic tasks more realistic. A detailed description of the data and network generating procedures is given in "Appendix B".</p><p>For each experimental setting, we generated 5 Bayesian networks, and sampled one dataset from each. The connectivity parameter C was set to 10 (i.e., the average degree of each node), the class distribution of T was 50/50, and the variance of the error term was set to 1. To investigate scalability in terms of sample size, we fixed the number of features to 1000 and varied the sample size from 2 to 10 M. Scalability in terms of feature size was evaluated on datasets with 100K samples and varying the feature size from 20 to 100 K, all of which also included the optimal feature set (i.e. the Markov blanket of T ). Finally, scalability in terms of number of workers was investigated on datasets with 10 K variables and 1M samples. The maximum number of variables maxVars to select was set to 50.</p><p>The results are summarized in Fig. <ref type="figure" target="#fig_4">3</ref>. On the top row we show the relative runtime of PFBP with varying sample size (left) and number of variables (right), respectively. The bottom figure shows the speed-up achieved with varying the number of workers. Relative time and speed up are computed with respect to the lowest point on the x-axis. We can clearly see that: (Top Left) PFBP improves super-linearly with sample size; in other words, feeding twice the number of rows to the algorithm requires less than double the time. This characteristic can be attributed to the Early Stopping and Early Return heuristics. (Top Right) PFBP scales linearly with number of features due to the Early Dropping heuristic and (Bottom) PFBP is able to utilize the allocated machines, although the speed-up factor does not reach the theoretical optimum. The reason for this is that the Early Stopping heuristic quickly prunes many features from consideration after processing the first Group sample, reducing parallelization in subsequent Groups as only few features remain Alive.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.3">Comparative evaluation of PFBP on real datasets</head><p>We evaluated the PFBP algorithm on 13 binary classification datasets, collected from the LIBSVM dataset repository, <ref type="foot" target="#foot_16">16</ref> with the constraint that each dataset contains at least 500K samples or variables. A summary of the datasets, shown in order of increasing variable size, is shown in Table <ref type="table" target="#tab_8">2</ref>. The first two columns show the total number of samples and variables of each dataset, while the last column shows the average number of non-zero elements of each sample. The maximum number of non-zero elements equals the total number of variables. Except for the first four datasets, all other datasets are extremely sparse.</p><p>All algorithms were compared in terms of classification accuracy and running time. To estimate the classification accuracy, 10% of the training instances were randomly selected  The fastest algorithms are shown in bold, while algorithms that timed out are indicated with an asterisk. PFBP significantly outperforms all competitors in terms of running time, and is the only algorithm that is able to terminate for all datasets within the given time limit of 12 h. Furthermore, except for 2 cases (FBS on the epsilon dataset and SFO on the rcv1 dataset; see Table <ref type="table" target="#tab_9">4</ref>), none of the competing algorithms were able to select a single variable within 12 h and kept out. The remaining 90% were used by each algorithm to select a set of features and to train a logistic regression model using those features. The maximum number of features to select was set to 50. We note that, for PFBP, the backward phases and the second phase were only executed if the algorithm terminated (i.e., the remaining variables were empty) before the variable limit was reached. This was done because PFBP would not have terminated otherwise (i.e., the first phase would still have variables to consider), and thus would not have executed the extra phases. A timeout limit of 12 h was used for each algorithm. In case an algorithm did not terminate within the time limit, the number of features selected up to that point are reported. If no feature was selected, the accuracy was set to N/A (not available). For PFBP, we used the data partitioning strategy described in Sect. 5. For the remaining methods, the number of partitions was set to 4 times the total number of Spark tasks. We ran 6 Spark tasks, each one using 13 cores, on each of the 5 workers. Thus, the total number of partitions was set to 120.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.3.1">Comparison of PBFP with forward selection based methods</head><p>We compared PFBP to 3 forward selection based algorithms: (i) Single Feature Optimization (SFO) <ref type="bibr" target="#b66">(Singh et al. 2009</ref>), (ii) Forward-Backward Selection (FBS), and (iii) Univariate Feature Selection (UFS). UFS and FBS were implemented using a parallelized implementation of standard binary logistic regression for Big Data provided in the Spark MLLib <ref type="bibr" target="#b50">(Meng et al. 2016)</ref>.</p><p>Table <ref type="table">3</ref> shows the running times of the algorithms (rounded up to the closest minute), and Table <ref type="table" target="#tab_9">4</ref> show the classification accuracy and the number of selected variables. We included  show the best performing method for a given classifier, while numbers shown in italic indicate that there is a significant difference (&gt; 1%) between the predictive performance obtained using the classifiers, or that the classifier performs worse than the trivial classifier. Overall, all feature selection methods perform similarly, with PFBP and SFO typically having the best predictive performance. PFBP achieves the better or on par performance by selecting fewer variables than its competitors. Furthermore, in most cases, combining models CombLR works as well or better than the logistic regression of MLlib, SparkLR the results of the trivial classifier, which assigns each sample to the most frequent class, and thus attains an accuracy equal to the frequency of the most common class.</p><p>It can be seen that PFBP outperforms all competing methods in terms of running time. SFO, UFS, and FBS only terminate selecting at least 1 feature in the smallest, first 4 datasets. UFS and FBS reach the timeout limit and do not select a single feature even for the moderately sized rcv1 dataset, which contains only 47K variables and 698K samples, while SFO is able to select only a single feature in 12 h.<ref type="foot" target="#foot_17">foot_17</ref> PFBP is able to terminate for all datasets within 12 h, taking a maximum of 10.5 h for the kdd2010b dataset which contains 19M samples and 30M variables.</p><p>In terms of predictive performance, PFBP always produces the best or an equally predictive model. When a competitor produces a better model the difference is in order of 0.01% of accuracy. Some larger differences are observed only when the final model is fit with the SparkLR. In terms of the number of features, PFBP always selects the lowest number of features to achieve the same or better performance. An exception is when FBS timed-out for the epsilon dataset selecting 10 features versus 50 for PFBP; however, the lower number of features comes with a significant drop in performance of about 10% of accuracy.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.3.2">Comparison of PBFP with information theoretic feature selection methods</head><p>Next, we compare PFBP to three algorithms of the family of information theoretic feature selection (ITFS) methods <ref type="bibr" target="#b12">(Brown et al. 2012</ref>): the Minimum-Redundancy Maximum-Relevance (MRMR) algorithm <ref type="bibr" target="#b59">(Peng et al. 2005)</ref>, the Joint Mutual Information (JMI) algorithm <ref type="bibr" target="#b84">(Yang and Moody 2000)</ref> and the Conditional Mutual Information Maximization algorithm <ref type="bibr" target="#b26">(Fleuret 2004</ref>). Those methods were chosen as they have been shown to be perform well compared to several other members of the ITFS family <ref type="bibr" target="#b12">(Brown et al. 2012)</ref>. For all of the above algorithms, we used existing Spark-based implementations<ref type="foot" target="#foot_18">foot_18</ref>  <ref type="bibr" target="#b60">(Ramrez-Gallego et al. 2017)</ref>.</p><p>As information-theoretic feature selection methods require discrete data, we performed a simple discretization method on all sparse datasets (i.e., except for SUSY, HIGGS, covtype and epsilon), by setting the value to 0 if the original value was 0, and to 1 otherwise. Thus, a 0 or 1 indicates the absence or presence of a value respectively. Although this discretization method may be sub-optimal, it still allows for a fair comparison between all methods, as they are all executed on the same data. Furthermore, discretization to more than 2 values would put PFBP at a disadvantage, as the independence tests based on logistic regression models would need to fit models for more parameters. Specifically, if a discrete variable takes K values, logistic regression would need to fit K -1 coefficients. As we will see below, this discretization method does not significantly affect the results in terms of classification accuracy, justifying its use in this case. On the contrary, in some cases the produced models have a higher accuracy than the ones obtained from the original data.</p><p>The results are summarized in Tables <ref type="table" target="#tab_10">5</ref> and<ref type="table" target="#tab_11">6</ref>. They show the running time in hours and minutes (rounded up to the closest minute) and the classification accuracy for each algorithm. The number of selected variables is not shown, as all algorithms terminated within the timelimit of 12 h and selected 50 variables.</p><p>As expected, regarding running time, ITFS methods clearly outperform PFBP, being about 2-23 times faster than PFBP. As explained in the discussion in Sect. 8.3, this is because PFBP  Classification accuracy is obtained by combining models (see Sect. 3.5) as well as using the default MLlib logistic regression implementation. Bold numbers show the best performing method for a given classifier, while numbers shown in italic indicate that the classifier performs worse than the trivial classifier. In most cases, PFBP produces better methods, often significantly so, having a higher accuracy of up to 5-9% on the rcv1, news20 and webspam datasets. As before, in most cases, combining models works as good or better than the implementation in MLlib treats data as dense and is not specific or optimized for discrete data. In addition, PFBP's current implementation is based on fitting logistic regression models that require iterative techniques, while ITFS methods only require the counts in the contingency tables of the joint distributions.</p><p>In terms of classification accuracy, PFBP outperforms ITFS methods in most cases. In some cases (rcv1, news20, webspam) the accuracy difference is more than 4%; when PFBP does not produce the best model, the accuracy difference is less than 0.1% . Thus, overall, if the goal is predictive accuracy, PFBP should be preferred over ITFS methods.</p><p>In any case, it is encouraging that in all cases, PFBP using CombLR produces models on par or better than SparkLR.</p><p>Unfortunately, we were not able to determine the cases where SparkLR Specifically, we tried to (a) vary the number of partitions used, and (b) relax the stopping conditions used by the model fitting procedures (increasing number of iterations and reducing tolerance of the termination criterion), but neither of those made any difference.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.4">Proof-of-concept application on genetic SNP data</head><p>Single Nucleotide Polymorphisms (SNPs), <ref type="foot" target="#foot_19">19</ref> the most common type of genetic variation, are variations of a single nucleotide at specific loci in the genome of a species. The Single Nucleotide Polymorphism Database (dbSNP) (build 150) <ref type="bibr" target="#b65">(Sherry et al. 2001</ref>) now lists 324 million different variants found in sequenced human genomes. <ref type="foot" target="#foot_20">20</ref> In several human studies, SNPs have been associated with genetic diseases or predisposition to disease or other phenotypic traits. As of 2018-07-17, the GWAS Catalog<ref type="foot" target="#foot_21">foot_21</ref> contains 3471 publications and 65793 unique SNP-trait associations. Large scale studies under way [e.g., Precision Medicine Initiative <ref type="bibr" target="#b16">(Collins and Varmus 2015)</ref>] intend to collect SNP data in large population cohorts, as well as other medical, clinical and lifestyle data. The resulting matrices may end up with millions of rows, one for each individual, and variables (SNP or some other measured quantity). Thus, we believe that investigating the behavior of newly proposed Big Data FS algorithms on such data is worthwhile. A proof-of-concept application of PFBP is presented next.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.4.1">SNP data generation and setup</head><p>We simulated genotype data containing 500,000 individuals (samples) and 592,555 SNP genotypes (variables), following the procedure described in <ref type="bibr" target="#b13">Canela-Xandri et al. (2015)</ref>. As SNP data are dense, they require approximately 2.16 TB of memory, and thus are more challenging to analyze than sparse data, such as the ones used in the previous set of experiments. The data were simulated with the HAPGEN 2 software <ref type="bibr" target="#b14">(Chang et al. 2015)</ref> from the Hapmap 2 (release 22) CEU population <ref type="bibr">(Consortium 2015)</ref>. A more detailed description of the data generation procedure is given in "Appendix C".</p><p>We used M = 100 randomly selected SNPs to generate a binary phenotype (outcome), as described in <ref type="bibr" target="#b13">Canela-Xandri et al. (2015)</ref> (see also "Appendix C"). The optimal accuracy using all 100 SNPs is 81.42%. Ideally and given enough samples, any feature selection method should select those 100 SNPs and achieve an accuracy around 81.42%. Due to linkage disequilibrium however, many neighboring SNPs are highly correlated (collinear) and as a consequence offer similar predictive information about the outcome and are informationally equivalent. Therefore, a high accuracy can be achieved even with SNPs other than the 100 used to simulated the outcome.</p><p>We used 95% of the samples as a training set, and 5% as a test set for performance estimation. We set a timeout limit of 15 h, and used the same setup as used in previous experiments, with the exception that the maximum number of variables to select was set to 100.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.4.2">Repartitioning to reduce memory requirements</head><p>For big, dense data such as the SNP data considered in this experiment which require over 2 TB of memory, a direct application of PFBP as used in other experiments is possible, but may be unnecessarily slow. We found that for such problems, it makes sense to repartition the data at some point, if enough variables have been removed by the Early Dropping heuristic. Repartitioning and discarding dropped variables reduces storage requirements, and may offer a significant speed boost. It is an expensive operation however, and should only be used in special situations. For the SNP data, after the first iteration only about a third of the variables remained, reducing the memory requirements to less than 1 TB, and thus most (if not all) of the data blocks were able to fit in memory. In this case repartitioning makes sense, as its benefits far outweigh the computational overhead.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.4.3">Results on the SNP data</head><p>PFBP was able to select 84 features in 15 h, using a total of 960 core hours. It achieved an accuracy of 77.62%, which is over 95% of the theoretical optimal accuracy. The results are very encouraging; in comparison the DISSECT software <ref type="bibr" target="#b13">(Canela-Xandri et al. 2015)</ref> took 4 h on 8400 cores (that is, 33,600 core hours) and using 16 TB of memory to fit a mixed linear model on similar data, and to achieve an accuracy around 86% of the theoretical maximum. The two experiments are not directly comparable because (a) the outcome in our case is binary instead of continuous requiring logistic regression instead of linear regression models favoring DISSECT in terms of computational time, (b) the scenarios simulated in <ref type="bibr" target="#b13">Canela-Xandri et al. (2015)</ref> had larger Markov blankets (1000 and 10000 instead of 100) favoring PFBP (although, their results are invariant to the size of the Markov blanket). Nevertheless, the reported results are still indicative of the efficiency of PFBP on SNP Big Data.</p><p>Figure <ref type="figure">4</ref> shows the effects of the heuristics used by PFBP for the first 10 iterations. The y-axis shows the number of Remaining and Alive features on a logarithmic scale. The xaxis shows the current iteration, and the width is proportional to the total number of Groups processed in that iteration. We observe that (a) Early Dropping discards many features in the first iteration, reducing the number of Remaining features by about an order of magnitude, (b) in most iterations, Early Stopping is able to reduce the number of Alive features to around 10 after processing the first Group, (c) Early Return is applied 2 times, ending the Iteration and selecting the top feature after processing a single Group.</p><p>Finally, by combining the intermediate logistic regression models at each Iteration using CombLR, we computed the accuracy at each iteration of PFBP with no additional overhead. This provides an insight regarding its predictive performance behavior with increasing number of selected features. As before, the accuracy is computed on the 5% of the data that were kept out as a test set. Such information could be used to decide early whether a sufficient number of features has been selected, and to stop computation if the accuracy reaches a plateau. This is often the case, as most important features are typically selected during the first few iterations. This task can be performed using PFBP with minimal computational overhead, as the local models required to approximate a full global model (see Sect. 3.5) are already available. The results are shown in Fig. <ref type="figure">5</ref>. As expected, the largest increase in accuracy is obtained after selecting the first few features, reaching an accuracy of 75% even after selecting only 30 features. In addition, after selecting about 70 features, the accuracy increases only marginally afterwards, increasing from 77.59% with 70 features to 77.62% with 84. Thus, computation could be stopped after 70 features have been selected, and still attain almost the same accuracy.</p><p>Fig. <ref type="figure">4</ref> The effects of the early pruning heuristics is shown for the first 10 forward iterations on the SNP data. The y-axis shows the number of variables on a logarithmic scale. The width of each iteration is proportional to the number of groups processed. The Early Dropping heuristic is able to quickly discard many features, reducing them by about an order of magnitude. Early stopping filters out most variables after processing the first group, and early return is applied two times Accuracy vs Selected Features on the SNP Data Fig. <ref type="figure">5</ref> The figure shows how the accuracy of PFBP on the SNP data increases as it selects more features. The models are produced by PFBP at each iteration with minimal computational overhead. In the first few iteration, accuracy increases sharply, while in the later iterations a plateau is reached, reaching a value of 77.59% with 70 features, with the maximum being 77.62% with 84 features. This could be used as a criterion to stop feature selection early</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.5">Summary and discussion of experimental results</head><p>Overall </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10">Discussion and conclusions</head><p>We present a novel algorithm for feature selection (FS) in Big Data settings called Parallel, Forward-Backward with Pruning (PFBP). PFBP is a general algorithm for any type of data and outcome, by equipping it with an appropriate conditional independence test. It works on both dense and sparse data. PFBP can scale to millions of predictive quantities (i.e., features, variables) and millions of training instances (samples). The Parallel, Forward-Backward with Pruning (PFBP) enables computations that can be performed in a massively parallel way by partitioning data both horizontally (over samples) and vertically (over features) and using meta-analysis techniques to combine results of local computations. Similar meta-analysis tricks can combine local logistic regression coefficients to global models with excellent results in practice against the global logistic regression models produced by MLlib. PFBP is equipped with heuristics that can quickly and safely drop from consideration some of the redundant and irrelevant features to significantly speed up computations. The heuristics are inspired by causal models and provide theoretical guarantees of correctness in distributions faithful to causal models (Bayesian networks or maximal ancestral graphs). Bootstrapping testing allows PFBP to determine whether enough samples have been seen to safely apply the heuristics and forgo computations on the remaining samples. Our empirical analysis confirms that, PFBP exhibits a super-linear speedup with increasing sample size and a linear scalability with respect to the number of features and processing cores. A comparative evaluation shows that PFBP dominates other alternative map-reduce algorithms in its class in terms of computational performance, number of selected features, and predictive performance. Against information theoretic algorithms, specialized for sparse, discrete data it is slower, but returns models with higher predictive performance. PFBP was tested on high dimensional SNP data of about 500K demonstrating its applicability to dense, genomic data. A limitation to address in the future is to equip the algorithm with a principled criterion for the determining the number of selected features. Other directions to improve include exploiting the sparsity of the data, implementing run-time re-partitioning when deemed beneficial, and implementing tests in GPUs to name a few.  To validate the STD rule, we used the results of the previous simulation experiment and computed the value of c by solving the equation for c and substituting in the values of the class distributions, degrees of freedom and sample size per Sample Set. We kept the values of c that correspond to an agreement percentage between 85 and 95% (focusing on an interesting range of high agreement between p-value computation methods), and computed their median value for each class distribution, conditioning size k and for both rules. Ideally, one would expect c to be constant across rows (class distribution) and columns (conditioning size). A constant value of c for a rule means that the rule can exactly compute the required sample size to get an agreement percentage around 90%. Furthermore, we note that the values of c are not comparable between rules, and thus their exact values are not important; what matters is the relative difference between values of c for the same rule.</p><p>The results are shown in Table <ref type="table" target="#tab_14">8</ref>. Although the value of c varies across class distributions and degrees of freedom, we can see that the relative differences are smaller the STD rule. Specifically, for EPV c ranges from 4.2 to 11.2, the latter being over 2.5 times larger, while for STD it ranges from 7.8 to 14.9, which is less than 2 times larger. This suggests that the STD rule performs better than EPV across various conditioning set sizes and class distributions, at least on the experiments considered here. Furthermore, the results suggest that a value of at least c = 10 should be used for STD to get reasonably accu-123 0.8 5.7 5.2 5.7 6.7 11.5 10.5 11.4 13.3 0.9 5.0 4.4 4.2 4.4 14.9 13.2 12.5 13.3</p><p>p max corresponds to the proportion of the most frequent class, while df is the degrees of freedom in the largest model. The relative differences for the STD rule are smaller (less than 2 against over 2.5 for the EPV rule), suggesting it is more appropriate. A minimum value of c = 10 with the proposed rule is recommended and used in the experiments rate results. We note that, in practice this value is much higher in most cases for PFBP, as it partitions the samples initially by considering the worst case scenario (i.e., selecting maxVars variables). Thus especially in early Iterations, which are the most crucial ones, PFBP will typically have a sufficient number of samples even with c = 10 to select the best variables.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B: Simulating data from Bayesian networks</head><p>To generate data with complex correlation structures, we chose to generate data from Bayesian networks. This is done in three steps: (a) generate a Bayesian network structure G with N nodes (variables) and M edges, (b) sample the parameters of G, and (c) sample instances from G. We will next describe the procedures used for each step.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B.1: Generating the Bayesian network structure</head><p>First, we need to specify the number of nodes N and the connectivity C between those nodes, which implicitly corresponds to some number of edges M. The connectivity parameter C corresponds to the (average) degree of each variable. Using the connectivity instead of setting the number of edges allows one to easily control the complexity of the network, as C directly corresponds to the average number of parents and children of each node. We proceed by showing how the edges were sampled. Let V 1 , . . . , V N be all nodes of G, listed in topological order. To sample the edges of the network we iterate over all pairs of variables V i and V j (i &lt; j), and add an edge from V i to V j with probability C/(N -1), ensuring acyclicity of the resulting graph. It can be easily shown that this will result in a network with an average degree of C.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B.2: Generating the Bayesian network parameters</head><p>The first step is to pick the variable that corresponds to the outcome variable T . We chose to use the node at position N /2 , as this node has the same number of parents and children on average. For our experiments, we chose T to be of binary type and all remaining variables to be of continuous type, but in principle everything stated can be easily adapted to other variable types. In Bayesian networks, the each variable V is a function of its parents Pa(V ).</p><p>The functional form for continuous variables V i is</p><formula xml:id="formula_11">V i = β 0 + V j ∈Pa(V i ) β j V j + i</formula><p>where β 0 is the intercept, β j is the coefficient of the jth parent of V i and i is its error term. In our case, we set the intercept to 0, as it does not affect the correlation structure. The coefficients β j are sampled uniformly at random from [-1, -0.1] ∪ [0.1, 1] to avoid coefficients which are close to 0. The error term i follows a normal distribution with 0 mean and σ 2 i variance, which was set to the default value of 1 in our experiments, unless stated otherwise. Note that all variables are normally distributed as they are sums of normally distributed variables. For each variable V i the mean equals zero and the variance equals σ 2 i + V j ∈Pa(V i ) β 2 j . The fact that the variance increases may lead to numerical instabilities in practice, especially when generating large networks. Because of that, we standardize each variable to have unit variance by dividing it with its standard deviation, which is the square root of the variance as described above. For the target T , its log-odds ratio is again a linear function of its parents, defined as log P(T = 1) 1 -P(T = 1) = β 0 +</p><p>V j ∈Pa(T )</p><formula xml:id="formula_12">β j V j + T</formula><p>As before, the log-odds ratio is standardized to have unit variance.</p><p>The value of T is set to 1 whenever the log-odds ratio is larger than some threshold t, and to 0 otherwise. Setting t to 0 results in a 50/50 class distribution of T . Other class distributions p 0 / p 1 can be obtained by simply setting t to N -1 0,1 (1p 0 ), where N -1 0,1 is the standard normal inverse cumulative distribution function. As a final note, the standardization method used above only guarantees that variables that come before T in the topological ordering are standard normal variables. As T is not normally distributed (nor does it have unit variance), all variables that are direct or indirect functions of T are not exactly normally distributed. However, as this neither alters the correctness of the data generation method, nor leads to any other issues, we leave it as is.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B.3: Sampling data from the generated Bayesian network</head><p>To generate a sample, one has to traverse the network in topological order and to compute the value of each variable separately, using the formulas described previously. By construction the network is already in topological order, which is simply given by the index of each variable. To compute the value of a variable one has to compute the sum of its parents (if it has any parents), and to add the error term, which is drawn from a normal distribution.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C: SNP data generation</head><p>To generate the SNP dataset we followed the procedure described in <ref type="bibr" target="#b13">Canela-Xandri et al. (2015)</ref>. We used the HAPGEN 2 software <ref type="bibr" target="#b14">(Chang et al. 2015)</ref> with the Hapmap 2 (release 22) CEU population <ref type="bibr">(Consortium 2015)</ref> to simulate 500000 individuals (samples). This population contains 2543887 SNPs, but only 592555 were kept, by filtering out the ones not available in the Illumina Human OmniExpress-12 v1.1 BeadChip. <ref type="foot" target="#foot_22">22</ref> The final dataset contains 500000</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1</head><label>1</label><figDesc>Fig. 1 Example of Markov blankets of T in a Bayesian network (left) and a maximal ancestral graph (right).The nodes in the Markov blanket are shown with solid lines, and the remaining ones with dashed lines. In both cases, the Markov blanket contains all adjacent nodes (parents and children) and X 5 (spouse of T ). In addition, in the maximal ancestral graph X 9 and X 10 are also contained, as they are connected with T through a collider path (T → X 8 ↔ X 9 ← X 10 )</figDesc><graphic coords="11,78.11,55.72,283.44,133.68" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 2</head><label>2</label><figDesc>Fig. 2 Left: Data partitioning of the algorithm. In the top the initial data matrix D is shown with 6 features and instances I 1 , . . . , I m . In the bottom, the 6 features are partitioned to Feature Subsets F 1 = {1, 2, 3} and F 2 = {4, 5, 6}. The rows are randomly partitioned to Sample Subsets S 1 , . . . , S ns , and the Sample Subsets are assigned to Group Samples. Each Block D i, j is physically stored as a unit. Right: Example of trace of a Forward Iteration of PFBP. a The Remaining features, Alive features, and Selected features are initialized. b All Data Blocks D 1,1 , D 1,2 , D 4,1 , D 4,2 in the first Group are processed in parallel (by workers). c The resulting local p-values are collected (reduced) in a master node for each Alive feature and Sample Set in the first Group (as well as the likelihoods, not shown in the figure). d Bootstrap-based tests determine which features to Early Drop or Stop based on Π , or whether to Early Return (based on Λ, not shown in the figure).The sets R and A are updated accordingly. In this example, X 2 , X 5 and X 6 are Dropped, X 3 is stopped, and only X 1 and X 4 remain Alive. Notice that always A ⊆ R. e The second Group is processed in parallel (by workers) containing Blocks D 3,1 , D 3,2 , D 2,1 , D 2,2 . f New local p-values for all features still Alive are appended to Π . If G 2 was the last Group, global p-values for the Alive features would be computed and the one with the minimum value (in this example X 1 ) would be selected for inclusion in S. g In case, X 1 and X 4 are deemed almost equally predictive (based on their log-likelihoods) the current best is Early Returned</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>6.1), (b) the Sample Sets S 1 , . . . , S ns are assigned to Q approximately equal-sized Groups, G 1 , . . . , G Q , (c) the features are assigned to feature sets F 1 , . . . , F nf , Algorithm 2 Parallel Forward-Backward With Pruning (PFBP) Input: Dataset D, Target T , Maximum Number of Runs maxRuns Output: Selected Variables S 1: //Data Partitioning 2: Randomly assign samples to sample sets S 1 , . . . , S ns 3: Assign sample sets S 1 , . . . , S ns to equally-sized Groups G 1 , . . . , G K 4: Assign features to feature sets F 1 , . . . , F n f 5: Partition D to data blocks D i, j containing samples from S i and F j , ∀i, j 6: 7: S ← ∅ //No selected variables 8: run ← 1 //First run 9: 10: //Iterate until (a) maximum number of runs reached, or (b) selected features S did not change 11: while run ≤ max Runs ∧ S changes do 12: S ← OneRun(D, T , S) 13: run ← run + 1 14: end while 15: return S 16: function OneRun(Data Blocks D, Target T , Selected Variables S, Maximum Number of Variables To Select maxVars) 17: R ← F\S //All variables remaining 18: //Forward phase: iterate until (a) maximum number of variables selected or (b) no new variable has been selected 19: while |S| &lt; maxVars ∧ S changes do 20: S, R ← ForwardIteration(D, T , S, R) 21: end while 22: 23: //Backward phase: iterate until no variable can be removed 24: while S changes do 25:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Input:</head><label></label><figDesc>Log p-values Π , Remaining Variables R, Alive Variables A, Number of Bootstrap Samples B, Significance Level Threshold α, ED Threshold P drop Output: Remaining variables R, Alive Variables A 1: π ← Combine(Π ) //Combine log p-values Π using Fisher's c.p.t. 2: cnts ← 0 |A| //Count vector of size equal to the number of alive variables 3: cnts ← cnts + I(π ≥ α) 4: for b = 1 to B do 5:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 3</head><label>3</label><figDesc>Fig.3Scalability of PFBP with increasing sample size (top left), feature size (top right) and number of machines (bottom). Time and speed-up were computed relatively to the first point on the x-axis, for the same number of Runs. PFBP improves super-linearly with sample size, linearly with feature size and running time is reduced linearly with increasing number of machines. The results are similar for PFBP with 1 run and 2 runs</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>obtained by combining models CombLR (see Sect. 3.5) as well as using the default MLlib logistic regression implementation, SparkLR. Bold numbers</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig. 6</head><label>6</label><figDesc>Fig. 6The percentage of agreement is shown, which corresponds to how often combining local p-values and computing the p-value on all samples leads to the same decision. The y-axis shows how the sample size per sample set affects the agreement percentage. Both methods tend to agree asymptotically for various class distributions and conditioning set sizes</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1</head><label>1</label><figDesc>Table containing common acronyms, terms and mathematical notation (left) used throughout the paper with a short description (right)</figDesc><table><row><cell>Table 1 continued</cell><cell></cell></row><row><cell>π</cell><cell>Vector with combined log p-values</cell></row><row><cell>π i</cell><cell>Combined log p-value for the ith alive variable</cell></row><row><cell>S</cell><cell>Set of Selected features</cell></row><row><cell>R</cell><cell>Set of Remaining features</cell></row><row><cell>A</cell><cell>Set of Alive features</cell></row><row><cell>B</cell><cell>Number of bootstrap iterations used by bootstrap tests</cell></row><row><cell>b</cell><cell>Value corresponding to bth bootstrap sample</cell></row><row><cell>P drop</cell><cell>Threshold used by bootstrap test for Early Dropping</cell></row><row><cell>P stop</cell><cell>Threshold used by bootstrap test for Early Stopping</cell></row><row><cell>P return</cell><cell>Threshold used by bootstrap test for Early Return</cell></row><row><cell>lt</cell><cell>Tolerance level used by bootstrap test for Early Return</cell></row></table><note><p>loops of the algorithm and Iteration to the part that decides which feature to add or remove next.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Input Dataset Initialization Remaining Features Feature Subsets</head><label></label><figDesc></figDesc><table><row><cell>Features</cell></row><row><cell>s</cell></row><row><cell>e l p m</cell></row><row><cell>a S</cell></row><row><cell>s t</cell></row><row><cell>e</cell></row><row><cell>s</cell></row><row><cell>b u S</cell></row><row><cell>e l</cell></row><row><cell>p m</cell></row><row><cell>S a</cell></row><row><cell>Data Blocks</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Partitioned Dataset Alive Features Selected Features Forward Iteration Processing p-values collected at Master Combined p-values with Fisher's c.p.t. Early Drop Processing Parallel processing by Workers Parallel processing by Workers … Group Samples p-values collected at Master Combined p-values with Fisher's c.p.t. Remaining Features Early Stop Alive Features Early Return Alive Features Output Selected Features Remaining Features Alive Features Alive Features</head><label></label><figDesc></figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head></head><label></label><figDesc>Exclude variables from A that are worse than V best with probability at least P stop 11: A ← A\{X i ∈ A : cnts i /(B + 1) ≥ P stop } 12: return A</figDesc><table><row><cell></cell><cell>X i ∈A</cell><cell>π i //Identify variable with minimum Fisher's combined p-value</cell></row><row><cell cols="3">3: cnts ← 0 |A| //Count vector of size equal to the number of alive variables</cell></row><row><cell cols="3">4: cnts ← cnts + I(π best &lt; π)</cell></row><row><cell cols="2">5: for b = 1 to B do</cell></row><row><cell>6:</cell><cell cols="2">Π b ← BootstrapSample(Π )</cell></row><row><cell cols="3">7: π 8: cnts ← cnts + I(π b best &lt; π b ) 9: end for</cell></row><row><cell cols="2">10: //</cell></row></table><note><p>log p-values Π b using Fisher's c.p.t. 7: cnts ← cnts + I(π b ≥ α) 8: end for 9: //Drop variables if p-value larger than α with probability at least P drop 10: R ← R\{X i ∈ A : cnts i /(B + 1) ≥ P drop } 11: A ← A\{X i ∈ A : cnts i /(B + 1) ≥ P drop } 12: return R, A Algorithm 6 EarlyStopping Input: Log p-values Π , Alive Variables A, Number of Bootstrap Samples B, ES Threshold P stop Output: Alive Variables A 1: π ← Combine(Π ) //Combine log p-values Π using Fisher's c.p.t. 2: X best ← argmin b ← Combine(Π b ) //Combine log p-values Π b using Fisher's c.p.t.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head></head><label></label><figDesc>Log-likelihoods Λ, Alive Variables A, Number of Bootstrap Samples B, ER Threshold P return , ER Tolerance lt Output: Alive Variables A 1: π ← Combine(Π ) //Combine log p-values Π using Fisher's c.p.t. 2: λ ← SumRows(Λ) //Sum rows of log-likelihoods Λ 3: X best ← argmin Select X best early if better than all other variables with probability at least P return 12: if ∀i, cnts i /(B + 1) ≥ P return then</figDesc><table><row><cell cols="3">Algorithm 7 EarlyReturn</cell></row><row><cell></cell><cell>X i ∈A</cell><cell>π i //Identify variable with minimum Fisher's combined p-value</cell></row><row><cell cols="3">4: cnts ← 0 |A| //Count vector of size equal to the number of alive variables</cell></row><row><cell cols="3">5: cnt ← cnts + I(λ best -λ &gt; lt)</cell></row><row><cell cols="2">6: for b = 1 to B do</cell></row><row><cell cols="3">7: 8: 9: 10: end for Λ b ← BootstrapSample(Λ) λ b ← SumRows(Λ) //Sum rows of log-likelihoods Λ b cnts ← cnts + I(λ b best -λ b &gt; lt)</cell></row><row><cell>11: //13:</cell><cell>A ← {X best }</cell></row><row><cell cols="2">14: end if</cell></row><row><cell cols="2">15: return A</cell></row></table><note><p>Input:</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8"><head>Table 2</head><label>2</label><figDesc>Binary classification datasets used in the comparative evaluation</figDesc><table><row><cell>Name</cell><cell>#Samples</cell><cell>#Variables</cell><cell>Non-zeros per row</cell></row><row><cell>SUSY</cell><cell>5,000,000</cell><cell>18</cell><cell>17.79</cell></row><row><cell>HIGGS</cell><cell>11,000,000</cell><cell>28</cell><cell>25.79</cell></row><row><cell>covtype.binary</cell><cell>581,012</cell><cell>54</cell><cell>11.88</cell></row><row><cell>epsilon</cell><cell>500,000</cell><cell>2000</cell><cell>2000.00</cell></row><row><cell>rcv1.binary</cell><cell>697,641</cell><cell>47,236</cell><cell>73.15</cell></row><row><cell>avazu-app</cell><cell>14,596,137</cell><cell>1,000,000</cell><cell>15.00</cell></row><row><cell>avazu-site</cell><cell>25,832,830</cell><cell>1,000,000</cell><cell>15.00</cell></row><row><cell>criteo</cell><cell>45,840,617</cell><cell>1,000,000</cell><cell>39.00</cell></row><row><cell>news20.binary</cell><cell>19,996</cell><cell>1,355,191</cell><cell>454.99</cell></row><row><cell>url</cell><cell>2,396,130</cell><cell>3,231,961</cell><cell>115.63</cell></row><row><cell>webspam</cell><cell>350,000</cell><cell>16,609,143</cell><cell>3727.71</cell></row><row><cell>kdd2010a</cell><cell>8,407,752</cell><cell>20,216,830</cell><cell>36.35</cell></row><row><cell>kdd2010b</cell><cell>19,264,097</cell><cell>29,890,095</cell><cell>29.40</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_9"><head>Table 4</head><label>4</label><figDesc>The table shows the number of selected variables and the classification accuracy of forward-selection based algorithms on all datasets</figDesc><table><row><cell>Classification accuracy (%)</cell></row><row><cell>Dataset</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_10"><head>Table 5 table</head><label>5</label><figDesc></figDesc><table><row><cell>shows the total running time of each algorithm</cell><cell>Dataset</cell><cell cols="2">Running time (HH:MM)</cell><cell></cell></row><row><cell>on all discretized datasets</cell><cell></cell><cell>PFBP</cell><cell>MRMR</cell><cell>JMI</cell><cell>CMIM</cell></row><row><cell></cell><cell>rcv1</cell><cell>00:13</cell><cell>00:06</cell><cell>00:06</cell><cell>00:07</cell></row><row><cell></cell><cell>avazu-app</cell><cell>06:00</cell><cell>00:16</cell><cell>00:16</cell><cell>00:16</cell></row><row><cell></cell><cell>avazu-site</cell><cell>06:02</cell><cell>00:29</cell><cell>00:25</cell><cell>00:32</cell></row><row><cell></cell><cell>criteo</cell><cell>03:56</cell><cell>01:15</cell><cell>01:36</cell><cell>01:23</cell></row><row><cell></cell><cell>news20</cell><cell>01:02</cell><cell>00:03</cell><cell>00:03</cell><cell>00:04</cell></row><row><cell></cell><cell>url</cell><cell>02:20</cell><cell>00:15</cell><cell>00:14</cell><cell>00:16</cell></row><row><cell></cell><cell>webspam</cell><cell>02:00</cell><cell>00:53</cell><cell>01:04</cell><cell>00:58</cell></row><row><cell></cell><cell>kdd2010a</cell><cell>07:03</cell><cell>00:25</cell><cell>00:22</cell><cell>00:23</cell></row><row><cell></cell><cell>kdd2010b</cell><cell>08:49</cell><cell>00:43</cell><cell>00:40</cell><cell>00:48</cell></row><row><cell></cell><cell cols="5">The fastest algorithm for each dataset is shown in bold. ITFS methods</cell></row><row><cell></cell><cell cols="5">significantly outperform PFBP in terms of running time, being almost</cell></row><row><cell></cell><cell cols="4">23 times faster than PFBP (for the avazu-app dataset)</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_11"><head>Table 6</head><label>6</label><figDesc>The table shows the classification accuracy % for each algorithm and dataset</figDesc><table><row><cell>Dataset</cell><cell cols="3">Classification accuracy (%)</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell>CombLR</cell><cell></cell><cell></cell><cell></cell><cell>SparkLR</cell><cell></cell><cell></cell><cell></cell><cell>Trivial</cell></row><row><cell></cell><cell>PFBP</cell><cell>MRMR</cell><cell>JMI</cell><cell>CMIM</cell><cell>PFBP</cell><cell>MRMR</cell><cell>JMI</cell><cell>CMIM</cell><cell></cell></row><row><cell>rcv1</cell><cell>90.64</cell><cell>86.14</cell><cell>85.64</cell><cell>85.60</cell><cell>90.87</cell><cell>86.35</cell><cell>86.20</cell><cell>85.63</cell><cell>52.71</cell></row><row><cell>avazu-app</cell><cell>88.19</cell><cell>88.14</cell><cell>87.89</cell><cell>88.15</cell><cell>87.45</cell><cell>87.54</cell><cell>88.11</cell><cell>88.08</cell><cell>88.12</cell></row><row><cell>avazu-site</cell><cell>80.48</cell><cell>80.50</cell><cell>79.74</cell><cell>79.79</cell><cell>79.77</cell><cell>80.33</cell><cell>80.42</cell><cell>80.42</cell><cell>80.14</cell></row><row><cell>criteo</cell><cell>76.39</cell><cell>76.19</cell><cell>75.98</cell><cell>75.91</cell><cell>76.32</cell><cell>75.92</cell><cell>75.98</cell><cell>75.91</cell><cell>74.41</cell></row><row><cell>news20</cell><cell>86.03</cell><cell>81.22</cell><cell>79.79</cell><cell>79.27</cell><cell>83.16</cell><cell>77.43</cell><cell>77.12</cell><cell>78.30</cell><cell>51.47</cell></row><row><cell>url</cell><cell>96.80</cell><cell>94.87</cell><cell>95.79</cell><cell>95.07</cell><cell>96.98</cell><cell>95.77</cell><cell>95.36</cell><cell>95.70</cell><cell>67.11</cell></row><row><cell>webspam</cell><cell>98.22</cell><cell>94.30</cell><cell>94.62</cell><cell>93.92</cell><cell>98.22</cell><cell>89.52</cell><cell>91.23</cell><cell>90.88</cell><cell>60.42</cell></row><row><cell>kdd2010a</cell><cell>86.17</cell><cell>86.27</cell><cell>86.15</cell><cell>86.10</cell><cell>59.15</cell><cell>38.89</cell><cell>30.20</cell><cell>29.58</cell><cell>85.33</cell></row><row><cell>kdd2010b</cell><cell>86.10</cell><cell>86.08</cell><cell>86.07</cell><cell>86.07</cell><cell>43.17</cell><cell>37.98</cell><cell>38.22</cell><cell>37.49</cell><cell>86.09</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_12"><head></head><label></label><figDesc>, the experiments indicate that PFBP scales superlinearly with the available sample size, and linearly with the number of features and available workers. Compared with other algorithms in its class, namely forward selection-based algorithms with map-reduce implementations, under the same conditions (type of test and predictive model), PFBP dominates the alternatives (UFS, FBS, SFO) in terms of execution time, number of selected features, and predictive performance. Against information-theoretic variants specialized for discrete and sparse data with available map-reduce implementations, PFBP performs worse in terms of running time, however, it is still applicable and practical to apply to large datasets. However, PFBP dominates the information-theoretic variants in terms of predicting performance. Furthermore, as a side product of the experiments, we compared two logistic regression algorithms, namely SparkLR that is available in MLlib and fits in a parallelized fashion a global logistic regression model, and CombLR that combines the coefficients of local logistic regression models. CombLR always converges, providing on average more predictive models than SparkLR, and it is considerably more efficient than SparkLR even when computed from scratch and not during PFBD. Finally, the proof-of-concept application to SNP data demonstrates that the emergence of Big genetic Data can become amenable to analysis using algorithms such as PFBP. A detailed trace of the computational experiment shows the effectiveness of the Early Stop, Drop and Return heuristics of PFBP: (a) after the first few iterations the Remaining features are reduced by 1-2 orders of magnitude. (b) The number of Alive features drops exponentially as more groups are processed. The trace visualizes PFBP's scalability properties.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_14"><head>Table 8</head><label>8</label><figDesc>Median value of c to obtain an agreement percentage between 85 and 95%</figDesc><table><row><cell cols="3">p max | df EPV Rule</cell><cell></cell><cell></cell><cell cols="2">STD Rule</cell><cell></cell></row><row><cell></cell><cell>2</cell><cell>3</cell><cell>4</cell><cell>5</cell><cell>2</cell><cell>3</cell><cell>4</cell><cell>5</cell></row><row><cell>0.5</cell><cell cols="3">11.2 7.8 9.0</cell><cell cols="2">9.7 11.2</cell><cell>7.8</cell><cell>9.0</cell><cell>9.7</cell></row><row><cell>0.6</cell><cell cols="4">7.7 7.6 7.4 11.2</cell><cell>9.4</cell><cell>9.3</cell><cell cols="2">9.1 13.7</cell></row><row><cell>0.7</cell><cell cols="3">6.6 5.7 5.9</cell><cell cols="2">8.6 10.1</cell><cell>8.8</cell><cell cols="2">9.1 13.2</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>Optimally predictive with respect to an ideal predictor; seeTsamardinos and Aliferis (2003)  for a discussion.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>This definition covers what we call single FS; the problem of multiple FS can be defined as the problem of identifying all minimal and optimally-predictive subsets but it has received much less study in the literature<ref type="bibr" target="#b68">(Statnikov et al. 2013;</ref><ref type="bibr" target="#b39">Lagani et al. 2017</ref>).</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2"><p>See Zhao et al. (2013),<ref type="bibr" target="#b86">Zhai et al. (2014)</ref> andBolón-Canedo et al. (2015a, b)  for the evolution of Big Data dimensionality in various ML datasets.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_3"><p>Alternatively, one can combine the test statistics that produce the p-values. This is conceptually equivalent, although there may be differences in practice.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_4"><p>Alternatively, one can use information criteria such as AIC<ref type="bibr" target="#b1">(Akaike 1973)</ref> and BIC<ref type="bibr" target="#b64">(Schwarz 1978)</ref>, or out-of-sample methods such as cross-validation to evaluate the performance of the current set of selected features; see<ref type="bibr" target="#b38">Kutner et al. (2004)</ref> and<ref type="bibr" target="#b79">Weisberg (2005)</ref> for more details.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_5"><p>For example, the R-package MXM<ref type="bibr" target="#b39">(Lagani et al. 2017</ref>) includes asymptotic, permutation-based, and robust tests for nominal, ordinal, continuous, time-course, percentage, count, and censored time-to-event targets.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="7" xml:id="foot_6"><p>An implicit assumption made here is that the models are correctly specified. If this does not hold, the statistic follows a different distribution<ref type="bibr" target="#b27">(Foutz and Srivastava 1977)</ref>. There exist methods that handle the more general case<ref type="bibr" target="#b81">(White 1982;</ref><ref type="bibr" target="#b77">Vuong 1989</ref>), but this is clearly out of this paper's scope.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="8" xml:id="foot_7"><p>Often, the original sample is not considered and thus the estimate is computed by using only the bootstrap samples and dividing by B. However, it has been noted (in the context of bootstrap-based hypothesis testing) that one should also consider the original sample statistic [see Section 4.2 in<ref type="bibr" target="#b19">Davison and Hinkley (1997)</ref>], which is why we chose to do so too.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="9" xml:id="foot_8"><p>Some recent algorithms<ref type="bibr" target="#b68">(Statnikov et al. 2013;</ref><ref type="bibr" target="#b39">Lagani et al. 2017)</ref> deal with the problem of solution multiplicity in feature selection.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="10" xml:id="foot_9"><p>Naturally, any method for combining p-values can be used instead of Fisher's method, but we did not further investigate this in this work.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_10"><p>Implementation of the Early Dropping, Stopping and Return heuristics using bootstrap tests on local p-valuesRecall that the algorithm processes Group Samples sequentially. After processing each Group and collecting the results, PFBP applies the Early Dropping, Early Stopping and Early Return heuristics, computed on the master node, to filter out variables and reduce subsequent computation. Thus, all three heuristics involve making early probabilistic decisions based on a subset of the samples examined so far. Naturally, if all samples have been processed, Early Dropping can be applied on the combined p-values without making probabilistic decisions.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="11" xml:id="foot_11"><p>One case where this happens is if the covariance matrix of the input data is singular, or close to singular. Note that, due to the nature of the feature selection method which considers one variable at a time, this can happen only if the newly added variable is (almost) collinear with some of the previously selected variables. If this is the case, the variable would not be selected anyway.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="12" xml:id="foot_12"><p>https://spark-packages.org/package/sramirez/spark-infotheoretic-feature-selection.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="13" xml:id="foot_13"><p>There are methods that do not fall into this framework, but we will not go into more detail; see<ref type="bibr" target="#b12">Brown et al. (2012)</ref> for more details.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="14" xml:id="foot_14"><p>Recently, there have been efforts for exact algorithms solving the BSS problem using mixed-integer optimization formulations for linear regression<ref type="bibr" target="#b6">(Bertsimas et al. 2016</ref>) and logistic regression<ref type="bibr" target="#b62">(Sato et al. 2016</ref>).</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="15" xml:id="foot_15"><p>Typical choices for the significance level α are 0.01 and 0.05<ref type="bibr" target="#b2">(Aliferis et al. 2010)</ref>. Using lower values of α leads to fewer type I errors (falsely selected variables) but more type II errors (falsely rejected variables). This also depends on the sample size, with more samples typically leading to fewer type II errors, with type I errors not affected by sample size. Therefore, in large sample settings, as the ones considered in our experiments, one should use lower values for α to minimize type I errors. For that reason, we chose α = 0.01, although it would make sense to consider even lower values.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="16" xml:id="foot_16"><p>http://www.csie.ntu.edu.tw/~cjlin/libsvmtools/datasets/.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="17" xml:id="foot_17"><p>We tried running SFO, UFS and FBS on some of the large datasets using a timeout limit of 2 days, the maximum possible on the cluster we used; however, none of the algorithms were able to select even a single variable.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="18" xml:id="foot_18"><p>https://github.com/sramirez/spark-infotheoretic-feature-selection.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="19" xml:id="foot_19"><p>https://ghr.nlm.nih.gov/primer/genomicresearch/snp.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="20" xml:id="foot_20"><p>https://ncbiinsights.ncbi.nlm.nih.gov/2017/05/08/dbsnps-human-build-150-has-doubled-the-amountof-refsnp-records/.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="21" xml:id="foot_21"><p>https://www.ebi.ac.uk/gwas/.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="22" xml:id="foot_22"><p>https://support.illumina.com/array/array_kits/humanomniexpress-12-beadchip-kit.html.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div><head n="9">Experimental evaluation</head><p>We performed three sets of experiments to evaluate PFBP.</p><p>1. We investigate the scalability of PFBP in terms of variable size, sample size and number of workers on synthetic datasets, simulated from Bayesian networks. 2. We compare PFBP to three competing forward-selection based feature selection algorithms. 3. We compare against three algorithms from the family of information theoretic feature selection methods <ref type="bibr" target="#b12">(Brown et al. 2012)</ref>, implemented for Big Data (<rs type="person">Ramrez-Gallego</rs> et al. 2017). 4. We performed a proof-of-concept experiment of PFBP on dense synthetic Single Nucleotide Polymorphism (SNP) data. These are important types of very highdimensional data that arise in biology and for which feature selection algorithms that can scale up are needed. Acknowledgements IT and GB have received funding from the <rs type="funder">European Research Council</rs> under the European Union's <rs type="programName">Seventh Framework Programme</rs> (FP/2007-2013) / <rs type="funder">ERC</rs> Grant Agreement n. <rs type="grantNumber">617393</rs>. We'd like to thank <rs type="person">Kleanthi Lakiotaki</rs> for help with the motivating example text and data simulation, <rs type="person">Vincenzo Lagani</rs> and <rs type="person">Michail Tsagris</rs> for proofreading and constructive feedback, and <rs type="person">Iordanis Xanthopoulos</rs> for helping set up the experiments on the ARIS cluster. This work was supported by computational time granted from the <rs type="institution" subtype="infrastructure">Greek Research &amp; Technology Network (GRNET) in the National HPC facility -ARIS -</rs>under project <rs type="projectName">ID p004007_taskp-BioSD</rs>.</p></div>
			</div>
			<listOrg type="funding">
				<org type="funding" xml:id="_FFu3bAu">
					<orgName type="program" subtype="full">Seventh Framework Programme</orgName>
				</org>
				<org type="funded-project" xml:id="_ntNrZ7p">
					<idno type="grant-number">617393</idno>
					<orgName type="project" subtype="full">ID p004007_taskp-BioSD</orgName>
				</org>
			</listOrg>

			<listOrg type="infrastructure">
				<org type="infrastructure">					<orgName type="extracted">Greek Research &amp; Technology Network (GRNET) in the National HPC facility -ARIS -</orgName>
				</org>
			</listOrg>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Positive values indicate that CombLR performs better. In the continuous data from the comparison between PFBP, SFO, UFS and FBS, N/A values correspond to cases where the algorithm did not terminate. For the discretized data, N/A values correspond to cases where the experiment was not performed. In all cases, PFBP using CombLR produces models with similar or better performance than SparkLR</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.3.3">Comparison of CombLR and SparkLR</head><p>We proceed by comparing the performance obtained using different logistic regression classifiers, namely SparkLR and CombLR. We remind the reader that CombLR comes at no additional computational overhead by combining the coefficients of local models already produced by PFBP for feature selection purposes. SparkLR in contrast, fits a global LR model, with a corresponding computational overhead. For the comparison between PFBP, SFO, UFS and FBS on the original datasets, CombLR slightly outperforms SparkLR on most datasets. There are however a few cases where large differences between both classifiers can be seen. For covtype, CombLR results in a large performance drop for SFO, UFS and FBS. However, the performance of PFBP is similar, regardless of the method used for producing the classifier. For PFBP, for kdd2010a and kdd2010b, SparkLR completely fails, achieving an accuracy lower than the one obtained by the trivial classifier (see Table <ref type="table">4</ref>). Regarding the comparison of PFBP with informationtheoretic methods on the discretized data, we observe again a qualitatively similar behavior as in the previous experiments. The problematic datasets seem to be news20, webspam, kdd2010a and kdd2010b. As before, there are cases where SparkLR fails to produce a model better than the trivial classifier, whereas CombLR is more robust overall. The difference may exceed 50% of accuracy! When CombLR fails to beat the trivial classifier the accuracy difference is less than 0.5% of accuracy; this case never happen for the PFBP algorithm, arguably due to a better selection of features with less collinearities (deterministic relations).</p><p>Open Access This article is distributed under the terms of the Creative Commons Attribution 4.0 International License (<ref type="url" target="http://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</ref>), which permits unrestricted use, distribution, and reproduction in any medium, provided you give appropriate credit to the original author(s) and the source, provide a link to the Creative Commons license, and indicate if changes were made.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendices A: Accuracy of p-value combination using meta-analysis and evaluation of the STD rule</head><p>We evaluated the ability of the proposed p-value computation method (combination of local p-values using Fisher's combined probability test) in identifying the same variable to select as when global p-values are used. We performed a computational experiment on simulated data to investigate the effect of the total sample size and number of data Blocks on the accuracy of the proposed approach. Furthermore, we compare the STD and EPV rules for setting the minimum number of samples in each Data Block. The EPV rule computes the sample size per Sample Group as</p><p>is set to the maximum number of degrees of freedom (see 5.1 for more details), c is a positive constant (which may take different values for each rule), and p 0 and p 1 are the frequencies of the negative and positive class respectively.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.1: Data generation</head><p>To generate data with complex correlation structures, we chose to generate data from simulated Bayesian networks. All variables are continuous Gaussian and are linear functions of their parents. The target variable is binary, and the log-odds ratio is a linear function of its parents. The procedure is described in detail in "Appendix B". We used the following parameters to generate Bayesian networks and data from those networks: (a) the number of variables was set to 101 (100 variables plus the outcome T ), (b) the connectivity parameter was set to 10 (i.e., the average degree of each node), (c) the frequency of the most frequent class of T was set to {50, 60, 70, 80, 90%} and (d) the standard deviation of the error terms was set to {0.01, 0.1, 1}. In total this results in 15 possible Bayesian network configurations. Note that, the connectivity is relatively high and the standard deviation of the error terms is relatively low so that all variables are highly correlated, increasing the difficulty of the problem of selecting the best variable. For each such parameter combination we generated 250 Bayesian networks, resulting in a total of 250 × 15 = 3750 networks. Next, we generated datasets with different sample sizes, by varying the sample size from 10 2.5 to 10 4 in increments of 0.1 of the exponent, leading to 16 different sample sizes. Overall this resulted in 60,000 datasets.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.2: Simulation results: combined p-values versus global p-values</head><p>We performed conditional independence tests on all generated datasets to simulate a forward Iteration using p-values from global tests (i.e., using all data) and from combined p-values using Fisher's method. We varied the following parameters: (a) the number of conditioning variables, which was set to 0, 1, 2 or 3, and (b) the number of Sample Sets each dataset was split to, which ranged from 1 (no split) to 25 with increments of 1 (a total of 25 cases). This allows us to investigate the effect of the total number of combined local p-values. The simulation of a forward Iteration was performed for each dataset and conditioning size k as follows: (a) k variables were randomly selected from the Markov blanket of T (simulating that k variables have already been selected), (b) the global conditional independence test was performed between T and the remaining variables over all samples (i.e. number of sample sets equals 1), (c) the same test was performed on all Sample Sets resulting by splitting the data randomly to m equally-sized sample sets (m ranging from 2 to 25) and combining the p-values using Fisher's combined probability test.</p><p>We compute the percentage of agreement between both methods, that is, how often both methods select the same variable. This is computed as the proportion of times both methods agreed on the 250 repetitions, leading to one value for each of the 15 Bayesian network configurations, each sample size, conditioning set size and number of Sample Sets. Thus, in total we have 15 × 16 × 4 × 24 = 23,040 such values. The results are summarized in Fig. <ref type="figure">6</ref>. There are 4 figures, one for each different conditioning size, and each figure contains 5 curves, one for each class distribution of T . Each such curve summarizes the results over all error variances, sample sizes and number of Sample Sets (that is, 3 × 16 × 24 = 1152 points). Note that the number of parameters of the largest model is always the conditioning size plus 2, as the model also includes the variable that is tested for (conditional) independence with T and the intercept. The x-axis shows the sample size per Sample Set, which is computed as the sample size divided by the number of Sample Sets. We only show the results up to 500 samples per Sample Set; the agreement percentage approaches 100% in all cases with increasing sample size, reaching at least 99% with 5000 samples per Sample Set. The y-axis shows how often both methods lead to the same decision. To avoid cluttering, we computed the curves by fitting a power regression model y = α • x β + c. We found that this model is appropriate, as it has R 2 values between 0.75 and 0.95. We conclude the following: (a) both approaches tend to make the same decision with increasing sample size, (b) the sample size per Sample Set required depends on the number of parameters and the class distribution, and increases with increasing number of parameters and class imbalance.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.3: Simulation results: STD versus EPV for determining the required sample size</head><p>We propose an alternative rule to EPV, which is computed as d f •c/ √ p 0 • p 1 . The denominator is the standard deviation of the class distribution, which follows a Bernoulli distribution. We call this the STD rule hereafter. For balanced class distributions the result is identical to the EPV rule, while for skewed distributions the value is always smaller.</p><p>samples and 592,555 SNPs. Each variable takes values in {0, 1, 2}, which correspond to the number of reference alleles. Thus, the dataset is dense, and requires approximately 2.16 TB memory (stored as double precision floats). Naturally, fewer bytes can be used to store SNP data as each variable only takes 3 values, but this would require a specialized implementation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C.1: Phenotype simulation</head><p>Let s i j be the ith value of the jth SNP s j , and p j be the reference allele frequency of SNP j, that is, p j is the average value of s i j divided by 2. The standardized value of s i j , z i j is defined as</p><p>where μ j = 2 p j and σ j = 2 p j (1p j ).</p><p>The phenotype (outcome) y follows an additive genetic model</p><p>where y i is the ith value of y, g i is the genetic effect, e i is the noise term, M is the number of variables influencing y, and u j is the effect (coefficient) of z j . The coefficients z j were sampled from a normal distribution with zero mean and unit variance. The error terms e i follow a normal distribution with zero mean and variance σ 2 i (1h 2 )/h 2 , where σ 2 i is the variance of g i and h 2 corresponds to the trait heritability. Naturally, the larger h 2 , the more y depends on the SNPs. In our case, we chose M = 100 and set h 2 = 0.7, one of the values used in <ref type="bibr" target="#b13">Canela-Xandri et al. (2015)</ref>. Finally, to obtain a binary outcome, we set the value of y i to 1 if it is positive, and to 0 otherwise, resulting in an approximately balanced outcome.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Affiliations</head><p>Ioannis Tsamardinos 1,2 • Giorgos Borboudakis 1 • Pavlos Katsogridakis 1,3 • Polyvios Pratikakis 1,3 • Vassilis Christophides 1,4 Giorgos Borboudakis borbudak@gmail.com Pavlos Katsogridakis pkatsogr@gmail.com</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<author>
			<persName><forename type="first">A</forename><surname>Agresti</surname></persName>
		</author>
		<title level="m">Wiley series in probability and statistics</title>
		<meeting><address><addrLine>Hoboken</addrLine></address></meeting>
		<imprint>
			<publisher>Wiley</publisher>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
	<note>Categorical data analysis</note>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Information theory and an extension of the maximum likelihood principle</title>
		<author>
			<persName><forename type="first">H</forename><surname>Akaike</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Second international symposium on information theory</title>
		<meeting><address><addrLine>Budapest</addrLine></address></meeting>
		<imprint>
			<publisher>Akadémiai Kiado</publisher>
			<date type="published" when="1973">1973</date>
			<biblScope unit="page" from="267" to="281" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Local causal and Markov blanket induction for causal discovery and feature selection for classification part i: Algorithms and empirical evaluation</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">F</forename><surname>Aliferis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Statnikov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Tsamardinos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Mani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><forename type="middle">D</forename><surname>Koutsoukos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Machine Learning Research</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page" from="171" to="234" />
			<date type="published" when="2010-01">2010. Jan</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">HITON: A novel Markov blanket algorithm for optimal variable selection</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">F</forename><surname>Aliferis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Tsamardinos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Statnikov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">AMIA annual symposium proceedings</title>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Minimization of functions having Lipschitz continuous first partial derivatives</title>
		<author>
			<persName><forename type="first">L</forename><surname>Armijo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Pacific Journal of Mathematics</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1" to="3" />
			<date type="published" when="1966">1966</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">The synthesis of regression slopes in meta-analysis</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">J</forename><surname>Becker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M.-J</forename><surname>Wu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Statistical Science</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="page" from="414" to="429" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Best subset selection via a modern optimization lens</title>
		<author>
			<persName><forename type="first">D</forename><surname>Bertsimas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>King</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Mazumder</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The Annals of Statistics</title>
		<imprint>
			<biblScope unit="volume">44</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="813" to="852" />
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">On the difference between orthogonal matching pursuit and orthogonal least squares</title>
		<author>
			<persName><forename type="first">T</forename><surname>Blumensath</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">E</forename><surname>Davies</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Sánchez-Maroño</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Alonso-Betanzos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Feature selection for highdimensional data</title>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2007">2007. 2015</date>
		</imprint>
		<respStmt>
			<orgName>University of Edinburgh. Bolón-Canedo,</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical report</note>
	<note>st ed.</note>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Recent advances and emerging challenges of feature selection in the context of big data</title>
		<author>
			<persName><forename type="first">V</forename><surname>Bolón-Canedo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Sánchez-Maroño</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Alonso-Betanzos</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2015">2015b</date>
			<publisher>Knowledge-Based Systems</publisher>
			<biblScope unit="volume">86</biblScope>
			<biblScope unit="page" from="33" to="45" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Exploring the consequences of distributed feature selection in DNA microarray data</title>
		<author>
			<persName><forename type="first">V</forename><surname>Bolón-Canedo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Sechidis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Sánchez-Marono</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Alonso-Betanzos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Brown</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International joint conference on neural networks</title>
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="1665" to="1672" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<author>
			<persName><forename type="first">G</forename><surname>Borboudakis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Tsamardinos</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1705.10770[cs.LG]</idno>
		<title level="m">Forward-backward selection with early dropping</title>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Parallel coordinate descent for l1-regularized loss minimization</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">K</forename><surname>Bradley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Kyrola</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Bickson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Guestrin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 28th international conference on machine learning, ICML 2011</title>
		<meeting>the 28th international conference on machine learning, ICML 2011<address><addrLine>Bellevue, Washington, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2011-06-28">2011. June 28-July 2, 2011</date>
			<biblScope unit="page" from="321" to="328" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Conditional likelihood maximisation: A unifying framework for information theoretic feature selection</title>
		<author>
			<persName><forename type="first">G</forename><surname>Brown</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Pocock</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M.-J</forename><surname>Zhao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Luján</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Machine Learning Research</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page" from="27" to="66" />
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">A new tool called dissect for analysing large genomic data sets using a big data approach</title>
		<author>
			<persName><forename type="first">O</forename><surname>Canela-Xandri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Law</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Gray</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Woolliams</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Tenesa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nature Communications</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page">10162</biblScope>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Second-generation plink: rising to the challenge of larger and richer datasets</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">C</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">C</forename><surname>Chow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">C</forename><surname>Tellier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Vattikuti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">M</forename><surname>Purcell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">J</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Gigascience</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page">7</biblScope>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">On a class of incomplete gamma functions with applications</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Chaudhry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">M</forename><surname>Zubair</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2001">2001</date>
			<publisher>CRC Press</publisher>
			<pubPlace>Boca Raton</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">A new initiative on precision medicine</title>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">S</forename><surname>Collins</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Varmus</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">New England Journal of Medicine</title>
		<imprint>
			<biblScope unit="volume">372</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="793" to="795" />
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">A haplotype map of the human genome</title>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">H</forename><surname>Consortium</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nature</title>
		<imprint>
			<biblScope unit="volume">437</biblScope>
			<biblScope unit="issue">7063</biblScope>
			<biblScope unit="page" from="1299" to="1320" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Adaptive time-frequency decompositions</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">M</forename><surname>Davis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">G</forename><surname>Mallat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Optical Engineering</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="2183" to="2192" />
			<date type="published" when="1994">1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">C</forename><surname>Davison</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">V</forename><surname>Hinkley</surname></persName>
		</author>
		<title level="m">Bootstrap methods and their application</title>
		<meeting><address><addrLine>Cambridge</addrLine></address></meeting>
		<imprint>
			<publisher>Cambridge university press</publisher>
			<date type="published" when="1997">1997</date>
			<biblScope unit="volume">1</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Supervised and unsupervised discretization of continuous features</title>
		<author>
			<persName><forename type="first">J</forename><surname>Dougherty</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Kohavi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Sahami</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Machine Learning Proceedings</title>
		<imprint>
			<date type="published" when="1995">1995. 1995</date>
			<biblScope unit="page" from="194" to="202" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<author>
			<persName><forename type="first">B</forename><surname>Efron</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Hastie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Johnstone</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Tibshirani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Least angle regression</title>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="page" from="407" to="499" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">An introduction to the bootstrap</title>
		<author>
			<persName><forename type="first">B</forename><surname>Efron</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">J</forename><surname>Tibshirani</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1994">1994</date>
			<publisher>CRC press</publisher>
			<pubPlace>Boca Raton</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Wald, likelihood ratio, and Lagrange multiplier tests in econometrics</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">F</forename><surname>Engle</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Handbook of Econometrics</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="775" to="826" />
			<date type="published" when="1984">1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">High-dimensional variable selection for Cox&apos;s proportional hazards model</title>
		<author>
			<persName><forename type="first">J</forename><surname>Fan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Feng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Wu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Borrowing strength: Theory powering applications-a Festschrift for Lawrence D. Brown</title>
		<imprint>
			<publisher>Institute of Mathematical Statistics</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="70" to="86" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<author>
			<persName><forename type="first">R</forename><surname>Fisher</surname></persName>
		</author>
		<title level="m">Statistical methods for research workers</title>
		<meeting><address><addrLine>Edinburgh</addrLine></address></meeting>
		<imprint>
			<publisher>Oliver &amp; Boyd</publisher>
			<date type="published" when="1932">1932</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Fast binary feature selection with conditional mutual information</title>
		<author>
			<persName><forename type="first">F</forename><surname>Fleuret</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Machine Learning Research</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page" from="1531" to="1555" />
			<date type="published" when="2004-11">2004. Nov</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">The performance of the likelihood ratio test when the model is incorrect</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">V</forename><surname>Foutz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">C</forename><surname>Srivastava</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The Annals of Statistics</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="1183" to="1194" />
			<date type="published" when="1977">1977</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">An introduction to variable and feature selection</title>
		<author>
			<persName><forename type="first">I</forename><surname>Guyon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Elisseeff</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Machine Learning Research</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="1157" to="1182" />
			<date type="published" when="2003-03">2003. Mar</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<title level="m" type="main">Comparative analysis of orthogonal matching pursuit and least angle regression. Master&apos;s thesis</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Hameed</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
		<respStmt>
			<orgName>Michigan State University, Electrical Engineering</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<monogr>
		<author>
			<persName><forename type="first">F</forename><surname>Harrell</surname></persName>
		</author>
		<title level="m">Regression modeling strategies</title>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
	<note>corrected ed.</note>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Fixed-and random-effects models in meta-analysis</title>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">V</forename><surname>Hedges</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">L</forename><surname>Vevea</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Psychological Methods</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page">486</biblScope>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">W</forename><surname>Hosmer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jr</forename><surname>Lemeshow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Sturdivant</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">X</forename></persName>
		</author>
		<title level="m">Introduction to the Logistic Regression Model</title>
		<meeting><address><addrLine>Hoboken</addrLine></address></meeting>
		<imprint>
			<publisher>Wiley</publisher>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Adaptive Lasso and group-Lasso for functional Poisson regression</title>
		<author>
			<persName><forename type="first">S</forename><surname>Ivanoff</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Picard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Rivoirard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Machine Learning Research</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1903" to="1948" />
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Irrelevant features and the subset selection problem</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">H</forename><surname>John</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Kohavi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Pfleger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Machine learning: Proceedings of the eleventh international conference</title>
		<imprint>
			<date type="published" when="1994">1994</date>
			<biblScope unit="page" from="121" to="129" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Chimerge: Discretization of numeric attributes</title>
		<author>
			<persName><forename type="first">R</forename><surname>Kerber</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the tenth national conference on Artificial intelligence</title>
		<meeting>the tenth national conference on Artificial intelligence</meeting>
		<imprint>
			<publisher>AAAI Press</publisher>
			<date type="published" when="1992">1992</date>
			<biblScope unit="page" from="123" to="128" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Toward optimal feature selection</title>
		<author>
			<persName><forename type="first">D</forename><surname>Koller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Sahami</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Thirteenth International Conference on Machine Learning</title>
		<meeting>the Thirteenth International Conference on Machine Learning</meeting>
		<imprint>
			<date type="published" when="1996">1996</date>
			<biblScope unit="page" from="284" to="292" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Feature selection in enterprise analytics: A demonstration using an R-based data analytics system</title>
		<author>
			<persName><forename type="first">P</forename><surname>Konda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Ré</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Sashikanth</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the VLDB Endowment</title>
		<meeting>the VLDB Endowment</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="1306" to="1309" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<monogr>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">H</forename><surname>Kutner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">J</forename><surname>Nachtsheim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Neter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Li</surname></persName>
		</author>
		<title level="m">Applied Linear Statistical Models</title>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>McGraw-Hill/Irwin</publisher>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
	<note>th ed.</note>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Feature selection with the R package MXM: Discovering statistically equivalent feature subsets</title>
		<author>
			<persName><forename type="first">V</forename><surname>Lagani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Athineou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Farcomeni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Tsagris</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Tsamardinos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Statistical Software</title>
		<imprint>
			<biblScope unit="volume">80</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="1" to="25" />
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Biomarker signature identification in omics data with multiclass outcomes</title>
		<author>
			<persName><forename type="first">V</forename><surname>Lagani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Kortas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Tsamardinos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computational and Structural Biotechnology Journal</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="1" to="7" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Structure-based variable selection for survival data</title>
		<author>
			<persName><forename type="first">V</forename><surname>Lagani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Tsamardinos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="issue">15</biblScope>
			<biblScope unit="page" from="1887" to="1894" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">On model parallelization and scheduling strategies for distributed machine learning</title>
		<author>
			<persName><forename type="first">S</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">K</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Zheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Ho</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">A</forename><surname>Gibson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">P</forename><surname>Xing</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in neural information processing systems 27: Annual conference on neural information processing systems</title>
		<imprint>
			<publisher>Montreal</publisher>
			<date type="published" when="2014-12-08">2014. 2014. December 8-13, 2014</date>
			<biblScope unit="page" from="2834" to="2842" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Feature selection: A data perspective</title>
		<author>
			<persName><forename type="first">J</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Cheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Morstatter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">P</forename><surname>Trevino</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Tang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Computing Surveys</title>
		<imprint>
			<biblScope unit="volume">50</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page">45</biblScope>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Parallel lasso screening for big data optimization</title>
		<author>
			<persName><forename type="first">Q</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Qiu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Ji</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">M</forename><surname>Thompson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Ye</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 22nd ACM SIGKDD international conference on knowledge discovery and data mining</title>
		<meeting>the 22nd ACM SIGKDD international conference on knowledge discovery and data mining<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="1705" to="1714" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">A systematic comparison of methods for combining p values from independent tests</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">M</forename><surname>Loughin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computational Statistics &amp; Data Analysis</title>
		<imprint>
			<biblScope unit="volume">47</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="467" to="485" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Toward provably correct feature selection in arbitrary domains</title>
		<author>
			<persName><forename type="first">D</forename><surname>Margaritis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in neural information processing systems</title>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="1240" to="1248" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Bayesian network induction via local neighborhoods</title>
		<author>
			<persName><forename type="first">D</forename><surname>Margaritis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Thrun</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Advances in Neural Information Processing Systems</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="505" to="511" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">The group lasso for logistic regression</title>
		<author>
			<persName><forename type="first">L</forename><surname>Meier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Van De Geer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Bühlmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the Royal Statistical Society, Series B</title>
		<imprint>
			<biblScope unit="volume">70</biblScope>
			<biblScope unit="page" from="53" to="71" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">High-dimensional graphs and variable selection with the Lasso</title>
		<author>
			<persName><forename type="first">N</forename><surname>Meinshausen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Bühlmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The Annals of Statistics</title>
		<imprint>
			<biblScope unit="volume">34</biblScope>
			<biblScope unit="page" from="1436" to="1462" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">Mllib: Machine learning in apache spark</title>
		<author>
			<persName><forename type="first">X</forename><surname>Meng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Bradley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Yavuz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Sparks</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Venkataraman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Liu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Machine Learning Research</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1235" to="1241" />
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<monogr>
		<title level="m" type="main">Subset selection in regression</title>
		<author>
			<persName><forename type="first">A</forename><surname>Miller</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002">2002</date>
			<publisher>CRC Press</publisher>
			<pubPlace>Boca Raton</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<monogr>
		<title level="m" type="main">A comparison of numerical optimizers for logistic regression</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">P</forename><surname>Minka</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
	<note type="report_type">Technical report</note>
	<note>unpublished draft</note>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title level="a" type="main">Orthogonal matching pursuit: Recursive function approximation with applications to wavelet decomposition</title>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">C</forename><surname>Pati</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Rezaiifar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">S</forename><surname>Krishnaprasad</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Conference record of the twenty-seventh Asilomar conference on signals, systems and computers</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="1993">1993</date>
			<biblScope unit="page" from="40" to="44" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<monogr>
		<title level="m" type="main">Probabilistic reasoning in intelligent systems: Networks of plausible inference</title>
		<author>
			<persName><forename type="first">J</forename><surname>Pearl</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1988">1988</date>
			<publisher>Morgan Kaufmann Publishers Inc</publisher>
			<pubPlace>San Francisco</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<monogr>
		<author>
			<persName><forename type="first">J</forename><surname>Pearl</surname></persName>
		</author>
		<title level="m">Causality, models, reasoning, and inference</title>
		<meeting><address><addrLine>Cambridge</addrLine></address></meeting>
		<imprint>
			<publisher>Cambridge University Press</publisher>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<analytic>
		<title level="a" type="main">A theory of inferred causation</title>
		<author>
			<persName><forename type="first">J</forename><surname>Pearl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">S</forename><surname>Verma</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Studies in Logic and the Foundations of Mathematics</title>
		<imprint>
			<date type="published" when="1995">1995</date>
			<biblScope unit="volume">134</biblScope>
			<biblScope unit="page" from="789" to="811" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b57">
	<analytic>
		<title level="a" type="main">A simulation study of the number of events per variable in logistic regression analysis</title>
		<author>
			<persName><forename type="first">P</forename><surname>Peduzzi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Concato</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Kemper</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">R</forename><surname>Holford</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">R</forename><surname>Feinstein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Clinical Epidemiology</title>
		<imprint>
			<biblScope unit="volume">49</biblScope>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="1373" to="1379" />
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b58">
	<analytic>
		<title level="a" type="main">Towards scalable and data efficient learning of Markov boundaries</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Peña</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Nilsson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Björkegren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Tegnér</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International Journal of Approximate Reasoning</title>
		<imprint>
			<biblScope unit="volume">45</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="211" to="232" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b59">
	<analytic>
		<title level="a" type="main">Feature selection based on mutual information criteria of maxdependency, max-relevance, and min-redundancy</title>
		<author>
			<persName><forename type="first">H</forename><surname>Peng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Long</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Ding</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Pattern Analysis and Machine Intelligence</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="1226" to="1238" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b60">
	<analytic>
		<title level="a" type="main">An information theory-based feature selection framework for big data under apache spark</title>
		<author>
			<persName><forename type="first">S</forename><surname>Ramrez-Gallego</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Mourio-Taln</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Martnez-Rego</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Boln-Canedo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Bentez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Alonso-Betanzos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Systems, Man, and Cybernetics: Systems</title>
		<imprint>
			<biblScope unit="page" from="1" to="13" />
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b61">
	<analytic>
		<title level="a" type="main">Ancestral graph Markov models</title>
		<author>
			<persName><forename type="first">T</forename><surname>Richardson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Spirtes</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Annals of Statistics</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="page" from="962" to="1030" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b62">
	<analytic>
		<title level="a" type="main">Feature subset selection for logistic regression via mixed integer optimization</title>
		<author>
			<persName><forename type="first">T</forename><surname>Sato</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Takano</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Miyashiro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Yoshise</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computational Optimization and Applications</title>
		<imprint>
			<biblScope unit="volume">64</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="865" to="880" />
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b63">
	<analytic>
		<title level="a" type="main">Estimation for high-dimensional linear mixed-effects models using l1-penalization</title>
		<author>
			<persName><forename type="first">J</forename><surname>Schelldorfer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Bühlmann</surname></persName>
		</author>
		<author>
			<persName><surname>Van De</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Geer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Scandinavian Journal of Statistics</title>
		<imprint>
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="197" to="214" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b64">
	<analytic>
		<title level="a" type="main">Estimating the dimension of a model</title>
		<author>
			<persName><forename type="first">G</forename><surname>Schwarz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The Annals of Statistics</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="461" to="464" />
			<date type="published" when="1978">1978</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b65">
	<analytic>
		<title level="a" type="main">dbSNP: The NCBI database of genetic variation</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">T</forename><surname>Sherry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M.-H</forename><surname>Ward</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kholodov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Baker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Phan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">M</forename><surname>Smigielski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nucleic Acids Research</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="308" to="311" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b66">
	<analytic>
		<title level="a" type="main">Parallel large scale feature selection for logistic regression</title>
		<author>
			<persName><forename type="first">S</forename><surname>Singh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Kubica</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Larsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Sorokina</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2009 SIAM international conference on data mining</title>
		<meeting>the 2009 SIAM international conference on data mining</meeting>
		<imprint>
			<publisher>SIAM</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="1172" to="1183" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b67">
	<monogr>
		<author>
			<persName><forename type="first">P</forename><surname>Spirtes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">N</forename><surname>Glymour</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Scheines</surname></persName>
		</author>
		<title level="m">Causation, prediction, and search</title>
		<meeting><address><addrLine>Cambridge</addrLine></address></meeting>
		<imprint>
			<publisher>MIT Press</publisher>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
	<note>nd ed.</note>
</biblStruct>

<biblStruct xml:id="b68">
	<analytic>
		<title level="a" type="main">Algorithms for discovery of multiple Markov boundaries</title>
		<author>
			<persName><forename type="first">A</forename><surname>Statnikov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">I</forename><surname>Lytkin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Lemeire</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">F</forename><surname>Aliferis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Machine Learning Research</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page" from="499" to="566" />
			<date type="published" when="2013-02">2013. Feb</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b69">
	<analytic>
		<title level="a" type="main">Regression shrinkage and selection via the Lasso</title>
		<author>
			<persName><forename type="first">R</forename><surname>Tibshirani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the Royal Statistical Society. Series B (Methodological)</title>
		<imprint>
			<biblScope unit="volume">58</biblScope>
			<biblScope unit="page" from="267" to="288" />
			<date type="published" when="1996">1996</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b70">
	<analytic>
		<title level="a" type="main">Feature selection for high-dimensional temporal data</title>
		<author>
			<persName><forename type="first">M</forename><surname>Tsagris</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Lagani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Tsamardinos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">BMC Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page">17</biblScope>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b71">
	<analytic>
		<title level="a" type="main">Towards principled feature selection: Relevancy, filters and wrappers</title>
		<author>
			<persName><forename type="first">I</forename><surname>Tsamardinos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">F</forename><surname>Aliferis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ninth international workshop on artificial intelligence and statistics</title>
		<meeting>the ninth international workshop on artificial intelligence and statistics</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b72">
	<analytic>
		<title level="a" type="main">Time and sample efficient discovery of Markov blankets and direct causal relations</title>
		<author>
			<persName><forename type="first">I</forename><surname>Tsamardinos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">F</forename><surname>Aliferis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Statnikov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ninth ACM SIGKDD international conference on Knowledge discovery and data mining</title>
		<meeting>the ninth ACM SIGKDD international conference on Knowledge discovery and data mining</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="673" to="678" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b73">
	<analytic>
		<title level="a" type="main">Algorithms for large scale Markov blanket discovery</title>
		<author>
			<persName><forename type="first">I</forename><surname>Tsamardinos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">F</forename><surname>Aliferis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">R</forename><surname>Statnikov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FLAIRS conference</title>
		<imprint>
			<date type="published" when="2003">2003b</date>
			<biblScope unit="volume">2</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b74">
	<analytic>
		<title level="a" type="main">Multi-source causal analysis: Learning Bayesian networks from multiple datasets</title>
		<author>
			<persName><forename type="first">I</forename><surname>Tsamardinos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">P</forename><surname>Mariglis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IFIP international conference on artificial intelligence applications and innovations</title>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="479" to="490" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b75">
	<analytic>
		<title level="a" type="main">Causal networks: Semantics and expressiveness</title>
		<author>
			<persName><forename type="first">T</forename><surname>Verma</surname></persName>
		</author>
		<author>
			<persName><surname>Pearl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings, 4th workshop on uncertainty in artificial intelligence</title>
		<meeting>4th workshop on uncertainty in artificial intelligence</meeting>
		<imprint>
			<date type="published" when="1988">1988</date>
			<biblScope unit="page" from="352" to="359" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b76">
	<analytic>
		<title level="a" type="main">Relaxing the rule of ten events per variable in logistic and Cox regression</title>
		<author>
			<persName><forename type="first">E</forename><surname>Vittinghoff</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">E</forename><surname>Mcculloch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">American Journal of Epidemiology</title>
		<imprint>
			<biblScope unit="volume">165</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="710" to="718" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b77">
	<analytic>
		<title level="a" type="main">Likelihood ratio tests for model selection and non-nested hypotheses</title>
		<author>
			<persName><forename type="first">Q</forename><forename type="middle">H</forename><surname>Vuong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Econometrica: Journal of the Econometric Society</title>
		<imprint>
			<biblScope unit="volume">57</biblScope>
			<biblScope unit="page" from="307" to="333" />
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b78">
	<analytic>
		<title level="a" type="main">Decorrelated feature space partitioning for distributed sparse regression</title>
		<author>
			<persName><forename type="first">X</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Dunson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Leng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in neural information processing systems</title>
		<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="802" to="810" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b79">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">S</forename><surname>Weisberg</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2005">2005</date>
			<publisher>Wiley</publisher>
			<biblScope unit="volume">528</biblScope>
			<pubPlace>Hoboken</pubPlace>
		</imprint>
	</monogr>
	<note>Applied linear regression</note>
</biblStruct>

<biblStruct xml:id="b80">
	<analytic>
		<title level="a" type="main">Algorithmic complexity: Three NP-hard problems in computational statistics</title>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">J</forename><surname>Welch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Statistical Computation and Simulation</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="17" to="25" />
			<date type="published" when="1982">1982</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b81">
	<analytic>
		<title level="a" type="main">Maximum likelihood estimation of misspecified models</title>
		<author>
			<persName><forename type="first">H</forename><surname>White</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Econometrica</title>
		<imprint>
			<biblScope unit="volume">50</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1" to="25" />
			<date type="published" when="1982">1982</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b82">
	<analytic>
		<title level="a" type="main">The large-sample distribution of the likelihood ratio for testing composite hypotheses</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">S</forename><surname>Wilks</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The Annals of Mathematical Statistics</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="60" to="62" />
			<date type="published" when="1938">1938</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b83">
	<analytic>
		<title level="a" type="main">Strategies and principles of distributed machine learning on Big Data</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">P</forename><surname>Xing</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Q</forename><surname>Ho</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Xie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Wei</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Engineering</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="179" to="195" />
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b84">
	<analytic>
		<title level="a" type="main">Data visualization and feature selection: New algorithms for nongaussian data</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">H</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Moody</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in neural information processing systems</title>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="687" to="693" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b85">
	<monogr>
		<title level="m" type="main">Spark: Cluster computing with working sets</title>
		<author>
			<persName><forename type="first">M</forename><surname>Zaharia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Chowdhury</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Franklin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Shenker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Stoica</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
	<note>HotCloud</note>
</biblStruct>

<biblStruct xml:id="b86">
	<analytic>
		<title level="a" type="main">The emerging big dimensionality</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Ong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">W</forename><surname>Tsang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computational Intelligence Magazine</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="14" to="26" />
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b87">
	<analytic>
		<title level="a" type="main">Kernel-based conditional independence test and application in causal discovery</title>
		<author>
			<persName><forename type="first">K</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Peters</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Janzing</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Schölkopf</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the twenty-seventh conference on uncertainty in artificial intelligence</title>
		<meeting>the twenty-seventh conference on uncertainty in artificial intelligence</meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="804" to="813" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b88">
	<analytic>
		<title level="a" type="main">Massively parallel feature selection: An approach based on variance preservation</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Zhao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Cox</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Duling</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Sarle</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Machine Learning</title>
		<imprint>
			<biblScope unit="volume">92</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="195" to="220" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b89">
	<analytic>
		<title level="a" type="main">Parallel and distributed sparse optimization</title>
		<author>
			<persName><forename type="first">P</forename><surname>Zhimin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Ming</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Wotao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Asilomar conference on signals, systems and computers</title>
		<meeting>the Asilomar conference on signals, systems and computers</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b90">
	<analytic>
		<title level="a" type="main">Parallel feature selection inspired by group testing</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Porwal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">Q</forename><surname>Ngo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Nguyen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Ré</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Govindaraju</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in neural information processing systems</title>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="3554" to="3562" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b91">
	<monogr>
		<title level="m" type="main">Publisher&apos;s Note Springer Nature remains neutral with regard to jurisdictional claims in published maps and institutional affiliations</title>
		<imprint/>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
