<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">A Distributed Fixed-Point Algorithm for Extended Dependency Graphs *</title>
				<funder>
					<orgName type="full">Sino-Danish Basic Research Center IDEA4CPS, Innovation Fund Denmark center DiCyPS</orgName>
				</funder>
				<funder>
					<orgName type="full">European Research Council</orgName>
					<orgName type="abbreviated">ERC</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Andreas</forename><forename type="middle">E</forename><surname>Dalsgaard</surname></persName>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">Department of Computer Science</orgName>
								<orgName type="department" key="dep2">Department of Computer Science</orgName>
								<orgName type="department" key="dep3">Department of Computer Science</orgName>
								<orgName type="department" key="dep4">Department of Computer Science</orgName>
								<orgName type="department" key="dep5">Department of Computer Science</orgName>
								<orgName type="department" key="dep6">Department of Computer Science</orgName>
								<orgName type="department" key="dep7">Department of Computer Science</orgName>
								<orgName type="department" key="dep8">Department of Computer Science</orgName>
								<orgName type="department" key="dep9">Department of Computer Science</orgName>
								<orgName type="department" key="dep10">Department of Computer Science</orgName>
								<orgName type="department" key="dep11">Faculty of Informatics Masaryk University</orgName>
								<orgName type="department" key="dep12">Department of Computer Science</orgName>
								<orgName type="institution" key="instit1">Aalborg University</orgName>
								<orgName type="institution" key="instit2">Aalborg University</orgName>
								<orgName type="institution" key="instit3">Aalborg University</orgName>
								<orgName type="institution" key="instit4">Aalborg University</orgName>
								<orgName type="institution" key="instit5">Aalborg University</orgName>
								<orgName type="institution" key="instit6">Aalborg University</orgName>
								<orgName type="institution" key="instit7">Aalborg University</orgName>
								<orgName type="institution" key="instit8">Aalborg University</orgName>
								<orgName type="institution" key="instit9">Aalborg University</orgName>
								<orgName type="institution" key="instit10">Aalborg University</orgName>
								<orgName type="institution" key="instit11">Aalborg University</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Søren</forename><surname>Enevoldsen</surname></persName>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">Department of Computer Science</orgName>
								<orgName type="department" key="dep2">Department of Computer Science</orgName>
								<orgName type="department" key="dep3">Department of Computer Science</orgName>
								<orgName type="department" key="dep4">Department of Computer Science</orgName>
								<orgName type="department" key="dep5">Department of Computer Science</orgName>
								<orgName type="department" key="dep6">Department of Computer Science</orgName>
								<orgName type="department" key="dep7">Department of Computer Science</orgName>
								<orgName type="department" key="dep8">Department of Computer Science</orgName>
								<orgName type="department" key="dep9">Department of Computer Science</orgName>
								<orgName type="department" key="dep10">Department of Computer Science</orgName>
								<orgName type="department" key="dep11">Faculty of Informatics Masaryk University</orgName>
								<orgName type="department" key="dep12">Department of Computer Science</orgName>
								<orgName type="institution" key="instit1">Aalborg University</orgName>
								<orgName type="institution" key="instit2">Aalborg University</orgName>
								<orgName type="institution" key="instit3">Aalborg University</orgName>
								<orgName type="institution" key="instit4">Aalborg University</orgName>
								<orgName type="institution" key="instit5">Aalborg University</orgName>
								<orgName type="institution" key="instit6">Aalborg University</orgName>
								<orgName type="institution" key="instit7">Aalborg University</orgName>
								<orgName type="institution" key="instit8">Aalborg University</orgName>
								<orgName type="institution" key="instit9">Aalborg University</orgName>
								<orgName type="institution" key="instit10">Aalborg University</orgName>
								<orgName type="institution" key="instit11">Aalborg University</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Peter</forename><surname>Fogh</surname></persName>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">Department of Computer Science</orgName>
								<orgName type="department" key="dep2">Department of Computer Science</orgName>
								<orgName type="department" key="dep3">Department of Computer Science</orgName>
								<orgName type="department" key="dep4">Department of Computer Science</orgName>
								<orgName type="department" key="dep5">Department of Computer Science</orgName>
								<orgName type="department" key="dep6">Department of Computer Science</orgName>
								<orgName type="department" key="dep7">Department of Computer Science</orgName>
								<orgName type="department" key="dep8">Department of Computer Science</orgName>
								<orgName type="department" key="dep9">Department of Computer Science</orgName>
								<orgName type="department" key="dep10">Department of Computer Science</orgName>
								<orgName type="department" key="dep11">Faculty of Informatics Masaryk University</orgName>
								<orgName type="department" key="dep12">Department of Computer Science</orgName>
								<orgName type="institution" key="instit1">Aalborg University</orgName>
								<orgName type="institution" key="instit2">Aalborg University</orgName>
								<orgName type="institution" key="instit3">Aalborg University</orgName>
								<orgName type="institution" key="instit4">Aalborg University</orgName>
								<orgName type="institution" key="instit5">Aalborg University</orgName>
								<orgName type="institution" key="instit6">Aalborg University</orgName>
								<orgName type="institution" key="instit7">Aalborg University</orgName>
								<orgName type="institution" key="instit8">Aalborg University</orgName>
								<orgName type="institution" key="instit9">Aalborg University</orgName>
								<orgName type="institution" key="instit10">Aalborg University</orgName>
								<orgName type="institution" key="instit11">Aalborg University</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Lasse</forename><forename type="middle">S</forename><surname>Jensen</surname></persName>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">Department of Computer Science</orgName>
								<orgName type="department" key="dep2">Department of Computer Science</orgName>
								<orgName type="department" key="dep3">Department of Computer Science</orgName>
								<orgName type="department" key="dep4">Department of Computer Science</orgName>
								<orgName type="department" key="dep5">Department of Computer Science</orgName>
								<orgName type="department" key="dep6">Department of Computer Science</orgName>
								<orgName type="department" key="dep7">Department of Computer Science</orgName>
								<orgName type="department" key="dep8">Department of Computer Science</orgName>
								<orgName type="department" key="dep9">Department of Computer Science</orgName>
								<orgName type="department" key="dep10">Department of Computer Science</orgName>
								<orgName type="department" key="dep11">Faculty of Informatics Masaryk University</orgName>
								<orgName type="department" key="dep12">Department of Computer Science</orgName>
								<orgName type="institution" key="instit1">Aalborg University</orgName>
								<orgName type="institution" key="instit2">Aalborg University</orgName>
								<orgName type="institution" key="instit3">Aalborg University</orgName>
								<orgName type="institution" key="instit4">Aalborg University</orgName>
								<orgName type="institution" key="instit5">Aalborg University</orgName>
								<orgName type="institution" key="instit6">Aalborg University</orgName>
								<orgName type="institution" key="instit7">Aalborg University</orgName>
								<orgName type="institution" key="instit8">Aalborg University</orgName>
								<orgName type="institution" key="instit9">Aalborg University</orgName>
								<orgName type="institution" key="instit10">Aalborg University</orgName>
								<orgName type="institution" key="instit11">Aalborg University</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Peter</forename><forename type="middle">G</forename><surname>Jensen</surname></persName>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">Department of Computer Science</orgName>
								<orgName type="department" key="dep2">Department of Computer Science</orgName>
								<orgName type="department" key="dep3">Department of Computer Science</orgName>
								<orgName type="department" key="dep4">Department of Computer Science</orgName>
								<orgName type="department" key="dep5">Department of Computer Science</orgName>
								<orgName type="department" key="dep6">Department of Computer Science</orgName>
								<orgName type="department" key="dep7">Department of Computer Science</orgName>
								<orgName type="department" key="dep8">Department of Computer Science</orgName>
								<orgName type="department" key="dep9">Department of Computer Science</orgName>
								<orgName type="department" key="dep10">Department of Computer Science</orgName>
								<orgName type="department" key="dep11">Faculty of Informatics Masaryk University</orgName>
								<orgName type="department" key="dep12">Department of Computer Science</orgName>
								<orgName type="institution" key="instit1">Aalborg University</orgName>
								<orgName type="institution" key="instit2">Aalborg University</orgName>
								<orgName type="institution" key="instit3">Aalborg University</orgName>
								<orgName type="institution" key="instit4">Aalborg University</orgName>
								<orgName type="institution" key="instit5">Aalborg University</orgName>
								<orgName type="institution" key="instit6">Aalborg University</orgName>
								<orgName type="institution" key="instit7">Aalborg University</orgName>
								<orgName type="institution" key="instit8">Aalborg University</orgName>
								<orgName type="institution" key="instit9">Aalborg University</orgName>
								<orgName type="institution" key="instit10">Aalborg University</orgName>
								<orgName type="institution" key="instit11">Aalborg University</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Tobias</forename><forename type="middle">S</forename><surname>Jepsen</surname></persName>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">Department of Computer Science</orgName>
								<orgName type="department" key="dep2">Department of Computer Science</orgName>
								<orgName type="department" key="dep3">Department of Computer Science</orgName>
								<orgName type="department" key="dep4">Department of Computer Science</orgName>
								<orgName type="department" key="dep5">Department of Computer Science</orgName>
								<orgName type="department" key="dep6">Department of Computer Science</orgName>
								<orgName type="department" key="dep7">Department of Computer Science</orgName>
								<orgName type="department" key="dep8">Department of Computer Science</orgName>
								<orgName type="department" key="dep9">Department of Computer Science</orgName>
								<orgName type="department" key="dep10">Department of Computer Science</orgName>
								<orgName type="department" key="dep11">Faculty of Informatics Masaryk University</orgName>
								<orgName type="department" key="dep12">Department of Computer Science</orgName>
								<orgName type="institution" key="instit1">Aalborg University</orgName>
								<orgName type="institution" key="instit2">Aalborg University</orgName>
								<orgName type="institution" key="instit3">Aalborg University</orgName>
								<orgName type="institution" key="instit4">Aalborg University</orgName>
								<orgName type="institution" key="instit5">Aalborg University</orgName>
								<orgName type="institution" key="instit6">Aalborg University</orgName>
								<orgName type="institution" key="instit7">Aalborg University</orgName>
								<orgName type="institution" key="instit8">Aalborg University</orgName>
								<orgName type="institution" key="instit9">Aalborg University</orgName>
								<orgName type="institution" key="instit10">Aalborg University</orgName>
								<orgName type="institution" key="instit11">Aalborg University</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Isabella</forename><surname>Kaufmann</surname></persName>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">Department of Computer Science</orgName>
								<orgName type="department" key="dep2">Department of Computer Science</orgName>
								<orgName type="department" key="dep3">Department of Computer Science</orgName>
								<orgName type="department" key="dep4">Department of Computer Science</orgName>
								<orgName type="department" key="dep5">Department of Computer Science</orgName>
								<orgName type="department" key="dep6">Department of Computer Science</orgName>
								<orgName type="department" key="dep7">Department of Computer Science</orgName>
								<orgName type="department" key="dep8">Department of Computer Science</orgName>
								<orgName type="department" key="dep9">Department of Computer Science</orgName>
								<orgName type="department" key="dep10">Department of Computer Science</orgName>
								<orgName type="department" key="dep11">Faculty of Informatics Masaryk University</orgName>
								<orgName type="department" key="dep12">Department of Computer Science</orgName>
								<orgName type="institution" key="instit1">Aalborg University</orgName>
								<orgName type="institution" key="instit2">Aalborg University</orgName>
								<orgName type="institution" key="instit3">Aalborg University</orgName>
								<orgName type="institution" key="instit4">Aalborg University</orgName>
								<orgName type="institution" key="instit5">Aalborg University</orgName>
								<orgName type="institution" key="instit6">Aalborg University</orgName>
								<orgName type="institution" key="instit7">Aalborg University</orgName>
								<orgName type="institution" key="instit8">Aalborg University</orgName>
								<orgName type="institution" key="instit9">Aalborg University</orgName>
								<orgName type="institution" key="instit10">Aalborg University</orgName>
								<orgName type="institution" key="instit11">Aalborg University</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Kim</forename><forename type="middle">G</forename><surname>Larsen</surname></persName>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">Department of Computer Science</orgName>
								<orgName type="department" key="dep2">Department of Computer Science</orgName>
								<orgName type="department" key="dep3">Department of Computer Science</orgName>
								<orgName type="department" key="dep4">Department of Computer Science</orgName>
								<orgName type="department" key="dep5">Department of Computer Science</orgName>
								<orgName type="department" key="dep6">Department of Computer Science</orgName>
								<orgName type="department" key="dep7">Department of Computer Science</orgName>
								<orgName type="department" key="dep8">Department of Computer Science</orgName>
								<orgName type="department" key="dep9">Department of Computer Science</orgName>
								<orgName type="department" key="dep10">Department of Computer Science</orgName>
								<orgName type="department" key="dep11">Faculty of Informatics Masaryk University</orgName>
								<orgName type="department" key="dep12">Department of Computer Science</orgName>
								<orgName type="institution" key="instit1">Aalborg University</orgName>
								<orgName type="institution" key="instit2">Aalborg University</orgName>
								<orgName type="institution" key="instit3">Aalborg University</orgName>
								<orgName type="institution" key="instit4">Aalborg University</orgName>
								<orgName type="institution" key="instit5">Aalborg University</orgName>
								<orgName type="institution" key="instit6">Aalborg University</orgName>
								<orgName type="institution" key="instit7">Aalborg University</orgName>
								<orgName type="institution" key="instit8">Aalborg University</orgName>
								<orgName type="institution" key="instit9">Aalborg University</orgName>
								<orgName type="institution" key="instit10">Aalborg University</orgName>
								<orgName type="institution" key="instit11">Aalborg University</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Søren</forename><forename type="middle">M</forename><surname>Nielsen</surname></persName>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">Department of Computer Science</orgName>
								<orgName type="department" key="dep2">Department of Computer Science</orgName>
								<orgName type="department" key="dep3">Department of Computer Science</orgName>
								<orgName type="department" key="dep4">Department of Computer Science</orgName>
								<orgName type="department" key="dep5">Department of Computer Science</orgName>
								<orgName type="department" key="dep6">Department of Computer Science</orgName>
								<orgName type="department" key="dep7">Department of Computer Science</orgName>
								<orgName type="department" key="dep8">Department of Computer Science</orgName>
								<orgName type="department" key="dep9">Department of Computer Science</orgName>
								<orgName type="department" key="dep10">Department of Computer Science</orgName>
								<orgName type="department" key="dep11">Faculty of Informatics Masaryk University</orgName>
								<orgName type="department" key="dep12">Department of Computer Science</orgName>
								<orgName type="institution" key="instit1">Aalborg University</orgName>
								<orgName type="institution" key="instit2">Aalborg University</orgName>
								<orgName type="institution" key="instit3">Aalborg University</orgName>
								<orgName type="institution" key="instit4">Aalborg University</orgName>
								<orgName type="institution" key="instit5">Aalborg University</orgName>
								<orgName type="institution" key="instit6">Aalborg University</orgName>
								<orgName type="institution" key="instit7">Aalborg University</orgName>
								<orgName type="institution" key="instit8">Aalborg University</orgName>
								<orgName type="institution" key="instit9">Aalborg University</orgName>
								<orgName type="institution" key="instit10">Aalborg University</orgName>
								<orgName type="institution" key="instit11">Aalborg University</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Mads</forename><forename type="middle">Chr</forename><surname>Olesen</surname></persName>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">Department of Computer Science</orgName>
								<orgName type="department" key="dep2">Department of Computer Science</orgName>
								<orgName type="department" key="dep3">Department of Computer Science</orgName>
								<orgName type="department" key="dep4">Department of Computer Science</orgName>
								<orgName type="department" key="dep5">Department of Computer Science</orgName>
								<orgName type="department" key="dep6">Department of Computer Science</orgName>
								<orgName type="department" key="dep7">Department of Computer Science</orgName>
								<orgName type="department" key="dep8">Department of Computer Science</orgName>
								<orgName type="department" key="dep9">Department of Computer Science</orgName>
								<orgName type="department" key="dep10">Department of Computer Science</orgName>
								<orgName type="department" key="dep11">Faculty of Informatics Masaryk University</orgName>
								<orgName type="department" key="dep12">Department of Computer Science</orgName>
								<orgName type="institution" key="instit1">Aalborg University</orgName>
								<orgName type="institution" key="instit2">Aalborg University</orgName>
								<orgName type="institution" key="instit3">Aalborg University</orgName>
								<orgName type="institution" key="instit4">Aalborg University</orgName>
								<orgName type="institution" key="instit5">Aalborg University</orgName>
								<orgName type="institution" key="instit6">Aalborg University</orgName>
								<orgName type="institution" key="instit7">Aalborg University</orgName>
								<orgName type="institution" key="instit8">Aalborg University</orgName>
								<orgName type="institution" key="instit9">Aalborg University</orgName>
								<orgName type="institution" key="instit10">Aalborg University</orgName>
								<orgName type="institution" key="instit11">Aalborg University</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Samuel</forename><surname>Pastva</surname></persName>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">Department of Computer Science</orgName>
								<orgName type="department" key="dep2">Department of Computer Science</orgName>
								<orgName type="department" key="dep3">Department of Computer Science</orgName>
								<orgName type="department" key="dep4">Department of Computer Science</orgName>
								<orgName type="department" key="dep5">Department of Computer Science</orgName>
								<orgName type="department" key="dep6">Department of Computer Science</orgName>
								<orgName type="department" key="dep7">Department of Computer Science</orgName>
								<orgName type="department" key="dep8">Department of Computer Science</orgName>
								<orgName type="department" key="dep9">Department of Computer Science</orgName>
								<orgName type="department" key="dep10">Department of Computer Science</orgName>
								<orgName type="department" key="dep11">Faculty of Informatics Masaryk University</orgName>
								<orgName type="department" key="dep12">Department of Computer Science</orgName>
								<orgName type="institution" key="instit1">Aalborg University</orgName>
								<orgName type="institution" key="instit2">Aalborg University</orgName>
								<orgName type="institution" key="instit3">Aalborg University</orgName>
								<orgName type="institution" key="instit4">Aalborg University</orgName>
								<orgName type="institution" key="instit5">Aalborg University</orgName>
								<orgName type="institution" key="instit6">Aalborg University</orgName>
								<orgName type="institution" key="instit7">Aalborg University</orgName>
								<orgName type="institution" key="instit8">Aalborg University</orgName>
								<orgName type="institution" key="instit9">Aalborg University</orgName>
								<orgName type="institution" key="instit10">Aalborg University</orgName>
								<orgName type="institution" key="instit11">Aalborg University</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Jiří</forename><surname>Srba</surname></persName>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">Department of Computer Science</orgName>
								<orgName type="department" key="dep2">Department of Computer Science</orgName>
								<orgName type="department" key="dep3">Department of Computer Science</orgName>
								<orgName type="department" key="dep4">Department of Computer Science</orgName>
								<orgName type="department" key="dep5">Department of Computer Science</orgName>
								<orgName type="department" key="dep6">Department of Computer Science</orgName>
								<orgName type="department" key="dep7">Department of Computer Science</orgName>
								<orgName type="department" key="dep8">Department of Computer Science</orgName>
								<orgName type="department" key="dep9">Department of Computer Science</orgName>
								<orgName type="department" key="dep10">Department of Computer Science</orgName>
								<orgName type="department" key="dep11">Faculty of Informatics Masaryk University</orgName>
								<orgName type="department" key="dep12">Department of Computer Science</orgName>
								<orgName type="institution" key="instit1">Aalborg University</orgName>
								<orgName type="institution" key="instit2">Aalborg University</orgName>
								<orgName type="institution" key="instit3">Aalborg University</orgName>
								<orgName type="institution" key="instit4">Aalborg University</orgName>
								<orgName type="institution" key="instit5">Aalborg University</orgName>
								<orgName type="institution" key="instit6">Aalborg University</orgName>
								<orgName type="institution" key="instit7">Aalborg University</orgName>
								<orgName type="institution" key="instit8">Aalborg University</orgName>
								<orgName type="institution" key="instit9">Aalborg University</orgName>
								<orgName type="institution" key="instit10">Aalborg University</orgName>
								<orgName type="institution" key="instit11">Aalborg University</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">A Distributed Fixed-Point Algorithm for Extended Dependency Graphs *</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="DOI">10.3233/FI-2016-0000</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.1" ident="GROBID" when="2025-10-14T18:30+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Equivalence and model checking problems can be encoded into computing fixed points on dependency graphs. Dependency graphs represent causal dependencies among the nodes of the graph by means of hyper-edges. We suggest to extend the model of dependency graphs with * An extended version of [1]. Dalsgaard et al. / Extended Dependency Graphs and Efficient Distributed Fixed-Point Computation</p><p>so-called negation edges in order to increase their applicability. The graphs (as well as the verification problems) suffer from the state space explosion problem. To combat this issue, we design an on-the-fly algorithm for efficiently computing fixed points on extended dependency graphs. Our algorithm supplements previous approaches with the possibility to back-propagate, in certain scenarios, the domain value 0, in addition to the standard back-propagation of the value 1. Finally, we design a distributed version of the algorithm, implement it in our open-source tool TAPAAL, and demonstrate the efficiency of our general approach on the benchmark of Petri net models and CTL queries from the annual Model Checking Contest.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Model checking <ref type="bibr" target="#b1">[2]</ref>, a widely used verification technique for exhaustive state space search, may be both time and memory consuming as a result of the state space explosion problem. As a consequence, interesting real-life models can often be too large to be verified. Numerous approaches have been proposed to address this problem, including symbolic model checking and various abstraction techniques <ref type="bibr" target="#b2">[3]</ref>. An alternative approach is to distribute the computation across multiple cores/machines, thus expanding the amount of available resources. Tools such as LTSmin <ref type="bibr" target="#b3">[4]</ref> and DIVINE <ref type="bibr" target="#b4">[5]</ref> have recently been exploring this possibility, without the need of being committed to a fixed model description language.</p><p>It has also been observed that model checking is closely related to the problem of evaluating fixed points <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b6">7,</ref><ref type="bibr" target="#b7">8,</ref><ref type="bibr" target="#b8">9]</ref>, as these are suitable for expressing system properties described in the logics like Computation Tree Logic (CTL) <ref type="bibr" target="#b9">[10]</ref> or the modal µ-calculus <ref type="bibr" target="#b10">[11]</ref>. This has been formally captured by the notion of dependency graphs of Liu and Smolka <ref type="bibr" target="#b5">[6]</ref>. A dependency graph, consisting of a finite set of nodes and hyper-edges with multiple target nodes, is an abstract framework for efficient minimum fixed-point computation over the node assignments that assign to each node the value 0 or 1. It has a variety of usages, including model checking <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b7">8,</ref><ref type="bibr" target="#b8">9]</ref> and equivalence checking <ref type="bibr" target="#b11">[12]</ref>. Apart from formal verification, dependency graphs are also used to solve games based e.g. on timed game automata <ref type="bibr" target="#b12">[13]</ref> or to encode Boolean equation systems <ref type="bibr" target="#b13">[14]</ref>.</p><p>Liu and Smolka proved in <ref type="bibr" target="#b5">[6]</ref> that dependency graphs can be used to compute fixed points of Boolean graphs and to solve the P-complete problem HORNSAT <ref type="bibr" target="#b14">[15]</ref> in linear time. They offered both a global and local algorithm for computing the minimum fixed-point value. The global algorithm computes the minimum fixed-point value for all nodes in the graph, though, we are often only interested in the values for some specific nodes. The advantage of the local algorithm is that it only needs to compute the values for a subset of the nodes in order to conclude about the assignment value for a given node of the graph. In practise, the local algorithm is superior to the global one <ref type="bibr" target="#b6">[7]</ref> and to further boost its performance, we recently suggested a distributed implementation of the local algorithm with preliminary experimental results <ref type="bibr" target="#b11">[12]</ref> conducted for weak bisimulation and simulation checking of CCS processes.</p><p>Our contributions. Neither the original paper by Liu and Smolka <ref type="bibr" target="#b5">[6]</ref> nor the recent distributed implementation <ref type="bibr" target="#b11">[12]</ref> handle the problem of negation in dependency graphs as this can break the monotonicity in the iterative evaluation of the fixed points. In our work, we extend dependency graphs with so-called negation edges, define a sufficient condition for the existence of unique fixed points and design an efficient algorithm for their computation, hence allowing us to encode richer properties rather than just plain equivalence checking or negation-free model checking. As we aim for a competitive implementation and applicability in various verification tools, it is necessary to offer the user not only the binary answer (whether a property holds or not or whether two systems are equivalent or not) but also the evidence for why this is the case. This can be conveniently done by the use of two-player games between Attacker and Defender. In our approach, it is possible for the user to play the role of Defender while the Attacker (played by the tool) can convince the user why a property does not hold. We formally define games played on the extended dependency graphs and prove a correspondence between the winner of the game and the fixed-point value of a node in a dependency graph.</p><p>In order to maximize the computation performance, we introduce a novel concept of certain zero value that can be back-propagated along hyper-edges and negation edges in order to ensure early termination of the fixed-point algorithm. This technique can often result in considerable improvements in the verification time and has not been, to the best of our knowledge, exploited in earlier work. To further enhance the performance, we present a distributed algorithm for a fixed-point computation and prove its correctness. Last but not least, we implement the distributed algorithm in an extensible open source framework and we demonstrate the applicability of the framework on CTL model checking of Petri nets. In order to do so, we integrate the framework into the tool TAPAAL <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b16">17]</ref> and run a series of experiments on the Petri net models and queries from the Model Checking Contest (MCC) 2016 <ref type="bibr" target="#b17">[18]</ref>. A single-core prototype of the tool implementing the negation edges and certain zero backpropagation also participated in the 2017 competition and was awarded a silver medal in the category of CTL verification with 23940 points for CTL cardinality queries, while the tool LoLA <ref type="bibr" target="#b18">[19]</ref> took the gold medal with 28652 points in this subcategory (which includes colored net models that our tool does not support yet). As documented by the experiments in this paper, our 4-core distributed algorithm outperforms the optimized sequential algorithm and hence it will challenge LoLA's first place in the next year competition (also given that LoLA employs stubborn set reduction technique that is not yet supported by our current implementation).</p><p>Related Work. Related algorithms for explicit distributed CTL model checking include the assumption based method <ref type="bibr" target="#b19">[20]</ref> and a map-reduce based method <ref type="bibr" target="#b20">[21]</ref>. Opposed to our algorithm, which computes a local result, these algorithms often focus on computing the global result. The local and global algorithms by Liu and Smolka <ref type="bibr" target="#b5">[6]</ref> were also extended to weighted Kripke structures for weighted CTL model checking via symbolic dependency graphs <ref type="bibr" target="#b6">[7]</ref>, however, without any parallel or distributed implementation.</p><p>LTSmin <ref type="bibr" target="#b3">[4]</ref> is a language independent model checker which provides a large amount of parallel and symbolic algorithms. To the best of our knowledge, LTSmin uses a symbolic algorithm based on binary decision diagrams for CTL model checking and even our sequential algorithm outperformed LTSmin at MCC'16 <ref type="bibr" target="#b17">[18]</ref> and MCC'17 <ref type="bibr" target="#b21">[22]</ref> (in e.g. 2017 CTL cardinality category LTSmin scored 8389 points compared to 23940 points achieved by our tool). Marcie <ref type="bibr" target="#b22">[23]</ref> is another Petri net model checking tool that performs symbolic analysis using interval decision diagrams whereas our approach is based on explicit analysis using extended dependency graphs. Marcie was a previous winner of the CTL category at MCC'15 <ref type="bibr" target="#b23">[24]</ref>, however, in 2016 it finished on a third place and in 2017 on the fourth place with almost the same number of points as ITS-tools <ref type="bibr" target="#b24">[25]</ref> that were third in 2017.</p><p>Other related work includes <ref type="bibr" target="#b25">[26,</ref><ref type="bibr" target="#b26">27,</ref><ref type="bibr" target="#b27">28]</ref> designing parallel and/or distributed algorithms for modelchecking of the alternation-free modal µ-calculus. As in our approach, they often employ the on-thefly technique but our framework is more general as it relies on dependency graphs to which the various verification problems can be reduced. The notion of support sets as an evidence for the validity of CTL formulae has been introduced in <ref type="bibr" target="#b28">[29]</ref> and it is close to a (relevant part of) assignment on a dependency graph, however, the game characterization of support sets was not further developed, as stated in <ref type="bibr" target="#b28">[29]</ref>. In our work, we provide a natural game-theoretic characterization of an assignment on general dependency graphs and such a characterization can be used to provide an evidence about the fixed-point value of a node in a dependency graph.</p><p>Finally, there are several mature tools like FDR3 <ref type="bibr" target="#b29">[30]</ref>, CADP <ref type="bibr" target="#b30">[31]</ref>, SPIN <ref type="bibr" target="#b31">[32]</ref> and mCRL2 <ref type="bibr" target="#b32">[33]</ref>, some of them implementing distributed and on-the-fly algorithms. The specification language of these is however often fixed and extensions of such a language requires nontrivial implementation effort. Our approach relies on reducing a variety of verification problems into extended dependency graphs and then on employing our optimized and efficient distributed implementation, as e.g. demonstrated on CTL model checking of Petri nets presented in this paper or on bisimulation checking of CCS processes <ref type="bibr" target="#b11">[12]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Extended Dependency Graphs and Games</head><p>We shall now define the notion of extended dependency graphs, adding a new feature of negation edges to the original definition by Liu and Smolka <ref type="bibr" target="#b5">[6]</ref>.</p><formula xml:id="formula_0">Definition 2.1. An Extended Dependency Graph (EDG) is a tuple G = (V, E, N ) where V is a finite set of configurations, E ⊆ V × P(V ) is a finite set of hyper-edges, and N ⊆ V × V is a finite set of negation edges.</formula><p>For a hyper-edge e = (v, T ) ∈ E we call v the source configuration and T ⊆ V is the set of target configurations. We write</p><formula xml:id="formula_1">v → u if there is a (v, T ) ∈ E such that u ∈ T and v u if (v, u) ∈ N . Furthermore, we write v u if v → u or v u. The successor function succ : V → (E ∪ N ) returns the set of outgoing edges from v, i.e. succ(v) = {(v, T ) ∈ E} ∪ {(v, u) ∈ N }.</formula><p>An example of an EDG is given in Figure <ref type="figure" target="#fig_3">1</ref>(a) with the configurations named a to f , hyper-edges denoted by solid arrows with multiple targets, and dashed negation edges. Note that the configuration f in the example has one hyper-edge with the empty set of target configurations, denoted by ∅.</p><p>In what follows, we consider only EDGs without cycles containing negation edges.</p><formula xml:id="formula_2">Definition 2.2. An EDG G = (V, E, N ) is negation safe if there are no v, v ∈ V s.t. v v and v * v.</formula><p>After the restriction to negation safe EDG, we can now define the negation distance function dist : V → N 0 that returns the maximum number of negation edges throughout all paths starting in a configuration v and is inductively defined as</p><formula xml:id="formula_3">dist(v) = max({dist(v ) + 1 | v , v ∈ V and v → * v v }) where by convention max(∅) = 0. Note that dist(v) is always finite because every a b d c e f ∅ (a) An EDG with dist(G) = 2 and V0 = {b, c, f }, V1 = {d, e} ∪ V0, V2 = {a} ∪ V1 b c f A 0 0 0 0 F 0 (A 0 ) 0 0 1 F 0 (F 0 (A 0 )) 0 0 1 (b) A C 0 min Computation b c d e f A 0 0 0 0 0 0 F 1 (A 0 ) 0 0 1 0 1 F 1 (F 1 (A 0 )) 0 0 1 1 1 F 1 (F 1 (F 1 (A 0 ))) 0 0 1 1 1 (c) A C 1 min Computation a b c d e f A 0 0 0 0 0 0 0 F 2 (A 0 ) 0 0 0 1 1 1 F 2 (F 2 (A 0 )) 0 0 0 1 1 1 (d) A C 2 min Computation</formula><p>Figure <ref type="figure" target="#fig_3">1</ref>: An EDG and iterative calculation of its minimum fixed-point assignment path can visit each negation edge at most once. We then define dist(G) of an EDG G as dist(G) = max v∈V (dist(v)) and for an edge e ∈ E ∪ N where v is its source configuration, we write dist(e</p><formula xml:id="formula_4">) = dist(v). A component C i of G, where i ∈ N 0 , is a subgraph induced on G by the set of configurations V i = {v ∈ V | dist(v) ≤ i}.</formula><p>We write V i , E i and N i to denote the set of configurations, hyperedges and negation edges of each respective component. Note that by definition, C 0 does not contain any negation edges. Also observe that G = C dist(G) and that for all k, ∈ N 0 , if k &lt; then C k is a subgraph of C . The EDG G in our example from Figure <ref type="figure" target="#fig_3">1</ref>(a) contains three nonempty components and has dist(G) = 2.</p><p>An assignment A of an EDG G = (V, E, N ) is a function A : V → {0, 1} that assigns the value 0 (interpreted as false) or the value 1 (interpreted as true) to each configuration of G. A zero assignment A 0 is such that A 0 (v) = 0 for all v ∈ V . We also assume a component wise ordering of assignments such that A 1 A 2 whenever A 1 (v) ≤ A 2 (v) for all v ∈ V . The set of all assignments of G is denoted by A G and clearly (A G , ) is a complete lattice.</p><p>We are now ready to define the minimum fixed-points assignment of an EDG G (assuming that a conjunction over the empty set is true, while a disjunction over the empty set is false).</p><p>Definition 2.3. The minimum fixed-point assignment of an EDG G, denoted by</p><formula xml:id="formula_5">A G min = A C dist(G) min is defined inductively on the components C 0 , C 1 , . . . , C dist(G) of G. For all i, s.t. 0 ≤ i ≤ dist(G), we define A C i</formula><p>min to be the minimum fixed-point assignment of the function F i :</p><formula xml:id="formula_6">A C i → A C i where F i (A)(v) = A(v) ∨ (v,T )∈E i u∈T A(u) ∨ (v,u)∈N i ¬A C i-1 min (u) .<label>(1)</label></formula><p>Note that when computing the minimum fixed-point assignment A C 0 min for the base component C 0 , we know that N 0 = ∅ and hence the third disjunct in the function F 0 always evaluates to false. In the inductive steps, the assignment</p><formula xml:id="formula_7">A C i-1</formula><p>min is then well defined for the use in the function F i . It is also easy to observe that each function F i is monotonic (by a simple induction on i) and hence by Knaster-Tarski, the unique minimum fixed-point always exists for each i.</p><p>In Figure <ref type="figure" target="#fig_3">1</ref> we show the iterative computation of A C 0 min , A C 1 min and A C 2 min , starting from the zero assignment A 0 . We iteratively upgrade the assignment of a configuration v from the value 0 to 1 whenever there is a hyper-edge (v, T ) such that all target configurations u ∈ T already have the value 1 or whenever there is a negation edge v u such that the minimum fixed-point assignment of u (computed earlier) is 0. Once the application of the function F i stabilizes, we have reached the minimum fixed-point assignment for the component C i .</p><p>Remark 2.4. The algorithm for computing A C i min described above, also called the global algorithm, relies on the fact that the complete minimum fixed-point assignment of smaller components C j where j &lt; i must be available before we can proceed with the computation on the component C i . As we show later on, it is not always necessary to know the whole</p><formula xml:id="formula_8">A C i-1</formula><p>min in order to compute A C i min (v) for a specific configuration v and such a computation can be done in an on-the-fly manner, using the so-called local algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.">Game Characterization</head><p>In order to offer a more intuitive understanding of the minimum fixed-point computation on an extended dependency graph G, and to provide a convincing argumentation why the minimum fixed-point value in a given configuration v is 0 or 1 (for the use in our tool), we define a two player game between the players Defender and Attacker. The positions of the game are of the form (v, r) where v ∈ V is a configuration and r ∈ {0, 1} is a claim about the minimum fixed-point value in v, postulating that A G min (v) = r. The game is played in rounds and Defender defends the current claim while Attacker does the opposite.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Rules of the Game:</head><p>In each round starting from the current position (v, r), the players determine the new position for the next round as follows:</p><p>• If r = 1 then Defender chooses an edge e ∈ succ(v). If no such edge exists then Defender loses, otherwise</p><p>if e = (v, u) ∈ N then (u, 0) becomes the new current position, and if e = (v, T ) ∈ E then Attacker chooses the next position (u, 1) where u ∈ T , unless T = ∅ which means that Attacker loses. • If r = 0 then Attacker chooses an edge e ∈ succ(v). If no such edge exists then Attacker loses, otherwise if e = (v, u) ∈ N then (u, 1) becomes the new current position, and if e = (v, T ) ∈ E then Defender chooses the next position (u, 0) where u ∈ T , unless T = ∅ which means that Defender loses. A play is a sequence of positions formed according the rules of the game. Any finite play is lost either by Defender or Attacker as defined above. If a play is infinite, we observe that the claim r can be switched only finitely many times (since the graph is negation safe). Therefore there is only one claim r that is repeated infinitely often in such a play. If r = 1 is the infinitely repeated claim then Defender loses, otherwise (r = 0) Attacker loses.</p><p>The game starting from the position (v, r) is winning for Defender if she has a universal winning strategy from (v, r). Similarly, the position is winning for Attacker if he has a universal winning strategy from (v, r). Clearly, the game is determined such that only one of the players has a universal winning strategy and from the symmetry of the game rules, we can also notice that Defender is the winner from (v, r) if and only if Attacker is the winner from (v, 1r).</p><p>Theorem 2.5. Let G be a negation safe EDG, v ∈ V be a configuration and r ∈ {0, 1} be a claim. Then A G min (v) = r if and only if Defender is the winner of the game starting from the position (v, r).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof:</head><p>(⇒) Let us first define that a configuration v is of level i if v belongs to the component C i but not to any component C j where 0 ≤ j &lt; i. By induction on the level of a configuration v, we show that (i) if A G min (v) = 0 then Defender has a winning strategy from (v, 0), and (ii) if A G min (v) = 1 then Defender has a winning strategy from (v, 1).</p><p>Let us consider the base case where v is of level 0.</p><p>• For the case (i), let us assume that A G min (v) = 0 and consider any play starting from (v, 0). Either Attacker has no outgoing edge v and Defender wins, or for every outgoing hyper-edge (v, T ) (notice that there are no negation edges for configurations at level 0) there must be at least one u ∈ T such that A G min (u) = 0, otherwise A G min would not be a fixed-point assignment. Defender will choose such u and the play continues from (u, 0). Eventually, either a loop is formed, and the infinite game is winning for Defender as the claim 0 appears infinitely often, or there is no outgoing edge for the attacker to choose, in which case Defender also wins.</p><p>• For the case (ii), let us assume that A G min (v) = 1. There must have been a reason why the value of v has been raised from 0 to 1 and the reason is that either v has an outgoing hyper-edge with the empty target set, or there is an outgoing hyper-edge from v such that every node from the target set has the value 1 in the minimum fixed-point assignment. As before, no negation edges can be reached from the component C 0 . This means that for the distance function d inductively defined as</p><formula xml:id="formula_9">-d(v) = 0 if there is a hyper-edge (v, ∅) ∈ E, otherwise -d(v) = 1 + min (v,T )∈E max u∈T d(u),</formula><p>we have that d(v) is finite for every v where A G min (v) = 1. Defender's strategy from the position (v, 1) is then to pick from the outgoing hyper-edges (at least one must exist) one that reduces the distance. The distance to the configuration that has a hyper-edge with the empty target set then decreases by at least one (irrelevant of Attacker's choice) and eventually Defender picks such a hyper-edge and Attacker loses the play. Hence Defender has a winning strategy in this case as well.</p><p>Let us now consider the inductive case where we have a configuration v of level i &gt; 0. Both in the case (i) and (ii) we can now also encounter negation edges.</p><p>• For the case (i), Defender still selects configurations from the target set that have the minimum fixed-point value 0, identically with the base case. The only change can be that Attacker can from a configuration v such that A min (v) = 0 select also a negation edge (v, u) ∈ N where A min (u) = 1. As the level of u is lower than the level of v, we can use the induction hypothesis to conclude that Defender has a winning strategy from (u, 1). • For the case (ii), we change the definition of the distance function d such that in the base case</p><formula xml:id="formula_10">d(v) is zero also if there is a negation-edge (v, u) ∈ N such that A min (u) = 0.</formula><p>If the game position becomes such a configuration v, with a negation edge (v, u), then Defender will select that edge and the play continues from (u, 0) that is by induction hypothesis winning for Defender.</p><p>Hence the direction from left to right is established.</p><p>(⇐) We prove the other direction by contraposition. Assume that A G min (v) = r and we want to argue that Defender does not have a universal winning strategy from (v, r) (which by determinacy of the game means that Attacker has a universal winning strategy from (v, r)). However, the fact that A G min (v) = r implies that A G min (v) = 1r and Defender has a winning strategy from (v, 1r) as proved above. By the symmetry of the game, this means that Attacker has a winning strategy from (v, r).</p><p>Let us now argue that Defender wins from the position (a, 0) in the EDG G from Figure <ref type="figure" target="#fig_3">1(a)</ref>. First, Attacker picks either (i) the hyper-edge (a, {b, d}) or (ii) the negation edge (a, e). In case (i), Defender answers by selecting the configuration b and the game continues from (b, 0). Now Attacker can only pick the hyper-edge (b, {c}) and Defender is forced to select the configuration c, ending in the position (c, 0) and from here the only continuation of the game brings us again to the position (b, 0). As the play now repeats forever with the claim 0 appearing infinitely often, Defender wins this play. In case (ii) where Attacker selects the negation edge, we continue from the position (e, 1). Defender is forced to select the only available hyper-edge (e, {d, f }), on which Attacker can answer by selecting the new position (d, 1) or (f, 1). The first choice is not good for Attacker, as Defender will answer by taking the negation edge (d, c) and ending in the position (c, 0) from which we already know that Defender wins. The position (f, 1) is not good for Attacker either as Defender can now select the hyper-edge (f, ∅) and Attacker loses as he gets stuck. Hence Defender has a universal winning strategy from (a, 0) and by Theorem 2.5 we get that A G min (a) = 0. </p><formula xml:id="formula_11">p 0 p 1 t 0 t 1</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.">Encoding of CTL Model Checking of Petri Nets into EDG</head><p>We shall now give an example of how CTL model checking of Petri nets can be encoded into computing fixed-points on EDGs. Let us first recall the Petri net model. Let N 0 denote the set of natural numbers including zero and N ∞ the set of natural numbers including infinity.</p><p>A Petri net is a 4-tuple N = (P, T, F, I) where P is a finite set of places, T is a finite set of transitions such that P ∩ T = ∅ and P ∪ T = ∅, F : (P × T ∪ T × P ) → N 0 is the flow function and I : P × T → N ∞ is the inhibitor function. A marking on N is a function M : P → N 0 assigning a number of tokens to each place. The set of all markings on N is denoted M (N ). A transition t is enabled in a marking M if M (p) ≥ F ((p, t)) and M (p) &lt; I(p, t) for all p ∈ P . If t is enabled in M , it can fire and produce a marking M , written</p><formula xml:id="formula_12">M t - → M , such that M (p) = M (p)-F ((p, t))+F ((t, p))</formula><p>for all p ∈ P . We write M → M if there is t ∈ T such that M t -→ M . A path in N , starting in a marking M , is a finite or infinite sequence of markings and transition firings, written as</p><formula xml:id="formula_13">M ≡ M 0 → M 1 → M 2 → . . .</formula><p>A path is maximal if it is either infinite or ends in a marking M i such that M i →; also called a deadlock. The set of all maximal paths for a Petri net N from the marking M is denoted by Π max (M ).</p><p>An example of a Petri net is illustrated in Figure <ref type="figure" target="#fig_0">2</ref>. The circles represent places, the rectangles are transitions and arcs that have weight at least one are represented by arrows (in our example, all arcs have weight one, so we omit this annotation on the arrows). A marking can then be represented as a vector (n 0 , n 1 ) where n 0 denotes the number of tokens in p 0 and n 1 the number of tokens in p 1 , respectively. A possible path from the initial marking is (1, 0) is e.g. (1, 0) → (1, 0) → (1, 0) → . . . . This repeated sequence of markings and firings of the transition t 0 forms an infinite maximal path. Another (finite) maximal path is e.g. (1, 0) → (1, 0) → (1, 0) → (0, 1).</p><p>In CTL, properties are expressed using a combination of logical and temporal operators over a set of basic propositions. In our case the propositions express properties of a concrete marking M and include the proposition is_fireable(Y ) for a set of transitions Y that is true iff at least one of the transitions from Y is enabled in the marking M , and arithmetical expressions and predicates over the basic construct token_count(X) where X is a subset of places such that token_count(X) returns the total number of tokens in the places from the set X in the marking M . The CTL logic is motivated by the requirements of the MCC'16 and MCC'17 competition <ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b21">22]</ref> and the syntax of CTL formula ϕ is</p><formula xml:id="formula_14">ϕ ::= true | false | is_fireable(Y ) | ψ 1 ψ 2 | ¬ϕ | ϕ 1 ∧ ϕ 2 | ϕ 1 ∨ ϕ 2 | EG ϕ | AG ϕ | EF ϕ | AF ϕ | EX ϕ | AX ϕ | Eϕ 1 U ϕ 2 | Aϕ 1 U ϕ 2 ψ ::= ψ 1 ⊕ ψ 2 | c | token_count(X)</formula><p>where ∈ {&lt;, ≤, =, ≥, &gt;}, X ⊆ P , Y ⊆ T , c ∈ N 0 and ⊕ ∈ {+, -, •}. The semantics of a CTL formula ϕ over a given marking M of the Petri net N is defined in Table <ref type="table">1</ref>, using the function eval M that is given in Table <ref type="table">2</ref>. The remaining operators are defined as abbreviations in Table <ref type="table">3</ref>.</p><formula xml:id="formula_15">M |= true M |= ¬ϕ iff M |= ϕ M |= ϕ 1 ∧ ϕ 2 iff M |= ϕ 1 and M |= ϕ 2 M |= EX ϕ iff there exists M ∈ M (N ) where M → M and M |= ϕ M |= Eϕ 1 U ϕ 2 iff there exists (M ≡ M 0 → M 1 → M 2 → . . .) ∈ Π max (M ) s.t.</formula><p>there is i ∈ N 0 where M i |= ϕ 2 and for all j ∈ N 0 s.t. 0 ≤ j &lt; i holds</p><formula xml:id="formula_16">M j |= ϕ 1 M |= Aϕ 1 U ϕ 2 iff for all (M ≡ M 0 → M 1 → M 2 → . . .) ∈ Π max (M ) there is i ∈ N 0 where M i |= ϕ 2 and for all j ∈ N 0 s.t. 0 ≤ j &lt; i holds M j |= ϕ 1 M |= is_fireable(Y ) iff there exists t ∈ Y and M s.t. M t - → M M |= ψ 1 ψ 2 iff eval M (ψ 1 ) eval M (ψ 2 ) Table 1: CTL Semantics eval M (c) = c eval M (token_count(X)) = p∈X M (p) eval M (e 1 ⊕ e 2 ) = eval M (e 1 ) ⊕ eval M (e 2 )</formula><p>Table <ref type="table">2</ref>: The semantics of eval M</p><p>We now reduce the problem of CTL model checking over Petri nets to calculating the minimum fixed-point assignment of an EDG. We construct an EDG with the configurations of the form M, ϕ where M is a marking and ϕ a CTL formula. If ϕ is an atomic proposition then there is a hyper-edge from M, ϕ with the empty target set iff M |= ϕ, otherwise there is no hyper-edge connected to</p><formula xml:id="formula_17">ϕ 1 ∨ ϕ 2 ≡ ¬(¬ϕ 1 ∧ ¬ϕ 2 ) AX ϕ ≡ ¬EX ¬ϕ EF ϕ ≡ E true U ϕ AF ϕ ≡ A true U ϕ EG ϕ ≡ ¬AF ¬ϕ AG ϕ ≡ ¬EF ¬ϕ false ≡ ¬true Table 3: Standard abbreviations M, true ∅ (a) True iff eval M (ψ 1 ) eval M (ψ 2 ) M, ψ 1 ψ 2 ∅ (b) Token count iff M t - → M for some M and some t ∈ Y M, is_fireable(Y) ∅ (c) Is fireable</formula><p>Figure <ref type="figure">3</ref>: Atomic rules the configuration. This construction is shown in Figure <ref type="figure">3</ref>. In Figure <ref type="figure" target="#fig_2">4</ref> we present the rules for the minimal set of operators from Table <ref type="table">1</ref>. Finally in Figure <ref type="figure" target="#fig_5">5</ref> we also show a direct encoding for some of the derived CTL operators. These are included in order to limit the amount of configurations required to calculate the minimum fixed-point assignment of the extended dependency graph and hence to improve the efficiency of the algorithm. Observe that the reduction produces a negation safe EDG. An example of such a reduction is shown in Figure <ref type="figure">6</ref>.</p><p>We can now state the correctness result for the reduction. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof:</head><p>The proof is by a mathematical induction on the level of a configuration M, ϕ in the extended dependency graph (recall that a configuration is of level i if it belongs to the component C i of the graph but not to any component C j where j &lt; i). After this induction, we employ a nested structural induction on the formula ϕ.</p><formula xml:id="formula_18">M, ϕ 1 ∧ ϕ 2 M, ϕ 1 M, ϕ 2 (a) Conjunction M, ¬ϕ M, ϕ (b) Negation M, EXϕ M 1 , ϕ M n , ϕ . . . (c) Existential next M, Eϕ 1 U ϕ 2 M 1 , Eϕ 1 U ϕ 2 M, ϕ 1 M, ϕ 2 M n , Eϕ 1 U ϕ 2 . . . (d) Existential until M, Aϕ 1 U ϕ 2 M 1 , Aϕ 1 U ϕ 2 M, ϕ 1 M, ϕ 2 M n , Aϕ 1 U ϕ 2 . . . (e) Universal until</formula><p>• Let ϕ = true, ϕ = ψ 1 ψ 2 or ϕ = is_fireable(Y). Then it is straightforward to see that A min ( M, ϕ ) = 1 if and only if there is a hyper-edge with the empty target set, which is the case (according to the rules in Figure <ref type="figure">3</ref>) if and only if M |= ϕ. </p><formula xml:id="formula_19">• Let ϕ = ϕ 1 ∧ ϕ 2 . Then M |= ϕ 1 ∧ ϕ 2 if</formula><formula xml:id="formula_20">( M, ϕ 1 ) = A min ( M, ϕ 2 ) = 1.</formula><p>By Figure <ref type="figure" target="#fig_2">4</ref>(a) there is an edge</p><formula xml:id="formula_21">( M, ϕ 1 ∧ ϕ 2 , { M, ϕ 1 , M, ϕ 2 }</formula><p>) and this is the only hyperedge connected to the configuration M, ϕ 1 ∧ ϕ 2 . This implies that</p><formula xml:id="formula_22">A min ( M, ϕ 1 ∧ ϕ 2 ) = 1 if and only if M |= ϕ 1 ∧ ϕ 2 .</formula><p>• Let ϕ = ϕ 1 ∨ ϕ 2 . This case is analogous to the case of conjunction.</p><p>• Let ϕ = EXϕ   Then by the mathematical induction hypothesis, we have that A min ( M 1 , EF ϕ 1 ) = 1 and due to the corresponding hyper-edge in Figure <ref type="figure" target="#fig_5">5</ref>(c) the value 1 propagates also to M, EF ϕ 1 ). Next we argue for the direction from right to left. Let us assume that A min ( M, EF ϕ 1 ) = 1. Then at least one of the children of M, EF ϕ 1 in Figure <ref type="figure" target="#fig_5">5</ref>(c) must have the value 1, otherwise A min is not the minimum fixed-point assignment. If A min ( M, ϕ 1 ) = 1 then by the structural induction hypothesis M |= ϕ 1 and hence also M |= EF ϕ 1 . If this is not the case then there is a marking M such that M → M and A min ( M , EF ϕ 1 ) = 1. We select such a marking M that minimizes the number of steps needed to reach a configuration of the form M , ϕ 1 such that A min ( M , ϕ 1 ) = 1. This configuration must exist due to the assumption that A min ( M, EF ϕ 1 ) = 1. The argument then follows by the mathematical induction on the number of steps needed to reach such a configuration.</p><formula xml:id="formula_23">M = M 0 → M 1 → M 2 → ...M j such that M j |= ϕ 1 . By M, ϕ 1 ∨ ϕ 2 M, ϕ 1 M, ϕ 2 (a) Disjunction M, AXϕ M 1 , ϕ M n , ϕ . . . (b) Universal next M, EF ϕ M 1 , EF ϕ M, ϕ M n , EF ϕ . . . (c) Existential finally M, AF ϕ M 1 , AF ϕ M, ϕ M n , AF ϕ . . .</formula><formula xml:id="formula_24">• Let ϕ = AF ϕ 1 , ϕ = Eϕ 1 U ϕ 2 , or ϕ = Aϕ 1 U ϕ 2 .</formula><p>These cases are analogous to the EF case by following the same proof strategies. • Let ϕ = ¬ϕ 1 . In the construction of the dependency graph, the only outgoing edge from M, ¬ϕ 1 is the negation edge to the configuration M, ϕ 1 where we by the mathematical induction hypothesis on the level of the configuration M, ϕ 1 know that A min ( M, ϕ 1 ) = 1 if and only if M |= ϕ 1 . By the definition of A min this implies that A min ( M, ¬ϕ 1 ) = 1 if and only if M |= ¬ϕ 1 as required.</p><p>Remark 2.7. The reader probably noticed that if the Petri net is unbounded (has infinitely many reachable markings), we are actually producing an infinite EDG. Indeed, CTL model checking for unbounded Petri nets is undecidable <ref type="bibr" target="#b33">[34]</ref>, so we cannot hope for a general algorithmic solution. However,</p><formula xml:id="formula_25">p p 3 p 1 p 2 (a) Petri net ϕ = E(¬AF ¬(p 1 ≤ 2)) U (p 2 = 2) (b) CTL query M, ϕ 1 c 0 (1, 0, 0, 2), p 2 = 2 0 c 1 (1, 0, 0, 2), ¬AF ¬(p 1 ≤ 2) 1 c 2<label>(1, 1, 1, 1), ϕ 1 c 3</label></formula><p>(1, 0, 0, 2), AF ¬(p 1 ≤ 2) 0 </p><formula xml:id="formula_26">c 4 (1, 1, 1, 1), p 2 = 2 0 c 5 (1, 1, 1, 1), ¬AF ¬(p 1 ≤ 2) 1 c 6 (1, 2, 2, 0), ϕ 1 c 7 (1, 0, 0, 2), ¬(p 1 ≤ 2) 0 c 8 (1, 1, 1, 1), AF ¬(p 1 ≤ 2) 0 c 9 (1, 2, 2, 0), p 2 = 2 1 c 10 (1, 0, 0, 2), p 1 ≤ 2 1 c 11 (1, 1, 1, 1), ¬(p 1 ≤ 2) 0 c 12 (1, 2, 2, 0), AF ¬(p 1 ≤ 2) 0 c 13 (1, 1, 1, 1), p 1 ≤ 2 1 c 14 (1, 2, 2, 0), ¬(p 1 ≤ 2) 0 c 15 (1, 2, 2, 0), p 1 ≤ 2 1 c 16 ∅ ∅ ∅ ∅<label>(</label></formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Algorithms for Fixed-Point Computation on EDG</head><p>We shall now discuss the differences of our new distributed algorithm for fixed-point computation of EDG compared to the previous approaches, followed by the description of our algorithm.</p><p>Figure <ref type="figure">7</ref> shows the partial ordering of the assignment values used by the algorithms. The orderings in the figure show how the configuration values are upgraded during the execution of the algorithms. The global algorithm, described in Section 2, only uses the assignment values 0 and 1 as shown in Figure <ref type="figure">7</ref>(a). Initially, the whole graph is constructed and all configurations are assigned the value 0. Then it iterates, starting from the component C 0 , over all hyper-edges and upgrades the source configuration values to 1 whenever all target configurations are already assigned the value 1. This repeats until no further upgrades are possible and then it uses the negation edges to propagate the values to the higher components until the minimum fixed-point assignment of a given configuration is set to 1 (in which case an early termination is possible) or until the whole process terminates and we can claim that the minimum fixed-point assignment of the given configuration is 0.</p><p>The key insight for the local algorithm, as suggested by Liu and Smolka <ref type="bibr" target="#b5">[6]</ref> for dependency graphs without negation edges, is that if we are only interested in A G min (v) for a given configuration v, we do not have to necessarily enumerate the whole graph and compute the value for all configurations in G in order to establish that A G min (v) = 1. The local algorithm introduces the value ⊥ for not yet explored configurations as shown in Figure <ref type="figure">7</ref>(b) and performs a forward search in the dependency graph with backward propagation of the value 1. This significantly improves the performance of the global algorithm in case the configuration v gets the value 1. In the case where A G min (v) = 0, the local algorithm must search the whole graph before terminating and announcing the final answer.</p><p>Our improvement to the local algorithm is twofold: the handling of negation edges in an on-thefly manner and the introduction of a new value ?, taking over the previous role of 0, as shown in Figure <ref type="figure">7(c</ref>). Here ⊥ means that a configuration has not been discovered yet, ? that the final minimum fixed-point assignment has not been determined yet, and 0 and 1 mean the final values in the minimum fixed-point assignment. Hence as soon as the given configuration gets the value 0 or 1, we can early terminate and announce the answer. The previous approaches did not allow early termination for the value 0, but as Figure <ref type="figure">7</ref>(d) shows, it can save lots of work. Since d has no outgoing hyper-edges, it can get assigned the value 0 (called certain zero) and because the single target configuration of the hyper-edge (b, {d}) is 0, the value 0 can back-propagate to b (we do this by removing hyper-edges that contain at least one target configuration with the value 0 and once a configuration has no outgoing hyper-edges, it will get assigned the certain zero value 0). Now the hyper-edge (a, {b, c}) can also be removed and as a no longer has any hyper-edges, we can conclude that A G min (a) = 0 without having to explore the potentially large subgraph rooted at c as it would be necessary in the previous algorithms. We moreover have to deal with negation edges where we allow early back-propagation of the certain 0 and certain 1 values, essentially performing an on-the-fly search for the existence of Defender's winning strategy. In what follows, we shall present the formal details of our algorithm, including its distributed implementation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.">Distributed Algorithm for Minimum Fixed-Point Computation</head><p>We assume n workers running Algorithm 1 in parallel. Each worker has a unique identifier i ∈ {1, ..., n} and can communicate with any other worker using reliable channels. If not stated otherwise, i refers to the identifier of the local worker and j refers to an identifier of some remote worker.</p><p>Global Data Structures. Initially, each worker has access to the means of generating a given EDG G = (V, E, N ) via the function succ, an initial configuration v 0 ∈ V , and a partition function δ : V → {1, . . . , n} that splits the configurations among the workers. We say that worker i owns a configuration v if δ(v) = i.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Local Data Structures. Each worker has the following local data structures:</head><p>• W i E ⊆ E is the waiting list of hyper-edges,</p><formula xml:id="formula_27">• W i N ⊆ N is the waiting list of negation edges, • D i : V → P(E ∪ N ) is the dependency set for each configuration, • succ i : V → P(E ∪ N ) is the local successor relation such that initially succ i (v) = succ(v) if δ(v) = i and otherwise succ i (v) = ∅, • A i : V → {⊥, ?</formula><p>, 0, 1} is the assignment function (implemented via hashing), initially returning ⊥ for all configurations, • C i : V → P({1, . . . , n}) is the set of interested workers who requested the value of a given configuration,</p><formula xml:id="formula_28">• M i R ⊆ V × {1, .</formula><p>. . , n} is the (unordered) message queue for requests (v, j), where j is the identifier of the worker requesting the assigned value (i.e. 0 or 1) of a configuration v belonging to the partition of worker i, and</p><formula xml:id="formula_29">• M i A ⊆ V × {0, 1}</formula><p>is the (unordered) message queue for answers (v, a), where a is the assigned value of configuration v which has been previously requested by worker i. For syntactical convenience, we assume that we can add messages to M i R and M i A directly from other workers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm 1 Distributed Certain Zero Algorithm for a Worker i</head><p>Require: Worker id i, an EDG G = (V, E, N ) and an initial configuration v 0 ∈ V . Ensure: The minimum fixed-point assignment</p><formula xml:id="formula_30">A G min (v 0 ) 1: function DISTRIBUTEDCERTAINZERO(G, v 0 ) 2: if δ(v 0 ) = i then EXPLORE(v 0 ) Algorithm 2 3: repeat 4: if W i E ∪ W i N ∪ M i R ∪ M i A = ∅ then 5: task ← PICKTASK(W i E , W i N , M i R , M i A ) 6: if task ∈ W i E then PROCESSHYPEREDGE(task) Algorithm 2 7: else if task ∈ W i N then PROCESSNEGATIONEDGE(task) Algorithm 2 8: else if task ∈ M i R then PROCESSREQUEST(task) Algorithm 2 9: else if task ∈ M i A then PROCESSANSWER(task) Algorithm 2 10:</formula><p>until TERMINATIONDETECTION 11:</p><formula xml:id="formula_31">if A i (v 0 ) = ? ∨A i (v 0 ) = 0 then return 0 12:</formula><p>else return 1</p><p>Global waiting lists. When we need to reference the global state in the computation of the parallel algorithm, we can use the following abbreviations.</p><p>• The global waiting list of hyper-edges</p><formula xml:id="formula_32">W E = n i=1 W i E . • The global waiting list of negation edges W N = n i=1 W i N . • The global request message queue M R = n i=1 M i R .</formula><p>• The global answer message queue M A = n i=1 M i A .</p><p>Pick Task. Algorithm 1 uses at line 5 the function PICKTASK(W i E , W i N , M i R , M i A ) that nondeterministically returns:</p><p>• a hyper-edge from</p><formula xml:id="formula_33">W i E , or • a message from M i R or M i A , or • a negation edge (v, u) from W i N provided that A i (u) ∈ {0, 1, ⊥}, or • a negation edge (v, u) from W i</formula><p>N if all workers are idle and v has a minimal distance in all waiting lists and message queues (i.e. for all (v , x)</p><formula xml:id="formula_34">∈ (W E ∪ W N ∪ M A ∪ M R ) it holds that dist(v) ≤ dist(v )).</formula><p>If none of the above is satisfied, the worker waits until either a message is received or a negation edge becomes safe to pick. Notice that in this case, W i E will remain empty until a message or negation edge is processed. Even though PICKTASK depends on the global state of the computation to decide whether a negation edge is safe to pick, the rest of the conditions can be determined based on the data that is available locally to each worker. Therefore it is not necessary to synchronise across all workers every time a task should be picked, it is only required if the worker wants to pick a negation edge (v, u) where A i (u) =?.</p><p>Idle Worker. We say that a worker i is idle if it is currently waiting at line 5 for the return value of the function PICKTASK. </p><formula xml:id="formula_35">W i E ← W i E \ {e} 3: if ∀u ∈ T : A i (u) = 1 then FINALASSIGN(v, 1) Edge propagates 1 4:</formula><p>else if ∃u ∈ T where A i (u) = 0 then DELETEEDGE(e) 5:</p><p>else if X ⊆ T s.t. X = ∅ and ∀u ∈ X :</p><formula xml:id="formula_36">A i (u) = ? ∨ A i (u) = ⊥ then 6:</formula><p>for u ∈ X do 7:</p><formula xml:id="formula_37">D i (u) ← D i (u) ∪ {e} 8: if A i (u) = ⊥ then EXPLORE(u) 1: function PROCESSNEGATIONEDGE(e = (v, u)) e ∈ N 2: W i N ← W i N \ {e} 3: if A i (u) = ? ∨A i (u) = 0 then FINALASSIGN(v, 1)</formula><p>Assign negated value 4:</p><formula xml:id="formula_38">else if A i (u) = 1 then DELETEEDGE(e) 5:</formula><p>else if A i (u) =⊥ then 6:</p><formula xml:id="formula_39">D i (u) ← D i (u) ∪ {e}; W i N ← W i N ∪ {e}; EXPLORE(u) 1: function PROCESSREQUEST(m = (v, j))</formula><p>request from worker j 2:</p><formula xml:id="formula_40">if A i (v) = 1 ∨ A i (v) = 0 then Value of v is already known 3: M j A ← M j A ∪ {(v, A i (v))} ; M i R ← M i R \ {m} 4:</formula><p>else Value of v is not computed yet 5:</p><formula xml:id="formula_41">C i (v) ← C i (v) ∪ {j}</formula><p>Remember that worker j is interested in v 6:</p><formula xml:id="formula_42">M i R ← M i R \ {m} 7: if A i (v) = ⊥ then EXPLORE(v) 1: function PROCESSANSWER(m = (v, a)) a ∈ {0, 1} and m ∈ M i A 2: M i A ← M i A \ {m} 3: FINALASSIGN(v, a)</formula><p>Assign the received answer to v</p><formula xml:id="formula_43">1: function EXPLORE(v) v ∈ V 2: A i (v) ← ? 3:</formula><p>if δ(v) = i then Does worker i own v?</p><p>4:</p><formula xml:id="formula_44">if succ i (v) = ∅ then FINALASSIGN(v, 0)</formula><p>It is safe to propagate 0 5:</p><formula xml:id="formula_45">W i E ← W i E ∪ (succ i (v) ∩ E); W i N ← W i N ∪ (succ i (v) ∩ N ) 6: else 7: M δ(v) R ← M δ(v) R ∪ {(v, i)}</formula><p>If not, request the value from the owner of v</p><formula xml:id="formula_46">1: function DELETEEDGE(e = (v, T ) or e = (v, u)) e ∈ (E ∪ N ) 2: succ i (v) ← succ i (v) \ {e} 3: if succ i (v) = ∅ then FINALASSIGN(v, 0) It is safe to propagate 0 4:</formula><p>if e ∈ E then 5:</p><formula xml:id="formula_47">W i E ← W i E \ {e} 6: for all u ∈ T do D i (u) ← D i (u) \ {e} 7:</formula><p>if e ∈ N then 8:</p><formula xml:id="formula_48">W i N ← W i N \ {e}; D i (u) ← D i (u) \ {e} 1: function FINALASSIGN(v, a) a ∈ {0, 1} and v ∈ V 2:</formula><p>if v = v 0 then return a and terminate all workers; Early termination 3:</p><formula xml:id="formula_49">A i (v) ← a 4: for all j ∈ C i (v) do M j A ← M j A ∪ {(v, a)</formula><p>} Notify all interested workers 5:</p><formula xml:id="formula_50">W i E ← W i E ∪ {D i (v) ∩ E}; W i N ← W i N ∪ {D i (v) ∩ N }</formula><p>Termination of the Algorithm. We utilize a standard TERMINATIONDETECTION function computed distributively that returns true if and only if all message queues are empty, all waiting lists are empty (i.e.</p><formula xml:id="formula_51">W E ∪ W N ∪ M R ∪ M A = ∅</formula><p>) and all workers are idle. Notice that once the initial configuration v 0 is assigned the final value 0 or 1, the algorithm can terminate early.</p><p>We shall now focus on the correctness of the algorithm. By a simple code analysis, we can observe the following lemma. Lemma 3.1. During the execution of Algorithm 1, the value of A i (v) for any worker i and any configuration v will never decrease (with respect to the ordering from Figure <ref type="figure">7(c)</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof:</head><p>First let us observe that the algorithm never assigns ⊥ to any configuration, hence the only possible way to decrease the assignment value is to assign ? to a configuration which is already assigned 1 or 0. The only place where this can happen is line 2 of the EXPLORE function as the function FINALASSIGN is always called with only 1 or 0 as an input parameter. However, thanks to the conditions on line 8 of PROCESSHYPEREDGE, line 5 of PROCESSNEGATIONEDGE and line 7 of PROCESSREQUEST, the EXPLORE function is only called if the previous assignment value is ⊥. Hence we can never decrease the assignment value of a configuration in any of the local assignments.</p><p>Based on this lemma we can now argue about the termination of the algorithm. Lemma 3.2. Algorithm 1 terminates.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof:</head><p>To show that the algorithm terminates, we have to argue that eventually all waiting lists become empty and all workers go to idle (unless early termination kicks in before this). By guaranteeing this, the TERMINATIONDETECTION condition will be satisfied and the algorithm terminates.</p><p>First, let us observe that if the waiting lists of a worker are empty, the worker will eventually become idle. That is because none of the functions called from the repeat-until loop contain any loops or recursive calls. Also note that in such case, the worker will stay idle until a message is received. In each iteration, an edge is inserted into a waiting list only if the assignment value of some configuration increases. By Lemma 3.1, the assignment value can never decrease, and since the assignment value can only increase finitely many times, eventually no edges will be inserted into the waiting lists. The same argument applies to request messages as a request can only be sent if an assignment value of a configuration increases from ⊥ to ?. The only exception to the considerations above are the answer messages. An answer message can be sent either as a result of an assignment value increase (line 4 of the FINALASSIGN), which only happens finitely many times. However, it can be also sent as a direct response to a request message (line 3 of the PROCESSREQUEST). As we have already shown, each computation can produce only finitely many requests and since each such request can produce at most one answer, the number of answer messages will also be finite.</p><p>Finally, we note that as soon as all the messages and hyper-edges are processed by all workers, at least one negation edge becomes safe to pick. Hence if no new messages are sent or edges being inserted into the waiting lists, eventually a negation edge is picked (at most once). Therefore all waiting lists become eventually empty and as a result all workers go idle, satisfying the TERMINATIONDE-TECTION condition.</p><p>The main correctness argument is contained in the following loop invariants.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 3.3. (Loop Invariants)</head><p>For any worker i, the repeat-until loop in Algorithm 1 satisfies the following invariants.</p><formula xml:id="formula_52">1. For all v ∈ V , if A i (v) = 1 then A G min (v) = 1. 2. For all v ∈ V , if A i (v) = 0 then A G min (v) = 0. 3. For all v ∈ V , if A i (v) = ? and i = δ(v) then for all e ∈ succ i (v) it holds that e ∈ W i E ∪ W i N or e ∈ D i (u) for some u ∈ V where A i (u) = ?.</formula><p>4. For all v ∈ V , if A i (v) = ? and i = δ(v) then one of the following must hold:</p><formula xml:id="formula_53">• (v, i) ∈ M δ(v) R , • i ∈ C δ(v) (v) and A δ(v) (v) = ?, or • (v, a) ∈ M i A and A δ(v) (v) = a for some a ∈ {0, 1}.</formula><p>5. If there is a negation edge e = (v, u) ∈ W i N s.t. A i (u) = ? and all workers are idle and v is minimal in all waiting lists and message queues (i.e. for all (v , x)</p><formula xml:id="formula_54">∈ (W E ∪ W N ∪ M A ∪ M R ) it holds that dist(v) ≤ dist(v )), then A G min (u) = 0.</formula><p>Proof: First we prove Invariants 1 and 2. The only place where the algorithm assigns value 1 or 0 to a configuration is in FINALASSIGN. Therefore we need to analyse the conditions under which FINALASSIGN is called. FINALASSIGN with value 1 or 0 can be called under these circumstances:</p><p>• Line 3 of PROCESSHYPEREDGE or line 3 of PROCESSNEGATIONEDGE where the target is assigned 0. If all targets of a hyper-edge are assigned 1 or the target of a negation edge is assigned 0, it is by the invariant assumption safe to assign 1 also to the source configuration. • Line 3 of PROCESSNEGATIONEDGE where the target is assigned ? or 0. The case where the target is 0 is clear thanks to Invariant 2. If the target is assigned ?, this can only happen if the edge was picked based on the fourth condition of PICKTASK. Therefore the conditions of Invariant 5 apply and it is safe to assign 1 to the source configuration. • Line 3 of PROCESSANSWER. An answer message (a, i) is only sent if A δ(v) (v) = a and this value is the minimum fixed-point value by Invariants 1 and 2. Therefore it is also safe to assign the same value to A i (v) in worker i. • Line 4 of EXPLORE or line 3 of DELETEEDGE. If a configuration has no remaining successors that can propagate the value 1, then it is safe to assign 0 to it. Hence we proved the validity of Invariants 1 and 2.</p><p>We shall now focus on Invariant 3. When the value of the assignment is increased from ⊥ to ? (line 2 of EXPLORE) for a configuration v owned by worker i, all successor edges are pushed into the waiting lists, thus preserving the invariant. By exploring the functions PROCESSHYPEREDGE and PROCESSNEGATIONEDGE, we observe the following fact. When an edge is picked from the waiting list, one of the following occurs: the source v is assigned a final value, the edge is deleted, or the edge is inserted into the dependency set of some target configuration that is assigned ?. If the target is assigned ⊥, we call the EXPLORE function that is going to increase it to ?. Finally, when a configuration is assigned 0 or 1, the dependency set is pushed into the waiting lists, therefore the invariant is still preserved.</p><p>Let us now discuss Invariant 4. When the value of the assignment is increased from ⊥ to ? for a configuration v not owned by worker i, the worker sends a request message to the owner (line 7 of EXPLORE), thus the invariant is preserved. As soon as the owner of the configuration receives a request, one of two things happen. If the value of the configuration is already 0 or 1 then the owner sends an answer message to worker i (line 3 of PROCESSREQUEST). Alternatively, if the value of the configuration is ⊥ or ? then i is inserted into the interested set (line 5 of PROCESSREQUEST) and the value of the configuration is increased from ⊥ to ? if necessary. Afterwards, when a configuration is assigned 0 or 1, all workers in the interested set are notified via an answer message (line 4 of FINALASSIGN). Finally, when the answer message is processed by worker i, the configuration is assigned 0 or 1, and the invariant trivially holds too.</p><p>We finish by proving Invariant 5. When the conditions of the invariant are satisfied, there are no tasks in any of the waiting and message lists (on any of the workers) that concern the component where the target of the negation edge is located. Since all workers are currently idle, it is also guaranteed that no such task is currently being processed (the opposite would mean that the assignment values in the component can still change as a result of the processing). Therefore it is safe to assume that A G min (u) = 0 as the value of u can never increase to 1, and the invariant holds.</p><p>Now we can state two technical lemmas.</p><p>Lemma 3.4. Upon termination of Algorithm 1 at line 11 or line 12, for every negation edge e = (v, u) ∈ N it holds that either A δ(v) (v) ∈ {1, ⊥} or the negation edge is deleted from succ δ(v) .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof:</head><p>First, observe that if a negation edge is processed more than once for worker δ(v), it is either deleted or the source configuration is assigned 1. Hence the target configuration is guaranteed not to be ⊥. When a negation edge is processed, one of the following will happen:</p><p>• the edge is deleted,</p><p>• the source configuration is assigned 1, or • the value of the target configuration is ⊥. In this case, the edge is re-inserted into the waiting list and will be processed at least twice. If a negation edge is processed at least once, the condition is satisfied. Observe that if the edge is picked for the first time, and the value of the target configuration is ?, then by Invariant 5, the source configuration can be assigned 1.</p><p>Lemma 3.5. Upon termination of Algorithm 1 at line 11 or line 12, for every i ∈ {1, ..., n} and for every v ∈ V it holds that either</p><formula xml:id="formula_55">A i (v) = ⊥ or A i (v) = A δ(v) (v).</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Implementation and Experiments</head><p>The single-core local algorithm (local) and its extension with certain zero propagation (czero), together with the distributed versions of czero with non-shared memory and using MPI running on 4 cores (dist-4), 16 cores (dist-16) and 32 cores (dist-32) have been implemented in an open-source framework written in C++. The implementation is available at <ref type="url" target="http://code.launchpad.net/~tapaal-dist-ctl/">http://code.launchpad.net/~tapaal-dist-ctl/</ref> verifypn/paper-dist and contains also all experimental data. The engine is now fully integrated in the latest release of the tool TAPAAL (<ref type="url" target="http://www.tapaal.net">http://www.tapaal.net</ref>), including a GUI support for creating CTL queries.</p><p>The general tool architecture is shown in Figure <ref type="figure">8</ref>. It consists of the interface that allows the user to define the dependency graph by proving the initial configuration and a function generating (on demand) the sucessor configurations. Then the user can decide to implement their own search strategy or to use one of the predefined ones, choose the custom lightweight comunicator for message passing or define its own (including the serializer that encodes configurations), and the user also defines the partitioning function assigning configurations to workers. On the engine side, one can choose to run either the sequential local or certain zero algorithm, or the parallel one that by default implements only the certain zero algorithm. A game engine allows to interact with the annotated dependency graph and convince the user why a certain configuration has the value 0 or 1. It uses the console mode at the moment-the integration into the GUI of the tool TAPAAL is currently under development.</p><p>The framework in Figure <ref type="figure">8</ref> was instantiated for CTL model checking of Petri nets by providing C++ code for the initial configuration of the EDG and the successor generator (that for a given configuration outputs all outgoing hyper-edges and negation edges). Optionally, one can also customize the search strategy and communication among workers, or choose from the predefined ones. In our experiments, we use DFS strategy for both the forward and backward propagation (note that even if each worker in the distributed version runs DFS strategy, depending on the actual order of the request arrivals, this may result in pseudo DFS strategies).</p><p>To compare the algorithms, we ran experiments on CTL queries interpreted on the Petri nets from MCC'16 <ref type="bibr" target="#b17">[18]</ref> on machines with four AMD Opteron 6376 processors, each processor having 16 cores. A 15 GB memory limit per core was enforced for all verification runs. We considered all 322 known Petri net models from the competition, each of them coming with 16 different CTL cardinality queries. As many of these models are either trivial to solve or none of the algorithms are able to provide any answer, we first selected an interesting subset of the models where the slowest algorithm used at least 30 seconds on one of the first three queries and at the same time the fastest algorithm solved all three queries within 30 minutes. This left us with 49 models on which we run all 16 CTL queries (in total 784 executions) with the time limit of 1 hour. Table <ref type="table">4</ref> shows in the row marked as Answers how many queries were answered by the algorithms and documents that our certain zero algorithm solved 90 more queries than the one by Liu and Smolka. Running the distributed algorithm on 4 cores further solved 54 more queries and the utilization of 32 cores allowed us to solve additional 51 queries. This is despite the fact that we are solving a P-hard problem <ref type="bibr" target="#b14">[15]</ref> and such problems are in general believed not to have efficient parallel algorithms. Table <ref type="table">5</ref>: Verification time in seconds for selected models A: BridgeAndVehicles-PT-V20P20N10, B: Peterson-PT-3, C: ParamProductionCell-PT-4, D: BridgeAndVehicles-PT-V20P10N10, and E: SharedMemory-PT-000010.</p><p>In Table <ref type="table">5</ref> we zoom in on a few selected models that demonstrate different aspects of the distribution. We report the running times (rounded up to the nearest higher second) for all 16 queries of each model. A dash means running out of resources (time or memory). We can observe a significant positive effect of the certain zero propagation on several queries like A.6, B.7, C.8, D.8 and E.16 and in general a satisfactory performance of this technique. The clear trend with multi-core algorithms is that there is usually a considerable speedup when moving from 1 to 4 cores and a generally nice scaling when we employ all 32 cores. Here we can often notice reasonable speedups compared to 1 core certain zero algorithm (A.9, B.1, B.2, B.3, B.12, C.9), sometimes even superlinear speedups like in D.5. On the other hand, occasionally using more cores can actually slowdown the computation like in B.9, E.5 or even E.12 where the distributed algorithms did not find the answer at all. These sporadic anomalies can be explained by the pseudo DFS strategy of the distributed algorithm, which means that the answer is either discovered immediately like in D.5 or the workers explore significantly more configurations in a portion of the dependency graph where the answer cannot be concluded from. Nevertheless, these unexpected results are rather rare and the general performance of the distributed algorithms, summarized in Table <ref type="table">4</ref>, is compelling.</p><p>Based on our experience in MCC'16 and MCC'17, we decided to reimplement our distributed engine in order speed up its performance. This resulted in an improved verification engine (available at <ref type="url" target="https://code.launchpad.net/~verifypn-stub/verifypn/exp-ctl-sm">https://code.launchpad.net/~verifypn-stub/verifypn/exp-ctl-sm</ref>) with the following main new features.</p><p>• We perform some basic query rewriting optimizations (while preserving logical equivalence) so that negations are pushed as far as possible down in the parse tree. This reduces the number of negation edges in the case when some negations can be all the way down to the atomic propositions.</p><p>• We implemented a more efficient memory representation of the queries and added query compilation that compiles atomic expressions into a byte-code format that is then evaluated by a our new virtual machine for the atomic expressions. • We use our newly developed data structure PTrie <ref type="bibr" target="#b34">[35]</ref> for fast and memory efficient storing of the state space. • We switched from using MPI to our custom-made, light-weight implementation (still relying on message-passing) and optimize the message-passing to avoid unnecessary copying of memory regions by the kernel. • We employ a new partitioning algorithm for distributing the work among n workers. Earlier we simply computed a hash of the whole configuration. In the current implementation we perform hashing only on 2 n + 2 places that are uniformly picked from a given marking. This seems to improve the locality, so that the same worker is more likely to be assigned several of the successor configurations in order to reduce the communication overhead. • We optimize the way of handeling negation edges in the situations where the values can be propagated locally without the need to synchronize with other workers. We try to delay synchronization among workers via sending messages as much as possible as this is an expensive operation.</p><p>As a result, the engine performance substantially improved already for the single-core cases, as demonstrated in the column Anwers (improved) in Table <ref type="table">4</ref>, where both the local algorithm as well as our certain zero algorithm solve significantly more queries. In fact, our improved single-core performance for the certain zero now almost matches the number of answers that were previously achieved with 16 cores. On the other hand, the improved sequential engine became so efficient that it now also solves some of the instances that the improved distributed versions are not able to solve (due to the different search strategy and message-passing communication overhead). In other words, the anomalies mentioned earlier became more frequent but at the same time there were several models where the distribution of work made substantial (even super-linear) improvements. Hence we decided to utilize the cores in the results reported in Table <ref type="table">4</ref> for the improved implementation in such a way that e.g. for the 16 cores algorithm, we run in parallel the 1 core algorithm, 2 core algorithm, 4 core algorithm and 8 core algorithm (utilizing only 15 cores in fact) and terminate as soon as the first algorithm provides the answer. The advantage of using more cores is then clear from the table, even though the absolute numbers are smaller than previously. This is likely the indication of the fact that the remaining queries in the database of the selected models are so difficult that one cannot expect to achieve more answers only by the exploration of the state space. Finally, we also compare the performance of our verification engine with LoLA, the winner in the CTL category both at MCC'16 <ref type="bibr" target="#b17">[18]</ref> and MCC'17 <ref type="bibr" target="#b21">[22]</ref>. We run LoLA on all 784 executions (as summarized for our engines in Table <ref type="table">4</ref>) with the same 1 hour timeout and 15 GB memory limit. LoLA provided a conclusive answer in 673 cases and given that it is a sequential tool, it won in the comparison with our sequential czero implementation that solved 565 queries (resp. 652 in the improved version). The reason is that about one third of all the 784 queries are actually equivalent to either true or false and hence they can be answered without any state space exploration by a query rewriting technique implemented in LoLA <ref type="bibr" target="#b18">[19]</ref>. This query simplification technique in LoLA cannot be turned off, so in order to compete with the tool, we implemented a similar query reduction algorithm on top of our improved engine. We are now able to answer 721 queries with our certain zero sequential engine, which is considerably more than 673 answers of LoLA. We have to remark though that LoLA developers recently added a new stubborn set reduction for CTL model checking. This engine competed against our sequential engine in MCC'17 <ref type="bibr" target="#b21">[22]</ref>. Over all queries in the CTL category (disregarding the colored net instances that TAPAAL does not support), we solved 17036 queries compared to 17396 queries solved by LoLA. Our MCC'17 competition engine did not yet include the byte-code interpretation of atomic expressions and some other minor improvements. Hence the performance of our current sequential algorithm is now essentially comparable with LoLA. The main advantage of our approach is that we also provide a distributed implementation that already with 4 cores outperforms our single-core implementation, so we hope to challenge LoLA's first place in the next year competition (where each tool is allowed to use 4 cores).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Conclusion</head><p>We extended the formalism of dependency graphs by Liu and Smolka <ref type="bibr" target="#b5">[6]</ref> with the notion of negation edges in order to capture nested minimum fixed-point assignments within the same graph. On the extended dependency graphs, we designed an efficient local algorithm that allows us to back-propagate also certain zero values-both along the normal hyper-edges as well as the negation edges and hence considerably speed up the computation. To further increase the performance and applicability of our approach, we suggested to distribute the local algorithm, proved the correctness of the pseudo-code and provided an efficient, open-source implementation. Now the user can take a verification problem, reduce it to an extended dependency graph and get an efficient distributed verification engine for free. This is a significant advantage compared to a number of other tools that design a specific distributed algorithm for a fixed modeling language and a fixed property language.</p><p>We demonstrated the general applicability of our tool on an example of CTL model checking of Petri nets and evaluated the performance on the benchmark of models from the Model Checking Contest 2016. The results confirm significant improvements over the local algorithm by Liu and Smolka achieved by the certain zero propagation and the distribution of the work among several workers. Already the performance of our sequential algorithm with certain zero propagation is comparable with the world leading tool LoLA for CTL model checking of Petri nets. While LoLA implements only a sequential algorithm, we also provide a generic and efficient distribution of the work among a scalable number of workers.</p><p>It was observed that for certain models, the search with a large number of workers can be occasionally directed into a portion of the graph where no conclusive answer can be drawn, implying that sometimes just a few workers find the answer faster. With our recent optimized implementation of the single-core algorithm, this issue becomes even more visible on certain models. We can overcome this drawback by a pragmatic decision to run in parallel the single-core algorithm together with the distributed algorithm in order to get the benefits of both, given that we are allowed to use a multicore architecture.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: A Petri net illustrating tokens, places and transitions</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Theorem 2 . 6 .</head><label>26</label><figDesc>(Encoding Correctness) Let N = (P, T, I, F ) be a Petri net, M a marking on N and ϕ a CTL-formula. Let G be the extended dependency constructed according to the rules in Figures3, 4and 5 with the root M, ϕ . Then M |= ϕ iff A G min ( M, ϕ ) = 1.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Minimum set of operators where we let {M 1 , ..., M n } = {M | M → M }</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>1 .</head><label>1</label><figDesc>Notice that M |= EXϕ 1 if and only if there is M such that M → M and M |= ϕ 1 . By the induction hypothesis A min ( M , ϕ 1 ) = 1 if and only if M |= ϕ 1 . By Figure 4(c) there is an edge ( M, EXϕ 1 , { M , ϕ 1 }) for all successors M of M and in order to propagate the value 1 to the root, at least one of the child configurations must have the value 1. Hence A min ( M, EXϕ 1 ) = 1 if and only if M |= EXϕ 1 .• Let ϕ = AXϕ 1 . This case is analogous to the case of EX.• Let ϕ = EF ϕ 1 . First we prove the direction from left to right. By definition we have M |= EF ϕ 1 iff there is a computation</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Derived operator set where we let {M 1 , ..., M n } = {M | M → M }</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 6 :Figure 7 :</head><label>67</label><figDesc>Figure 6:  The EDG in (c) is constructed from the Petri net in (a) and the CTL query in (b). Each configuration is superscripted with its minimum fixed-point assignment, and subscripted with its identifier, e.g. the initial configuration is identified by c 0 . For readability, we abbreviate expressions like token_count({p 1 }) ≤ 2 with p 1 ≤ 2.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Algorithm 2</head><label>2</label><figDesc>Functions for Worker i Called from Algorithm 1 1: function PROCESSHYPEREDGE(e = (v, T )) e ∈ E 2:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>and only if M |= ϕ 1 and M |= ϕ 2 which is by the structural induction hypothesis the case if and only if A min</figDesc><table /></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div><p>Acknowledgments. We would like to thank to <rs type="person">Frederik Bønneland</rs>, <rs type="person">Jakob Dyhr</rs>, <rs type="person">Mads Johannsen</rs> and <rs type="person">Torsten Liebke</rs> for their help with running LoLA experiments. We thank the anonymous reviewers for their detailed comments. The work was funded by <rs type="funder">Sino-Danish Basic Research Center IDEA4CPS, Innovation Fund Denmark center DiCyPS</rs> and <rs type="funder">ERC</rs> Advanced Grant LASSO. The last author is partially affiliated with FI MU in Brno.</p></div>
			</div>
			<listOrg type="funding">
			</listOrg>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof:</head><p>Consider a worker i and a configuration v. If δ(v) = i, the condition holds trivially. If δ(v) = i and A i (v) = ?, then by Lemma 3.3 Condition 4 also A δ(v) (v) = ? (since no messages are in transit, because the algorithm has terminated).</p><p>If δ(v) = i and A i (v) = a ∈ {0, 1}, it means that worker i at some point received an answer message (v, a). That is because the only place where FINALASSIGN is called with a configuration that the worker does not own is in PROCESSANSWER (and a worker never sends messages to itself). Also, an answer message (v, a) is only sent if the worker who owns v has already assigned it a final value a. Therefore if a worker receives an answer message (v, a) then it is guaranteed that A δ(v) (v) = a.</p><p>We finish this section with the correctness theorem. Theorem 3.6. Algorithm 1 terminates and upon termination it holds, for all i,</p><p>Proof: By Lemma 3.2 we know that Algorithm 1 terminates. For a fixed worker i, by Lemma 3.3, it certainly holds that if</p><p>Next we show that B is a fixed-point assignment of G. For a contradiction, let us assume B is not a fixed-point assignment. This can happen in two cases:</p><p>• There is a hyper-edge e = (v, T ) such that B(v) = 0 and B(u) = 1 for all u ∈ T . If A i (v) = 0 for some i, it is a direct contradiction with Lemma 3.3 Condition 2. Otherwise for some i it must hold that A i (v) = ?. By Lemma 3.5, we get that</p><p>. Therefore according to Lemma 3.3 Condition 3, there exists a configuration u such that A δ(v) (u) = ? and e is in the dependency set of u. However, A δ(v) (u) = ? implies that there exists u ∈ T such that B(u) = 0. • There is a negation edge e = (v, u) such that B(v) = 0, and A G min (u) = 0 and e is not deleted. If A i (v) = 0 for some i, it is again a contradiction with Lemma 3.3 Condition 2. Otherwise for some i it must hold that A i (v) = ?. Then by Lemma 3.5 we get that A i (v) = A δ(v) (v) = ?, which is a contradiction with Lemma 3.4. Because B is a fixed-point assignment and A G min is the minimum fixed-point assignment, we get A G min B. Therefore if A i (v) = ? then by the definition of B we have that B(v) = 0 and by</p><p>As a direct consequence of Theorem 3.6 we get the following corollary. </p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Extended Dependency Graphs and Efficient Distributed Fixed-Point Computation</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">E</forename><surname>Dalsgaard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Enevoldsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Fogh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Jensen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">S</forename><surname>Jepsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Kaufmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">G</forename><surname>Larsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">M</forename><surname>Nielsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">C</forename><surname>Olesen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Pastva</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Srba</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-319-57861-3_10</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Petri Nets&apos;17</title>
		<meeting>Petri Nets&apos;17</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2017">2017</date>
			<biblScope unit="volume">10258</biblScope>
			<biblScope unit="page" from="139" to="158" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Model checking: algorithmic verification and debugging</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">M</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">A</forename><surname>Emerson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Sifakis</surname></persName>
		</author>
		<idno type="DOI">10.1145/1592761.1592781</idno>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">52</biblScope>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page" from="74" to="84" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Informatics: 10 Years Back, 10 Years Ahead, volume 2000 of LNCS, chapter Progress on the State Explosion Problem in Model Checking</title>
		<author>
			<persName><forename type="first">E</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Grumberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Jha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Veith</surname></persName>
		</author>
		<idno type="DOI">10.1007/3-540-44577-3_12</idno>
		<imprint>
			<date type="published" when="2001">2001</date>
			<publisher>Springer</publisher>
			<biblScope unit="page" from="176" to="194" />
			<pubPlace>Berlin, Heidelberg</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">High-Performance Language-Independent Model Checking</title>
		<author>
			<persName><forename type="first">G</forename><surname>Kant</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Laarman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Meijer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Van De Pol</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Blom</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Van Dijk</surname></persName>
		</author>
		<author>
			<persName><surname>Ltsmin</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-662-46681-0_61</idno>
	</analytic>
	<monogr>
		<title level="j">TACAS</title>
		<imprint>
			<biblScope unit="volume">9035</biblScope>
			<biblScope unit="page" from="692" to="707" />
			<date type="published" when="2015">2015. 2015</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
	<note>LNCS</note>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">DiVinE 3.0 -An Explicit-State Model Checker for Multithreaded C &amp; C++ Programs</title>
		<author>
			<persName><forename type="first">J</forename><surname>Barnat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Brim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Havel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Havlíček</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Kriho</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Lenčo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Ročkai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Štill</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Weiser</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-642-39799-8_60</idno>
	</analytic>
	<monogr>
		<title level="m">Computer Aided Verification (CAV&apos;13)</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="volume">8044</biblScope>
			<biblScope unit="page" from="863" to="868" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Simple Linear-Time Algorithms for Minimal Fixed Points</title>
		<author>
			<persName><forename type="first">X</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">A</forename><surname>Smolka</surname></persName>
		</author>
		<idno type="DOI">10.1007/BFb0055040</idno>
	</analytic>
	<monogr>
		<title level="m">ICALP&apos;98</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1998">1998</date>
			<biblScope unit="volume">1443</biblScope>
			<biblScope unit="page" from="53" to="66" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Efficient Model Checking of Weighted CTL with Upper-Bound Constraints</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">F</forename><surname>Jensen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">G</forename><surname>Larsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Srba</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">K</forename><surname>Oestergaard</surname></persName>
		</author>
		<idno type="DOI">10.1007/s10009-014-0359-5</idno>
	</analytic>
	<monogr>
		<title level="j">STTT</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="409" to="426" />
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Advanced Reduction Techniques for Model Checking</title>
		<author>
			<persName><forename type="first">Jja</forename><surname>Keiren</surname></persName>
		</author>
		<idno type="DOI">10.6100/IR757862</idno>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
		<respStmt>
			<orgName>Eindhoven University of Technology</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Ph.D. thesis</note>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Parametric Verification of Weighted Systems</title>
		<author>
			<persName><forename type="first">P</forename><surname>Christoffersen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Hansen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Mariegaard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">T</forename><surname>Ringsmose</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">G</forename><surname>Larsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Mardare</surname></persName>
		</author>
		<idno type="DOI">10.4230/OASIcs.SynCoP.2015.77</idno>
	</analytic>
	<monogr>
		<title level="m">SynCoP&apos;15</title>
		<editor>
			<persName><forename type="first">É</forename><surname>André</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">G</forename><surname>Frehse</surname></persName>
		</editor>
		<meeting><address><addrLine>Germany</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="volume">44</biblScope>
			<biblScope unit="page" from="77" to="90" />
		</imprint>
	</monogr>
	<note>Dagstuhl</note>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Design and Synthesis of Synchronization Skeletons Using Branching-Time Temporal Logic</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">M</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">A</forename><surname>Emerson</surname></persName>
		</author>
		<idno type="DOI">10.1007/BFb0025774</idno>
	</analytic>
	<monogr>
		<title level="m">Logic of Programs, Workshop</title>
		<meeting><address><addrLine>London, UK</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1982">1982</date>
			<biblScope unit="page" from="52" to="71" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Results on the propositional µ-calculus</title>
		<author>
			<persName><forename type="first">D</forename><surname>Kozen</surname></persName>
		</author>
		<idno type="DOI">10.1007/BFb0012782</idno>
	</analytic>
	<monogr>
		<title level="m">ICALP&apos;82</title>
		<meeting><address><addrLine>Berlin, Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1982">1982</date>
			<biblScope unit="volume">140</biblScope>
			<biblScope unit="page" from="348" to="359" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Distributed Computation of Fixed Points on Dependency Graphs</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">E</forename><surname>Dalsgaard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Enevoldsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">G</forename><surname>Larsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Srba</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-319-47677-3_13</idno>
	</analytic>
	<monogr>
		<title level="m">SETTA&apos;16</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2016">2016</date>
			<biblScope unit="volume">9984</biblScope>
			<biblScope unit="page" from="197" to="212" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Efficient on-the-fly algorithms for the analysis of timed games</title>
		<author>
			<persName><forename type="first">F</forename><surname>Cassez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>David</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Fleury</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">G</forename><surname>Larsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Lime</surname></persName>
		</author>
		<idno type="DOI">10.1007/11539452_9</idno>
	</analytic>
	<monogr>
		<title level="m">CONCUR&apos;05</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="volume">3653</biblScope>
			<biblScope unit="page" from="66" to="80" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Techniques for Solving Boolean Equation Systems</title>
		<author>
			<persName><forename type="first">M</forename><surname>Keinänen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Research Report A105</title>
		<meeting><address><addrLine>Espoo, Finland</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2006">2006</date>
		</imprint>
		<respStmt>
			<orgName>Helsinki University of Technology, Laboratory for Theoretical Computer Science</orgName>
		</respStmt>
	</monogr>
	<note>Doctoral dissertation</note>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Limits to parallel computation: P-completeness theory</title>
		<author>
			<persName><forename type="first">R</forename><surname>Greenlaw</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">J</forename><surname>Hoover</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">L</forename><surname>Ruzzo</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1995">1995</date>
			<publisher>Oxford University Press, Inc</publisher>
			<biblScope unit="volume">200</biblScope>
			<pubPlace>New York, NY, USA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">TAPAAL 2.0: Integrated Development Environment for Timed-Arc Petri Nets</title>
		<author>
			<persName><forename type="first">A</forename><surname>David</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Jacobsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Jacobsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Jørgensen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Møller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Srba</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-642-28756-5_36</idno>
	</analytic>
	<monogr>
		<title level="m">TACAS&apos;12</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="volume">7214</biblScope>
			<biblScope unit="page" from="492" to="497" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<author>
			<persName><forename type="first">J</forename><surname>Jensen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Nielsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Oestergaard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Srba</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-662-53401-4_16</idno>
	</analytic>
	<monogr>
		<title level="m">TAPAAL and Reachability Analysis of P/T Nets</title>
		<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="volume">9930</biblScope>
			<biblScope unit="page" from="307" to="318" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<author>
			<persName><forename type="first">F</forename><surname>Kordon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Garavel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">M</forename><surname>Hillah</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Hulin-Hubard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Chiardo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Hamez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Jezequel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Miner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Meijer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Paviot-Adet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Racordon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Rodriguez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Rohr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Srba</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Thierry-Mieg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tri</forename><surname>Wolf</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename></persName>
		</author>
		<ptr target="http://mcc.lip6.fr/2016/results.php" />
		<title level="m">of the Model Checking Contest</title>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
	<note>Complete Results for the 2016 Edition</note>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Running LoLA 2.0 in a Model Checking Competition</title>
		<author>
			<persName><forename type="first">K</forename><surname>Wolf</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-662-53401-4_13</idno>
	</analytic>
	<monogr>
		<title level="j">LNCS</title>
		<imprint>
			<biblScope unit="volume">9930</biblScope>
			<biblScope unit="page" from="274" to="285" />
			<date type="published" when="2016">2016</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Using Assumptions to Distribute CTL Model Checking</title>
		<author>
			<persName><forename type="first">L</forename><surname>Brim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Crhova</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Yorav</surname></persName>
		</author>
		<idno type="DOI">10.1016/S1571-0661(05)80758-3</idno>
	</analytic>
	<monogr>
		<title level="j">ENTCS</title>
		<imprint>
			<biblScope unit="volume">68</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="559" to="574" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">Distributed CTL model checking in the cloud</title>
		<author>
			<persName><forename type="first">C</forename><surname>Bellettini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Camilli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Capra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Monga</surname></persName>
		</author>
		<idno type="DOI">10.1109/SYNASC.2014.52</idno>
		<idno type="arXiv">arXiv:1310.6670</idno>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<author>
			<persName><forename type="first">F</forename><surname>Kordon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Garavel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">M</forename><surname>Hillah</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Hulin-Hubard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Berthomieu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Ciardo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Colange</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dal</forename><surname>Zilio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Amparore</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Beccuti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Liebke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Meijer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Miner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Rohr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Srba</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Thierry-Mieg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Van De Pol</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Wolf</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename></persName>
		</author>
		<ptr target="http://mcc.lip6.fr/2017/results.php" />
		<title level="m">of the Model Checking Contest</title>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
	<note>Complete Results for the 2017 Edition</note>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">MARCIE-model checking and reachability analysis done efficiently</title>
		<author>
			<persName><forename type="first">M</forename><surname>Heiner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Rohr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Schwarick</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-642-38697-8_21</idno>
	</analytic>
	<monogr>
		<title level="m">Petri Nets&apos;13</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="volume">7927</biblScope>
			<biblScope unit="page" from="389" to="399" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<author>
			<persName><forename type="first">F</forename><surname>Kordon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Garavel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">M</forename><surname>Hillah</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Hulin-Hubard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Linard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Beccuti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Hamez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Lopez-Bobeda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Jezequel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Meijer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Paviot-Adet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Rodriguez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Rohr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Srba</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Thierry-Mieg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Wolf</surname></persName>
		</author>
		<ptr target="http://mcc.lip6.fr/2015/results.php" />
		<title level="m">of the Model Checking Contest</title>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
	<note>Complete Results for the 2015 Edition</note>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<author>
			<persName><forename type="first">Y</forename><surname>Thierry-Mieg</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-662-46681-0_20</idno>
	</analytic>
	<monogr>
		<title level="m">Symbolic Model-Checking Using ITS-Tools</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2015">2015</date>
			<biblScope unit="volume">9035</biblScope>
			<biblScope unit="page" from="231" to="237" />
		</imprint>
	</monogr>
	<note>Proceedings of TACAS&apos;15</note>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<title level="m" type="main">SPIN&apos;02, volume 2318 of LNCS, chapter Local Parallel Model Checking for the Alternation-Free µ-Calculus</title>
		<author>
			<persName><forename type="first">B</forename><surname>Bollig</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Leucker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Weber</surname></persName>
		</author>
		<idno type="DOI">10.1007/3-540-46017-9_11</idno>
		<imprint>
			<date type="published" when="2002">2002</date>
			<publisher>Springer</publisher>
			<biblScope unit="page" from="128" to="147" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">Distributed Symbolic Model Checking for µ-Calculus. Formal Methods in System Design</title>
		<author>
			<persName><forename type="first">O</forename><surname>Grumberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Heyman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Schuster</surname></persName>
		</author>
		<idno type="DOI">10.1007/s10703-005-1493-1</idno>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="197" to="219" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Distributed On-the-Fly Model Checking and Test Case Generation</title>
		<author>
			<persName><forename type="first">C</forename><surname>Joubert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Mateescu</surname></persName>
		</author>
		<idno type="DOI">10.1007/11691617_8</idno>
	</analytic>
	<monogr>
		<title level="m">SPIN&apos;06</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="volume">3925</biblScope>
			<biblScope unit="page" from="126" to="145" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Evidence-Based Model Checking</title>
		<author>
			<persName><forename type="first">L</forename><surname>Tan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Cleaveland</surname></persName>
		</author>
		<idno type="DOI">10.1007/3-540-45657-0_</idno>
	</analytic>
	<monogr>
		<title level="m">International Conference on Computer Aided Verification (CAV&apos;02), volume 2404 of LNCS</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="455" to="470" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">FDR3-A Modern Refinement Checker for CSP</title>
		<author>
			<persName><forename type="first">T</forename><surname>Gibson-Robinson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Armstrong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Boulgakov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Roscoe</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-642-54862-8_13</idno>
	</analytic>
	<monogr>
		<title level="m">TACAS&apos;14</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2014">2014</date>
			<biblScope unit="volume">8413</biblScope>
			<biblScope unit="page" from="187" to="201" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">CADP 2011: A toolbox for the construction and analysis of distributed processes</title>
		<author>
			<persName><forename type="first">H</forename><surname>Garavel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Lang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Mateescu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Serwe</surname></persName>
		</author>
		<idno type="DOI">10.1007/s10009-012-0244-z</idno>
	</analytic>
	<monogr>
		<title level="j">STTT</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="89" to="107" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<title level="m" type="main">The Spin Model Checker: Primer and Reference Manual</title>
		<author>
			<persName><forename type="first">G</forename><surname>Holzmann</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003">2003</date>
			<publisher>Addison-Wesley Professional</publisher>
		</imprint>
	</monogr>
	<note>first edition</note>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
		<title level="m" type="main">Modeling and Analysis of Communicating Systems</title>
		<author>
			<persName><forename type="first">J</forename><surname>Groote</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Mousavi</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2014">2014</date>
			<publisher>The MIT Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Decidability of model checking for infinite-state concurrent systems</title>
		<author>
			<persName><forename type="first">J</forename><surname>Esparza</surname></persName>
		</author>
		<idno type="DOI">10.1007/s002360050074</idno>
	</analytic>
	<monogr>
		<title level="j">Acta Informatica</title>
		<imprint>
			<biblScope unit="volume">34</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="85" to="107" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Data Structure for Compressing and Storing Sets via Prefix Sharing</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">G</forename><surname>Jensen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">G</forename><surname>Larsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Srba</surname></persName>
		</author>
		<author>
			<persName><surname>Ptrie</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-319-67729-3_15</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 14th International Colloquium on Theoretical Aspects of Computing (ICTAC&apos;17)</title>
		<meeting>the 14th International Colloquium on Theoretical Aspects of Computing (ICTAC&apos;17)</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2017">2017</date>
			<biblScope unit="volume">10580</biblScope>
			<biblScope unit="page" from="248" to="265" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
