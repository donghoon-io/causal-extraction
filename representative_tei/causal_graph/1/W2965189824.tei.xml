<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">A Refined Understanding of Cost-optimal Planning with Polytree Causal Graphs *</title>
				<funder ref="#_W37VGXD">
					<orgName type="full">Swedish Research Council (VR)</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Christer</forename><surname>Bäckström</surname></persName>
							<email>christer.backstrom@liu.se</email>
							<affiliation key="aff0">
								<orgName type="institution">Linköping University</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Peter</forename><surname>Jonsson</surname></persName>
							<email>peter.jonsson@liu.se</email>
							<affiliation key="aff0">
								<orgName type="institution">Linköping University</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Sebastian</forename><surname>Ordyniak</surname></persName>
							<email>sordyniak@gmail.com</email>
							<affiliation key="aff1">
								<orgName type="institution">University of Sheffield</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">A Refined Understanding of Cost-optimal Planning with Polytree Causal Graphs *</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.1" ident="GROBID" when="2025-10-14T18:18+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Complexity analysis based on the causal graphs of planning instances is a highly important research area. In particular, tractability results have led to new methods for constructing domain-independent heuristics. Important early examples of such results were presented by, for instance, Brafman &amp; Domshlak and Katz &amp; Keyder. More general results based on polytrees and bounding certain parameters were subsequently derived by Aghighi et al. and Ståhlberg. We continue this line of research by analyzing cost-optimal planning for instances with a polytree causal graph, bounded domain size and bounded depth. We show that no further restrictions are necessary for tractability, thus generalizing the previous results. Our approach is based on a novel method of closely analysing optimal plans: we recursively decompose the causal graph in a way that allows for bounding the number of variable changes as a function of the depth, using a reording argument and a comparison with prefix trees of known size. We then transform the planning instances into tree-structured constraint satisfaction instances.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>A common approach for identifying tractable fragments of planning is to analyse the causal graph <ref type="bibr" target="#b6">[Knoblock, 1994]</ref>, a directed graph where the vertices represent variables and the arcs represent certain dependencies between variables. By combining restrictions on the structure of this graph with bounds on certain problem-specific parameters, many different tractability results have been obtained. It was early noted that if the causal graph is acyclic, then all actions are unary, i.e. change one variable only, yet such restricted instances can be useful even in practice <ref type="bibr" target="#b8">[Williams and Nayak, 1997]</ref>. <ref type="bibr" target="#b4">Helmert [2006]</ref> pioneered the idea of defining heuristics based on subgraphs of the causal graph.</p><p>He removed arcs in the graph to be able to find acyclic subgraphs, which made it easier to define heuristics. However, not even acyclicity is sufficient in the general case; planning is still PSPACE-complete even when restricted to arbitrary acyclic causal graphs <ref type="bibr" target="#b4">[Jonsson et al., 2014]</ref>. Hence, there has been much focus on various restricted types of acyclic graphs, for example forks, inverted forks and hourglasses. Cost-optimal planning is NP-hard if the causal graph is of either of these types with no further restrictions, but becomes tractable for all three types if we also bound the variable domain size by a constant <ref type="bibr" target="#b5">[Katz and Keyder, 2012;</ref><ref type="bibr" target="#b4">Katz and Domshlak, 2010]</ref>.</p><p>A directed graph is a polytree if it is acyclic and its underlying undirected graph is a tree. Problems with causal graphs that are polytrees have been intensively studied in the literature. It is easy to verify that (inverted) forks and hourglasses are polytrees. <ref type="bibr" target="#b0">Aghighi et al. [2015]</ref> show that costoptimal planning is tractable for instances with bounded domain size and a polytree causal graph with bounded diameter, the length of the longest path in the underlying undirected graph. Another popular parameter is the in-degree of the causal graph, i.e. the maximum number of arcs that go into a vertex. The in-degree is 1 for forks but unbounded for inverted forks and hourglasses. Cost-optimal planning is tractable for instances with polytree causal graphs, domain size 2 and bounded in-degree <ref type="bibr" target="#b4">[Katz and Domshlak, 2008]</ref>. This result cannot be generalised to arbitrarily large domains: even satisficing planning is NP-hard for domain size 5 and in-degree 1 <ref type="bibr">[Giménez and Jonsson, 2009]</ref>. <ref type="bibr" target="#b7">Ståhlberg [2017]</ref> considered the depth of the causal graph, i.e. the length of the longest directed path (which is obviously upper bounded by the diameter). He showed that cost-optimal planning is tractable for instances with bounded domain size and polytree causal graphs with bounded depth and in-degree. We improve on his result, showing that it is sufficient to bound only the depth and the domain size to achieve tractability. The resulting tractable fragment is maximal for polytrees in the sense that we cannot drop the domain size bound nor the depth bound with retained tractability; it is known that costoptimal planning is NP-hard for causal graphs of arbitrary depth, even if the domain size is 2 [Giménez and <ref type="bibr" target="#b4">Jonsson, 2008]</ref> and for inverted-fork causal graphs and unbounded domain size <ref type="bibr">[Domshlak and Dinitz, 2001]</ref>.</p><p>The structure of this extended abstract follows the original full paper <ref type="bibr" target="#b1">[Bäckström et al., 2018]</ref>, using the same sections and the same numbering of results.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Preliminaries</head><p>A SAS + planning instance is a tuple P = V, A, s I , s G , c where V is a set of variables, with an implicit domain D, A is a set of actions and c : A → Q ≥0 is a cost function. The initial state s I is a total state and the goal s G is a partial state. Each action a ∈ A has two partial states the precondition pre(a) and the effect eff(a). An action sequence ω is a plan for P if transforms s I to a state s that satisfies s G . The length |ω| of ω is the number of actions in ω and the cost c(ω) is the total cost of the actions in ω. We also define C(v, ω) as the number of value changes of v when executing ω. Furthermore, ω is a cost-optimal plan for P if there is no plan ω for P such that c(ω ) &lt; c(ω); and ω is a shortest cost-optimal plan for P if it is cost optimal and there is no plan ω for P such that c(ω ) = c(ω) and |ω | &lt; |ω|. The latter concept is important in the presence of zero-cost actions, since a costoptimal plan can then be arbitrarily long. In order to find a cost-optimal plan, it is obviously sufficient to find a shortest cost-optimal plan. The projection of P to a subset V ⊆ V is denoted P[V ] and is identical to P except that all components are restricted to the variables in V . The projection ω[V ] of a plan ω to a set V ⊆ V of variables is the subsequence of actions in ω with an effect on at least one variable in V . The causal graph CG(P) for P describes how the variables depend on each other, as implicitly defined by the actions. It is defined as the directed graph CG(P) = V, E where for all distinct v, w ∈ V , v, w ∈ E if there is some action that either has a precondition on v and an effect on w or it has effects on both v and w. An action is unary if it has an effect on exactly one variable, and it is immediate that all actions must be unary if CG(P) is acyclic, and the following proposition is immediate since a shortest (cost-optimal) plan cannot have any redundant actions. Proposition 1. Let P be a unary SAS + instance. If ω is a shortest or shortest cost-optimal plan for P, then |ω</p><formula xml:id="formula_0">[v]| = C(v, ω) for all v ∈ V .</formula><p>A directed graph G = V, E is a polytree if it is acyclic and the undirected variant of it is a tree, i.e. if we ignore the direction of the edges then G must be connected and contain no cycles. The depth d(v) of a vertex v ∈ V is the length of the longest directed path from v to any sink in G.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Planning for Polytrees</head><p>We focus on planning for instances where the causal graph is a polytree, first deriving a bound on the complexity of costoptimal planning for such instances given that we know how many variable changes we must consider. Then we present such a bound as a function B(s, d) of the domain size and the depth, such that for every variable v and every shortest costoptimal plan ω, it holds that C(v, ω) ≤ B(s, d(v)). Finally, we combine this into our main result (Theorem 4).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Planning as CSP</head><p>We first improve a known complexity result.</p><p>Lemma 2. Let P = V, A, s I , s G , c be a SAS + instance such that CG(P) is a polytree. Let B be an upper bound on C(v, ω) for all v ∈ V and all shortest cost-optimal plans ω for P. Then cost-optimal planning can be solved in time O((Bs B+1 ) 6 n), where n = P is the instance size.</p><p>Proof. If we know an upper bound k on the number of walks that has to be considered in any domain-transition graph (DTG), then plan satisfiability can be solved in time O((ks) 6 n) <ref type="bibr" target="#b2">Bäckström [2014]</ref>. This result uses a CSP encoding based on a tree decomposition of the causal graph, exploiting that CSP can be solved in time O(N C D 2 C ) for tree primal graphs <ref type="bibr" target="#b3">[Dechter and Pearl, 1989]</ref>, where N C is the number of CSP variables and D C their domain size. <ref type="bibr" target="#b2">Bäckström [2014]</ref> also shows how to solve cost-optimal planning this way, but no explicit complexity figure is given. However, since also cost-optimal CSP can be solved in time <ref type="bibr">and Schiex, 2004, Theorem 5.4</ref>] for tree primal graphs, it follows from the proof of Theorem 12 in <ref type="bibr" target="#b2">Bäckström [2014]</ref> that also cost-optimal planning can be solved in time O((ks) 6 n). Let B be an upper bound on the length of the subplan for any variable in a shortest costoptimal plan. Then there are at most B i=0 (s -1) i ≤ Bs B walks of length B in any DTG, so it follows that we can find a shortest cost-optimal plan in time O((Bs B+1 ) 6 n)</p><formula xml:id="formula_1">O(N C D 2 C ) [Cooper</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Bounds for Polytree Causal Graphs</head><p>In the derivation and definition of the bound function B, we need a function τ , defined such that τ (s, h) is the number of nodes in a maximal tree of height h where the root has branching factor s and all other interior nodes have branching factor s -1. The reason for this definition will become clear later. For all s ≥ 2 and h ≥ 1, we thus have</p><formula xml:id="formula_2">τ (s, h) = 1 + s h-1 i=0 (s -1) i</formula><p>which can be bounded from above as τ (s, h) ≤ 3(s -1) h . We can now define the bound function B of the domain size s and the depth d as</p><formula xml:id="formula_3">B(s, d) = s -1, if d = 0 τ s, B(s, d -1) + 1 + (s -2), if d &gt; 0.</formula><p>We will show that this function is an upper bound on the number of variable changes in all shortest cost-optimal plans, and it can itself be upper bounded by a 'tower function' with d levels of exponentiation of the form 4(s -1) 4(s-1)</p><formula xml:id="formula_4">• • • 4(s-1) s .</formula><p>Lemma 3. Let P = V, A, s I , s G , c be a SAS + instance with a polytree causal graph. If ω is a shortest cost-optimal plan for P, then C(v, ω) ≤ B(s, d(v)) for all v ∈ V . We will sketch the proof of this lemma in Sec. 4, and can now state our main result. Theorem 4 (Main result). Let P = V, A, s I , s G , c be a SAS + instance such that CG(P) is a polytree with maximum depth d. If P is solvable, we can find a cost-optimal plan for it in time O (B(s, d) • s B(s,d)+1 ) 6 • P .</p><p>Proof. It is sufficient to find a shortest cost-optimal plan, so the result follows from Lemmas 2 and 3.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Plan Lengths for Polytree Causal Graphs</head><p>In this section we will informally sketch the proof of Lemma 3 using examples (we refer the reader to the original publication <ref type="bibr" target="#b1">[Bäckström et al., 2018]</ref> for the full formal proof). The proof is by induction over the depth of vertices (i.e. variables) in the causal graph. Figure <ref type="figure" target="#fig_0">1</ref> shows an example of a polytree which is drawn such that the vertices are aligned according to depth. We will use this polytree as an example for illustrating the induction. The base case consists of all variables at depth 0 (1-5 in the example). Since a variable v at depth 0 has no outgoing arcs, no other variables depend on it. Hence, the subplan ω[v] for this variable cannot contain any cycles, since ω is a shortest cost-optimal plan. Thus, in the worst case ω[v] is a Hamilton cycle in the DTG for v, i.e. of length s -1. It follows that C(v, ω) ≤ s -1 = B(s, 0) for all v such that d(v) = 0.</p><p>In the induction step, we must prove that if C(v, ω) ≤ B(s, d(v)) for all v ∈ V with d(v) ≤ d, for some d, then it also holds that C(v, ω) ≤ B(s, d(v)) for all v ∈ V with d(v) = d + 1. We will explain the induction step by example, assuming the claim holds up to depth 1, i.e. we want to prove the claim for depth 2. We assume an arbitrary variable u at depth d + 1 and let v 1 , . . . , v m denote the incident variables of its outgoing arcs. As an example, we choose u = 9 as an arbitrary variable at this depth, so we get v 1 = 2 and v 2 = 7. At least one of v 1 , . . . , v m must be at depth d, while the others can be at any depth ≤ d. In the example we have v 2 at depth 1 but v 1 at depth 0. If we were to remove the outgoing arcs from u, we would partition the graph into three sets</p><formula xml:id="formula_5">V 1 , V 2 and U such that v 1 ∈ V 1 , v 2 ∈ V 2 and u ∈ U . This partitioning is illustrated in Figure 2.</formula><p>The remainder of this proof sketch is divided into three steps as in the original full proof.</p><p>Step I. Let χ 1 be the sequence of defined preconditions on u in the actions in subplan ω[v 1 ] and define χ 2 analogously for v 2 . Also let ψ be the sequence of values that u passes, from the initial value to the goal value. We define a releasetime function r that maps the indices of χ 1 and χ 2 to indices of ψ, witnessing that χ 1 and χ 2 are subsequences of ψ. We write r 1 and r 2 for the restrictions of r to χ 1 and χ 2 respectively. We further say that r 1 is minimal if every index in χ 1 is mapped as early as possible in χ. Note that if there exists a release-time function for χ 1 , then there must also exist a unique minimal one. Figure <ref type="figure" target="#fig_2">3</ref> shows two different releasetime functions, r 1 and r 1 , for χ 1 , where r 1 , but not r 1 , is minimal. Furthermore, the function r is minimal if both r 1 and r 2 are minimal. We further note that the minimal release-time function always maps each sequence χ i to the shortest possible prefix of ψ. In Figure <ref type="figure" target="#fig_2">3</ref> we see that r 1 maps χ 1 to a shorter prefix than r 1 does. Furthermore, if two consecutive elements in χ 1 have the same value, then the minimal release-time function must map these to the same index in ψ. Hence, we may assume that χ 1 is an alternating sequence in the worst case. Clearly, χ 1 and χ 2 must be subsequences of ψ in this case.</p><formula xml:id="formula_6">U V 1 V 2 1 2 3</formula><formula xml:id="formula_7">ψ = 1 2 1 3 1 2 3 χ 1 = 2 1 3 r 1 ψ = 1 2 1 3 1 2 3 χ 1 = 2 1 3 r 1</formula><p>We note that the partition of V into the sets V 1 , V 2 and U also implies a corresponding partition of the plan ω into three subplans ω</p><formula xml:id="formula_8">[V 1 ], ω[V 2 ] and ω[U ],</formula><p>where every action occurence in ω belongs to exactly one of these three subplans since all actions are unary. In Figure <ref type="figure" target="#fig_1">2</ref> we see that the only arc from U to V 1 is from u to v 1 , so the only variable in V 1 that depends on some variable in U is v 1 and it depends only on u. Analogously, only v 2 in V 2 depends on u. Furthermore, no variable in V 1 depend on any variable in V 2 and vice versa. It follows that the subplans ω[V 1 ] and ω[V 2 ] are independent of each other, but both depend on the subplan ω[U ]. However, since there are only arcs from u to v 1 and v 2 , we only need to syncrhonise the subplans ω[v 1 ] and ω[v 2 ] with the subplan ω[u], which will be exploited later in the proof. Since ω[V 1 ] and ω[V 2 ] do not depend on each other, the corresponding release-time functions r 1 and r 2 are independent of each other, i.e. we can choose subsequences in ψ for χ 1 and χ 2 independently of each other. It follows that it is always possible to reorder ω into a plan ω that contains exactly the same action occurences as ω but where the release-time function for χ 1 and χ 2 is minimal. This is illustrated in Figure <ref type="figure">4</ref>. We first split</p><formula xml:id="formula_9">ω into ω[V 1 ], ω[V 2 ] and ω[U ].</formula><p>We retain the internal order of each of these three subplans, but reorder them with respect to each other. More precisely, we can interleave these subplans freely as long as we syncrhonise ω</p><formula xml:id="formula_10">[v 1 ] with ω[u] and ω[v 2 ] with ω[u].</formula><p>In particular, we can interleave them such that the release time functions r 1 and r 2 are both minimal. The point of this reordering is that ω is a permutation of ω, so it has the same length and cost as ω, but it is easier to analyse since we know that the release-time functions are minimal. Step II. For this step we need a slightly more complex example, so assume that variable u has four outgoing arcs to variables v 1 , . . . , v 4 , with corresponding sequences χ 1 , . . . , χ 4 of preconditions on u. Also suppose that χ 1 = 131, χ 2 = 132, χ 3 = 312, χ 4 = 323 and ψ = 123123. We can then build a prefix tree T that contains a node for every prefix of these four sequences, and then define a minimal tree mapping r T from the nodes of T to ψ as follows. The root of the prefix tree is the empyt prefix , which we map to 0, i.e. r T ( ) = 0. For all other nodes n, if n = x 1 . . . x m is a child of n in T , then n = x 1 . . . x m-1 , so we let r T (n) be the smallest index such that r T (n ) &lt; r T (n) and position r T (n) in ψ has value x m . That is, r T is a witness for the earliest occurence in ψ of each prefix in T . This minimal tree mapping is unique. Note that we can always reconstruct the unique minimal release-time function from this minimal tree mapping. Furthermore, let T max be the maximal prefix tree with the same depth as T , i.e. it contains all possible alternating prefixes of this length. Then T must be a subtree of T max . Figure <ref type="figure" target="#fig_4">5</ref> shows T max in green overlayed by the subtree T in thick black lines, and the unique minimal tree mapping from T to ψ is shown with blue dashed arrows. Step III. Let r T be the unique minimal tree mapping from T to ψ. In Figure <ref type="figure" target="#fig_4">5</ref>, r T does not map any node in T to the second index in ψ, marked in red. Since we do not know how many such unmapped indices may exist in general, we cannot use the size of T to bound the length of ψ. However, we can use T max to provide such a bound. We construct a partial tree mapping r T from T max to ψ such that r T is minimal and extends r T . For each index i in ψ which is not mapped by r T , we can always find at least one unique node n in T max which is not in T such that if r T is defined for n, then r T (n) = i must hold. In the example we can choose either n = 2 or n = 12 as the node to map to index 2. Hence, the number of indices in ψ that are not mapped by R are at most as many as the number of nodes in T max that are not in T . Since T is a subtree of T max , the length of ψ is bounded by the size of T max (plus ≤ s -1 actions for achieving the goal). If T max has height h, the size of T max is τ (s, h) so |ψ| ≤ τ (s, h + 1) + (s -1). We thus get that C(u, ω) = |ψ| -1 ≤ τ (s, h+1)+(s-1)-1 = τ (s, h+1)+s-2 ≤ τ (s, B(s, d)+ 1) + s -2 = B(s, d + 1) which ends the induction.</p><formula xml:id="formula_11">ω ω[V 1 ] ω[v 1 ] ω[V 2 ] ω[v 2 ] ω[U ] ω[u]</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Concluding Remarks</head><p>We have presented a polynomial-time algorithm for costoptimal planning restricted to polytree causal graphs, bounded depth, and bounded domain size. It, thus, advances the tractability frontier since previous tractability results using these restrictions also require further restrictions. Our algorithm is based on transforming cost-optimal planning into VCSP, using a transformation originally suggested by <ref type="bibr" target="#b2">Bäckström [2014]</ref>. The main technical result is a bound on the number of variable changes defined in terms of the depth of the causal graph and the domain size. This result is maximal in the sense that dropping the domain size bound or the depth bound size leads to an NP-hard problem. A natural open question is thus how to generalise the tractability result to larger classes of planning instances. It is not obvious what other parameter bounds would lead to tractability so it may be easier to consider larger classes of causal graphs than polytrees. The obvious generalisation is to consider causal graphs that have bounded tree-width-this is a method that have led to a large number of tractability results in many different areas of computer science, with a few examples also in planning <ref type="bibr" target="#b2">[Brafman and Domshlak, 2006;</ref><ref type="bibr">Domshlak and Nazarenko, 2013;</ref><ref type="bibr" target="#b2">Bäckström, 2014]</ref>. The very same planning algorithm would be useful also in this case: it runs in polynomial time whenever the tree-width of the causal graph and the number of variable changes are bounded. Unfortunately, it is not at all clear how to generalise the bound on variable changes when the causal graph has bounded treewidth larger than one. Although our algorithm is polynomialtime, its running time is admittedly not impressive. However, previous tractability results like <ref type="bibr" target="#b0">Aghighi et al. [2015]</ref> and <ref type="bibr" target="#b7">Ståhlberg [2017]</ref>, have similar tower functions despite using more restrictions than we do. We believe that our bounds can be considerably improved by an even more careful analysis, combining these proof techniques with others to give an even more refined picture of optimal plans.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: An example polytree causal graph.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Variable partition of the polytree causal graph.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Example release-time functions.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>Figure 4: Plan reordering.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Tree embedding.</figDesc></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_0"><p>Proceedings of the Twenty-Eighth International Joint Conference on Artificial Intelligence </p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div><head>Acknowledgments</head><p>Bäckström is partially supported by the <rs type="funder">Swedish Research Council (VR)</rs> under grant <rs type="grantNumber">621-2014-4086</rs>.   </p></div>
			</div>
			
			<div type="funding">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>* This is an extended abstract of the paper "A Refined Understanding of Cost-optimal Planning with Polytree Causal Graphs" which won the best-paper award at the SoCS-2018 conference.</p></div>
			</div>


			<listOrg type="funding">
				<org type="funding" xml:id="_W37VGXD">
					<idno type="grant-number">621-2014-4086</idno>
				</org>
			</listOrg>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Tractable cost-optimal planning over restricted polytree causal graphs</title>
		<author>
			<persName><surname>Aghighi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 29th AAAI Conference on Artificial Intelligence (AAAI 2015)</title>
		<meeting>29th AAAI Conference on Artificial Intelligence (AAAI 2015)<address><addrLine>Austin, TX, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2015">2015. 2015</date>
			<biblScope unit="page" from="3225" to="3231" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">A refined understanding of cost-optimal planning with polytree causal graphs</title>
		<author>
			<persName><surname>Bäckström</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 11th Int&apos;l Symp. Combinatorial Search, SOCS 2018</title>
		<meeting>11th Int&apos;l Symp. Combinatorial Search, SOCS 2018<address><addrLine>Stockholm, Sweden</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2018">2018. 2018. 2018</date>
			<biblScope unit="page" from="19" to="27" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Parameterising the complexity of planning by the number of paths in the domain-transition graphs</title>
		<author>
			<persName><forename type="first">Christer</forename><surname>Bäckström</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Bäckström ; Ronen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Carmel</forename><surname>Brafman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Domshlak ; Martin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Cooper</surname></persName>
		</author>
		<author>
			<persName><surname>Schiex</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 21st Eur. Conf. Artif. Intell. (ECAI-14)</title>
		<meeting>21st Eur. Conf. Artif. Intell. (ECAI-14)<address><addrLine>Prague; Boston, MA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2004">2014. 2014. 2006. 2006. 2006. 2004. 2004</date>
			<biblScope unit="volume">154</biblScope>
			<biblScope unit="page" from="199" to="227" />
		</imprint>
		<respStmt>
			<orgName>Cooper and Schiex</orgName>
		</respStmt>
	</monogr>
	<note>Artif. Intell.</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Domshlak and Nazarenko, 2013] Carmel Domshlak and Anton Nazarenko. The complexity of optimal monotonic planning: The bad, the good, and the causal graph</title>
		<author>
			<persName><forename type="first">Pearl</forename><forename type="middle">;</forename><surname>Dechter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rina</forename><surname>Dechter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Judea</forename><surname>Pearl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 6th European Conference on Planning</title>
		<meeting>6th European Conference on Planning<address><addrLine>Toledo, Spain</addrLine></address></meeting>
		<imprint>
			<publisher>Omer Giménez and Anders Jonsson</publisher>
			<date type="published" when="1989">1989. 1989. 2001. 2001. 2013. 2008. 2009. 2009</date>
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="page" from="675" to="706" />
		</imprint>
	</monogr>
	<note>J. Artif. Intell. Res.</note>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">New islands of tractability of cost-optimal planning</title>
		<author>
			<persName><forename type="first">Malte</forename><surname>Helmert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">;</forename><surname>Helmert</surname></persName>
		</author>
		<author>
			<persName><surname>Jonsson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Artif. Intell. Res</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="51" to="126" />
			<date type="published" when="2006">2006. 2006. 2014. 2014. 2008. 2008. 2010. 2010</date>
			<publisher>Michael Katz and Carmel Domshlak. Implicit abstraction heuristics</publisher>
		</imprint>
	</monogr>
	<note>J. Artif. Intell. Res.</note>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Structural patterns beyond forks: Extending the complexity boundaries of classical planning</title>
		<author>
			<persName><forename type="first">Keyder</forename><surname>Katz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><surname>Katz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Emil</forename><surname>Keyder</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 26th AAAI Conf</title>
		<meeting>26th AAAI Conf<address><addrLine>Toronto, ON, Canada</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2012">2012. 2012. 2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Automatically generating abstractions for planning</title>
		<author>
			<persName><forename type="first">Craig</forename><forename type="middle">A</forename><surname>Knoblock</surname></persName>
		</author>
		<author>
			<persName><surname>Knoblock</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Artif. Intell</title>
		<imprint>
			<biblScope unit="volume">68</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="243" to="302" />
			<date type="published" when="1994">1994. 1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Methods for Detecting Unsolvable Planning Instances using Variable Projection</title>
		<author>
			<persName><forename type="first">Simon</forename><surname>Ståhlberg</surname></persName>
		</author>
		<author>
			<persName><surname>Ståhlberg</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2017">2017. 2017</date>
			<pubPlace>Sweden</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Linköping University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Pandurang Nayak. A reactive planner for a model-based executive</title>
		<author>
			<persName><forename type="first">Nayak</forename><surname>Williams</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Brian</forename><forename type="middle">C</forename><surname>Williams</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 15th International Joint Conference on Artificial Intelligence (IJCAI 1997)</title>
		<meeting>15th International Joint Conference on Artificial Intelligence (IJCAI 1997)<address><addrLine>Nagoya, Japan</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1997">1997. 1997</date>
			<biblScope unit="page" from="1178" to="1185" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
