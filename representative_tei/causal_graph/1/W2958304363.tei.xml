<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Designing Chain Reaction Contraptions from Causal Graphs</title>
				<funder ref="#_GKMTYpu #_b5cjRaE">
					<orgName type="full">European Research Council</orgName>
					<orgName type="abbreviated">ERC</orgName>
				</funder>
				<funder>
					<orgName type="full">Google Faculty Award</orgName>
				</funder>
				<funder>
					<orgName type="full">Royal Society Advanced Newton Fellowship</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName><forename type="first">Robin</forename><surname>Roussel</surname></persName>
							<email>robin.roussel.15@ucl.ac.uk</email>
							<affiliation key="aff0">
								<orgName type="department">École Polytechnique JEAN-CLAUDE LÉON</orgName>
								<orgName type="laboratory">LIX</orgName>
								<orgName type="institution" key="instit1">University College London MARIE-PAULE CANI</orgName>
								<orgName type="institution" key="instit2">Univ. Grenoble Alpes</orgName>
								<orgName type="institution" key="instit3">CNRS</orgName>
								<address>
									<region>Inria</region>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="institution" key="instit1">Grenoble INP</orgName>
								<orgName type="institution" key="instit2">LJK NILOY J. MITRA</orgName>
								<orgName type="institution" key="instit3">University College London</orgName>
								<orgName type="institution" key="instit4">University College London</orgName>
								<orgName type="institution" key="instit5">Jean-Claude Léon</orgName>
								<orgName type="institution" key="instit6">Univ. Grenoble Alpes</orgName>
								<orgName type="institution" key="instit7">CNRS</orgName>
								<address>
									<settlement>Grenoble INP, LJK, jean-claude</settlement>
									<region>Inria</region>
								</address>
							</affiliation>
							<affiliation key="aff2">
								<orgName type="institution" key="instit1">Niloy J. Mitra</orgName>
								<orgName type="institution" key="instit2">University College London</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Designing Chain Reaction Contraptions from Causal Graphs</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="DOI">10.1145/3306346.3322977</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.1" ident="GROBID" when="2025-10-14T18:23+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>CCS Concepts:</term>
					<term>Computing methodologies → Shape analysis</term>
					<term>Model verification and validation</term>
					<term>Physical simulation computational design, robust design, causal graphs, chain reactions, success probability distribution</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>range of real world examples of increasing complexity, and report significant improvements over alternative approaches.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Fig. <ref type="figure">1</ref>. Our system takes as input an initial scene layout associated with a causal graph of expected events. It then combines simulation, search and learning to build a success probability measure with respect to layout perturbations, and optimizes the layout for robustness against manual placement errors during assembly. The optimized layout is then exported as a guide sheet and used to successfully assemble complex chain reactions in the physical world.</p><p>Chain reaction contraptions, commonly referred to as Rube Goldberg machines, achieve simple tasks in an intentionally complex fashion via a cascading sequence of events. They are fun, engaging and satisfying to watch. Physically realizing them, however, involves hours or even days of manual trial-and-error effort. The main difficulties lie in predicting failure factors over long chains of events and robustly enforcing an expected causality between parallel chains, especially under perturbations of the layout. We present a computational framework to help design the layout of such contraptions by optimizing their robustness to possible assembly errors. Inspired by the active learning paradigm in machine learning, we propose a generic sampling-based method to progressively approximate the success probability distribution of a given scenario over the design space of possible scene layouts. The success or failure of any given simulation is determined from a user-specified causal graph enforcing a time ordering between expected events. Our method scales to complex causal graphs and high dimensional design spaces by dividing the graph and scene into simpler sub-scenarios. The aggregated success probability distribution is subsequently used to optimize the entire layout. We demonstrate the use of our framework through a</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Chain reaction contraptions, also known as Rube Goldberg machines, achieve simple functions from intentionally complex sequences of events (see Figure <ref type="figure">2</ref>). These machines sit at the intersection of entertainment, art and engineering; as such, they are featured in TV commercials <ref type="bibr" target="#b12">[Honda 2003</ref>], exhibited as art pieces <ref type="bibr" target="#b9">[Fischli and Weiss 1987]</ref>, and used for educational purposes in classrooms and science fairs <ref type="bibr" target="#b14">[Kim and Park 2012]</ref>. A particularly compelling aspect of these setups is the careful management of risk: a chain of events is all the more captivating when it looks like it could fail at multiple points. Contraption builders can spend days trying to assemble these sophisticated structures in a reasonably predictable way, relying on a rich community knowledge including rules of thumb and specific procedures to try to minimize risks of failure <ref type="bibr" target="#b23">[Price 2017</ref>].</p><p>Fig. <ref type="figure">2</ref>. In a now-famous cartoon series, Rube Goldberg invented complicated gadgets performing simple tasks in convoluted ways. These machines are fun and exciting as they delicately balance apparent unpredictability and careful risk management. In this paper, we focus on computationally optimizing the layout of real-world Rube Goldberg machines. "Professor Butts and the Self-Operating Napkin" is from Wikipedia (public domain).</p><p>Despite these efforts, physical realization of such chains of events remains a delicate art, involving a tedious and very time consuming trial-and-error design process. Authors of chain reactions face two main challenges. First, small variations at one step may result in wider unintended deviations further down the line (aka the butterfly effect). Limitations in our spatial cognitive abilities prevent us from considering all possible outcomes of a sequence of physical events <ref type="bibr" target="#b28">[Schwartz and Hegarty 1996]</ref>. As a consequence, long chains of events -even individually simple ones -can easily fail due to a single unwanted side effect. For instance, dominoes arranged along tight, highly curved paths can fall onto each other in an unexpected order. Moreover, orchestrating complex sequences may require carefully synchronizing several simpler sub-chains that run in parallel, or at least being able to robustly predict the completion order of these sub-chains. In other words, a target causality between events is often sought, such as a lid being removed from a cup so that a ball can fall in it. This kind of effect is essential to make contraptions more visually engaging, as they make potential failures points more obvious to the spectator.</p><p>Rube Goldberg machines are an example of real life designs where authoring and assembly are several orders of magnitude longer than the final execution. Hence, despite the efforts of many passionate practitioners, such contraptions are often limited to linear chains and lack non-trivial causal dependencies involving the synchronization of parallel branches. In this paper, we investigate the use of computational design to simplify and accelerate the realization of chain reaction contraptions, notably by making designs robust to modeling bias and perturbations induced by manual assembly.</p><p>Interestingly, developing a computational design tool for such machines is quite different from design problems already tackled in computer graphics: while the creation of objects and assemblies from target motion has already been investigated (see the survey by <ref type="bibr" target="#b2">Bermano et al. [2017]</ref>), fabrication was done by connecting 3D printed or laser cut parts. By contrast, we face two extra challenges: first, Rube Goldberg machines are fully assembled by hand, and each placement error may jeopardize the whole execution. Second, only pre-existing and possibly imperfect real-world objects are used as components. The designed layout therefore needs to account for their variability and approximately known features. While the management of variability and errors is discussed in industrial contexts <ref type="bibr" target="#b3">[Brewer et al. 2010]</ref>, the prevalence of intentional risk-taking in Rube Goldberg machines makes them a challenging case study.</p><p>The key idea of this paper is to build a simulation-based success probability distribution (SPD) for the intended scenario conditioned on the layout parameters of the contraption assembly. The input design is subsequently optimized under this estimated probability to improve the robustness to perturbations of the machine layout. More precisely, we start with (i) an initial set of primitive objects (e.g., ball, track) arranged in a coarse scene layout provided by the user; (ii) a set of predefined events (e.g., 'rolling on', 'falling') arranged in a causal graph specifying their expected event order as in Figure <ref type="figure">1</ref>; and (iii) a limit range for each layout parameter. Note that the initial layout does not need to yield a successful run; instead, we expect to find such successful layouts in the provided parameter space. Efficiently computing a probability of success from such input requires solving two challenges: first, exploring the potentially highdimensional design space to find enough successful instances; and second, building an estimator that is accurate near the relevant regions of the design space.</p><p>We combine efficient search and machine learning techniques to address both issues. We tackle the first challenge using an adaptive sampling algorithm that progressively trades exploration of the design space for exploitation of the discovered successful regions. We formulate the second challenge as a binary success/failure classification task, where features are layout parameters and labels are derived from simulations run under the supervision of the causal graph. The success probability given the layout is therefore expressed as the probability of belonging to the 'success' class, as provided by the classifier; it is further refined with an active learning technique. Simulations are run with a fast rigid body engine [Coumans 2018], as we posit that a relatively coarse approximation of reality is sufficient to build a confidence metric. Additionally, we use sensitivity analysis to identify events holding a critical role in the sequence and map their individual probability of success to the relevant design parameters; this allows our method to scale to a high number of dimensions. Once a full SPD is built, we increase the robustness of the layout by identifying and optimizing weak points where the design is likely to fail. Note that our optimization takes place in a space with voids, i.e., containing physically impossible configurations preventing any meaningful measure of success.</p><p>We evaluate our framework on real-world contraption examples of increasing complexity, both quantitatively (by computing an integral sampling-based robustness metric and comparing the output of our method against several baselines) and qualitatively (by constructing these examples in real life). Our results demonstrate that we consistently generate robust designs even in high dimensional configuration spaces. In summary, our contributions are (i) a general methodology to optimize chain reaction contraptions; (ii) a general simulation-based measure of robustness to assembly errors; and (iii) a divide-and-conquer method to efficiently compute this function for complex sequences of events.</p><p>Fabrication-aware motion design. Real-life Rube Goldberg machines are a form of kinetic art. In the context of computational design and fabrication, researchers have investigated both kinematics and dynamics of machines from various functional considerations. Notable examples for kinematics include: periodic motion design for assemblies of gears and pulleys <ref type="bibr" target="#b4">[Ceylan et al. 2013;</ref><ref type="bibr" target="#b6">Coros et al. 2013;</ref><ref type="bibr" target="#b37">Zhu et al. 2012]</ref> and linkages <ref type="bibr" target="#b0">[Bächer et al. 2015;</ref><ref type="bibr" target="#b34">Thomaszewski et al. 2014]</ref>, as well as folding <ref type="bibr" target="#b18">[Li et al. 2015</ref>] and motion sequences <ref type="bibr" target="#b11">[Garg et al. 2016</ref>]. Examples of dynamics-driven design include: adapting internal mass distribution to allow spinning <ref type="bibr" target="#b1">[Bächer et al. 2014]</ref>, or configuring parts for pneumatic <ref type="bibr" target="#b20">[Ma et al. 2017]</ref> and elastic <ref type="bibr" target="#b5">[Chen et al. 2017</ref>] objects as well as wind-up toys <ref type="bibr" target="#b33">[Song et al. 2017</ref>]. Different from these examples, our contraptions are relatively large and their components may be loosely or even not constrained to each other: rather, collision and friction dynamics are predominant, and difficult to model accurately. Previous works in computational design generally neglect the sensitivity of solutions to modeling bias and fabrication errors, which can be significant when hand assembly with preexisting components is required. As Rube Goldberg machines typically reuse and subvert common objects, we consider the shape and physical properties of all components as given, and aim to obtain a robust design by only optimizing positions and orientations. The work of <ref type="bibr" target="#b10">Furuta et al. [2010]</ref> appears closer to our goal, as the authors propose an interface to design kinetic art pieces; however, their tool only allows to previsualize the contraption's behavior, whereas ours actively optimizes the layout to improve the robustness of the chain reaction. Simulation-based design functions. A growing number of works in computational design combine the parametrization of a 3D model with a black-box physically-based simulator to build functions directly in the design space. This approach is general, parallelizable, and can leverage efficient spatial data structures <ref type="bibr" target="#b31">[Shugrina et al. 2015</ref>] and machine learning techniques <ref type="bibr" target="#b35">[Umetani and Bickel 2018]</ref>. Such design functions are useful for exploration, allowing interactive visualization of complex physical phenomena including flight trajectory <ref type="bibr" target="#b36">[Umetani et al. 2014]</ref>, fluid flow <ref type="bibr" target="#b35">[Umetani and Bickel 2018]</ref>, and various material properties such as heat and stress distribution <ref type="bibr" target="#b27">[Schulz et al. 2017</ref>]. More general measures of performance and validity can be computed as well to provide user guidance <ref type="bibr" target="#b31">[Shugrina et al. 2015]</ref> or enable exploration of design trade-offs <ref type="bibr" target="#b26">[Schulz et al. 2018]</ref>. Different from these works, we use simulations to build a measure of success probability. Since our goal is to find a design robust to modeling and assembly inaccuracies, we only need to predict the occurrence of functionally important events (e.g., collision, rolling on a track, falling into a container, etc.) and not the exact motion, which allows us to use a faster (albeit less realistic) rigid body simulator. Moreover, we can focus the computational effort around the discovered successful regions of the design space. Lastly, we leverage the causal graph to decompose the global success probability into simpler functions defined on subspaces of the design space, allowing to scale to a high number of dimensions. Computational models of causality. Event graphs have been used for long to represent storyboards in narrative design. Pioneering work from <ref type="bibr" target="#b13">Kalra and Barr [1992]</ref> used directed graphs to analyze and model time and events in computer animation. While our causal graph is inspired from their event graph, our goal is to exploit it to create a real world contraption. Chains of events were also studied for video games and computational narratology, e.g. with the goal of finding a consistent causal order among events <ref type="bibr" target="#b25">[Riedl and Young 2006]</ref>. In our setting however, the causal chain is fully specified by the user. In the context of mechanical assemblies, researchers have investigated how representations can help analyze and understand causal relations in mechanisms <ref type="bibr" target="#b21">[Mitra et al. 2010;</ref><ref type="bibr" target="#b28">Schwartz and Hegarty 1996]</ref>, while more recently, functional graphs have also been used for reconstruction <ref type="bibr" target="#b19">[Lin et al. 2018]</ref>. By contrast, our work uses the causal graph to build a measure of robustness that is subsequently used to optimize the design.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">CONCEPTS AND DEFINITIONS</head><p>We start by introducing some key concepts with an illustrative example (see Figure <ref type="figure" target="#fig_1">3</ref>). Let us consider the case of a ball initially at rest on a tilted plank. The ball starts rolling on this plank, gains momentum, leaves the plank, and hits the head of a row of dominoes, which all gradually topple until the last one finally comes to a halt. We have just described a scenario, the central component of our framework. A scenario is a triplet S = {S, G, D} consisting of a scene S, a causal graph G and a design space D. Scene. A scene S is a collection of m 3D objects {o i } m i=1 laid out in space and organized as a scene graph in which a child object's transform (i.e., position and orientation) is defined in the local frame of reference of its parent. This graph is useful for objects whose initial position is more intuitively described relative to others (e.g., a ball resting on a track). For the sake of convenience, we assume that each scene is made of a small number of primitives (in this example, ball, track, dominoes) arbitrarily repeated, combined, and constrained to form an initial setup. Figure <ref type="figure" target="#fig_2">4</ref> shows all the primitives implemented in our system. Each primitive object o i is built from a set of predefined design parameters Θ i = {θ j i }, including both geometric (e.g., length, width) and physical (e.g., mass) parameters. Causal graph. A causal graph G organizes a collection of events expected to happen during the simulation. An event e = (c e , s e ) has a specific definition in our framework: it is an entity characterized by a condition c e and a state s e . The event condition is a Boolean function of time and one or more objects c e (t, o i , . . .) that evaluates one or more statements about the transform, velocity and/or geometric relationship of these objects at time t. The event state s e (t) is one of {asleep, awake, success, failure}. Let (t k ) k ≥0 be the sequence of simulation times. Any event but the first starts with s e (t 0 ) = asleep, and is triggered awake at some time t e by the success of all of its predecessor(s). The condition c e (t k ) is only evaluated while s e (t k -1 ) = awake. Since we cannot wait indefinitely for the event to happen, we introduce a timeout duration t max such that</p><formula xml:id="formula_0">s e (t k ) ← success if c e (t k ) = 1 and t e ≤ t k &lt; t e + t max , failure if c e (t k ) = 0 and t k ≥ t e + t max .</formula><p><ref type="url" target="https://www.overleaf.com/project/5a436e7525871b781d2c84e8">https://www.overleaf.com/project/5a436e7525871b781d2c84e8</ref> The timeout t max is manually set to match the longest expected time between two events (2s in our experiments). Figure <ref type="figure" target="#fig_3">5</ref> shows the events currently supported in our system. We note that our formulation induces a discrepancy with the intuitive definition of some events: the act of falling, for instance, is not instantaneous -it lasts a certain amount of time. In our system, however, the switch success or failure is immediate; hence, in such cases, success merely means that the event has started. In practice, we found this formulation sufficiently expressive for our needs.</p><p>Events are tied together as nodes of the causal graph, which is a directed acyclic graph with a single root node (i.e., only one starting event) and one or more terminal branches. Using a graph rather than a single timeline allows to account for events happening in parallel in more complex scenarios (see Figure <ref type="figure" target="#fig_4">6</ref>). Each edge (e i , e j ) enforces a temporal ordering of the two events it connects. Hence, for instance, if the ball was to fall on the last domino instead of the first, the causal graph would be violated because the intermediate expected events have not happened. We note that such a causal graph is not necessarily a tree: two branches may converge, signifying that all parent events need to happen before the current one. The scenario as a whole reaches its termination condition when either (i) the last event of each branch has been reached (global success), or (ii) at least one event has timed out (global failure).</p><p>Design space. The design space D allows us to explore different realizations of a scenario. While the previously defined primitive design parameters {Θ i } are fixed, D is composed of the layout parameters of each object relative to its parent in the scene graph. Therefore in the general case D = SE(3) m ; in practice however,</p><formula xml:id="formula_1">CAUSAL GRAPH TIME LINE (0) (0) (1)<label>(2)</label></formula><p>(2)</p><p>(3) A first domino run (top left of the view) topples and hits a plank, which in turns triggers two parallel branches: on one side, a second domino run topples and falls on a lever, which pivots; on the other, a ball rolls on a track, passes below the now-raised lever, and falls into a goblet. As in Figure <ref type="figure" target="#fig_1">3</ref>, snapshots are matched with events from the causal graph. The two arrows pointing towards event H mean that both E and G need to have happened for H to happen; i.e., the ball can only fall if it started rolling and the lever was raised. some layout parameters can be frozen (e.g., if an object is always in a given plane). This results in d free parameters, each in a predefined range <ref type="bibr">[a, b]</ref>. For convenience, we assume that each parameter range is normalized so that D = [0, 1] d . This design space is further structured as follows (see Figure <ref type="figure" target="#fig_5">7</ref>left): first, some regions are forbidden a priori (i.e., before simulation) because they are not physically feasible: typically when two distinct rigid bodies intersect each other at t 0 . They form the impossible region D . Second, the physically feasible space is divided between the success region D + and the failure region D -, which have no explicit representation in the general case, but can be approximated by sampling scenario instances and simulating them under the supervision of the causal graph. Thus, D = D ∪ D + ∪ D -, with some of these regions potentially disconnected. Note that although we are ultimately only interested in finding D + , D and D -are kept distinct for reasons given in Section 7.</p><formula xml:id="formula_2">(3) (4) (4)<label>(1</label></formula><p>While such virtual regions are (implicitly) defined, many sources of bias and error can make the behavior of a virtual scenario diverge from its concrete realization. Coming back to our design space representation, a more telling picture is given Figure <ref type="figure" target="#fig_5">7</ref>-top right: uncertainty affects not only the boundary ∂D + , but also the layout of the scene, or in other words, the position x in the design space D. The former reflects a wide range of factors throughout the pipeline: it encompasses random measurement errors as well as calibration, modeling and simulation biases, and rounding errors. The latter can originate from random placement error by the user. While a lot of effort can go into reducing these biases and errors (e.g., by choosing a better simulator, being more careful during assembly, etc.), we take a different approach to lower the chance of failure.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">OVERVIEW 4.1 User Experience</head><p>Our method workflow is divided in three steps: scenario definition, probability computation and optimization, and physical realization. Defining a scenario consists in specifying the scene, causal graph, and design space.</p><p>The user describes the scene by selecting the primitives, setting their geometric and physical parameters, organizing them as a scene graph (optional), and providing an initial layout (not necessarily a successful one). Setting the fixed parameters requires at least a few real-world measurements (e.g., size and weight). The user then indicates a causal graph by choosing events relative to one or several primitives from a preexisting library, and connecting them by directed edges. Lastly, the user specifies the design space in terms of ranges of values for the six transform parameters (position and orientation) of each primitive. Parameters with no range are locked to their initial values. We note that specifying a scene hierarchy in the first step can help avoid the exploration of large irrelevant portions of the design space; just like accurate models however, a sophisticated hierarchy is not strictly necessary. From this input, a simulation-based success probability is built, allowing to optimize the contraption layout to find a solution robust to errors. The solution is then exported as a printed outline to guide the user during assembly (see supplemental).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Algorithm Overview</head><p>The core of our method is the computation of a success probability distribution conditioned on the layout x, modeled as the class probability output by a binary success/failure classifier trained on the simulated scenario instances. In Section 5, we propose algorithms to efficiently find successful points in the design space, train the classifier and improve its accuracy via active learning. Section 6 then demonstrates how this method can scale in high-dimensional design spaces using a divide-and-conquer method where the global probability of success is decomposed into conditional probabilities of success of individual events. Each of these components is restricted to the design parameters that really influence the corresponding event, thus reducing the dimensionality of their respective design subspace. Finally, in Section 7, we take the scenario instance with the highest success probability and refine it using an SPD-based global energy that we minimize under physical validity constraints.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">SUCCESS PROBABILITY COMPUTATION</head><p>We consider a scenario S where objects are laid out according to a vector of parameters x ∈ D, with D = D ∪ D + ∪ D -. Our goal is to build an approximation of the success probability distribution (SPD) Pr(D + |x) using the data provided by the simulator.</p><p>Our key observation is that we can avoid explicitly modeling all the sources of uncertainty listed in Section 3. As long as we have a synthetic approximation of the outcome function (or 'oracle') h : D \ D → {failure, success}, we can build a probability distribution based solely on a learned approximation of the success region D + . Maximizing such a probability allows to 'push' a point x deeper inside D + , thus increasing robustness to bias and assembly errors. Indeed, moving away from the boundary reduces the dependence between the variance of the input (layout parameters x) and the variance of the output (success/failure flag), which is a central principle of the Taguchi methods for robust design <ref type="bibr" target="#b24">[Rao et al. 2008]</ref>. In short, the idea is to make the output less sensitive to parameter variations, thus avoiding the need to explicitly account for all possible sources of error.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Initial exploration</head><p>Classifier training ery synthesis</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Probability calibration</head><p>Section 5.1 Section 5.2 Section 5.3 The SPD is built by calibrating the score of a Support Vector Machine (SVM) classifier trained on simulated samples. We chose SVMs not only for their robustness to overfitting in high-dimensional spaces, but also because they mesh very well with our active learning strategy, as described next (see Section 8 for a comparison with baseline methods).</p><formula xml:id="formula_3">X X f + k f - k D k f + k +1 f - k +1 D k +1</formula><p>In this section, we consider a single SPD computed on the entire design space. Our method, as shown in Figure <ref type="figure" target="#fig_6">8</ref>-top, starts with an initial exploration of the design space (Section 5.1) by adaptively sampling D and running simulations to find a minimal number of successful instances. The main body of the algorithm (Section 5.2) then follows an active learning strategy in two alternating steps: first, during classifier training, a non-linear kernel SVM is trained on the current dataset to approximate ∂D + ; second, during query synthesis, the decision function of the SVM helps identify uncertain regions of the design space which are then probed to augment the dataset. As a final step (Section 5.3), we apply a probability calibration to map the final SVM score to a class probability for success.</p><p>During the entire process, new candidate samples are filtered to discard the physically impossible ones (e.g., those where rigid bodies intersect). Physical validity does not need to be learned because it is enforced by constraints during layout optimization (see Section 7). Valid scenario instances are simulated under supervision of the causal graph, yielding a global success or failure label.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Initial Exploration by Adaptive Sampling</head><p>The goal of the exploration stage is to discover an initial number of successful instances N + (200 by default). Algorithm 1 details our adaptive sampling method. We iteratively grow a list of physically valid sample points X = k X k , where X k is the list of N s k points</p><p>Algorithm 1 Exploration by adaptive sampling.</p><p>1: X ← ∅ 2: {n + i } ← ∅ 3: D 0 ← SobolSeqence() 4: k ← 0 5: enouдh ← false 6: while k ≤ k e and not enouдh do 7:</p><formula xml:id="formula_4">X k ← SamplePhysicallyValid(D k , N s k ) 8: X ← X ∪ X k 9:</formula><p>// Simulate each sample to get their # of successful events.</p><p>10:</p><formula xml:id="formula_5">{n + i } ← {n + i } ∪ {GetNumSuccEvents(x) ∀x ∈ X k } 11: if | {i : n + i = n } | ≥ N + then 12: enouдh ← true // Because x i ∈ D + ⇔ n + i = n.</formula><p>13: else 14:</p><formula xml:id="formula_6">I ← ArgNMax({n + i }, N + ) 15: w ← {n + I i / j ∈I n + j ∀i ∈ [1 . . N + ]} 16: D k +1 ← N + i =1 w i N(x I i , diag(σ |b -a |)) 17: k ← k + 1 18:</formula><p>end if 19: end while (10 by default) drawn from distribution D k at step k, until either (i) the number of successful points |{x ∈ X : x ∈ D + }| reaches N + , or (ii) after k e iterations (500 by default, which was never reached in our experiments). The initial sampling X 0 is drawn from the quasi-random Sobol sequence <ref type="bibr">[1967]</ref> (N s 0 = 500 by default). We use the causal graph G to orient the sampling towards the most relevant regions of the design space: for each new sample point x i ∈ X , we simulate the corresponding scenario instance and record the number of successful events n + i (between 0 and n, where n is the total number of events); in other words, n + i is the number of causal graph nodes whose state is success after simulation of a single instance x i . Then, we select the top N + values from {n + i }, and note I their indices. We use them to build a mixture of Gaussians</p><formula xml:id="formula_7">D k ∼ N + i=1 w i N (x I i , diag(σ )),<label>(1)</label></formula><p>with a diagonal factor σ = 0.01 by default. There is one Gaussian per sample x i ; their weight w i reflects the relative success of x i with</p><formula xml:id="formula_8">w i = n + I i / j ∈I n + j .</formula><p>This formulation focuses exploration around the current best partially successful scenario instances, which effectively helps it reach regions containing full successes even in high-dimensional design spaces. As in reinforcement learning, we can tune the balance between exploration and exploitation: for instance, a higher σ favors exploration, as points are sampled further from the current best. Moreover, as new successful data points are found, only taking the top N + points at each step means that our method progressively favors exploitation of full successes over exploration of partial successes. Lastly, we note that exploration can be made easier by providing a more detailed causal graph, as it yields a finer-grained distinction between partially successful instances.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Classifier Training and Query Synthesis</head><p>The goal of this step is to obtain a classifier with sufficient accuracy (90% in our experiments). We iteratively train an SVM and query new design space points until we reach either the target accuracy  </p><formula xml:id="formula_9">w ← { |f k (x i ) | / v j=1 |f k (x j ) | ∀i ∈ [1 . . v]} 8: D k ← v i =1 w i N(x i , |f k (x i ) |U ) 9: X k ← SamplePhysicallyValid(D k , 10N s ) 10: I ← ArgNMin({ |f k (x i ) | ∀x i ∈ X k }, N s ) 11: X ′ k ← {x i ∈ X k : i ∈ I } 12: X ← X ∪ X ′ k 13: y ← y ∪ ComputeLabels(X ′ k ) //</formula><formula xml:id="formula_10">f k , { xi } v i =1 , U , acc ← TrainEstimator(X, y) 16: k ← k + 1 17: end while</formula><p>or the maximal number of iterations k l (5 by default), as illustrated in Figure <ref type="figure" target="#fig_6">8</ref>-bottom and detailed in Algorithm 2. The list of samples is noted again X = k X k , where X 0 is the set of sample points obtained from the initialization step.</p><p>Classifier training. Following common machine learning practices, the dataset is first standardized (i.e., transformed to zero mean and unit variance). The SVM classifier has two hyperparameters: C, the regularization parameter, and γ , the inverse radius of influence of each support vector. We automatically select their optimal value from a logarithmic range using stratified 3-fold cross-validation. The accuracy at step k is given by the cross-validation score. Query synthesis. In active learning, a learner is able to improve its accuracy by querying an 'oracle' for data points that were not part of its original training set <ref type="bibr" target="#b29">[Settles 2012</ref>]. The query, however, comes at a computational cost; the algorithm thus needs to choose its queries wisely in order to improve its performance. In our case, where the oracle is a simulator, any physically valid point in the design space can be queried to obtain success/failure label; this problem is called query synthesis. A common strategy consists in reducing estimator uncertainty by querying regions of which the learner is the least certain about. For an SVM, this region is easy to find: it lies near the classification boundary, where the current SVM decision function f k : R d → R is close to 0. This boundary is itself defined by the v support vectors { xi } v i=1 . Hence, after training the SVM at step k, we draw samples from the mixture of Gaussians</p><formula xml:id="formula_11">D k ∼ v i=1 w i N (x i , | f k (x i )|U ), (<label>2</label></formula><formula xml:id="formula_12">)</formula><p>where U is the inverse of the diagonal scaling matrix used for standardization. The Gaussians are weighted by | f k | with:  </p><formula xml:id="formula_13">w i = | f k (x i )|/ j | f k (x j )|,</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Probability Calibration</head><p>While we do not strictly need to compute a probability when there is only one classifier (as the SVM decision function can be maximized directly), the divide-and-conquer method of Section 6 requires probabilities to be output by each classifier so that they can be meaningfully combined and/or compared. The decision function f , however, approximates a signed distance to a regularized boundary and not a probability. Nevertheless, the success probability distribution Pr(D + |x) can be approximated by applying a continuous transformation to the decision function, following a method known as Platt Scaling <ref type="bibr" target="#b22">[Platt 1999</ref>] that fits a logistic regression model to the classifier's scores. Specifically, a maximum likelihood optimization is performed to calibrate the coefficients α, β ∈ R in</p><formula xml:id="formula_14">Pr(D + |x) = (1 + exp(α f (x) + β)) -1 . (<label>3</label></formula><formula xml:id="formula_15">)</formula><p>After this calibration, we can evaluate the SPD of a new scenario instance x by computing Pr(D + |x) (see Figure <ref type="figure" target="#fig_8">9</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">EXTENSION TO COMPLEX CAUSAL CHAINS</head><p>Chain reactions of reasonable visual complexity can easily depend on several dozens of layout parameters. To help the SPD computation scale to such a high number of dimensions, we propose a 43:8 • Robin Roussel, Marie-Paule Cani, Jean-Claude Léon, and Niloy J. Mitra divide-and-conquer method where the global SPD for a scenario S = {S, G, D} is broken down into a set of success probabilities of simpler sub-scenarios S i = {S, G i , D i }, where G i is a subgraph of G, and D i is a subspace of D with dimension d i &lt; d. This inequality is key to the scalability of our method, as it reduces the combinatorial complexity of exploring D and approximating the SPD. Before detailing our extended pipeline, let us demonstrate how to factorize Pr(D + |x). By definition, a scenario is successful if and only if each event happens in the correct order; this is equivalent to each node of the causal graph reaching success after its parent(s) did the same. Formally, if we associate to each causal graph event e i the random variable E i giving the final state of this event after simulation, we are trying to decompose the joint probability</p><formula xml:id="formula_16">Pr(D + |x) = Pr {E i } n i=1 = success | x , (<label>4</label></formula><formula xml:id="formula_17">)</formula><p>where n is the number of events, and '{•} = success' means that all elements of the set are equal to success. To do so, let us consider the directed graphical model G obtained by substituting each node e i in G by the corresponding E i . By construction of the causal graph, the success of the parents is equivalent to the success of all ancestors; therefore the success of any E i , given x, only depends on its parents' success. In other words, G satisfies the local Markov property, expressed as conditional independence:</p><formula xml:id="formula_18">∀E i ∈ V (G) : E i ⊥ ⊥ {nd(E i ) \ pa(E i )} | pa(E i ), x,</formula><p>where V (G) is the set of vertices in G, and nd(E i ) and pa(E i ) are respectively the set of non-descendants and parents of E i in G. It can be shown that for directed acyclic graphs, this property is notably equivalent to the factorization of joint probabilities on the graph nodes into conditional probabilities given the node's parents <ref type="bibr" target="#b17">[Lauritzen 2001]</ref>. In particular, Eq. 4 yields the SPD factorization:</p><formula xml:id="formula_19">Pr(D + |x) = n i=1</formula><p>Pr</p><formula xml:id="formula_20">(E i = success | pa(E i ) = success, x) . (5)</formula><p>We call the i-th factor of the above product the E i -CSPD (where 'C' stands for 'Conditional'). Of course, if we were to approximate each E i -CSPD as we approximate the global SPD, the complexity would be multiplied by n, rather than decreased. To effectively reduce it, we make the key observation that given pa(E i ) = success, having E i = success depends on few design parameters; in other words, the variance of each E i -CSPD mostly only occurs in a relatively lowdimensional subspace D i ⊂ D. Computing this subspace mapping (see second block in Figure <ref type="figure" target="#fig_9">10</ref>) is described next. First, as a pre-processing step, we identify which E i are quasideterministic, i.e., nearly always successful when their parents are successful. Given X the sampling obtained after initial exploration (Section 5.1), which contains a minimum number of globally successful samples, we compute the success rate of each E i ,</p><formula xml:id="formula_21">ρ i = N + i /(N + i + N - i ),</formula><p>where N + i and N - i are respectively E i 's number of successes and failures in X , and assign D i = ∅ to each E i having ρ i ≥ 0.95. The corresponding E i -CSPDs are subsequently set to 1. We measure correlations between the remaining E i and the design parameters using mutual information <ref type="bibr" target="#b8">[Cover and Thomas 2006]</ref>, allowing us to discover linear as well as nonlinear relationships. In our experiments, We propose an extended version of our SPD building to scale with a high-dimensional design space.</p><p>parameters were selected if their mutual information with E i was greater than 0.2.</p><p>To approximate the non-constant factors, we apply the following method, illustrated as the stack of blocks of the extended pipeline in Figure <ref type="figure" target="#fig_9">10</ref>. For each E i -CSPD, we consider the subgraph G i containing only e i and its ancestors. We run the training and boundary consolidation loop (Section 5.2) using G i , with two slight modifications: (i) to satisfy the conditional probability in Eq. 5, we only keep the samples satisfying pa(E i ) = success. We know that such samples exist in the initial set for each E i , since some of the initial samples are globally successful over G. (ii) During boundary consolidation, we restrict sampling to the corresponding D i by simply taking the indices of the parameters not in D i , and setting their scale factor in U to 0: therefore, only the parameters in D i have non-zero variance. Lastly, we calibrate each probability as in Section 5.3.</p><p>As a result of the above steps, the SPD approximation can be computed with a significant complexity reduction as</p><formula xml:id="formula_22">Pr(D + |x) ≈ n i=1 r i (x),<label>(6)</label></formula><p>where</p><formula xml:id="formula_23">r i (x) = Pr (E i = success | pa(E i ) = success, ϕ i (x)</formula><p>) and ϕ i : D → D i is the subspace mapping.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">LAYOUT OPTIMIZATION</head><p>Once the SPD has been computed, we take the sample point with the highest success probability as our most robust current solution.</p><p>Although this design is indeed already quite robust, we further refine it by applying a nonlinear optimization. While the factorization could allow us, in theory, to optimize each E i -CSPD separately, in general they are not separable because their subspaces D i overlap. Instead, we aggregate all components into a global energy to find</p><formula xml:id="formula_24">min x∈D E r (x) subject to C (x) ≥ 0 (7) with E r (x) = -S α • r(x),<label>(8)</label></formula><p>where r i (x) is the E i -CSPD approximation from Eq. 6, and the function S α : R n → R is the smooth minimum <ref type="bibr" target="#b16">[Lange et al. 2014</ref>]: S α (z) = i z i e -α z i / i e -α z i with α ∈ R + controlling the importance of the smallest component of z. The reason for this choice (rather than taking the product, as in Eq. 6) comes from the observation that a chain is only as strong as its weakest link. This entails that priority should be given to maximizing the minimal E i -CSPD value, rather than maximizing their product.</p><p>The constraint vector C ensures that the design stays physically valid. It aggregates (i) penetrations between distinct rigid bodies in the scene, and (ii) primitive-specific constraints, such as ensuring that the layout of a rope-pulley is compatible with the rope length. The former is easily obtained from the rigid body simulator, as penetrations are needed to compute the reaction force between colliding shapes [Coumans 2018]. While we could have learned invalid configurations when computing the SPD, thus integrating the constraint into the energy, we chose to explicitly enforce physical validity during optimization for two reasons: first, validity would not have been guaranteed since we only approximate the SPD, and second, impossibility and failure are two distinct concepts. Indeed, the probability of success does not necessarily decrease as a design x ∈ D + is moved closer to D : for example, putting two successive dominoes in contact might robustly ensure that both topple.</p><p>As described earlier, the initial solution is the sample point with the highest SPD value. Assuming that this guess is close enough to the global minimum, we use Sequential Least-Squares Quadratic Programming <ref type="bibr" target="#b15">[Kraft 1988</ref>] to find the optimal design.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">RESULTS AND EVALUATION 8.1 Implementation</head><p>Our framework was implemented in Python 3. 3D models are generated by OpenSCAD and simulated using Bullet Physics. Most computations, including optimization, are done with Numpy and Scipy while Scikit-learn is used for the SVM classifier and the other machine learning tools. Our graphical interface (described next) was implemented with the Panda3D game engine. Code and additional details are included as supplementary material. Interface. Our graphical interface allows users to define the scene and causal graph. They can instantiate the primitives described in Section 3 and define the initial layout. We provide specific tools to help designing the most complex primitives: for instance, domino runs can be generated by simply drawing a path and having dominoes automatically distributed along it. Simulation can be run in real time, providing visual feedback during design. Once the scene is complete, users define the causal graph by instantiating events, linking them to the objects in the scene and drawing directed edges between them, and finally specifying necessary parameters such as design space ranges. We note that the specific layout designed in the GUI does not need to be a fully successful one: all that matters is that there is a successful region somewhere in the design space. Export. The final optimized layout is automatically exported as PDF sheets to be printed, in order to provide guidance during assembly. The outline is obtained by projecting the convex hull of each object onto a vertical or horizontal plane, depending on the user's need. A pattern of grey lines is added to the background to help join the paper sheets after printing. Guidance patterns for the examples presented in this paper are provided as supplementary material.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.2">Qualitative Evaluation</head><p>We designed, implemented, and physically realized a number of scenarios to validate our pipeline. We present here a selection of four examples, focusing on those most challenging due to complex movements and/or event synchronizations. Note that simple domino runs following long low-curvature paths are easy to design (as commonly seen in online videos) and hence were avoided in these experiments. The four presented sequences are called ball-Run, causalitySwitch, longChain, and teapotAdventure, in increasing order of complexity. The first two resulted in a successful real-life run after a single try; the others, due to their higher complexity, required a more careful adjustment of the parts to the printed layout and succeeded after 4-5 trials. We note that this number is much lower that the dozens of trials usually shown in behind-the-scenes videos found online. In this section, we describe each scenario at a high level, while further details and video clips are provided in the supplemental material.</p><p>In ballRun, the goal is to get the ball to roll down the tracks and fall into the cup. However, a wooden plank blocks the entrance of the cup. Synchronization is needed along the causal graph to realize the following sequence: the ball hits the first wooden block to get the lower support rotating, but the ball has to travel slowly enough to allow the other wooden block to fall, thus opening the pathway to the target cup (see Figure <ref type="figure" target="#fig_10">11</ref> but best seen in the video).</p><p>The causalitySwitch contains two longer chains running in parallel until a 'domino switch' allows only the fastest path to go through by blocking the way of the other. One path is a wave-like chain of dominoes, while the other involves a ball rolling on a track. This experiment demonstrates that we can choose to optimize for either side to be the fastest by modifying the causal graph accordingly. Figure <ref type="figure">12</ref> shows the causal graph along with the final and initial state with the 'ball' side successfully reaching the switch first. Both versions endings are shown in the supplementary video.</p><p>The longChain is a long linear sequence of events. Under the weight of the box's contents, a lever pivots to topple the domino run that, in turn, nudges the ball onto the track. The ball bounces on a small platform and hits a lever, resulting in the orange plank toppling. The plank tumbles and falls through a narrow entrance into a goblet, moving a pivot that makes the bottom weight fall, tugging on the central goblet from which coins fall into the box. Figure <ref type="figure" target="#fig_1">13</ref> shows the causal graph along with initial and final states of the optimized layout, while the full run is shown in the video.</p><p>The teapotAdventure is the most complex example shown in this paper (see Figures <ref type="figure">1</ref> and<ref type="figure" target="#fig_2">14</ref>). As seen from the causal graph, success for this contraption requires a very challenging synchronization between delicate event chains. In short, there are two balls involved (one initially free, and one in a cage), that need to escape the contraption and reach the teapot by opening each other's path along the way. Note that such a sequence is very difficult to manually author without computational guidance as proposed in this paper. On a lighter note, this kind of contraption illustrates the narrative power of Rube Goldberg machines, such as can be seen, e.g., in the Japanese show PythagoraSwitch.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.3">Quantitative Evaluation</head><p>Local and global robustness. We compare the output of different methods with the following measures of robustness. Let S be a scenario with design space D, and X ⊂ D a set of points decomposed as X = X + ∪X -∪X (respectively successes, failures and impossible instances). The local robustness ρ l : D × [0, 1] → [0, 1] is defined as</p><formula xml:id="formula_25">ρ l (x, ϵ) = | B ϵ (x)∩X + | | B ϵ (x)∩{X + ∪X -} | if x ∈ D \ D , 0 otherwise,</formula><p>where B ϵ (x) is the ball of radius ϵ centered at x ∈ D. In this formulation, ϵ represents a uniform error on the layout parameters, while ρ l is the success rate in the neighborhood B ϵ (x). The global robustness ρ д : D → [0, 1] is then defined as</p><formula xml:id="formula_26">ρ д (x) = ∫ 1 0 ρ l (x, ϵ)dϵ.</formula><p>In practice, the evaluation dataset X is computed from a relatively dense sampling of the design space (with 100K points for causali-tySwitch, and 1M points for the three others). Additional details on the computation of ρ l are provided in the supplemental.</p><p>Comparison with baseline methods. We define three baseline methods to compare against our technique:</p><p>(B1) Uniformly sample and simulate points in D until a successful configuration is found. (B2) Uniformly sample and simulate points in D, compute the local robustness x → ρ l (x, 0.1) for each, and take the best one.</p><p>(B3) Run a Bayesian Optimization with a Gaussian Process prior <ref type="bibr" target="#b30">[Shahriari et al. 2016</ref>] (initialized with uniform sampling) using x → ρ l (x, 0.1) as an objective function.   Each baseline is given the same 'simulation budget' B computed from our own method: we first run our method T times with a different random generator seed each time (with T = 10 in our experiments), and compute B as the average number of simulations carried out. Each baseline is then also run T times until B is reached (or until a success is found for baseline B1). The final local robustness curve is the average curve of the different trials.</p><p>Results in Figure <ref type="figure" target="#fig_14">15</ref> and Table <ref type="table" target="#tab_2">1</ref> show that our method outperforms the baselines for all four scenarios presented in Section 8.2. Interestingly, the Gaussian Process optimization (B3) appears to perform worse than the simpler uniform sampling (B2) in higher dimensions, which could be due to the presence of holes (i.e., components of D ) in the optimization landscape. Additionally, we demonstrate the positive impact of SPD factorization in Figure <ref type="figure" target="#fig_16">16</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.4">Limitations and Future Work</head><p>Our method is a first step towards the robustification of machines involving complex sequences of events. It presents several limitations that open exciting avenues for future improvements.</p><p>First, while our method does increase robustness to modeling biases, some neglected physical effects can still significantly influence the final execution, such as vibrations created by collisions, or tracks sagging under the weight of balls. Using a more realistic physical simulator would allow to take these secondary effects into account, as well as support more advanced primitives and events (e.g., involving cloths, fluids or fire), at the price of an increase in   <ref type="figure" target="#fig_14">15</ref> to compare two versions of our method for the longChain and teapotAdventure scenarios. 'Full' means that a single SVM was used over the entire design space, while 'Factorized' follows the method in Section 6.</p><p>simulation time. Second, it is assumed that the design space contains a continuous region of solutions, implying that the expected sequence of events is indeed possible. While it is unclear how this could be checked at design time, some heuristics could be developed to give feedback to the user and avoid the most obvious mistakes. Third, a better understanding of dysfunctional cases could help use simulations more efficiently, by stopping runs early if failure is expected. In the same vein, when building CSPD factors, further analysis could allow restarting simulations mid-run, i.e., from an initial state specific to each event, rather than starting all simulations from the same point. Lastly, the SPD computation could be improved in several ways. A clear next step is to try alternative classification models, such as neural networks, although SVMs present distinct advantages, such as the speed of training, the inherent ability to avoid overfitting, and the ease of sampling new points near the boundary for active learning. Performance could be improved by (i) using models supporting online training (i.e., allowing to train on new samples without retraining over the entire dataset), and (ii) using a more advanced stopping criterion for active learning. Besides these technical points, our work may appear very specific both in scope and audience. On one hand, Rube Goldberg machines are indeed a niche application; however, our work could be applied to more useful real-world mechanisms involving sequences of events, such as locks, pop-up tents and ejection seats, to name a few. Indeed, while we chose to limit our design space to layout parameters (as components were assumed to be preexisting), nothing prevents the inclusion of other geometric and physical parameters (although additional physical validity checks may have to be performed). The part requiring an extension would be the causal graph itself: indeed, it would need to support additional features such as disjunctions (i.e., 'if/else' paths), 'or' preconditions (i.e., checking for an event condition if any of its parent events happened) and duration-based events (i.e., with a condition expected to be true for a given amount of time). However, this does not fundamentally change the method in Section 5; as for the factorization in Section 6, it only requires the graph to be directed and acyclic. On the other hand, regarding the audience, while it is true that the expected input (scene, causal graph and parameter ranges) is demanding for novice users, we envision our work as part of a larger workflow where such data could be automatically generated from a more intuitive user input; this problem is left as an exciting avenue for future research.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9">CONCLUSION</head><p>We presented a computational approach to help design chain reaction contraptions by optimizing the components' layout for a target sequence of events specified as a causal graph. We specifically focused on robustifying the design against modeling bias and manual assembly errors. At the core of the method is the computation of a success probability distribution (SPD) that provides an approximate measure of robustness to uncertainties. We combined simulationbased search and machine learning techniques to build the SPD, before using it to obtain a robust design layout. We showed significant improvement over baseline methods across a wide range of dimensions, and validated our method by physically realizing a set of complex Rube Goldberg machines optimized with our technique.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. simple scenario. A ball rolls on a track and triggers the fall of a sequence of dominoes. A succession of snapshots taken from the simulation (top) is matched with the events of this scenario's causal graph (bottom). (Ticks along the timeline are uniformly spread for clearer visualization.)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 4 .</head><label>4</label><figDesc>Fig. 4. Primitive types. The above primitive types are available to the user in our implementation. The color hues correspond to the different types of behavior in the physically-based simulation. Arrows indicate the motion type allowed by the constraint. Please see the supplementary for details.</figDesc><graphic coords="5,81.50,158.32,114.81,64.58" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 5 .</head><label>5</label><figDesc>Fig. 5. Event types. The above events are supported in our implementation. Each event's condition c e (t ) is a function of the spatial transform (and corresponding time derivative) of the target object(s) at time t . Events may also have a negated version (e.g., 'o 1 stops' being equivalent to 'o 1 does not move'). Please see the supplementary for details.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 6 .</head><label>6</label><figDesc>Fig.6. branching scenario. A first domino run (top left of the view) topples and hits a plank, which in turns triggers two parallel branches: on one side, a second domino run topples and falls on a lever, which pivots; on the other, a ball rolls on a track, passes below the now-raised lever, and falls into a goblet. As in Figure3, snapshots are matched with events from the causal graph. The two arrows pointing towards event H mean that both E and G need to have happened for H to happen; i.e., the ball can only fall if it started rolling and the lever was raised.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 7 .</head><label>7</label><figDesc>Fig. 7. Design space. Abstract representation of a slice of a design space D, divided into success (D + ), failure (D -) and impossible (D ) regions. On the left, an idealized view shows each region unambiguously defined, and a layout x clearly positioned. On the right, uncertainties are taken into account: the realization of a layout is now only close to x with a certain probability, while its success or failure also become probabilistic. In other words, points near the success boundary ∂D + are likely to fail in real life.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig. 8 .</head><label>8</label><figDesc>Fig. 8. Building the SPD. Top: main steps of our global SPD approximation method. Bottom: detail of the active learning loop: at iteration k , we use the current dataset X (left) to train an SVM (middle; classification shown as background colors). The new support vectors (black dots) are used to build a new distribution D k (right; probability density shown in white) that encourages additional sampling where the classifier is the most uncertain (i.e., near the boundary).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>ACM Trans. Graph., Vol. 38, No. 4, Article 43. Publication date: July 2019.Designing Chain Reaction Contraptions from Causal Graphs • 43:7 Algorithm 2 Classifier training and query synthesis. 1: y ← ComputeLabels(X ) // Simulate each sample. 2: k ← 0 3: // Initial classifier training 4: f k , { xi } v i =1 , U , acc ← TrainEstimator(X, y) 5: while k ≤ k l and acc ≥ 0</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Fig. 9 .</head><label>9</label><figDesc>Fig. 9. SPD Visualization. A slice of our learned SPD approximation (top), with three instances (bottom) sampled from the design space of our simple scenario from Figure 3. The two dimensions of D shown here are the normalized X and Z coordinates of the track center (fixed slope). The color range is discretized for clearer visualization of the isolevels. We observe that both (a) and (b) belong to an elongated region where the ball hits the top left corner of the first domino, while in (c) it clearly misses the domino run.</figDesc><graphic coords="8,457.46,206.79,107.57,107.57" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Fig. 10 .</head><label>10</label><figDesc>Fig.10. Extended SPD building pipeline. We propose an extended version of our SPD building to scale with a high-dimensional design space.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Fig. 11 .</head><label>11</label><figDesc>Fig. 11. ballRun scenario. A ball rolls on a sequence of tracks and falls into a goblet. To open the entrance, it needs to hit the left plank, to make it fall, triggering the fall of the right plank via the bottom lever. Timing control is needed to ensure that the right plank falls before the ball reaches the goblet. Top: initial state; bottom: final state. See supplemental video.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Fig. 12 .FFig. 13 .</head><label>1213</label><figDesc>Fig. 12. causalitySwitch scenario. A branching domino run topples and triggers two parallel branches. On one side ('left'), a ball rolls down a track and topples a short straight domino run. On the 'right' side, a plank falls and topples a long, curved domino run. Whichever side is faster (in this figure: the left one) triggers the 'domino switch', closing the path of the other side.</figDesc><graphic coords="11,-30.64,336.12,282.93,159.15" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head></head><label></label><figDesc>Fig. 14. teapotAdventure scenario. See Figure 1 for initial layout. This figure shows rendered versus assembled layouts for start and end frames of the optimized layout. Ball 1 triggers the fall of the middle gate, releasing ball 2. Ball 2 hits the gate and takes the left route, falling on a lever so that ball 1 can roll underneath. Ball 2 then makes the central weight fall, liberating the bottom bridge. Both balls then meet in the teapot. Please see the supplementary video.</figDesc><graphic coords="12,-5.00,76.76,228.87,128.74" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>Fig. 15 .</head><label>15</label><figDesc>Fig. 15. Local robustness plots. Average local robustness ρ l (x * , ϵ ) as a function of the error ϵ on the layout parameters x * output by each method, for problems of different dimension d . Each curve is surrounded by a standard error of the mean interval (with T = 10 runs per method). Scenarios are respectively causalitySwitch, ballRun, longChain and teapotAdventure.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head></head><label></label><figDesc>Error ϵ on the output layout parameters x *</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head>Fig. 16 .</head><label>16</label><figDesc>Fig. 16. Full versus factorized SPD. We use the same metric as in Figure15to compare two versions of our method for the longChain and teapotAdventure scenarios. 'Full' means that a single SVM was used over the entire design space, while 'Factorized' follows the method in Section 6.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>Simulate each new sample.</figDesc><table><row><cell>14:</cell><cell>// Classifier training</cell></row><row><cell>15:</cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 1 .</head><label>1</label><figDesc>Experiments statistics. Both global robustness and processing time are averages of T = 10 random trials. The simulation step was 0.002s.</figDesc><table><row><cell>Scenario</cell><cell>Number of param. d</cell><cell>Max. simu. time (s)</cell><cell>Simu. budget B</cell><cell>Global robustness ρ д (x  *  ) B1 B2 B3 Ours</cell><cell cols="4">Processing time (s) B1 B2 B3 Ours</cell></row><row><cell>causalitySwitch</cell><cell>4</cell><cell>4</cell><cell>614</cell><cell cols="2">0.44 0.59 0.63 0.65 263</cell><cell>282</cell><cell>463</cell><cell>364</cell></row><row><cell>ballRun</cell><cell>8</cell><cell>4</cell><cell>1120</cell><cell>0.34 0.35 0.40 0.48</cell><cell>59</cell><cell>52</cell><cell>786</cell><cell>153</cell></row><row><cell>longChain</cell><cell>11</cell><cell>5</cell><cell>1915</cell><cell cols="5">0.09 0.13 0.13 0.16 1499 1597 1956 636</cell></row><row><cell>teapotAdventure</cell><cell>16</cell><cell>8</cell><cell>2420</cell><cell cols="3">0.16 0.23 0.14 0.27 536 536</cell><cell>988</cell><cell>779</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_0"><p>ACM Trans. Graph., Vol. 38, No. 4, Article 43. Publication date: July 2019.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div><head>ACKNOWLEDGEMENTS</head><p>We are grateful to the reviewers for their helpful feedback. We thank <rs type="person">Dan Koschier</rs> for proofreading the paper, <rs type="person">Tobias Ritschel</rs> and <rs type="person">Simon Julier</rs> for their valuable comments and <rs type="person">Mohamed Sayed</rs> for the video voiceover. This work was funded by an <rs type="funder">ERC</rs> <rs type="grantName">Starting Grant</rs> (SmartGeometry StG-2013-335373), an <rs type="funder">ERC</rs> <rs type="grantName">PoC Grant</rs> (<rs type="affiliation">Semantic-City</rs>), a <rs type="funder">Google Faculty Award</rs>, a <rs type="funder">Royal Society Advanced Newton Fellowship</rs> and gifts from Adobe.</p></div>
			</div>
			<listOrg type="funding">
				<org type="funding" xml:id="_GKMTYpu">
					<orgName type="grant-name">Starting Grant</orgName>
				</org>
				<org type="funding" xml:id="_b5cjRaE">
					<orgName type="grant-name">PoC Grant</orgName>
				</org>
			</listOrg>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<author>
			<persName><forename type="first">Moritz</forename><surname>Bächer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stelian</forename><surname>Coros</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bernhard</forename><surname>Thomaszewski</surname></persName>
		</author>
		<idno type="DOI">10.1145/2766985</idno>
		<ptr target="https://doi.org/10.1145/2766985" />
	</analytic>
	<monogr>
		<title level="m">LinkEdit: Interactive Linkage Editing Using Symbolic Kinematics</title>
		<imprint>
			<date type="published" when="2015-07">2015. July 2015</date>
			<biblScope unit="volume">34</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Spin-it: Optimizing Moment of Inertia for Spinnable Objects</title>
		<author>
			<persName><forename type="first">Moritz</forename><surname>Bächer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Emily</forename><surname>Whiting</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bernd</forename><surname>Bickel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Olga</forename><surname>Sorkine-Hornung</surname></persName>
		</author>
		<idno type="DOI">10.1145/2601097.2601157</idno>
		<ptr target="https://doi.org/10.1145/2601097.2601157" />
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Graph</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="page" from="1" to="96" />
			<date type="published" when="2014">2014. 2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">State of the Art in Methods and Representations for Fabrication-Aware Design</title>
		<author>
			<persName><forename type="first">H</forename><surname>Amit</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Bermano</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Szymon</forename><surname>Funkhouser</surname></persName>
		</author>
		<author>
			<persName><surname>Rusinkiewicz</surname></persName>
		</author>
		<idno type="DOI">10.1111/cgf.13146</idno>
		<ptr target="https://doi.org/10.1111/cgf.13146" />
	</analytic>
	<monogr>
		<title level="j">Computer Graphics Forum</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="509" to="535" />
			<date type="published" when="2017-05">2017. May 2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Forward Selection as a Candidate for Constructing Nonregular Robust Parameter Designs</title>
		<author>
			<persName><forename type="first">K</forename><surname>Brewer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Carraway</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Ingram</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
		<respStmt>
			<orgName>Arkansas State University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Designing and Fabricating Mechanical Automata from Mocap Sequences</title>
		<author>
			<persName><forename type="first">Wilmot</forename><surname>Duygu Ceylan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Niloy</forename><forename type="middle">J</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Maneesh</forename><surname>Mitra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mark</forename><surname>Agrawala</surname></persName>
		</author>
		<author>
			<persName><surname>Pauly</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGGRAPH Asia</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="page">11</biblScope>
			<date type="published" when="2013">2013. 2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Dynamics-aware Numerical Coarsening for Fabrication Design</title>
		<author>
			<persName><forename type="first">Desai</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">W</forename><surname>David</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wojciech</forename><surname>Levin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Danny</forename><forename type="middle">M</forename><surname>Matusik</surname></persName>
		</author>
		<author>
			<persName><surname>Kaufman</surname></persName>
		</author>
		<idno type="DOI">10.1145/3072959.3073669</idno>
		<ptr target="https://doi.org/10.1145/3072959.3073669" />
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Graph</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="page">15</biblScope>
			<date type="published" when="2017-07">2017. July 2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Computational Design of Mechanical Characters</title>
		<author>
			<persName><forename type="first">Stelian</forename><surname>Coros</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bernhard</forename><surname>Thomaszewski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gioacchino</forename><surname>Noris</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shinjiro</forename><surname>Sueda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Moira</forename><surname>Forberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Robert</forename><forename type="middle">W</forename><surname>Sumner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wojciech</forename><surname>Matusik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bernd</forename><surname>Bickel</surname></persName>
		</author>
		<idno type="DOI">10.1145/2461912.2461953</idno>
		<ptr target="https://doi.org/10.1145/2461912.2461953" />
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Graph</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="page" from="1" to="83" />
			<date type="published" when="2013">2013. 2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title/>
		<ptr target="https://github.com/bulletphysics/bullet3" />
	</analytic>
	<monogr>
		<title level="j">Bullet Physics SDK</title>
		<imprint>
			<date type="published" when="2018-01-01">2018. 2018-01-01</date>
			<publisher>Erwan Coumans</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<author>
			<persName><forename type="first">Thomas</forename><forename type="middle">M</forename><surname>Cover</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Joy</forename><forename type="middle">A</forename><surname>Thomas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Elements of Information Theory</title>
		<title level="s">Wiley Series in Telecommunications and Signal Processing</title>
		<meeting><address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Wiley-Interscience</publisher>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">The Way Things Go</title>
		<author>
			<persName><forename type="first">Peter</forename><surname>Fischli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Weiss</surname></persName>
		</author>
		<ptr target="https://www.youtube.com/watch?v=GXrRC3pfLnE" />
		<imprint>
			<date type="published" when="1987">1987</date>
			<biblScope unit="page" from="2018" to="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Kinetic Art Design System Comprising Rigid Body Simulation</title>
		<author>
			<persName><forename type="first">Yohsuke</forename><surname>Furuta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jun</forename><surname>Mitani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Takeo</forename><surname>Igarashi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yukio</forename><surname>Fukui</surname></persName>
		</author>
		<idno type="DOI">10.3722/cadaps.2010.533-546</idno>
		<ptr target="https://doi.org/10.3722/cadaps.2010.533-546" />
	</analytic>
	<monogr>
		<title level="j">Computer-Aided Design and Applications</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="533" to="546" />
			<date type="published" when="2010">2010. 2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Computational design of reconfigurables</title>
		<author>
			<persName><forename type="first">Akash</forename><surname>Garg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alec</forename><surname>Jacobson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Eitan</forename><surname>Grinspun</surname></persName>
		</author>
		<idno type="DOI">10.1145/2897824.2925900</idno>
		<ptr target="https://doi.org/10.1145/2897824.2925900" />
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Graph</title>
		<imprint>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="page" from="1" to="14" />
			<date type="published" when="2016">2016. 2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title/>
		<author>
			<persName><surname>Honda</surname></persName>
		</author>
		<ptr target="https://www.youtube.com/watch?v=Z57kGB-mI54" />
		<imprint>
			<date type="published" when="2003">2003. 2018-01-01</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Modeling with Time and Events in Computer Animation</title>
		<author>
			<persName><forename type="first">Devendra</forename><surname>Kalra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alan</forename><forename type="middle">H</forename><surname>Barr</surname></persName>
		</author>
		<idno type="DOI">10.1111/1467-8659.1130045</idno>
		<ptr target="https://doi.org/10.1111/1467-8659.1130045" />
	</analytic>
	<monogr>
		<title level="j">Computer Graphics Forum</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="45" to="58" />
			<date type="published" when="1992-05">1992. may 1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Development and Application of STEAM Teaching Model Based on the Rube Goldberg&apos;s Invention</title>
		<author>
			<persName><forename type="first">Yilip</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Namje</forename><surname>Park</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Science and its Applications</title>
		<editor>
			<persName><forename type="first">Soo</forename><surname>Yeo</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Yi</forename><surname>Pan</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Yang</forename><surname>Sun Lee</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Hang</forename><surname>Bae</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Chang</forename></persName>
		</editor>
		<meeting><address><addrLine>Netherlands, Dordrecht</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="693" to="698" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">A Software Package for Sequential Quadratic Programming</title>
		<author>
			<persName><forename type="first">Dieter</forename><surname>Kraft</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1988">1988</date>
			<pubPlace>Oberpfaffenhofen</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Institut fuer Dynamik der Flugsysteme</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Applications of lp-Norms and their Smooth Approximations for Gradient Based Learning Vector Quantization</title>
		<author>
			<persName><forename type="first">Mandy</forename><surname>Lange</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dietlind</forename><surname>Zühlke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Olaf</forename><surname>Holz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Villmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ESANN</title>
		<meeting><address><addrLine>Bruges</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="271" to="276" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Causal inference from graphical models</title>
		<author>
			<persName><surname>Steffen L Lauritzen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Complex stochastic systems</title>
		<imprint>
			<biblScope unit="page" from="63" to="107" />
			<date type="published" when="2001">2001. 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Foldabilizing Furniture</title>
		<author>
			<persName><forename type="first">Honghua</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ruizhen</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ibraheem</forename><surname>Alhashim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hao</forename><surname>Zhang</surname></persName>
		</author>
		<idno type="DOI">10.1145/2766912</idno>
		<ptr target="https://doi.org/10.1145/2766912" />
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Graph</title>
		<imprint>
			<biblScope unit="volume">34</biblScope>
			<biblScope unit="page">12</biblScope>
			<date type="published" when="2015-07">2015. July 2015</date>
		</imprint>
	</monogr>
	<note>Article</note>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Recovering Functional Mechanical Assemblies from Raw Scans</title>
		<author>
			<persName><forename type="first">M</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Shao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Zheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">J</forename><surname>Mitra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Zhou</surname></persName>
		</author>
		<idno type="DOI">10.1109/TVCG.2017.2662238</idno>
		<ptr target="https://doi.org/10.1109/TVCG.2017.2662238" />
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="1354" to="1367" />
			<date type="published" when="2018-03">2018. March 2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Computational Design and Fabrication of Soft Pneumatic Objects with Desired Deformations</title>
		<author>
			<persName><forename type="first">Li-Ke</forename><surname>Ma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yizhonc</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yang</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kun</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xin</forename><surname>Tong</surname></persName>
		</author>
		<idno type="DOI">10.1145/3130800.3130850</idno>
		<ptr target="https://doi.org/10.1145/3130800.3130850" />
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Graph</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page">12</biblScope>
			<date type="published" when="2017-11">2017. Nov. 2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Illustrating How Mechanical Assemblies Work</title>
		<author>
			<persName><forename type="first">J</forename><surname>Niloy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yong-Liang</forename><surname>Mitra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dong-Ming</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wilmot</forename><surname>Yan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Maneesh</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><surname>Agrawala</surname></persName>
		</author>
		<idno type="DOI">10.1145/1833351.1778795</idno>
		<ptr target="https://doi.org/10.1145/1833351.1778795" />
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Graph</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="page" from="1" to="11" />
			<date type="published" when="2010">2010. 2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Probabilistic Outputs for Support Vector Machines and Comparisons to Regularized Likelihood Methods</title>
		<author>
			<persName><forename type="first">John</forename><forename type="middle">C</forename><surname>Platt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Large Margin Classifiers</title>
		<imprint>
			<publisher>MIT Press</publisher>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="61" to="74" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">Top 10 Chain Reaction Tips | Rube Goldberg HowTo</title>
		<author>
			<persName><forename type="first">Steve</forename><surname>Price</surname></persName>
		</author>
		<ptr target="https://www.youtube.com/watch?v=p8Wwq_B5S7I" />
		<imprint>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="2018" to="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">The Taguchi methodology as a statistical tool for biotechnological applications: A critical appraisal</title>
		<author>
			<persName><forename type="first">Ravella</forename><surname>Sreenivas Rao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Ganesh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">Shetty</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Phil</forename><forename type="middle">J</forename><surname>Prakasham</surname></persName>
		</author>
		<author>
			<persName><surname>Hobbs</surname></persName>
		</author>
		<idno type="DOI">10.1002/biot.200700201</idno>
		<ptr target="https://doi.org/10.1002/biot" />
	</analytic>
	<monogr>
		<title level="j">Biotechnology Journal</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="510" to="523" />
			<date type="published" when="2008">2008. 2008. 200700201</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">From linear story generation to branching story graphs</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">O</forename><surname>Riedl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">M</forename><surname>Young</surname></persName>
		</author>
		<idno type="DOI">10.1109/MCG.2006.56</idno>
		<ptr target="https://doi.org/10.1109/MCG.2006.56" />
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Graphics and Applications</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="23" to="31" />
			<date type="published" when="2006-05">2006. May 2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Interactive Exploration of Design Trade-offs</title>
		<author>
			<persName><forename type="first">Adriana</forename><surname>Schulz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Harrison</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Eitan</forename><surname>Crinspun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Justin</forename><surname>Solomon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wojciech</forename><surname>Matusik</surname></persName>
		</author>
		<idno type="DOI">10.1145/3197517.3201385</idno>
		<ptr target="https://doi.org/10.1145/3197517.3201385" />
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Graph</title>
		<imprint>
			<biblScope unit="volume">37</biblScope>
			<date type="published" when="2018-07">2018. July 2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Interactive Design Space Exploration and Optimization for CAD Models</title>
		<author>
			<persName><forename type="first">Adriana</forename><surname>Schulz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jie</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bo</forename><surname>Zhu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Changxi</forename><surname>Zheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Eitan</forename><surname>Grinspun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wojciech</forename><surname>Matusik</surname></persName>
		</author>
		<idno type="DOI">10.1145/3072959.3073688</idno>
		<ptr target="https://doi.org/10.1145/3072959.3073688" />
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Graph</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<date type="published" when="2017-07">2017. July 2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Coordinating multiple representations for reasoning about mechanical devices</title>
		<author>
			<persName><forename type="first">L</forename><surname>Daniel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mary</forename><surname>Schwartz</surname></persName>
		</author>
		<author>
			<persName><surname>Hegarty</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the AAAI Spring Symposium on Cognitive and Computational Models of Spatial Representation</title>
		<meeting>the AAAI Spring Symposium on Cognitive and Computational Models of Spatial Representation<address><addrLine>Menlo Park, CA</addrLine></address></meeting>
		<imprint>
			<publisher>AAAI Press</publisher>
			<date type="published" when="1996">1996</date>
			<biblScope unit="page">9</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Active learning</title>
		<author>
			<persName><forename type="first">Burr</forename><surname>Settles</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Synthesis Lectures on Artificial Intelligence and Machine Learning</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="1" to="114" />
			<date type="published" when="2012">2012. 2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Taking the Human Out of the Loop: A Review of Bayesian Optimization</title>
		<author>
			<persName><forename type="first">B</forename><surname>Shahriari</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Swersky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">P</forename><surname>Adams</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>De Freitas</surname></persName>
		</author>
		<idno type="DOI">10.1109/JPROC.2015.2494218</idno>
		<ptr target="https://doi.org/10.1109/JPROC.2015.2494218" />
	</analytic>
	<monogr>
		<title level="j">Proc. IEEE</title>
		<imprint>
			<biblScope unit="volume">104</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="148" to="175" />
			<date type="published" when="2016-01">2016. Jan 2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Fab Forms: Customizable Objects for Fabrication with Validity and Geometry Caching</title>
		<author>
			<persName><forename type="first">Maria</forename><surname>Shugrina</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ariel</forename><surname>Shamir</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wojciech</forename><surname>Matusik</surname></persName>
		</author>
		<idno type="DOI">10.1145/2766994</idno>
		<ptr target="https://doi.org/10.1145/2766994" />
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Graph</title>
		<imprint>
			<biblScope unit="volume">34</biblScope>
			<biblScope unit="page">12</biblScope>
			<date type="published" when="2015-07">2015. July 2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">On the distribution of points in a cube and the approximate evaluation of integrals</title>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">M</forename><surname>Sobol</surname></persName>
		</author>
		<author>
			<persName><forename type="first">'</forename></persName>
		</author>
		<idno type="DOI">10.1016/0041-5553(67)90144-9</idno>
		<ptr target="https://doi.org/10.1016/0041-5553(67)90144-9" />
	</analytic>
	<monogr>
		<title level="j">U. S. S. R. Comput. Math. and Math. Phys</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="86" to="112" />
			<date type="published" when="1967">1967. 1967</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Computational Design of Wind-up Toys</title>
		<author>
			<persName><forename type="first">Peng</forename><surname>Song</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xiaofei</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xiao</forename><surname>Tang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Chi-Wing</forename><surname>Fu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hongfei</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ligang</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Niloy</forename><forename type="middle">J</forename><surname>Mitra</surname></persName>
		</author>
		<idno type="DOI">10.1145/3130800.3130808</idno>
		<ptr target="https://doi.org/10.1145/3130800.3130808" />
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Graph</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page">13</biblScope>
			<date type="published" when="2017-11">2017. Nov. 2017</date>
		</imprint>
	</monogr>
	<note>Article</note>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Computational Design of Linkage-based Characters</title>
		<author>
			<persName><forename type="first">Bernhard</forename><surname>Thomaszewski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stelian</forename><surname>Coros</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Damien</forename><surname>Gauge</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vittorio</forename><surname>Megaro</surname></persName>
		</author>
		<idno type="DOI">10.1145/2601097.2601143</idno>
		<ptr target="https://doi.org/10.1145/2601097.2601143" />
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Graph</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<date type="published" when="2014-07">2014. July 2014</date>
		</imprint>
	</monogr>
	<note>Eitan Grinspun, and Markus Gross</note>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Learning Three-dimensional Flow for Interactive Aerodynamic Design</title>
		<author>
			<persName><forename type="first">Nobuyuki</forename><surname>Umetani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bernd</forename><surname>Bickel</surname></persName>
		</author>
		<idno type="DOI">10.1145/3197517.3201325</idno>
		<ptr target="https://doi.org/10.1145/3197517.3201325" />
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Graph</title>
		<imprint>
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="page">10</biblScope>
			<date type="published" when="2018-07">2018. July 2018</date>
		</imprint>
	</monogr>
	<note>Article</note>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Pteromys: Interactive Design and Optimization of Free-formed Free-flight Model Airplanes</title>
		<author>
			<persName><forename type="first">Nobuyuki</forename><surname>Umetani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yuki</forename><surname>Koyama</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ryan</forename><surname>Schmidt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Takeo</forename><surname>Igarashi</surname></persName>
		</author>
		<idno type="DOI">10.1145/2601097.2601129</idno>
		<ptr target="https://doi.org/10.1145/2601097.2601129" />
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Graph</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="page" from="1" to="10" />
			<date type="published" when="2014">2014. 2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Motion-guided Mechanical Toy Modeling</title>
		<author>
			<persName><forename type="first">Lifeng</forename><surname>Zhu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Weiwei</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">John</forename><surname>Snyder</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yang</forename><surname>Liu</surname></persName>
		</author>
		<idno type="DOI">10.1145/2366145.2366146</idno>
		<ptr target="https://doi.org/10.1145/2366145.2366146" />
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Graph</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="page">10</biblScope>
			<date type="published" when="2012-11">2012. Nov. 2012</date>
		</imprint>
	</monogr>
	<note>Article</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
