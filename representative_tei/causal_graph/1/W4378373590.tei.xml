<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Metamorphic Testing with Causal Graphs</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Andrew</forename><forename type="middle">G</forename><surname>Clark</surname></persName>
							<email>agclark2@sheffield.ac.uk</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Sheffield</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Michael</forename><surname>Foster</surname></persName>
							<email>m.foster@sheffield.ac.uk</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Sheffield</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Neil</forename><surname>Walkinshaw</surname></persName>
							<email>n.walkinshaw@sheffield.ac.uk</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Sheffield</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Robert</forename><forename type="middle">M</forename><surname>Hierons</surname></persName>
							<email>r.hierons@sheffield.ac.uk</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Sheffield</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Metamorphic Testing with Causal Graphs</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="DOI">10.1109/ICST57152.2023.00023</idno>
					<note type="submission">Version: Accepted Version Proceedings Paper:</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.1" ident="GROBID" when="2025-10-14T18:27+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Metamorphic testing provides a means by which to generate succinct test oracles that can apply to large input spaces. For this it depends on the formulation of metamorphic relations, which generally require extensive domain expertise and human input. To address this problem, we present a model-based testing approach that can automatically generate metamorphic relations and associated tests. Our approach is motivated by the observation that metamorphic testing is a fundamentally causal task. We show how it is possible to leverage lightweight graphbased modelling techniques from the field of causal inference to specify causal properties of the system-under-test. Through a series of controlled experiments, we find that the proposed approach is robust to misspecification and can test evasive causal relationships (i.e. those that are difficult to exercise and observe) when combined with an appropriate test generation strategy. We also apply the approach to two case studies from the Defects4J framework with known bugs that affect causal behaviour. The results of these case studies suggest that the approach is not only useful for catching bugs affecting causal structure, but also alerting the user to inaccuracies in the specification.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Reuse</head><p>Items deposited in White Rose Research Online are protected by copyright, with all rights reserved unless indicated otherwise. They may be downloaded and/or printed for private study, or other acts as permitted by national copyright laws. The publisher or other rights holders may allow further reproduction and re-use of the full text version. This is indicated by the licence information on the White Rose Research Online record for the item.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Takedown</head><p>If you consider content in White Rose Research Online to be in breach of UK law, please notify us by emailing eprints@whiterose.ac.uk including the URL of the record and the reason for the withdrawal request.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I. Introduction</head><p>Metamorphic testing provides an approach for reasoning about the correctness of a system's output in terms of changes to its inputs <ref type="bibr" target="#b0">[1]</ref>. In this way, a single "metamorphic relationship" can be used to succinctly summarise the expected results for a potentially infinite range of inputs, as opposed to the conventional approach of writing test oracles that check the results for specific individual inputs. As a result, metamorphic testing has been successfully applied to various classes of systems that have traditionally been perceived as being particularly hard to test <ref type="bibr" target="#b1">[2]</ref>, such as machine learning systems <ref type="bibr" target="#b2">[3]</ref> and compilers <ref type="bibr" target="#b3">[4]</ref>.</p><p>One barrier to the widespread application of metamorphic testing is the difficulty of formulating metamorphic relationships <ref type="bibr" target="#b1">[2]</ref>, <ref type="bibr" target="#b0">[1]</ref>. Although several advances into semi-automatic metamorphic relation construction have been made <ref type="bibr" target="#b0">[1]</ref>, existing approaches have significant limitations. Techniques that reverse-engineer metamorphic relations from executions <ref type="bibr" target="#b4">[5]</ref> risk reverse-engineering faulty relations if the underlying code is faulty. Other approaches are restricted to specific domains <ref type="bibr" target="#b5">[6]</ref>. Ultimately, the construction of metamorphic relations is a difficult task for which there is no technique that is both generalisable and reliable. Instead, the burden of this task typically falls to an experienced tester or domain expert who must rely upon their ingenuity and intuition.</p><p>The approach proposed in this paper is based on the observation that metamorphic testing is an inherently causal activity: a transformation is applied to an input in order to establish the causal effect on an output. When viewed from this perspective, there are several powerful approaches to modelling and reasoning about causality, which have become particularly widespread in areas such as epidemiology <ref type="bibr" target="#b6">[7]</ref>. The authors are, however, not aware of any efforts to use these approaches to systematically generate metamorphic tests.</p><p>In this paper we propose a causal, model-based approach to the generation of metamorphic relations and test cases. Our approach is centred around causal directed acyclic graphs (DAGs) <ref type="bibr" target="#b7">[8]</ref>, a well-established and extremely simple graphical model that has been used extensively to model causal relationships in a wide range of disciplines. We show how causal DAGs can be used to model the expected causal relationships between inputs and outputs in a software system, and how these can be used in turn to automatically generate metamorphic relations and their test cases. Through a series of controlled experiments and real-world case studies, we then evaluate the ability of our approach to detect a specific class of bugs that modify the causal structure of the program-under-test and that appear in all forms of software.</p><p>Overall, we make the following contributions:</p><p>• We present an approach to metamorphic testing that uses causal graphs to automatically generate metamorphic relations with their source and follow-up test cases. • We perform a controlled experiment to analyse the ability of our approach to detect structural causal bugs under increasingly challenging conditions. • We apply our technique to real-world software from the Defects4J framework with known structural causal bugs. The remainder of this paper is structured as follows. Section II introduces a motivating example and provides the necessary background for this paper. Section III defines causal bugs and provides evidence that such bugs are common in software engineering. Section IV describes our process for creating metamorphic relations from causal DAGs. Section V presents an empirical evaluation of our technique before discussing the results in Section VI and demonstrating its application to two real-world case studies in Section VII. Section VIII then discusses related works in the literature and Section IX concludes the paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>II. Background</head><p>This section discusses the necessary background for this work in the context of a toy example. Consider a simple program which calculates a person's BMI from their weight and height, and outputs a classification of "overweight", "underweight" or "healthy weight" based on this. Our goal is to test this program.</p><p>Metamorphic Testing: Determining whether a program produces the correct output in response to a given input depends on the availability of a "test oracle". In many practical situations, however, the intended behaviour of the software might be poorly documented or understood. The resulting challenge of providing a reliable verdict on a test execution is known as the "oracle problem" <ref type="bibr" target="#b8">[9]</ref>.</p><p>Metamorphic testing <ref type="bibr" target="#b9">[10]</ref> is a promising solution to this problem <ref type="bibr" target="#b10">[11]</ref>. The overarching concept is to consider an input and a transformation to be applied to that input. The expected output behaviour is then characterised by a corresponding transformation in the output space. This allows us to define the oracle in relative terms, which is often simpler than determining if a given output is correct. Collectively, these components are specified in what is known as a "metamorphic relation" (MR). We provide a formal definition below. Definition 1. A metamorphic relation is a functional property of the system-under-test, S , that expresses how a given source test case (x s ) can be transformed into a follow-up test case (x f ) in such a way that some property over the outputs of these test cases can be anticipated, such as equality: S (x s ) = S (x f ).</p><p>Let us consider an MR for our BMI example. For a person of weight w and height h, BMI = w /h 2 . From this formula, we can derive the mutation relation BMI(kw, h) = kBMI(w, h) using basic arithmetic. This gives us our source test case as {W = w, H = h} and we can generate a follow-up test case {W = kw, H = h}. We then simply run both the source and follow-up test cases for various concrete values of w, h, and k and check if their outputs are equivalent.</p><p>Metamorphic testing is appealing because it presents an intuitive means by which to succinctly express properties against which to check software correctness <ref type="bibr" target="#b0">[1]</ref>. Using MRs, the generation of test sets is often straightforward, especially with the help of tools such as JFuzz <ref type="bibr" target="#b11">[12]</ref> and approaches such as iterative metamorphic testing <ref type="bibr" target="#b12">[13]</ref>.</p><p>A key barrier to the application of metamorphic testing lies in the construction of MRs <ref type="bibr" target="#b0">[1]</ref>. Although techniques have been developed to aid MR construction <ref type="bibr" target="#b0">[1]</ref>, <ref type="bibr" target="#b1">[2]</ref>, they tend to rely heavily on the tester's intuition or on the availability of a reasonably expansive and established specification <ref type="bibr" target="#b13">[14]</ref>.</p><p>Causal Graphs: Our work is based on the observation that metamorphic testing is an inherently causal activity. Drawing on this similarity, we leverage well-established causal modelling approaches to develop a systematic approach for constructing and testing MRs. Here we provide the relevant background on graphical causal models.</p><p>Discerning causation from association is a notoriously challenging task that calls upon significant domain expertise. Specifically, we need to identify and control for variables that bias the causal relationships of interest. This is particularly challenging when dealing with complex phenomena that accumulate large quantities of data involving many variables and relationships, such as large-scale software systems.</p><p>To address this problem, researchers in the field of causal inference developed a lightweight graphical model known as the causal graph <ref type="bibr" target="#b6">[7]</ref>, <ref type="bibr" target="#b7">[8]</ref>. Causal graphs provide a means to capture potential causal relationships between variables and are supported by an extensive mathematical framework. In particular, this framework can (semi-)automatically identify biasing variables and, thus, help to design statistical experiments capable of quantifying salient cause-effect relationships. Examples can be seen in Figures <ref type="figure" target="#fig_1">1b,</ref><ref type="figure" target="#fig_4">5</ref>, and 7. Definition 2. A causal graph G is a directed acyclic graph (DAG) G = (V, E) comprising a set of nodes representing random variables, V, and a set of edges, E, representing causality between these variables, where:</p><p>1) The presence/absence of an edge V i → V j represents the presence/absence of a direct causal effect of V i on V j . 2) All common causes of any pair of variables on the graph are themselves present on the graph.</p><p>Note that, unlike frameworks such as structural equation modelling <ref type="bibr" target="#b14">[15]</ref>, causal graphs do not specify the functional form of causal relationships, merely their presence, absence, and direction. From a testing standpoint, the lightweight nature of this model is desirable as it requires less input from the user.</p><p>Causal and Independence Relations: Causal graphs explicitly indicate which variables may (and, conversely, may not) affect each other by the presence (or absence) of edges. If a change to some variable of interest X (referred to a treatment) has no bearing on another variable Y (referred to as an outcome), i.e. P(X | Y) = P(X), the two are said to be independent. In a situation where P(X | Y, Z) = P(X | Y), we say that X and Y are conditionally independent given Z. Conversely, if X can be changed in a way that evokes a response in Y, we say that X causes Y.</p><p>Interventions: Causality concerns the effect of changes, actions, and policies; such terms are commonly referred to as interventions. Informally, an intervention is an external change to some variable in a system that forces that variable to take a specific value. We denote the act of intervening on a variable, X, to take a value x using Pearl's do notation <ref type="bibr" target="#b7">[8]</ref>: do(X = x). Viewed on a causal graph, do(X = x) removes all incoming edges to X as it overrides the causal information flowing through the causes of X. Furthermore, the value that an output Y takes upon performing do(X = x) is denoted as Y X=x .</p><p>Total and Direct Effects: Given a treatment X and an outcome Y, there are two main forms of causal relationships that can be measured: the total and direct effect <ref type="bibr" target="#b15">[16]</ref>.</p><p>The total effect of X on Y includes the effect of so-called mediators; variables that lie on a directed path between X and Y <ref type="bibr" target="#b6">[7]</ref>. For example, in the causal graph X Z Y , Z is a mediator of the effect of X on Y. To measure the total effect (TE) of changing the value of X from x to x ′ , we simply measure the outcome for both values of the treatment, X, and observe the resulting change in</p><formula xml:id="formula_0">Y. That is, T E = Y X=x ′ -Y X=x .</formula><p>Second, we can measure the direct effect of X on Y, which excludes the effect of any mediators. To measure the direct effect (DE), we block the flow of information along all mediating paths. This is achieved by "fixing" the value of at least one mediator, Z, on this path. That is,</p><formula xml:id="formula_1">DE = Y X=x ′ ,Z=z -Y X=x,Z=z .</formula><p>The intuition here is to block all paths between X and Y apart from the path X → Y itself <ref type="bibr" target="#b15">[16]</ref>. We refer to the set of "fixed" variables as an adjustment set.</p><p>Metamorphic Testing and Causality: At this point, we can draw a parallel with our definition of an MR (Definition 1). Essentially, an MR expresses the expected effect of a transformation defined by the pair of interventions do(X = x s ) and do(X = x f ), where x s and x f are the source and follow-up test cases, respectively. When viewed in this way, we can re-frame metamorphic testing to the task of measuring the causal effect of changing X from x s to x f on some output(s) Y.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>III. Causal Bugs</head><p>Software bugs are commonly characterised in terms of "cause and effect" <ref type="bibr" target="#b16">[17]</ref>. A particular parameter configuration might cause an execution path that leads to an erroneous output value. A particular GUI option might be implemented in the back-end, and ticking it might not have the effect on the output that the user might expect.</p><p>Such faults appear to be common. To explore the extent to which this is the case, we focus on Java units as a specific type of SUT. As a basis for our preliminary analysis, we refer to the analysis carried out by Sobreira et al. <ref type="bibr" target="#b17">[18]</ref>, who classified the fixes for each bug in the Defects4J repository <ref type="bibr" target="#b18">[19]</ref> (which contains details of 395 bugs from six open source Java projects). Examples of their classifications include "method call addition" or "wrapping with an if statement".</p><p>Out of the 81 classes of repair they identified, 12 imply a change to the underlying causal structure of the program between the buggy and fixed versions. The majority of these involve the addition or removal of program variables (method parameters, class instantiations, etc.), corresponding to the addition or removal of nodes in the underlying causal structure. Additionally, the "wrong variable reference" repair suggests a change in the relationships between existing variables in the program, corresponding to a change in the edges of the underlying causal structure. Of the 395 bugs in Defects4J, 228 of them were tagged with at least one structural repair. We shall refer to such bugs as structural causal bugs.</p><p>Even when the causal structure of a program is as expected, there may still a problem with the precise functional form of the relationships between inputs and outputs. Changing an input may cause changes in the anticipated outputs, but the nature of that change (the value of the output with respect to the input) may be incorrect. We refer to such bugs as functional causal bugs. These require a more fine-grained test oracle than the one considered in this paper, and are left to future work. In Defects4J, we identified three repair categories as being related to functional causal bugs: arithmetic expression modification, conditional expression modification, and changes to constants. These suggest that the causal structure remains the same between the buggy and fixed program versions, but that the functional form of the relationships changes. 80 of the bugs in Defects4J are tagged with at least one of these categories, 51 of which are also tagged with a structural repair.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IV. Causal Metamorphic Testing</head><p>This paper is based on the observation that there is a strong relationship between causal DAGs and the type of behaviours that are expressed in MRs. Both are fundamentally based on the notion of a "causal effect". Implicitly, MRs (Definition 1) incorporate a pair of interventions that transforms a given input (from the source to the follow-up) in such a way that it causes a change in output that can be anticipated. The notion of an edge in a causal graph (Definition 2) similarly incorporates the fact that a causal relationship between two variables occurs if an intervention on one may cause the other to change.</p><p>In this paper we explore the relationship between the two areas of metamorphic testing and (graph-based) causal reasoning. This raises the prospect of taking advantage of the significant amount of research on graph-based causal reasoning to identify and test potential MRs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Causal DAGs as a Software Model</head><p>To apply causal DAGs to metamorphic testing, we need to model the Software Under Test (SUT) in the form of a causal DAG. For this we consider a simple abstraction:</p><p>• There are "inputs", which correspond to parameters or environment variables that can affect the functional behaviour of the program. • There are "observable variables", which correspond to observable results of a computation by the SUT.</p><p>Definition 3. A Causal Software Graph (CSG) is an extension of a causal DAG (see Definition 2) defined as a tuple (V, E, I, O). Here, V and E correspond to the nodes and edges of the causal graph, and the sets I and O represent "inputs" and "observable variables", respectively, such that (I ∪ O) = V and I ∩O = ∅. Additionally, we have ∀(x, y) ∈ E. x ∈ O =⇒ y I, i.e. observable variables cannot cause inputs. This must hold true in all software systems<ref type="foot" target="#foot_0">foot_0</ref> since inputs must be provided before any computation can be done.</p><p>Where software inputs are known to be independent, we may also assume ∀(x, y) ∈ E. ¬(x ∈ I ∧ y ∈ i). This is not a requirement of our technique, but it does reduce the size of the test suite as we can ignore input-input tests.</p><p>When creating a CSG, it makes sense to start from the interface of the SUT. From this we can determine the set I: the input parameters and environmental variables that we can control as part of a test setup. We can also identify the set of outputs that we wish to check, and use this as a basis for O. It may also be helpful to capture additional key states of computation by including some internal state variables in O. This typically requires instrumentation of the SUT. We discuss this in Section IV-B.</p><p>The edges between the variables represent our expectation of how variables should affect each other. As with most modelbased testing techniques <ref type="bibr" target="#b19">[20]</ref>, the resulting model captures the developer's (or domain expert's) expectation of how the system should behave. Because of this, the CSG can only be as accurate as the developer's understanding of the SUT, and may end up being an approximate abstraction of the system. We investigate the degree to which our techniques can cope with model misspecification in Section V.</p><formula xml:id="formula_2">Input: A CSG (V, E, I, O),</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Generating Metamorphic Test Cases from a CSG</head><p>Algorithm 1 shows how a CSG can be used to generate metamorphic tests. The basic principle is to generate a metamorphic test for every edge in the CSG to check that a change to the variable at the source of the edge (whilst holding variables in the adjustment set constant) has a causal effect on the target variable. Similarly, if there is no edge between two variables, a metamorphic test is generated to check that changing the source variable does not cause a change to the target variable.</p><p>The approach iterates through every pair of nodes (x, y), where y is not an input (lines 3 and 4). We here assume ∀(x, y) ∈ E. ¬(x ∈ I ∧ y ∈ I) from Definition 3, although we could simply iterate over all node pairs in V ×V. For each pair of nodes, we proceed to identify an adjustment set (line 5) for the desired effect measure (see Section II), enabling the causal effect to be isolated. We then generate the source test case using the generateRandom function (line 7), which samples a random value for each variable in I and the adjustment set. The follow-up test case is obtained by applying the transform function (line 8) to the source test case, which changes the value of the treatment variable x to a fresh random value, while holding all variables in the adjustment set constant. Finally, we equip our metamorphic test case with an oracle. If (x, y) ∈ E, we check for inequality between the source and follow-up outputs (line 10) since the causal edge means we should be able to observe a change in the outcome y. Conversely, if (x, y) E, we check for equality instead (line 12) as, if there is no causal effect, there should be no change in y.</p><p>To execute our test cases, we need to be able to intervene on all variables x in the SUT for which we have a metamorphic test (x, y). While this is trivial for variables in I, we may also need to access and modify the values of variables in O. We refer to such variables as hidden. The means by which to access these variables (and the extent to which this can be automated) depends on the nature of the SUT. If, for example, the SUT is a Java class and variables in O correspond to classlevel variables, it is possible to use bytecode instrumentation frameworks such as Javassist (we do this for our second case study). In other cases, some manual instrumentation or testability transformations <ref type="bibr" target="#b20">[21]</ref> may be required (we use manual instrumentation for our first case study).</p><p>For some systems (e.g. when the system is a true "black box"), these approaches may simply be infeasible. In such cases, the inability to fully control and observe relevant variables presents a fundamental limitation in testability <ref type="bibr" target="#b21">[22]</ref>. In the worst case, this may prevent the testing of causal effects involving hidden variables, and the CSG may have to be restricted to the subset of accessible variables.</p><p>However, depending on the topology of the CSG, it may also be possible to infer causal effects involving hidden variables from existing data <ref type="bibr" target="#b22">[23]</ref>, <ref type="bibr" target="#b23">[24]</ref>. This requires the identification of a more advanced adjustment set that accounts for particular sources of bias in the data, such as confounding and selection bias <ref type="bibr" target="#b24">[25]</ref>. One such approach is to apply a graphical criterion known as d-separation <ref type="bibr" target="#b7">[8]</ref>. We do not apply these techniques in this work, but plan to extend our solution to accommodate this functionality in future work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Correctness and Performance</head><p>Given the two following strong assumptions, our approach is guaranteed to catch all bugs that change the causal structure of the SUT. </p><formula xml:id="formula_3">Y = f (X), we have f (x s ) = f (x f ) =⇒ x s = x f ,</formula><p>and equivalently x s x f =⇒ f (x s ) f (x f ). Thus, any pair satisfying x s x f is sufficient to test an X → Y relationship. For independence relations, if x s x f ∧ f (x s ) = f (x f ), we know that X cannot be a term in the function, so the independence relation holds.</p><p>□</p><p>As with any model-based testing technique, the model is an abstraction of the SUT and, in real settings, the fidelity of this will vary. In the following section, we systematically relax A1 and A2 to reduce the fidelity of our CSGs, both in terms of their accuracy (A1) and the proportion of noninjective causal relations (A2). While these assumptions are unlikely to hold in general, they provide a basis to quantify and control model fidelity and, ultimately, understand how this impacts the usefulness of the generated MRs and tests.</p><p>Misspecification is not the only way A1 can be undermined. As discussed in Section IV-B, the (lack of) testability of the SUT can play a role as well. Some of the variables that should be in the CSG may not feature because the corresponding variables in the SUT cannot be controlled or observed <ref type="bibr" target="#b21">[22]</ref>.</p><p>It is also worth commenting here on the cost of our technique. While our solution essentially reduces the problem of specifying MRs to drawing a causal DAG, this process incurs its own overhead; for complex and unwieldy systems, drawing a DAG may be a non-trivial and time-consuming task. The exact cost of constructing a DAG is hard to quantify. However, the increasing adoption of causal DAGs as a lightweight domain model <ref type="bibr" target="#b25">[26]</ref> across a range of fields such as epidemiology <ref type="bibr" target="#b26">[27]</ref>, <ref type="bibr" target="#b27">[28]</ref> indicates that the effort involved is perceived to be low enough to justify their use. Furthermore, causal DAGs are supported by an extensive mathematical framework that alleviates the burden associated with identifying independence relations -a task that, if conducted manually, quickly becomes cumbersome as the size of the subject system increases.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>V. Evaluation</head><p>In Section IV, we provided an informal proof that our technique can detect all structural causal bugs in an injective program, given a CSG which perfectly reflects its causal relationships. However, these assumptions are unlikely to hold in general. In this section, we investigate how our technique performs when these assumptions break down. Our research questions are as follows:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>RQ1 How robust to model misspecification is causal metamorphic testing?</head><p>As with all forms of specification, in real settings, the CSG is likely to contain imperfections. It is therefore important to understand how such imperfections impact the performance of causal metamorphic testing, particularly in terms of the validity of the generated MRs and ability to detect structural causal bugs.</p><p>RQ2 How robust to increasing amounts of non-injective causal relationships is causal metamorphic testing? When causal relationships are not injective, we face the additional challenge of finding a fault-revealing intervention, as the causal effect is only exercised by certain configurations. This research question aims to understand the extent to which the presence of evasive, non-injective causal relationships impacts the ability to detect structural causal bugs, and how this relationship varies with different sized randomly generated test suites.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Experimental Setup</head><p>To answer RQ1 and RQ2, we require software with a ground-truth CSG. To this end, we generate random CSGs and generate synthetic programs that reflect their causal structure, as in Figure <ref type="figure" target="#fig_1">1</ref>. We then use mutation analysis to inject artificial bugs that either add or delete a causal relationship in the implementation. We now describe the setup for each of these steps in greater detail.  CSG Generation: We first generate a random undirected graph using the Erdős-Rényi model <ref type="bibr" target="#b28">[29]</ref>, and assign each node a numerical label. This model has two parameters, n and p e , corresponding to the number of nodes and probability of including an arbitrary edge, respectively. We then convert the undirected edges to directed edges such that all edges point from nodes with a lower label to nodes with a higher label. Finally, we convert all endogenous nodes to inputs and all exogenous nodes to observable variables, and update the labels to denote inputs as X and observable variables as Y. This produces a CSG such as the one shown in Figure <ref type="figure" target="#fig_1">1b</ref>. We then generate tests from the CSGs as described in Section IV-B, sampling parameter values from the range [-10, 10].</p><p>Program Generation: Our programs take the form of Python methods comprising a series of linear equations for each node in O. We generate the program corresponding to a CSG by iterating over the nodes of the graph in order and generating an equation for each that includes a linear combination of all its cause nodes and a randomly sampled constant. For example, for the CSG in Figure <ref type="figure" target="#fig_1">1b</ref>, we could produce the equation Y1 = 2*X1 + 3*X2 + -3*X3 + 2. The method takes all nodes in I as mandatory parameters and all nodes in O as optional parameters. Each linear equation is then nested in an if statement that checks whether the effect node has been specified as an argument, in which case the argument overrides the equation. This allows us to intervene directly on any variable by passing in the appropriate argument.</p><p>For the purposes of answering RQ2, we add a "conditional behaviour" parameter, p c to determine how difficult the causal effects are to observe. This specifies the probability that a (randomly selected) node in O is conditional, meaning its assignment is nested in an if-then-else statement. To do this, we generate two linear equations -one for each branchand a predicate is generated as a random inequality check that compares the sum of a random non-empty subset of the effect node's parents to a random value in the range <ref type="bibr">[-10, 10]</ref>.</p><p>For example, consider the if-then-else statement surrounding the definition of Y1 in Figure <ref type="figure" target="#fig_1">1a</ref>. Because of the predicate if X1 + X3 &lt;= 2 and the absence of X2 in the else branch, X2 → Y1 is not injective: we must cover the if branch to observe the effect of X2. Therefore, the source and follow-up test case must satisfy the predicate X1 + X3 &lt;= 2, increasing the challenge of observing the causal effect of X2 on Y1.</p><p>Mutation Analysis: We define two mutation operators to add and remove causal relationships in a given program, referred to as AddCause and DeleteCause, respectively. We implemented these operators in a fork of the Python mutation analysis framework, Cosmic Ray <ref type="bibr" target="#b29">[30]</ref>, <ref type="bibr" target="#b31">[31]</ref>.</p><p>The AddCause operator adds a causal relationship from a specified cause node to a specified effect node. Our implementation finds definitions of the effect node in the source code and adds the cause node to the existing linear equation. For example, AddCause could add X2 as a causal effect to Y1 = 2*X1 + 3 as follows: Y1 = 2*X1 + 3 -X2. Where the effect node is defined conditionally (i.e. a different linear equation per branch), it is sufficient to add a causal effect to either branch to introduce a new causal relationship. This is because an edge X → Y in a causal graph (Definition 2) means there exists some intervention on X that brings about a change in Y. For this reason, our mutation operator acts on each branch individually, producing two mutants.</p><p>Conversely, the DeleteCause operator removes all causal relationships from a cause node to an effect node. Our implementation finds definitions of the effect node that include the cause node and replaces the cause node with a randomly sampled numerical constant. For example, DeleteCause could remove the causal effect of X2 on Y1 in Y1 = 3*X1 + 2*X2 + 1 as follows: Y1 = 3*X1 + 2*5 + 1. This also applies to variables appearing in the predicates generated for RQ2. Furthermore, where the effect node is defined conditionally, DeleteCause acts on both branches and the predicate to ensure that the effect is entirely removed.</p><p>Based on the structure of the CSG, we automatically define a list of applicable mutation operators for each program. Specifically, we define a DeleteCause mutation operator for each edge in the CSG, and an AddCause mutation operator for each unconnected pair of nodes in the CSG to which an edge could be added to form a valid DAG (i.e. without cycles, outputs causing inputs, or inputs causing inputs).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Methodology</head><p>Each experiment has three parameters n, p e , and p c , as discussed in Section V-A). We generate CSGs for every combination of parameters, n = <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b19">20,</ref><ref type="bibr" target="#b29">30]</ref>, p e = [0.25, 0.5, 0.75, 1], and p c = [0.25, 0.5, 0.75, 1]. To mitigate the potential for bias introduced by the random CSG and SUT generation approaches, we repeat each configuration 30 times with different random seeds. This results in 1440 CSG-program pairs. RQ1: Robustness to misspecification: To introduce model misspecification, for each ground truth CSG, we produce four mutant CSGs in which each edge or absence thereof is inverted (deletion of an existing edge or addition of a new one) with probability p m = [0.25, 0.5, 0.75, 1]. To quantify the extent of misspecification, we measure the Structural Hamming Distance (SHD) <ref type="bibr" target="#b33">[32]</ref>, <ref type="bibr" target="#b34">[33]</ref>. Put simply, this metric measures the number of changes that need to be made to restore the misspecified CSG to the ground truth.</p><p>Following Algorithm 1, we then generate our metamorphic relations and tests using the test generation outlined in Section IV-B, before applying the mutation analysis approach described in Section V-A. We then plot the relationship between mutation score and SHD.</p><p>RQ2: Robustness to conditional behaviour: As before, we perform mutation analysis on each of the generated programs. However, to answer this research question, we additionally report the McCabe complexity <ref type="bibr" target="#b35">[34]</ref> of the program and study the relationship between the mutation score and the McCabe complexity. Here we are using the McCabe complexity as a proxy for the extent to which the injective assumption (A2) is violated and, therefore, how difficult it is to exercise the causal relationship-under-test. For this research question, we use on the strata of data with S HD = 0, containing data from only the ground truth DAG (i.e. no misspecification).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VI. Results</head><p>Although we controlled the size n of the generated CSGs, there were no apparent differences between the corresponding results that would have a baring on the outcome of the RQs. Thus, we focus our discussion on the results for n = 20. Results for the other sizes can be found in our repository <ref type="foot" target="#foot_1">2</ref> .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. RQ1: Robustness to misspecification</head><p>The results in Figure <ref type="figure" target="#fig_2">2</ref> show that, as the CSG is increasingly misspecified (relaxing assumption A1 from Section IV), the mutation score falls proportionally to the SHD. This suggests that, where the user cannot provide a perfect (or even particularly accurate) CSG, the proposed technique can still produce metamorphic relations and tests for the correctly specified attributes of the CSG that reveal structural causal bugs.</p><p>We observe that the mutation score drops more steeply for CSGs with higher values of p e (i.e. for CSGs that have a denser edge structure). This can be explained in terms of the effects of the causal mutation operators on the adjustment sets of the generated MRs. When a spurious causal edge is added, the adjustment sets of MRs may then include additional variables, but are still sufficient to isolate the causal effect, meaning the test outcome is unaffected. By contrast, removing causal edges removes variables from the adjustment sets that are necessary to isolate the causal effect. This can lead to additional, correctly specified, MRs failing on the unmutated program (making them ineligible to catch mutants) because they fail to adjust for all variables necessary to isolate the causal effect. This is consistent with the general consensus within causal inference that the absence of a causal edge is a stronger assumption than the presence of one <ref type="bibr" target="#b25">[26]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>RQ1:</head><p>Our results indicate that the proposed approach is robust to misspecifications in the underlying CSG. They also suggest that missing genuine edges has a greater adverse effect on fault detection capability than including spurious ones.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. RQ2: Robustness to subtle causal relationships</head><p>Figure <ref type="figure" target="#fig_3">3</ref> shows that, as the McCabe complexity increases (relaxing assumption A2 from Section IV) the mutation score falls when using just a single test case. For all edge-densities, the mean mutation score decreases from almost 0.97 down to approximately 0.68 as the CSG increases in complexity. For larger test suites, however, this effect becomes negligible. For a test suite of size 5, the mean mutation score falls from 1 to 0.95. For a test suite of size 10 it falls from 1 to 0.98.</p><p>These findings indicate that faults residing in noninjective causal relationships (introduced here by conditional behaviour) can be notably harder to detect. However, they also show how an improved test generation strategy can help to address this issue, with the larger randomly generated test suites achieving significantly better mutation scores. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>RQ2:</head><p>Our results indicate that the fault detection capability of the proposed approach can be adversely affected by the presence of non-injective causal relationships. However, this issue may be mitigated by more rigorous test sets.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Threats to validity</head><p>External threats to validity: The main threat to external validity is that we generate synthetic programs in a parameterised, controlled manner. This was necessary to produce programs with a known causal structure, however they are unlikely to be representative of realistic programs. This concern motivated our case studies in Section VII where we apply our technique to two real programs from the Defects4J repository.</p><p>Another threat is that we employed a random test generation strategy to explore how the robustness to non-injective causal relationships varies with the size of a test suite. It is probable that we would have achieved better results by using a more advanced coverage-driven approach. However, the fact that our naïve approach can still achieve reasonable mutation scores demonstrates the promise of our technique.</p><p>Internal threats to validity: Our internal threats to validity are as follows. First, since we randomise the generation of the CSGs, programs, and mutation configurations, our results are subject to stochasticity, and are not guaranteed to provide a representative picture. We mitigate this threat by repeating each configuration 30 times as per <ref type="bibr" target="#b36">[35]</ref>.</p><p>Secondly, the metrics we select to measure the extent of misspecification (SHD) and non-injective behaviour (McCabe complexity) may not precisely resemble the target quantity. However, we chose these metrics because they are well known in their respective fields: SHD is commonly used to measure the accuracy of causal DAGs <ref type="bibr" target="#b37">[36]</ref>, and McCabe complexity is a common metric for measuring software branching behaviour.</p><p>It is also worth acknowledging that we were not able to compare our approach to a baseline or existing techniques such as <ref type="bibr" target="#b3">[4]</ref>, <ref type="bibr" target="#b13">[14]</ref>. Since there are very few MR generation techniques in the literature, there does not seem to be a commonly accepted baseline or set of comparison metrics. We leave this to future work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VII. Case studies</head><p>In Section V, we evaluated our technique on synthetic programs reflecting the causal structure of randomly generated CSGs. Our aim was to investigate how the fault-finding capability of our technique changes as assumptions A1 and A2 from Section IV deteriorate. In this section, we apply our technique to detect structural causal bugs from two systems in the Defects4J repository <ref type="bibr" target="#b18">[19]</ref>. The implementation of these case studies can be found in our repository <ref type="foot" target="#foot_2">3</ref> .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Apache Commons Math</head><p>First, we focus on a bug in the evaluation method of the Variance class in version 2.2 of the Apache Commons Math library (Bug ID: Math 41). According to the documentation <ref type="foot" target="#foot_3">4</ref> , this method calculates the weighted variance of a specified portion of an array of doubles, using a pre-computed mean.</p><p>The documentation states that evaluate takes five parameters: an array (values), an array (weights), the pre-computed mean (mean), a starting position (begin), and the number of elements to include (length). Furthermore, it stipulates that 0 is returned when length=1, and that evaluation calculates the variance with the following formula:</p><formula xml:id="formula_4">variance = begin+length i=begin Weights i (Values i -mean 2 ) ( begin+length i=begin Weights i ) -1 (1)</formula><p>The implementation of this method contains a structural causal bug, as shown in Figure <ref type="figure">4</ref>. During the computation of the denominator in Equation (1), the initialisation and condition of the for loop do not reference the specified start position, begin. Furthermore, the condition does not reference length to specify the correct end position, causing it to loop over the entire array instead. As a consequence, the causal effect of begin and length on the denominator is removed, and thus impacts the computed variance. double sumWts = 0; -for ( int i = 0 ; i &lt; weights.length ; i++) { + for ( int i = begin ; i &lt; begin + length ; i++) { sumWts += weights [i]; } Fig. <ref type="figure">4</ref>: A diff showing a structural causal bug located in the evaluate method of the Variance class.</p><p>Causal Software Graph: The CSG shown in Figure <ref type="figure" target="#fig_4">5</ref> uses only information that is available in the documentation. From this we know that mean, values, and length are used to compute a "numerator", and that length, begin and weights should be used to compute a "denominator". These are then combined to yield the final variance result. There is a direct edge from length to variance to cover the specific case where length is either zero or where begin+length exceeds the length of values.</p><p>The numerator and denominator nodes are not immediately observable (hence the dashed boxes). When developing the model from the documentation, we start from an assumption that we are able to instrument the implementation to expose the corresponding values in the implementation as it executes (elaborated below). Metamorphic relations and tests: Using our CSG, we identified and manually wrote test cases for the 18 causal metamorphic relations (11 ShouldCause and 7 ShouldNotCause). Each test case specifies a control value and randomly samples a follow-up value using a series of basic generator methods.</p><p>Instrumentation: For the two hidden variables (numerator and denominator), we manually instrumented the code to enable us to get and set the value of these variables. To achieve this, we modified evaluate to include two new variables, numerator and denominator, that store the numerator and denominator shown in Equation <ref type="bibr" target="#b0">(1)</ref>, and updated the definition of variance to use these variables. We also return a hash map containing the variables in the CSG and their respective values. While manual instrumentation was trivial in this instance, we appreciate this would not be feasible for larger, unwieldy software systems, and that source code is not always available. We address the latter of these concerns in the following case studies.</p><p>Results: Out of the 18 metamorphic test cases, 16 passed and 2 failed on the buggy version of Apache Commons Math. The two failing test cases correspond to the faultcausing relationships highlighted in red in Figure <ref type="figure" target="#fig_4">5</ref>: length → denominator and begin → denominator. We then ran the same test suite against the fixed version of Apache Commons Math, finding that all test cases passed as expected.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Apache Commons Lang</head><p>Next, we turn our attention to a bug in the format method of the FastDateFormat class, affecting version 2.5 of the Apache Commons Lang library (Bug ID: Lang 26). This is an efficient and thread-safe implementation for formatting and parsing dates that accounts for the user's locale <ref type="foot" target="#foot_4">5</ref> .</p><p>A FastDateFormat instance can be created by calling one of its factory methods, getInstance, that takes three inputs: a string representation of a pattern (e.g. "yyyy-mm-dd"); a TimeZone instance that can be obtained given a string encoding a time zone ID (e.g. "UK"); and a Locale instance that is defined by two strings, one specifying the language (e.g. "en") and the other specifying the country (e.g. "US"). Given a particular date as input, the format method is then called on the resulting FastDateFormat instance and returns a string representation of the specified date and format.</p><p>The implementation of the format method contains a structural causal bug, as shown in Figure <ref type="figure" target="#fig_5">6</ref>. Here, locale is not passed to the constructor of the GregorianCalendar instance for which the date is formatted, resulting in the user's default system locale being used instead. Consequently, if locale is set to be different to the default system locale, format may return an unexpected string.  This bug is problematic for locales that use the ISO 8601 date and time standard, such as en-GB, as this standard has 53 weeks for certain years (those with 53 Tuesdays), whereas others have 52. For example, if a FastDateFormat is instantiated with an ISO 8601 locale (e.g. en-GB) and the pattern ww (i.e week number) but the system locale is non-ISO 8601 (e.g. en-US), format will wrongly output week 1 instead of week 53 if the date is set to 1st January 2010.</p><p>Causal Software Graph: We constructed the CSG shown in Figure <ref type="figure" target="#fig_6">7</ref> using only information available in the documentation. Nodes represent the variables used to instantiate the FastDateFormat object: locale, timeZone, and rules. We then inserted two hidden variables (rules and maxLength) to capture the logic behind the initialisation of the FastDateFormat object. Specifically, the instance variables are used to construct a list of rules that are eventually used to create the formatted string (dateStr). The rules are also used to predict the maximum length of the formatted string (maxLength) to create a string buffer with sufficient capacity. A FastDateFormat object is then instantiated using each input configuration, before calling the format method with the fault-causing date, January 1st 2010.</p><p>Instrumentation: Whereas the previous case study dealt with a single method, this implementation is spread across a class. The hidden variables in our CSG (rules and maxLength) ultimately turn out to be derivable from class variables as opposed to internal method variables, which makes the task of observing and manipulating them much easier. In practice, we used the documentation to develop an automated bytecode instrumentation tool for this.</p><p>Results: Of the 12 metamorphic test cases, 10 passed and 2 failed. The failing test cases correspond to the faultcausing causal relationship highlighted in Figure <ref type="figure" target="#fig_6">7</ref>, locale → dateStr, and a further unexpected failure in the relationship maxLength → dateStr. Contrary to our initial expectation, our tests reveal that maxLength has no causal effect on dateStr. After further investigation, we found that although maxLength determines the initial capacity of the dateStr string buffer, it has no observable impact on the contents of dateStr because the capacity of the string buffer is automatically expanded upon However, we wrongly expected maxLength to set a hard upper-limit on the size of buffer that would result in an incomplete string.</p><p>Overall, in this case study, we were able to generate a set of metamorphic relations and tests that catch the structural causal bug in the format method of the FastDateFormat class. Additionally, these tests alerted us to a further discrepancy between our CSG and the implementation located in the maxLength → dateStr relationship that, upon investigation, turned out to be an error in our specification. Nevertheless, it was the process of generating metamorphic relations and tests from our CSG that revealed this misunderstanding.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>VIII. Related Work</head><p>This section provides a review of work related to the core topics of this paper, namely the construction of MRs, graph-based test case generation, and causality in software engineering. We also briefly summarise methods designed to learn causal graphs from data.</p><p>Construction of Metamorphic Relations: Several papers in the literature present heuristics to aid users in creating MRs <ref type="bibr" target="#b38">[37]</ref>, <ref type="bibr" target="#b39">[38]</ref>, <ref type="bibr" target="#b40">[39]</ref>. The main consensus is that source and follow up test cases which are "further apart" by some metric are more likely to discover faults. Mayer and Guderlei <ref type="bibr" target="#b39">[38]</ref> also find that MRs phrased as equalities are relatively weak, although Chen et al. <ref type="bibr" target="#b38">[37]</ref> say that theoretically stronger MRs are not necessarily better at detecting real program defects.</p><p>More recent work <ref type="bibr" target="#b13">[14]</ref> presents a method where users are given pairs of concrete parameter settings and asked to either generalise them into MRs or declare that no MR exists for the pair. Additionally, Liu et al. <ref type="bibr" target="#b41">[40]</ref> suggest constructing new MRs by composing existing ones.</p><p>These methods all require significant input from the user. To address this, Zhang et al. <ref type="bibr" target="#b4">[5]</ref> introduce a particle swarm optimisation based approach for automatically inferring polynomial MRs from program executions. This significantly reduces the burden on the user but has two key limitations. First, it requires a large amount of execution data from the SUT. Second, MRs inferred from execution data will reflect any bugs in the implementation, meaning we must now determine which of the inferred MRs capture the expected behaviour.</p><p>Test Case Generation from Directed Graphs: Vilkomir et al. <ref type="bibr" target="#b42">[41]</ref>, <ref type="bibr" target="#b43">[42]</ref> present a method of generating combinatorial test cases using a DAG representing dependencies between program inputs. Edges are labelled with parameter values such that test paths through the graph represent test cases. Their technique differs from ours in several ways. Where their graphical models only illustrate dependencies between input parameters, ours may also include outputs and internal variables, allowing them to also serve as test oracles. Second, our models do not require the user to precisely describe parameter domains. Our approach also produces metamorphic test cases where Vilkomir et al.'s approach produces combinatorial ones.</p><p>Chen et al. <ref type="bibr" target="#b44">[43]</ref> applied metamorphic testing to two bioinformatic programs that take a weighted directed graph representing gene-to-gene interactions as input. This work is fundamentally different from ours in that our DAGs model the expected behaviour of the SUT where Chen et al.'s are an input. Their work is also highly specialised to the field of gene regulatory behaviour, where our technique is domain agnostic.</p><p>Metamorphic Testing Tools: Several tools and techniques exist to assist in the practicalities of metamorphic testing. Zhu <ref type="bibr" target="#b11">[12]</ref> developed JFuzz, a tool for unit testing Java programs via metamorphic testing. Given a class to test and a series of MRs (implemented as classes), this tool automates the generation of source and follow-up test cases.</p><p>Kanewala et al. <ref type="bibr" target="#b5">[6]</ref> introduced a machine learning-based approach that predicts MRs based on a control flow graph and data dependency information. The approach has been shown to accurately predict whether a given function satisfies a library of pre-defined MRs commonly used for testing machine learning applications, but it does not aim to produce new ones.</p><p>Causality in Software Testing: There are a number of techniques that aim to establish causality in software systems. Johnson et al. <ref type="bibr" target="#b45">[44]</ref> developed a tool to explain the root cause of faulty software behaviour by mutating existing tests to form a suite of minimally different tests that, contrary to the original, are not fault-causing. The passing and failing tests can then be compared to understand why a fault occurred.</p><p>Another relevant technique is cause-effect graphing <ref type="bibr" target="#b46">[45]</ref>, <ref type="bibr" target="#b47">[46]</ref>. Here, input-output relationships are expressed in a variant of a combinatorial logic network called a cause-effect graph, created by manually extracting causes, effects, and boolean constraints from natural language specifications.</p><p>In a similar vein, dataflow testing <ref type="bibr" target="#b48">[47]</ref> is a family of testing strategies designed to verify the interactions between each program variable's definition and its uses, referred to as defuse pairs. The aim here is to exercise def-use pairs with respect to some coverage criterion. Although not explicitly related to causality, the field shares a similar objective to our work, namely to verify interactions between variables.</p><p>Automatic Generation of DAGs: While manual creation of DAGs is widely accepted in fields such as epidemiology, methods exist that could (partially) automate this process. Causal discovery <ref type="bibr" target="#b37">[36]</ref> aims to learn causal structures from data by exploiting asymmetries that separate association from causation <ref type="bibr" target="#b49">[48]</ref>. Causal DAGs have also been generated via static analysis of source code <ref type="bibr" target="#b50">[49]</ref>, <ref type="bibr" target="#b51">[50]</ref>. A fundamental weakness of both approaches is that inferred graphs represent the actual system rather than its intended behaviour, so reflect any bugs present in the implementation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IX. Conclusions</head><p>While metamorphic testing presents a promising solution to the oracle problem, a key challenge is to devise MRs describing the software behaviour in terms of how changes to the input parameters bring about changes to the outputs. Existing techniques either rely heavily on the user <ref type="bibr" target="#b13">[14]</ref>, or infer relations using the program itself <ref type="bibr" target="#b4">[5]</ref>, meaning the inferred relations may reflect implementational bugs in the SUT.</p><p>In this paper, we proposed a model-based technique for generating metamorphic relations from a lightweight, intuitive graphical causal model of software behaviour. We evaluated our technique using synthetic programs with a known causal structure, finding that our technique is able to produce useful metamorphic relations and tests capable of catching structural causal bugs, even in the presence of misspecification and evasive (i.e. difficult to observe) causal relationships.</p><p>To demonstrate the applicability of our technique to real systems, we also applied it to a pair of Java programs from Defects4J with known structural causal bugs. This revealed that our technique is not only able to catch structural causal bugs at various levels of abstraction, but it can also alert the user to problems with the specification.</p><p>In future work, we plan to enrich the proposed graphical model with functional information, such that we can also generate metamorphic relations capable of catching bugs that alter the functional form of a causal relationship. Furthermore, there is the potential to combine the proposed technique with more advanced test generation and selection techniques. A more comprehensive evaluation, application to further case studies, and perhaps a human usability study is also desirable to draw more general conclusions about our technique's performance.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>def program (X1 ,X2 ,Y1=None ,Y2=None): if Y1 is None: if X1 + X3 &lt;= 2: Y1 = 2*X1 + 3*X2 + 2 else: Y1 = 2*X1 + 2 if Y2 is None: Y2 = 3*Y1 + 2 return {'Y1': Y1 , 'Y2 ': Y2} (a) An example synthetic program.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 1 :</head><label>1</label><figDesc>Fig. 1: A synthetic CSG and python code reflecting the causal structure.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 2 :</head><label>2</label><figDesc>Fig. 2: Results for RQ1 demonstrating the relationship between structural hamming distance (SHD) and mutation score for CSGs with 20 nodes and different edge densities (p e ).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 3 :</head><label>3</label><figDesc>Fig. 3: Results for RQ2 demonstrating the relationship between McCabe complexity and mutation score for CSGs with 20 nodes and different edge densities (p e ).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 5 :</head><label>5</label><figDesc>Fig. 5: CSG for Variance.evaluate, with the fault-causing relationships highlighted in red and hidden variables shown as dashed boxes.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 6 :</head><label>6</label><figDesc>Fig. 6: A diff showing a structural causal bug located in the format method of the FastDateFormat class.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig. 7 :</head><label>7</label><figDesc>Fig.7: A CSG for the FastDateFormat.format method, with the fault-causing relationship highlighted in red, a misspecified edge shown by a dashed edge, and the hidden variables in dashed boxes.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>a number N of metamorphic tests to be generated per causal relationship. Output: A set of metamorphic tests MT , where each test is structured as (source, f ollowU p, output, relation).</figDesc><table><row><cell cols="2">1 begin</cell></row><row><cell>2</cell><cell>MT ← ∅;</cell></row><row><cell>3</cell><cell>for x ∈ V do</cell></row><row><cell></cell><cell>/* For every pair of variables that could feasibly</cell></row><row><cell></cell><cell>form a causal edge</cell><cell>*/</cell></row><row><cell>11</cell><cell>else</cell></row><row><cell></cell><cell>/* If (x, y) is not a causal edge,</cell></row><row><cell></cell><cell>changing X should not affect Y</cell><cell>*/</cell></row></table><note><p><p><p><p>4</p>for y ∈ (V \ (I ∪ {x})) do 5 ad justmentS et ← identify(x, y, E);</p>6 for i = 0; i &lt; N; i = i + 1 do //</p>Create a source input for variables in I 7 source ← generateRandom(I, ad justmentS et); /* Create a follow-up input, where variable x is transformed to a different value */ 8 f ollowU p ← transform(source, x, ad justmentS et); 9 if (x, y) ∈ E then /* If (x, y) is a causal edge, changing X should cause Y to change */ 10 MT ← MT ∪ {(source, f ollowU p, y, )}; 12 MT ← MT ∪ {(source, f ollowU p, y, =)}; 13 return MT ; Algorithm 1: Generating Metamorphic Tests from a causal DAG, assuming ∀(x, y) ∈ E.¬(x ∈ I ∧ y ∈ I).</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>complete set of MRs that cover all causal and independence relations in the SUT.If A2 holds, we can verify each MR using an individual (x s , x f ) pair. If F implements each causal relationship as an injective function</figDesc><table /><note><p><p><p><p><p><p>A1 No model misspecification: If the CSG perfectly reflects the causal structure of the SUT, we can generate an MR capable of exercising every causal and independence relationship. A2 Injective causal relationships: If every causal relationship X → Y in the CSG is implemented in the SUT as an injective function (i.e. f (x s</p>) = f (x f ) =⇒ x s = x f ),</p>then, for a given MR, all possible source and follow-up test case pairs, (x s , x f ) where x s x f , will exercise the causal or independence relationship.</p>Informal proof. Let F denote a software function and G = (V, E, I, O) denote a CSG representing its causal structure. Using A1 and the definition of a CSG (Definition 3), we know that for every pair of variables (X, Y)</p>∈ V × V, if (X, Y) ∈ E,</p>then there exists at least one statement in F where Y is assigned a value dependent on X. Conversely, if (X, Y) E, there is no such statement in F. Thus, by iterating over the edges and non-edges of F, as outlined in Algorithm 1, we obtain a</p></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>Iterating behaviour where the result of one iteration feeds into the next can be represented by either unrolling a fixed number of iterations or making the graph more abstract to consider the inputs and outputs of the iteration.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>https://github.com/AndrewC19/causal metamorphic relation generation/tree/main/full results</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2"><p>https://github.com/AndrewC19/DAG-MT-case-studies</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_3"><p>https://commons.apache.org/proper/commons-math/javadocs/api-3.6.1/org/apache/commons/math3/stat/descriptive/moment/Variance.html</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_4"><p>https://commons.apache.org/proper/commonslang/apidocs/org/apache/commons/lang3/time/FastDateFormat.html</p></note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Metamorphic testing: A review of challenges and opportunities</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">Y</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F.-C</forename><surname>Kuo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P.-L</forename><surname>Poon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Towey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Tse</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><forename type="middle">Q</forename><surname>Zhou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Computing Surveys (CSUR)</title>
		<imprint>
			<biblScope unit="volume">51</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1" to="27" />
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">A survey on metamorphic testing</title>
		<author>
			<persName><forename type="first">S</forename><surname>Segura</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Fraser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">B</forename><surname>Sanchez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Ruiz-Cortés</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on software engineering</title>
		<imprint>
			<biblScope unit="volume">42</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="805" to="824" />
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Properties of machine learning applications for use in metamorphic testing</title>
		<author>
			<persName><forename type="first">C</forename><surname>Murphy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Kaiser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Wu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Combining SOA and BPM Technologies for Cross-System Process Automation</title>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page">867</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">An automatic testing approach for compiler based on metamorphic testing technique</title>
		<author>
			<persName><forename type="first">Q</forename><surname>Tao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Zhao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Shen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2010 Asia Pacific Software Engineering Conference</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="270" to="279" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Search-based inference of polynomial metamorphic relations</title>
		<author>
			<persName><forename type="first">J</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Hao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Xiong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Xie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Mei</surname></persName>
		</author>
		<idno type="DOI">10.1145/2642937.2642994</idno>
		<ptr target="https://doi.org/10.1145/2642937.2642994" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 29th ACM/IEEE International Conference on Automated Software Engineering, ser. ASE &apos;14</title>
		<meeting>the 29th ACM/IEEE International Conference on Automated Software Engineering, ser. ASE &apos;14<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computing Machinery</publisher>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="701" to="712" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Predicting metamorphic relations for testing scientific software: a machine learning approach using graph kernels</title>
		<author>
			<persName><forename type="first">U</forename><surname>Kanewala</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Bieman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Ben-Hur</surname></persName>
		</author>
		<ptr target="https://doi.org/10.1002%2Fstvr.1594" />
	</analytic>
	<monogr>
		<title level="j">Softw. Test. Verif. Reliab</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="245" to="269" />
			<date type="published" when="2015-11">nov 2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Causal Inference: What if</title>
		<author>
			<persName><forename type="first">M</forename><surname>Hernan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Robins</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2020">2020</date>
			<publisher>CRC Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Causality</title>
		<author>
			<persName><forename type="first">J</forename><surname>Pearl</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009">2009</date>
			<publisher>Cambridge university press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">The oracle problem in software testing: A survey</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">T</forename><surname>Barr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Harman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Mcminn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Shahbaz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Yoo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE transactions on software engineering</title>
		<imprint>
			<biblScope unit="volume">41</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="507" to="525" />
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Metamorphic testing: A new approach for generating next test cases</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">Y</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">C</forename><surname>Cheung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">M</forename><surname>Yiu</surname></persName>
		</author>
		<ptr target="https://arxiv.org/abs/2002.12543" />
		<imprint>
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">How effectively does metamorphic testing alleviate the oracle problem?</title>
		<author>
			<persName><forename type="first">H</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F.-C</forename><surname>Kuo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Towey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">Y</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Software Engineering</title>
		<imprint>
			<biblScope unit="volume">40</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="4" to="22" />
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Jfuzz: A tool for automated java unit testing based on data mutation and metamorphic testing methods</title>
		<author>
			<persName><forename type="first">H</forename><surname>Zhu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2015 Second International Conference on Trustworthy Systems and Their Applications</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="8" to="15" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Iterative metamorphic testing</title>
		<author>
			<persName><forename type="first">P</forename><surname>Wu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">29th Annual International Computer Software and Applications Conference (COMPSAC&apos;05)</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="19" to="24" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Metric: Metamorphic relation identification based on the category-choice framework</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">Y</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P.-L</forename><surname>Poon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Xie</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Systems and Software</title>
		<imprint>
			<biblScope unit="volume">116</biblScope>
			<biblScope unit="page" from="177" to="190" />
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Principles and practice of structural equation modeling</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">B</forename><surname>Kline</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2015">2015</date>
			<publisher>Guilford publications</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Probabilistic and Causal Inference: The Works of Judea Pearl, 1st ed</title>
		<author>
			<persName><forename type="first">H</forename><surname>Geffner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Dechter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">Y</forename><surname>Halpern</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2022">2022</date>
			<publisher>Association for Computing Machinery</publisher>
			<biblScope unit="volume">36</biblScope>
			<pubPlace>New York, NY, USA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">A survey on software fault localization</title>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">E</forename><surname>Wong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Gao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Abreu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Wotawa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Software Engineering</title>
		<imprint>
			<biblScope unit="volume">42</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="707" to="740" />
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Dissection of a bug dataset: Anatomy of 395 patches from defects4j</title>
		<author>
			<persName><forename type="first">V</forename><surname>Sobreira</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Durieux</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Madeiral</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Monperrus</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Maia</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of SANER</title>
		<meeting>SANER</meeting>
		<imprint>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Defects4j: A database of existing faults to enable controlled testing studies for java programs</title>
		<author>
			<persName><forename type="first">R</forename><surname>Just</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Jalali</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">D</forename><surname>Ernst</surname></persName>
		</author>
		<idno type="DOI">10.1145/2610384.2628055</idno>
		<ptr target="https://doi.org/10.1145/2610384.2628055" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2014 International Symposium on Software Testing and Analysis, ser. ISSTA 2014</title>
		<meeting>the 2014 International Symposium on Software Testing and Analysis, ser. ISSTA 2014<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computing Machinery</publisher>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="437" to="440" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">A taxonomy of model-based testing approaches</title>
		<author>
			<persName><forename type="first">M</forename><surname>Utting</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Pretschner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Legeard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Software testing, verification and reliability</title>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="page" from="297" to="312" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Testability transformation</title>
		<author>
			<persName><forename type="first">M</forename><surname>Harman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Hierons</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Wegener</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Sthamer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Baresel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Roper</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Software Engineering</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="3" to="16" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Testability of software components</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">S</forename><surname>Freedman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE transactions on Software Engineering</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="553" to="564" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">On the testable implications of causal models with hidden variables</title>
		<author>
			<persName><forename type="first">J</forename><surname>Tian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Pearl</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1301.0608</idno>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">Testing causality in scientific modelling software</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">G</forename><surname>Clark</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Foster</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Prifling</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Walkinshaw</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">M</forename><surname>Hierons</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Schmidt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">D</forename><surname>Turner</surname></persName>
		</author>
		<ptr target="https://arxiv.org/abs/2209.00357" />
		<imprint>
			<date type="published" when="2022">2022</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<author>
			<persName><forename type="first">S</forename><surname>Greenland</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Pearl</surname></persName>
		</author>
		<idno type="DOI">10.1002/9781118445112.stat03732.pub2</idno>
		<ptr target="https://onlinelibrary.wiley.com/doi/abs/10.1002/9781118445112.stat03732.pub2" />
		<title level="m">Causal Diagrams</title>
		<imprint>
			<publisher>Ltd</publisher>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="1" to="10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Use of directed acyclic graphs (DAGs) to identify confounders in applied health research: review and recommendations</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">W</forename><surname>Tennant</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">J</forename><surname>Murray</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">F</forename><surname>Arnold</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Berrie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">P</forename><surname>Fox</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">C</forename><surname>Gadd</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">J</forename><surname>Harrison</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Keeble</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">R</forename><surname>Ranker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Textor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International Journal of Epidemiology</title>
		<imprint>
			<biblScope unit="volume">50</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="620" to="632" />
			<date type="published" when="2021">2021</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Causal knowledge as a prerequisite for confounding evaluation: an application to birth defects epidemiology</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A</forename><surname>Hernán</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Hernández-Díaz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">M</forename><surname>Werler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">A</forename><surname>Mitchell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">American journal of epidemiology</title>
		<imprint>
			<biblScope unit="volume">155</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="176" to="184" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Impact of sars-cov-2 variant on the severity of maternal infection and perinatal outcomes: Data from the uk obstetric surveillance system national cohort</title>
		<author>
			<persName><forename type="first">N</forename><surname>Vousden</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Ramakrishnan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Bunch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Morris</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Simpson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Gale</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>O'brien</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Quigley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Brocklehurst</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">J</forename><surname>Kurinczuk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">MedRxiv</title>
		<imprint>
			<date type="published" when="2021">2021</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">On the evolution of random graphs</title>
		<author>
			<persName><forename type="first">P</forename><surname>Erdős</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Rényi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Publ. Math. Inst. Hung. Acad. Sci</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="17" to="60" />
			<date type="published" when="1960">1960</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<title level="m" type="main">Cosmic ray: Variable inserter</title>
		<imprint/>
	</monogr>
	<note>Online</note>
</biblStruct>

<biblStruct xml:id="b30">
	<monogr>
		<title/>
		<author>
			<persName><surname>Available</surname></persName>
		</author>
		<ptr target="https://anonymous.4open.science/r/cosmic-ray-FORK258/src/cosmicray/operators/variableinserter.py" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<title level="m" type="main">Cosmic ray: Variable remover</title>
		<imprint/>
	</monogr>
	<note>Online</note>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
		<title/>
		<author>
			<persName><surname>Available</surname></persName>
		</author>
		<ptr target="https://anonymous.4open.science/r/cosmic-ray-FORK258/src/cosmicray/operators/variablereplacer.py" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">The max-min hillclimbing bayesian network structure learning algorithm</title>
		<author>
			<persName><forename type="first">I</forename><surname>Tsamardinos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">E</forename><surname>Brown</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">F</forename><surname>Aliferis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Machine learning</title>
		<imprint>
			<biblScope unit="volume">65</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="31" to="78" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">A comparison of structural distance measures for causal bayesian network models</title>
		<author>
			<persName><forename type="first">M</forename><surname>De Jongh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Druzdzel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Recent Advances in Intelligent Information Systems, Challenging Problems of Science</title>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="443" to="456" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">A complexity measure</title>
		<author>
			<persName><forename type="first">T</forename><surname>Mccabe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Software Engineering</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="308" to="320" />
			<date type="published" when="1976">1976</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">A hitchhiker&apos;s guide to statistical tests for assessing randomized algorithms in software engineering</title>
		<author>
			<persName><forename type="first">A</forename><surname>Arcuri</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Briand</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Software Testing, Verification and Reliability</title>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="page" from="219" to="250" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Causal discovery algorithms: A practical guide</title>
		<author>
			<persName><forename type="first">D</forename><surname>Malinsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Danks</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Philosophy Compass</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">1</biblScope>
			<date type="published" when="2018">12470. 2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Case studies on the selection of useful relations in metamorphic testing</title>
		<author>
			<persName><forename type="first">T</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Tse</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><forename type="middle">Q</forename><surname>Zhou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 4th Ibero-American Symposium on Software Engineering and Knowledge Engineering (JIISIC&apos;04)</title>
		<meeting>the 4th Ibero-American Symposium on Software Engineering and Knowledge Engineering (JIISIC&apos;04)</meeting>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page" from="569" to="583" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">An empirical study on the selection of good metamorphic relations</title>
		<author>
			<persName><forename type="first">J</forename><surname>Mayer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Guderlei</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">30th Annual International Computer Software and Applications Conference (COMPSAC&apos;06)</title>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="475" to="484" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">On the correlation between the effectiveness of metamorphic relations and dissimilarities of test case executions</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Cao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><forename type="middle">Q</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">Y</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2013 13th International Conference on Quality Software</title>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="153" to="162" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">A new method for constructing metamorphic relations</title>
		<author>
			<persName><forename type="first">H</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">Y</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2012 12th International Conference on Quality Software</title>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="59" to="68" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Modeling input space for testing scientific computational software: A case study</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">A</forename><surname>Vilkomir</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">T</forename><surname>Swain</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">H</forename><surname>Poore</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">T</forename><surname>Clarno</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computational Science -ICCS 2008</title>
		<editor>
			<persName><forename type="first">G</forename><forename type="middle">D</forename><surname>Bubak</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><surname>Van Albada</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">P</forename><forename type="middle">M A</forename><surname>Dongarra</surname></persName>
		</editor>
		<editor>
			<persName><surname>Sloot</surname></persName>
		</editor>
		<meeting><address><addrLine>Berlin, Heidelberg; Berlin Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="291" to="300" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Combinatorial test case selection with markovian usage models</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">A</forename><surname>Vilkomir</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">T</forename><surname>Swain</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">H</forename><surname>Poore</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Fifth International Conference on Information Technology: New Generations (itng</title>
		<imprint>
			<date type="published" when="2008">2008. 2008</date>
			<biblScope unit="page" from="3" to="8" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">An innovative approach for testing bioinformatics programs using metamorphic testing</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">Y</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">W</forename><surname>Ho</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Xie</surname></persName>
		</author>
		<ptr target="https://doi.org/10.1186%2F1471-2105-10-24" />
	</analytic>
	<monogr>
		<title level="j">BMC Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">1</biblScope>
			<date type="published" when="2009-01">jan 2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Causal testing: understanding defects&apos; root causes</title>
		<author>
			<persName><forename type="first">B</forename><surname>Johnson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Brun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Meliou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM/IEEE 42nd International Conference on Software Engineering</title>
		<meeting>the ACM/IEEE 42nd International Conference on Software Engineering</meeting>
		<imprint>
			<date type="published" when="2020">2020</date>
			<biblScope unit="page" from="87" to="99" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Cause-effect graphing analysis and validation of requirements</title>
		<author>
			<persName><forename type="first">K</forename><surname>Nursimulu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">L</forename><surname>Probert</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1995 Conference of the Centre for Advanced Studies on Collaborative research. Citeseer</title>
		<meeting>the 1995 Conference of the Centre for Advanced Studies on Collaborative research. Citeseer</meeting>
		<imprint>
			<date type="published" when="1995">1995</date>
			<biblScope unit="page">46</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<monogr>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">J</forename><surname>Myers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Badgett</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">M</forename><surname>Thomas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Sandler</surname></persName>
		</author>
		<title level="m">The Art of Software Testing</title>
		<imprint>
			<publisher>Wiley Online Library</publisher>
			<date type="published" when="2004">2004</date>
			<biblScope unit="volume">2</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">A survey on data-flow testing</title>
		<author>
			<persName><forename type="first">T</forename><surname>Su</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Miao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Pu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>He</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Su</surname></persName>
		</author>
		<idno type="DOI">10.1145/3020266</idno>
		<ptr target="https://doi.org/10.1145/3020266" />
	</analytic>
	<monogr>
		<title level="j">ACM Comput. Surv</title>
		<imprint>
			<biblScope unit="volume">50</biblScope>
			<biblScope unit="issue">1</biblScope>
			<date type="published" when="2017-03">mar 2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">Review of causal discovery methods based on graphical models</title>
		<author>
			<persName><forename type="first">C</forename><surname>Glymour</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Spirtes</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Frontiers in genetics</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page">524</biblScope>
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">Counterfault: Value-based fault localization by modeling and predicting counterfactual outcomes</title>
		<author>
			<persName><forename type="first">A</forename><surname>Podgurski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Küc</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2020 IEEE International Conference on Software Maintenance and Evolution (ICSME)</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2020">2020</date>
			<biblScope unit="page" from="382" to="393" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<monogr>
		<title level="m" type="main">Causal program dependence analysis</title>
		<author>
			<persName><forename type="first">S</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Binkley</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Feldt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Gold</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Yoo</surname></persName>
		</author>
		<idno type="arXiv">arXiv:2104.09107</idno>
		<imprint>
			<date type="published" when="2021">2021</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
