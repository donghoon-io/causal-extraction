<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Linear-Time Algorithms for Front-Door Adjustment in Causal Graphs *</title>
				<funder ref="#_qAfRvXT">
					<orgName type="full">Deutsche Forschungsgemeinschaft (DFG)</orgName>
				</funder>
				<funder ref="#_KVuB8X8">
					<orgName type="full">unknown</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability  status="unknown">
					<licence/>
				</availability>
				<date type="published" when="2024-01-26">26 Jan 2024</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Marcel</forename><surname>Wienöbst</surname></persName>
							<email>m.wienoebst@uni-luebeck.de</email>
							<affiliation key="aff0">
								<orgName type="department">Institute of Theoretical Computer Science</orgName>
								<orgName type="institution">University of Lübeck</orgName>
								<address>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Benito</forename><surname>Van Der Zander</surname></persName>
							<email>b.vanderzander@uni-luebeck.de</email>
							<affiliation key="aff0">
								<orgName type="department">Institute of Theoretical Computer Science</orgName>
								<orgName type="institution">University of Lübeck</orgName>
								<address>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Maciej</forename><surname>Liśkiewicz</surname></persName>
							<email>maciej.liskiewicz@uni-luebeck.de</email>
							<affiliation key="aff0">
								<orgName type="department">Institute of Theoretical Computer Science</orgName>
								<orgName type="institution">University of Lübeck</orgName>
								<address>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Linear-Time Algorithms for Front-Door Adjustment in Causal Graphs *</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2024-01-26">26 Jan 2024</date>
						</imprint>
					</monogr>
					<idno type="arXiv">arXiv:2211.16468v4[cs.AI]</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.1" ident="GROBID" when="2025-10-14T18:30+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Causal effect estimation from observational data is a fundamental task in empirical sciences. It becomes particularly challenging when unobserved confounders are involved in a system. This paper focuses on front-door adjustment -a classic technique which, using observed mediators allows to identify causal effects even in the presence of unobserved confounding. While the statistical properties of the front-door estimation are quite well understood, its algorithmic aspects remained unexplored for a long time. In 2022, Jeong, Tian, and Bareinboim presented the first polynomial-time algorithm for finding sets satisfying the front-door criterion in a given directed acyclic graph (DAG), with an O(n 3 (n + m)) run time, where n denotes the number of variables and m the number of edges of the causal graph. In our work, we give the first linear-time, i.e., O(n + m), algorithm for this task, which thus reaches the asymptotically optimal time complexity. This result implies an O(n(n + m)) delay enumeration algorithm of all front-door adjustment sets, again improving previous work by a factor of n 3 . Moreover, we provide the first linear-time algorithm for finding a minimal front-door adjustment set. We offer implementations of our algorithms in multiple programming languages to facilitate practical usage and empirically validate their feasibility, even for large graphs.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Discovering and understanding causal relationships and distinguishing them from purely statistical associations is a fundamental objective of empirical sciences. For example, recognizing the causes of diseases and other health problems is a central task in medical research enabling novel disease prevention and treatment strategies. One possible approach for establishing causal relationships and analyzing causal effects is through Randomized Controlled Trials <ref type="bibr" target="#b3">(Fisher 1936)</ref>, which are considered the gold standard of experimentation. In practice, however, experimentation is not always possible due to costs, technical feasibility, or ethical constraints -e.g., participants of medical studies should not be assigned to smoke over extended periods of time to ascertain its harmfulness.</p><p>The goal of causal inference is to determine cause-effect relationships by combining observed and interventional data with existing knowledge. In this paper, we focus on the problem of deciding when causal effects can be identified from a graphical model and observed data and, if possible, how to estimate the strength of the effect. The model is typically represented as a directed acyclic graph (DAG), whose edges encode direct causal influences between the random variables of interest. To analyze the causal effects in such models, <ref type="bibr" target="#b11">Pearl (1995</ref><ref type="bibr" target="#b12">Pearl ( , 2009) )</ref> introduced the do-operator which performs a hypothetical intervention forcing exposure (treatment) variables X to take some values x. This allows to regard the (total) causal effect of X on outcome variables Y, denoted as P (y|do(x)), as the probability distribution of variables Y after the intervention. <ref type="foot" target="#foot_0">1</ref> The fundamental task in causal inference is to decide whether P (y|do(x)) can be expressed using only standard (i.e., do-operator free) probabilities and it becomes challenging when unobserved confounders (variables affecting both the treatment and outcome) are involved in a system. A variable is considered unobserved if it cannot be measured by the researcher. Fig. <ref type="figure">1</ref> shows DAGs of some models with unobserved confounders.</p><p>It is well known that the IDC algorithm by <ref type="bibr">Shpitser and Pearl (2006a)</ref>, based on the prominent do-calculus <ref type="bibr" target="#b11">(Pearl 1995)</ref>, allows solving the identifiability problem in a sound and complete way <ref type="bibr" target="#b7">(Huang and Valtorta 2006;</ref><ref type="bibr">Shpitser and Pearl 2006b</ref>). As such, researchers could potentially apply IDC to decide identifiability. However, two drawbacks affect the widespread use of the algorithm: Firstly it runs in polynomial time of high degree which precludes computations for graphs involving a reasonable amount of variables. Secondly, the IDC algorithm computes complex expressions, even in case of small DAGs for which a simple formula exists (for details, see, e.g., (van der Zander, Liśkiewicz, and Textor 2019)). Hence, in practice, total causal effects are estimated using other methods.</p><p>One of the most popular approaches is to utilize covariate adjustment of the form P (y|do(x)) = z P (y|x, z)P (z), which is valid if Z satisfies the famous back-door (BD) criterion <ref type="bibr" target="#b11">(Pearl 1995)</ref>. Apart from convenient statistical properties, the BD based methods rely on efficient, sound, and complete algorithms for covariate adjustments in DAGs. In particular, utilizing the generalized BD criterion by <ref type="bibr" target="#b19">Shpitser, VanderWeele, and Robins (2010)</ref>, the algorithmic framework</p><formula xml:id="formula_0">X Z Y U (i) X A B C D Y U (ii) X A Y U D C B (iii)</formula><p>Figure <ref type="figure">1</ref>: Causal graphs, where X is the treatment, Y the outcome, and U represents an unobserved confounder. Graph (i) is a canonical example, with the (unique) set {Z} satisfying the front-door (FD) criterion relative to (X, Y ). For graph (ii), there exist 13 FD sets; Both the algorithm of Jeong, Tian, and Bareinboim as well as our basic Algorithm 2, output Z = {A, B, C, D} of maximum size. In contrast, Algorithm 3 computes minimal FD set {D} of size 1. Graph (iii) illustrates the non-monotonicity of the FD criterion: while both {A, B, C} and {A} are FD sets, neither {A, B} nor {A, C} nor {B, C} satisfy the FD criterion.</p><p>provided by <ref type="bibr" target="#b21">van der Zander, Liśkiewicz, and Textor (2014)</ref> allows to find an adjustment set in linear-time O(n + m) and to enumerate all covariate adjustment sets with delay O(n(n + m)), i.e., at most O(n(n + m)) time passes between successive outputs. <ref type="foot" target="#foot_1">2</ref>However, BD based approaches are unable to identify the causal effect in many cases involving unobserved confounders, which are commonplace in practice. For example, none of the instances in Fig. <ref type="figure">1</ref> can be identified via covariate adjustment, although P (y|do(x)) can be expressed by the formula (1) below. This illustrates the use of another classic technique, known as front-door (FD) adjustment <ref type="bibr" target="#b11">(Pearl 1995)</ref>, which is the main focus of this paper. The advantage of this approach, as seen in the example, is that it leverages observed mediators to identify causal effects even in the presence of unobserved confounding. In the general case, if a set of variables Z satisfies the FD criterion<ref type="foot" target="#foot_2">foot_2</ref> relative to (X, Y) in a DAG G, the variables Z are observed and P (x, z) &gt; 0, then the effect of X on Y is identifiable and is given by the formula</p><formula xml:id="formula_1">P (y|do(x)) = z P (z|x) x ′ P (y|x ′ , z) P (x ′ ),<label>(1)</label></formula><p>respectively P (y|do(x)) = P (y) in case Z = ∅. FD adjustment is an effective alternative to standard covariate adjustment <ref type="bibr" target="#b5">(Glynn and Kashin 2018)</ref> and is met with increasing applications in real-world datasets <ref type="bibr" target="#b0">(Bellemare, Bloem, and Wexler 2019;</ref><ref type="bibr" target="#b6">Gupta, Lipton, and Childers 2021;</ref><ref type="bibr" target="#b1">Chinco and Mayer 2016;</ref><ref type="bibr" target="#b2">Cohen and Malloy 2014)</ref>. Recent works <ref type="bibr" target="#b10">(Kuroki 2000;</ref><ref type="bibr" target="#b5">Glynn and Kashin 2018;</ref><ref type="bibr" target="#b6">Gupta, Lipton, and Childers 2021)</ref> have improved the understanding of the statistical properties of FD estimation and provided robust generalizations of this approach <ref type="bibr" target="#b8">(Hünermund and Bareinboim 2019;</ref><ref type="bibr" target="#b4">Fulcher et al. 2020)</ref>.</p><p>However, despite these advantages, the algorithmic and complexity-theoretical aspects of FD adjustment remained unexplored for a long time. Very recently, <ref type="bibr" target="#b9">Jeong, Tian, and Bareinboim (2022)</ref> have provided the first polynomial-time algorithm for finding an FD adjustment set with an O(n 3 (n + m)) run time. This amounts to O(n 5 ) for dense graphs, which does not scale well even for a moderate number of variables. The authors also gave an algorithm for enumerating all FD sets, which has delay O(n 4 (n + m)). Yet, it remained open, whether these tasks can be solved more efficiently.</p><p>Additionally, the O(n 3 (n + m)) algorithm by <ref type="bibr" target="#b9">Jeong, Tian, and Bareinboim (2022)</ref> always returns the maximum size FD set Z, which is often unpractical as it hinders the estimation of FD adjustment formula (1), which sums over all possible values z. Example (ii) in Fig. <ref type="figure">1</ref> illustrates this issue: while {A, B, C, D} is a valid FD adjustment, it is not minimal since its proper subset, e.g., {A}, satisfies the FD criterion, as well.</p><p>In this work, we address this issue of finding a minimal FD set. A feature, which may make the problem difficult to solve, is the non-monotonicity of the FD criterion, illustrated in Fig. <ref type="figure">1</ref>.(iii).</p><p>The main contributions of this work are threefold: • We present the first linear-time, that is O(n + m), algorithm, for finding an FD adjustment set. This run time is asymptotically optimal, as the size of the input is Ω(n + m). • For enumeration of FD adjustment sets, we provide an O(n(n + m))-delay algorithm. • We give the first linear-time algorithm for finding a minimal FD set. Thus, our results show that, in terms of computational complexity, the problems of finding and enumerating FD sets are not harder than for the well-studied covariate adjustment and indeed, our algorithms match the run time of the methods used in this setting. In addition, our work offers implementations of the new algorithms in multiple programming languages to facilitate practical usage and we empirically validate their feasibility, even for large graphs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Preliminaries</head><formula xml:id="formula_2">A directed graph G = (V, E) consists of a set of vertices (or variables) V and a set of directed edges E ⊆ V × V. In case of a directed edge A → B, vertex A is called a parent of B and B is a child of A. In case there is a causal path A → • • • → B, then A is called an ancestor of B and B is a descendant of A.</formula><p>Vertices are descendants and ancestors of themselves, but not parents/children. The sets of parents, children, ancestors, and descendants of a vertex V are denoted by Pa(V ), Ch(V ), An(V ), and De(V ), and they generalize to sets V in the natural way. We consider only acyclic graphs (DAGs), i.e., if B ∈ De(A), then there is no edge B → A. We denote by G S the graph obtained by removing from G all edges → S for every S ∈ S, and by G S , the graph obtained by removing ← S for every S ∈ S.</p><p>The statement Hence, ways can be used to determine d-separation and they make up the traversal sequence of the well-known Bayes-Ball algorithm <ref type="bibr" target="#b15">(Shachter 1998)</ref> for testing d-separation in linear time. A path (or way) from A to B is called a back-door (BD) path (or way) if it starts with the edge A ←. For a set of vertices A, we often speak of proper back-door (BD) paths (or ways), which are such that the path A ← . . . B for A ∈ A and B ∈ B does not contain any other vertex in A.</p><formula xml:id="formula_3">(A ⊥ ⊥ B | C) G in a DAG G holds for pairwise disjoint sets of vertices A, B, C ⊂ V if A and B are d-separated in G given C -that is, if there is no open path from some vertex A ∈ A to a vertex B ∈ B given C. A path is a sequence of adjacent, pairwise different vertices and it is open if, for any collider Y on the path (that is X → Y ← Z), we have De(Y ) ∩ C ̸ = ∅,</formula><p>Let G = (V, E) be a DAG and let I, R, with I ⊆ R, be subsets of vertices. Given pairwise disjoint X, Y, Z ⊂ V, set Z, with the constraint I ⊆ Z ⊆ R, satisfies the front-door criterion relative to (X, Y) in G if <ref type="bibr" target="#b11">(Pearl 1995)</ref>:</p><p>FD(1). The set Z intercepts all directed paths from X to Y.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>FD(2).</head><p>There is no unblocked proper BD path from X to Z, i.e., (Z ⊥ ⊥ X) G X .</p><p>FD(3). All proper BD paths from Z to Y are blocked by X, i.e.,</p><formula xml:id="formula_4">(Z ⊥ ⊥ Y | X) G Z .</formula><p>The set I consists of variables that must be included in the FD set, the set of variables R consists of the ones that can be used. We consider graphs consisting only of directed edges. Bidirected edges A ↔ B are frequently used to represent confounding and can be replaced by A ← U → B, where U is a new variable, which is not in R, in order to make use of the algorithms presented here.</p><p>The following algorithmic idea for finding a set Z satisfying the FD criterion relative to (X, Y) (if such a set exists) was recently given by <ref type="bibr" target="#b9">Jeong, Tian, and Bareinboim (2022)</ref>:</p><formula xml:id="formula_5">(i) Let Z (i) ⊆ R be the set of all variables Z ∈ R, which satisfy (Z ⊥ ⊥ X) G X . (ii) Let Z (ii) ⊆ Z (i) be the set of all Z ∈ Z (i) , for which ∃S ⊆ Z (i) s.t. ({Z} ∪ S ⊥ ⊥ Y | X) G {Z}∪S . (iii) If I ⊆ Z (ii) and Z (ii) intercepts all causal paths from X to Y, then output Z (ii) , else output ⊥.</formula><p>This algorithm is correct because all vertices not in Z (ii) cannot be in any set satisfying the FD criterion, as they are not in R or would violate FD(2) and/or FD(3). It follows from this maximality of Z (ii) that if I is not a subset of Z (ii) or if Z (ii) does not satisfy FD(1), then no set does (if some set Z satisfies FD(1), then any superset does as well). <ref type="bibr" target="#b9">Jeong, Tian, and Bareinboim (2022)</ref>  </p><formula xml:id="formula_6">Z (i) ⊆ R, i.e., all vertices Z in R with (Z ⊥ ⊥ X) G X , in time O(n + m).</formula><p>Proof. Start Bayes-Ball <ref type="bibr" target="#b15">(Shachter 1998</ref>) (Algorithm 5 in Appendix A) at X in the DAG G X . Precisely the vertices N not reached by the algorithm satisfy (Z ⊥ ⊥ X) G X . Hence,</p><formula xml:id="formula_7">Z (i) = N ∩ R.</formula><p>We exemplify the algorithms in this section with the running example in Fig. <ref type="figure">2</ref>. Here, the goal is to find an FD set relative to X and Y . The variables U 1 to U 4 are unobserved, hence R = {A, B, C, D}. Moreover, we have I = ∅. In the graph, vertex C is reachable via the BD path X ← U 2 → C from X, whereas the remaining vertices in R, A, B and D, are not reachable by such a path. Hence, Z (i) = {A, B, D}.</p><p>It remains to show how to execute step (ii), i.e., to compute Z (ii) , in time O(n + m). Thus, it is our task, given a set Z (i) ⊆ R disjoint with X and Y, which contains all vertices satisfying (i), to decide for every Z ∈ Z (i) whether there exists a set S ⊆ Z</p><formula xml:id="formula_8">(i) with ({Z} ∪ S ⊥ ⊥ Y | X) G {Z}∪S .</formula><p>First, we define the notion of a forbidden vertex v:</p><formula xml:id="formula_9">Definition 1. A vertex V is forbidden if it is not in Z (ii) . Hence, by definition this is the case if (a) V ̸ ∈ Z (i) or (b) there exists no S ⊆ Z (i) for V such that ({V }∪S⊥ ⊥Y | X) G {V }∪S .</formula><p>Our goal will be to find all forbidden vertices. The remaining vertices then make up the sought after set Z (ii) . We utilize the following key lemma. Lemma 2. Let G be a DAG and X, Y disjoint sets of vertices. Vertex V is forbidden if, and only if,</p><formula xml:id="formula_10">(A) V ̸ ∈ Z (i) , (B) V ← Y, or (C)</formula><p>there exists an open BD way π (consisting of at least three variables) from V to Y given X, and all its nonterminal vertices are forbidden.</p><p>Proof. We show two directions. First, if V ∈ Z (i) , there is no edge V ← Y and there exists no open BD way with only forbidden vertices from V to Y given X, then there exists a set S ⊆ Z (i) , for which</p><formula xml:id="formula_11">({V } ∪ S ⊥ ⊥ Y | X) G {V }∪S holds.</formula><p>It can be constructed by choosing, for every open way from V to Y, a non-forbidden vertex W and its set S W (which fulfills ({W }∪S W ⊥ ⊥Y | X) G {W }∪S W ) and taking the union</p><formula xml:id="formula_12">W ({W } ∪ S W ) = S.</formula><p>In particular, by taking W into S, we close the open way it is on as W is a non-collider (it is not in X as it is non-forbidden by definition) and hence the way is cut, due to the removal of outgoing edges from W . By adding all vertices in S W , it holds that W and the vertices in S W have no open BD way to Y given X. For this, note that if</p><formula xml:id="formula_13">({W }∪S W ⊥ ⊥Y | X) G {W }∪S W is true, then we also have for every set S ′ ⊇ {W } ∪ S W that ({W } ∪ S W ⊥ ⊥ Y | X) G S ′ .</formula><p>Hence, taking the union W ({W } ∪ S W ) will not open any previously closed ways.</p><p>Second, if V is not in Z (i) , then V is forbidden by Definition 1 (part (a)) and if there exists an open BD way π with only forbidden vertices, a set S satisfying (b) can never be found (the way could only be closed by adding one of its vertices to S, but all of them are forbidden). </p><formula xml:id="formula_14">Algorithm 1: Finding the set Z (ii) in time O(n+m). input :DAG G = (V, E) and sets X, Y, Z (i) ⊂ V. output :Set Z (ii) . 1 Initialize visited[V, inc], visited[V, out] and continuelater[V ] with false for all V ∈ V. 2 forbidden[V ] := true if V ̸ ∈ Z (i) else false. 3 function visit(G, V, edgetype) 4 visited[V, edgetype] := true 5 forbidden[V ] := true 6 if V ̸ ∈ X then 7 foreach W ∈ Ch(V ) do 8 if not visited[W, inc] then visit(G, W, inc) 9 end 10 if edgetype = out then 11 foreach W ∈ Pa(V ) do 12 if not visited[W, out] then 13 if forbidden[W ] then 14 visit(G, W, out)</formula><formula xml:id="formula_15">if continuelater[V ] and not visited[V, out] then visit(G, V, out) 22 end 23 foreach Y ∈ Y do 24 if not visited[Y, out] then visit(G, Y, out) 25 end 26 return V \ {V | forbidden[V ] = true}</formula><p>In Fig. <ref type="figure">2</ref>, X, Y , all U i and C are forbidden as they are not in Z (i) (condition (A) of Lemma 2). Moreover, vertex B is forbidden, as there is a BD way from it via forbidden vertex U 3 to Y (condition (C) of Lemma 2). In contrast, A and D are not forbidden and it follows that Z (ii) = {A, D}.</p><p>Lemma 2 suggests an algorithmic approach for finding all forbidden vertices in linear time (a formal description is given in Algorithm 1). First, we mark all vertices V ̸ ∈ Z (i) as forbidden (line 2). We then start a graph search, similar to Bayes-Ball, at Y visiting only forbidden vertices. Each vertex is visited at most twice, once through an incoming and once through an outgoing edge. For this, when handling a vertex V , we iterate over those of its neighbors, which could extend the path over forbidden vertices with which V was reached. As in Bayes-Ball, this depends on the direction of the edges (collider/non-collider) and membership in X. If a neighbor W ̸ ∈ X is a child of V , we visit it and it is consequently marked forbidden (line 8), as we either have</p><formula xml:id="formula_16">(B) that W ← Y (if V ∈ Y) or (C) an open BD way from W over V to Y via forbidden vertices. If W ̸ ∈ X is a parent of V</formula><p>and already marked forbidden (line 13), we visit it (if it has not already been visited through an outgoing edge W →). If it is not marked forbidden (line 16), we record in continuelater[W ] that it is connected to Y via a non-BD way over forbidden vertices. However, we do not visit it directly, as our search only visits forbidden vertices. If it later becomes forbidden, we continue the search at that point (line 21). Note that we do not need to consider the case W ∈ X, as is shown in the proof<ref type="foot" target="#foot_3">foot_3</ref> of Theorem 1. Theorem 1. Given a DAG and sets X, Y,</p><formula xml:id="formula_17">Z (i) , Algorithm 1 computes the set Z (ii) in time O(n + m).</formula><p>For the graph in Fig. <ref type="figure">2</ref>, first the vertices not in Z (i) , i.e., X, Y , U 1 to U 4 and C, are marked forbidden. The graph search starts at Y and visits U 3 and U 4 as they are parents of Y and already marked forbidden. Vertex B is visited as child of U 3 and thus marked forbidden as well. In contrast D, as parent of U 4 is not visited and hence not marked forbidden (it is merely marked in continuelater). This corresponds to the fact that there is no set S for which</p><formula xml:id="formula_18">({B} ∪ S ⊥ ⊥ {Y } | {X}) G {B}∪S holds, whereas ({D} ⊥ ⊥ {Y } | {X}) G {D} is true (i.e., S = ∅ contradicts condition (b)</formula><p>in Definition 1). The search then halts and A and D remain as non-forbidden vertices, which hence make up Z (ii) .</p><p>As the remaining step of testing whether Z (ii) fulfills condition FD(1) can be performed in linear-time as well <ref type="bibr" target="#b9">(Jeong, Tian, and Bareinboim 2022)</ref>, overall linear-time follows. The full algorithm for obtaining an FD set Z is given in Algorithm 2. Theorem 2. Given a DAG and sets X and Y, Algorithm 2 finds an FD set Z relative to (X, Y) with I ⊆ Z ⊆ R, or decides that such a set does not exist, in time O(n + m).</p><p>Proof. According to Lemma 1 and Theorem 1, the algorithm correctly computes Z (i) and Z (ii) . The algorithm verifies the conditions that I ⊆ Z (ii) and, by following directed edges, <ref type="table"></ref>and<ref type="table">Z (ii) by Algorithm 1.</ref> 3 Start a depth-first search (DFS) at X following only directed edges, which stops at vertices in Z (ii) ∪ Y.</p><formula xml:id="formula_19">Algorithm 2: Finding an FD set Z relative to (X, Y) in time O(n + m). input :A DAG G = (V, E) and sets X, Y, I ⊆ R ⊆ V. output :Set Z with I ⊆ Z ⊆ R or ⊥. 1 Start the Bayes-Ball (Shachter 1998) algorithm at X in G X . Let N be the non-visited vertices. 2 Compute Z (i) := N ∩ R</formula><p>Let W be the set of visited vertices. <ref type="bibr" target="#b9">Tian, and Bareinboim (2022)</ref> have shown, this makes Z (ii) an FD set.</p><formula xml:id="formula_20">4 if I ⊆ Z (ii) and W ∩ Y = ∅ then 5 return Z (ii) 6 else 7 return ⊥ 8 end that Z (ii) intercepts all causal paths from X to Y. As Jeong,</formula><p>Revisiting Fig. <ref type="figure">2</ref>, the set Z (ii) = {A, D} indeed blocks all causal paths between X and Y and is hence a valid FD set. This can be checked by starting a DFS at X, which follows the edge X → A and does not continue from there as A ∈ Z (ii) . As X has no other children, the search terminates.</p><p>It follows from Theorem 2, that given a DAG and sets X, Y, and Z, one can verify in linear-time whether the set Z is an FD set Z relative to (X, Y) by setting I = R = Z and calling Algorithm 2 as it finds Z if and only if Z is an FD set.</p><p>Moreover, with standard techniques developed by van der Zander, Liśkiewicz, and <ref type="bibr" target="#b21">Textor (2014)</ref> and applied by <ref type="bibr" target="#b9">Jeong, Tian, and Bareinboim (2022)</ref> to the FD criterion, it is possible to enumerate all FD sets with delay O(n • find(n, m)), where find(n, m) is the time it takes to find an FD set in a graph with n vertices and m edges. Hence, with the linear-time Algorithm 2 for finding FD sets presented in this work, an O(n(n + m)) delay enumeration algorithm follows directly. This improves the previous best run time of O(n 4 (n + m)) by <ref type="bibr" target="#b9">Jeong, Tian, and Bareinboim (2022)</ref> by a factor of n 3 . Corollary 1. There exists an algorithm for enumerating all front-door adjustment sets in a DAG G = (V, E) with delay O(n(n + m)).</p><p>A linear-time delay enumeration algorithm appears to be out-of-reach because even for the simpler tasks of enumerating d-separators and back-door adjustment sets, the best known delay is again O(n(n + m)) (van der Zander, Liśkiewicz, and Textor 2014).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Finding Minimal Front-Door Adjustment Sets</head><p>The method in the previous section guarantees us to find an FD set (if it exists) in linear-time. The set it will return, however, is the maximum size FD set, as the least amount of variables are pruned from R in order to satisfy condition FD(2) and FD(3). From a practical point-of-view using this set for FD adjustment appears artificial and impedes the evaluation of the FD formula. In this section, we discuss the problem of finding FD adjustment sets of small size. More precisely we aim to find minimal FD sets, that is, sets for which no proper subset satisfies the FD criterion. We remark that minimal FD sets are not necessarily of minimum size. E.g., in graph (ii) in Fig. <ref type="figure">1</ref> the FD set {B, C} is minimal, but {A} is also an FD set and has smaller sizer.</p><p>It is an open problem to efficiently compute minimum size FD sets.</p><p>The obvious algorithm for finding a minimal FD set is to find a non-minimal set and remove vertices one-by-one until no more vertices can be removed. This trivial approach has been successfully used to find minimal back-door adjustment sets in polynomial time (van der Zander, Liśkiewicz, and Textor 2019), but it is not applicable to FD sets.  <ref type="formula">3</ref>) when C ∈ Z). Removing C from the FD set turns it into a unblocked proper path, hence {A, B} is not an FD set. Neither is {A, C} nor {B, C}. Since no single vertex can be removed from Z, one might believe Z to be minimal. However, the only minimal FD set is {A}.</p><p>While it would be possible to use a modified version of this strategy, by iteratively removing a variable W from the non-minimal set Z if there exists an FD set with R = Z \ {W }, a statement which could be checked for each variable using Algorithm 2, this would yield a time complexity of O(n(n + m)). In this section, we present a linear-time O(n + m) algorithm, which moreover reveals structural insights of (minimal) FD sets. We begin with a formal definition: Definition 2. An FD set Z relative to (X, Y) is I-inclusion minimal, if and only if, no proper subset Z ′ ⊂ Z with I ⊆ Z ′ is an FD set relative to (X, Y). If I = ∅, we call the set (inclusion) minimal. <ref type="foot" target="#foot_4">5</ref>The following lemma allows us to characterize minimal FD sets: Lemma 3. Let G be a DAG and X, Y be disjoint sets of vertices. An FD set Z relative to (X, Y) is I-inclusion minimal if it can be written as Z = I ∪ Z XY ∪ Z ZY such that 1. For each Z ∈ Z XY , there exists a directed proper path from X to Z to Y containing no vertex of Z \ {Z}, and 2. for each Z ∈ Z ZY , there exists a proper BD way from I∪Z XY to Y containing an edge Z → (i.e., an edge facing in the direction of Y) but no edge Z ′ → for Z ′ ∈ Z \ {Z} which contains no vertex of X and each collider is opened by Z.</p><p>Proof. Suppose there exists a smaller FD set</p><formula xml:id="formula_21">Z ′ ⊂ Z with I ⊆ Z ′ . Let Z be a vertex of Z \ Z ′ . If Z is in Z XY , Z ′ does not block all directed paths from X to Y and is no FD set. So Z XY ⊆ Z ′ and Z is in Z ZY .</formula><p>Let π be the BD way from I ∪ Z XY to Y containing the edge Z → from point 2. Let Algorithm 3: Finding an I-inclusion minimal frontdoor adjustment set Z in linear time.</p><p>input :A DAG G = (V, E) and sets X, Y,</p><formula xml:id="formula_22">I ⊆ R ⊆ V. output :Minimal FD set Z min with I ⊆ Z min ⊆ R or ⊥ if no FD set exists.</formula><p>1 Compute the set Z (ii) with Algorithm 2; If it outputs ⊥, then return ⊥ and stop.</p><formula xml:id="formula_23">2 Let Z An ⊆ Z (ii) ∩ An(Y) be a maximal set such that each V ∈ Z An is a parent of Y or there exists a directed path from V to Y containing no vertex of X ∪ (Z (ii) \ {V }). 3 Let Z XY ⊆ Z An ∩ De(X) be a maximal set such that,</formula><p>for each V ∈ Z XY , there exists a directed proper path from X to V containing no vertex of I ∪ (Z An \ {V }). 4 Let Z ZY ⊆ Z An be a maximal set such that, for each V ∈ Z ZY , there exists a proper BD way from I ∪ Z XY to V containing no edge Z An → with Z An ∈ I ∪ Z An and no vertex of X, and all colliders are in I ∪ Z An . Z l be the last vertex of Z ′ on π. It exists since π starts in I ∪ Z XY ⊆ Z ′ . It occurs with an incoming edge Z l ← since Z → is the only outgoing edge Z → on π. So the sub-way of π from Z l to Y exists in G Z ′ , is a BD way, and is not blocked by X. Hence, Z ′ is no FD set.</p><formula xml:id="formula_24">5 return Z min := I ∪ Z XY ∪ Z ZY X A B C Y D E U 1 U 2</formula><p>The intuition behind Lemma 3 is to include only vertices that are necessary for identifying the effect of X on Y. The set Z XY is needed to block causal paths between X and Y, while the set Z ZY is needed to disconnect BD paths from Z XY to Y. The conditions are chosen, such that each path is blocked by exactly one vertex, so no vertex from Z XY ∪ Z ZY can be removed from the FD set without opening a path. Algorithm 3 shows how sets Z XY and Z ZY can be computed, by first calling Algorithm 2 and constructing Z An (defined in the algorithm).</p><p>Theorem 3. Given a DAG G and sets X and Y, Algorithm 3 finds an I-inclusion minimal FD set Z relative to (X, Y), with I ⊆ Z ⊆ R, or decides that such a set does not exist, in linear time.</p><p>These concepts are exemplified in Fig. <ref type="figure" target="#fig_3">3</ref>, where the goal is to find a minimal FD set with respect to X and Y with R = {A, B, C, D, E} and I = ∅. The FD set Z (ii) = {A, B, C, D, E} is returned by Algorithm 2. Vertices B, C, D, and E are in Z An as they are parents of Y and in Z (ii) . Based on this set, we first have Z XY = {B} as every path from X to C goes through B and there is no path to D and E. Moreover, Z ZY = {D, E} as both are needed to block BD paths from B to Y . Notably, D alone does not suffice as there would be the BD path D ← E → Y violating FD(3), i.e., the statement</p><formula xml:id="formula_25">(Z ⊥ ⊥ Y | X) G Z . By including E, this condition is satisfied because outgoing edges from variables in Z are removed in G Z . Hence Z min = Z XY ∪ Z ZY = {B, D, E} is a minimal FD set.</formula><p>From this theorem, we can conclude that the conditions of Lemma 3 are "if and only if" conditions:</p><p>Corollary 2. An FD set Z relative to (X, Y) is I-inclusion minimal if and only if it can be written as Z = I ∪ Z XY ∪ Z ZY such that Z XY and Z ZY satisfy conditions 1. and 2. given in Lemma 3.</p><p>Proof. The "if"-direction is Lemma 3. The reverse follows from the algorithm of Theorem 3. For a given set Z, apply the algorithm with R = Z. The algorithm returns a minimal set Z ′ ⊆ Z that satisfies the conditions of Lemma 3. If Z is minimal, Z = Z ′ and Z satisfies the conditions, too.</p><formula xml:id="formula_26">Corollary 3. An I-inclusion minimal FD set Z relative to (X, Y) is a subset of I ∪ An(Y).</formula><p>As we show empirically in Appendix E, the minimal FD sets returned by Algorithm 3 are often much smaller compared to the maximal FD set. However, we reemphasize that they are not guaranteed to have minimum size, i.e., there might exist an FD set of smaller cardinality, and that it is open whether it is possible to compute such sets efficiently.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Experiments</head><p>We have shown that the run time of the algorithms proposed in this work scales linearly in the size of the graph. In this section, we empirically show that this translates to practical implementations, which are able to handle hundreds of thousands of variables.</p><p>We implement our methods in Python, Julia, and JavaScript to enable wide practical usage in the causal inference community. 6 In the main paper, we show the run time for the Python implementation and compare it to the author's implementation of the algorithm for finding FD sets given in Jeong, Tian, and Bareinboim (2022) (JTB). In Appendix E, we also evaluate our Julia and Javascript implementations and provide more detailed results. We ran the experiments on a single core of the AMD Ryzen Threadripper 3970X 32-core processor on a 256GB RAM machine. 7 Figure <ref type="figure" target="#fig_4">4</ref> shows the average run time of the algorithms in seconds. Per instance, 6 To facilitate adoption, we base on the networkx Python package, which is the graph library used by causal inference packages such as DoWhy <ref type="bibr" target="#b16">(Sharma, Kiciman et al. 2019)</ref>. Similarly, in Julia we allow for easy integration into CausalInference.jl <ref type="bibr" target="#b13">(Schauer, Keller, and Wienöbst 2023)</ref> and in Javascript into the DAGitty environment <ref type="bibr" target="#b20">(Textor et al. 2016)</ref>. 7 The experiments can be replicated within a few days on a desktop computer without any problems. each algorithm was given a time limit of 30 seconds (we only report results for parameter choices for which each instance was solved within the allocated time).</p><p>The results confirm our theoretical findings as FIND (Algorithm 2) outperforms JTB by a factor of more than 10 4 on medium-sized instances (the gap widens with the number of variables). For the sparser graphs (expected degree 3), JTB does not terminate in under 30 seconds in case of more than 256 vertices; for denser graphs (expected degree 10) the performance degrades faster and only the instances up to 64 vertices are solved within the time limit. In the Appendix D, we also provide a run-time comparison for the real-life DAGs from the bnlearn repository (Scutari 2010), which further validate our findings, showing that FIND yields a sizeable improvement even for smaller graphs.</p><p>These gains also translate to MIN which has merely a slightly higher run time compared to FIND, while giving significantly smaller FD sets, as we report in more detail in Appendix E. In particular, the FD sets returned by FIND and JTB grow linearly in the number of vertices, even when MIN computes FD sets of size zero or one.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Conclusions</head><p>We have developed efficient algorithms for solving several tasks related to estimation of causal effects via FD adjustment, including finding a minimal FD set in asymptotically optimal run time. Our work shows that, from the algorithmic perspective, these tasks are not harder than for the celebrated back-door (BD) adjustment. We also offer implementations of our algorithms which significantly outperform previous methods allowing practical usage in empirical studies even for very large instances. <ref type="foot" target="#foot_5">8</ref>An important open problem is whether minimum size FD sets can be computed efficiently. For back-door adjustment, this is the case as there exists an O(n 3 ) algorithm (van der Zander, Liśkiewicz, and Textor 2019), while it is not clear if a polynomial-time algorithm exists in the FD case as well. Moreover, throughout this work, we assume that the causal DAG is known and correctly specified by the researcher. It would be interesting to combine our approach with causal discovery methods by developing algorithms for causal models representing a class of DAGs, e.g., a Markov equivalence class, instead of a single one. In such settings, the results could provide a means to construct more "robust" front-door adjustment sets if there are several options for DAGs which can be learned from data.</p><p>Another issue is that FD adjustment is still not as thoroughly understood as covariate adjustment, for which a complete graphical characterization exists <ref type="bibr">(Shpitser, Van-derWeele, and Robins 2010)</ref>, such that a set Z can be used to compute the causal effect of X on Y using the covariate adjustment formula if, and only if, it satisfies the adjustment criterion. For the FD criterion, the analogous statement does not hold and we consider it an important direction for future work to extend it and our algorithms in this way. Finally, in the classical FD criterion it has to hold that there is no BD path from X to Z. In practice, this can be rather restrictive. Recent works have relaxed this assumption <ref type="bibr" target="#b8">(Hünermund and Bareinboim 2019;</ref><ref type="bibr" target="#b4">Fulcher et al. 2020</ref>) by instead demanding that a set W exists, which blocks all such BD paths (FD(3) is generalized in the same way) and this is also an interesting avenue for future research.</p><p>Algorithm 5: Bayes-Ball Search started at vertex set X. The set of all vertices d-connected to X given Z in G is returned.</p><p>input :A DAG G = (V, E) and disjoint vertex sets X and Z. output :Set of vertices d-connected to X in G given Z. 1 Initialize visited[V, inc] and visited[V, out] with false for all V ∈ V. Note that it suffices to start visit with edgetype out (line 16), as X and Z are disjoint and hence all neighbors of X are considered during this call.</p><formula xml:id="formula_27">2 function visit(G, V , edgetype) 3 visited[V, edgetype] := true 4 if V ̸ ∈ Z then 5 foreach W ∈ Ch(V ) do 6 if not visited[W, inc] then visit(G, W , inc)</formula><p>In both the DFS and the Bayes-Ball algorithm, we gave a formulation which returns all visited vertices. As utilized in Lemma 1 in the main paper, this enables testing d-separation (the statement (X ⊥ ⊥ Y |Z) G holds if Y is not visited when starting Bayes-Ball at X).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B Missing Proofs of Section 3</head><p>We now provide the missing proof of Theorem 1. It proceeds by showing that Algorithm 1 correctly labels vertices as forbidden (by correctness of Lemma 2), which yields the statement.</p><p>Proof of Theorem 1. The correctness follows from Lemma 2 and the fact that a vertex V is marked forbidden, if, and only if, (A) it is not in Z (i) or (B) it is a child of Y or (C) there is an open BD way from V to Y given X over forbidden vertices. For this, we first observe that the algorithm is sound, i.e, a vertex marked forbidden is actually forbidden. Moreover, the completeness with regard to (A) and (B) is clear, hence, it remains to show it with regard to (C).</p><p>Consider the situation when the algorithm has terminated and assume there are forbidden vertices, which have not been visited by the algorithm and are not marked forbidden (let these be W = {W 1 , . . . , W k } and note that these are forbidden due to (C), else they would have been marked). We show that there exists an open BD way π over forbidden vertices from some W i to Y which does not contain any other W j . If this were not the case, consider the last W j on an open BD way from W i to Y (such a way has to exist as W i is forbidden, it is only not marked forbidden). If it occurs as W j ← the existence of π would follow. Hence, all such W j occur as W j →. Then it would hold that (W ⊥ ⊥ Y | X) G W and the vertices in W would not be forbidden. Thus, there is such a π and it starts with the edge W i ← P with P being visited by the algorithm (on π, every vertex is marked forbidden and it is open, hence, the graph search must have reached P by correctness of Bayes-Ball). Furthermore, no vertex X ∈ X occurs on π. It cannot occur as non-collider since that would block π; and it cannot occur as collider, since then the path from W j to → X would be a BD path from X to W j and W j would already be marked as forbidden. It follows that W i as a child of P is also visited and marked forbidden, which leads to a contradiction.</p><p>The run time bound can be derived from the fact that for each vertex we call visit at most two times (for edgetype = inc and edgetype = out) and as every such call has cost O(|Ne(v)|), every edge is visited only a constant amount of times. Hence, we obtain a run time of O(n + m).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C Missing Proofs of Section 4</head><p>In this section, we provide the missing proofs of Section 4. During this, we develop an elegant and concise framework for implementing the various graph searches discussed in this work.</p><p>Each step of Algorithm 3 for finding minimal FD sets is performed by basing on the DFS approach introduced in Section A. However, the searches have different rules which vertices can be visited and which vertices are yielded to the output set. Rather than repeating the description of the algorithm for each step, we generalize the DFS presented in Algorithm 4 to one general graph search, Algorithm 6, that can handle all different cases. Each step of Algorithm 3 becomes then a call to Algorithm 6.</p><p>In the generalization, we specify the rules in the form of a table rather than implicitly as code in a "visit()" function. For each possible combination of previous and next edge, the table lists if the vertex after the next edge should be visited. The table also lists whether that vertex should be yielded to the output.</p><p>There are four possible combinations → V → W , ← V ← W , ← V → W , and → V ← W of explicit edges to consider. The first edge → V or ← V corresponds to the parameters of the "visit()" function. V is the visited vertex and the edge the edgetype parameter. The second edge V → W or V ← W , describes whether a parent or child W of V will be visited next.</p><p>Furthermore, we consider two additional combinations of the initial edges: When starting the search at vertices X, we visit the children and parents of X, similarly to the foreach X ∈ X loop in Algorithm 4. Since there are no previously visited edges into X, these are denoted as two separate combinations init V → W and init V ← W , where V ∈ X.</p><p>For each combination, the rule table has a row. In each row, it says, whether the vertex W is visited next, and/or the vertex W is yielded to the output set. Like the DFS, the general graph search visits all vertices that can be visited, and in this sense returns a maximal set. It also runs in linear time.</p><p>Algorithm 6: General graph search in time O(n + m).</p><p>input :A DAG G = (V, E), starting vertices X, and rule table τ mapping (edgetype, vertex, edgetype, vertex) to ℘{continue, yield}. output :Yielded vertices.</p><p>1 Initialize visited[V, inc], visited[V, out] and result[V ] with false for all V ∈ V. </p><formula xml:id="formula_28">foreach V ∈ X do 22 visit(G, V , init) 23 end 24 return {V | result[V ] = true}</formula><p>Lemma 4. Given a DAG G = (V, E), starting vertices X, and rule table τ , Algorithm 6 returns a maximal vertex set W such that there exists a way v 1 e 1 v 2 e 2 . . . e k-1 v k where v i ∈ V, e i ∈ E, v 1 ∈ X, v k ∈ W, and either</p><formula xml:id="formula_29">• k = 2 and yield ∈ τ (init, v 1 , e 1 , v 2 ), or • continue ∈ τ (init, v 1 , e 1 , v 2 ), continue ∈ τ (e i , v i+1 , e i+1 , v i+2 ) (for i + 2 &lt; k), and yield ∈ τ (e k-2 , v k-1 , e k-1 , v k ), in time O(n + m).</formula><p>Proof. The algorithm performs an obvious graph search. Each vertex is only visited, if there exists a way from X to the vertex on which the rule table τ returns continue for each two-vertex sub-way. A vertex is only returned if τ returns yield.</p><p>The run time is O(n + m), because each vertex is only visited once from each edgetype.</p><formula xml:id="formula_30">case continue to W yield W init V → W - - init V ← W W ̸ ∈ X ∪ I ∪ Z XY W ∈ Z An → V → W W ̸ ∈ X ∧ V ̸ ∈ I ∪ Z An W ∈ Z An ∧ V ̸ ∈ I ∪ Z An ← V ← W W ̸ ∈ X ∪ I ∪ Z XY W ∈ Z An ← V → W W ̸ ∈ X ∧ V ̸ ∈ I ∪ Z An W ∈ Z An ∧ V ̸ ∈ I ∪ Z An → V ← W V ∈ I ∪ Z An ∧ W ̸ ∈ X ∪ I ∪ Z XY V ∈ I ∪ Z An ∧ W ∈ Z An 7 return I ∪ Z XY ∪ Z ZY Proof.</formula><p>Both algorithms follow the same approach, computing sets Z (ii) , Z An , Z XY , Z ZY , and returning I ∪ Z XY ∪ Z ZY . We need to show that each set is equal between the algorithms. Z (ii) is equal because it is computed by algorithm Algorithm 2.</p><p>In the following, we store the number of the algorithm (3 and 9) as superscript to distinguish between the sets and then show their equality. Both Z 3</p><p>An and Z 9 An include Pa(Y) ∩ Z (ii) . Z 3 An as "parent of Y", Z 9 An from rule init V ← W . If Z 3 An includes a non-parent V , there exists a directed path from V to Y containing no vertex of X ∪ (Z (ii) \ {V }). The shortest such path contains only one vertex of Y. Starting from that vertex, Algorithm 9 will take rule init V ← W and then rule ← V ← W , until it reaches V of Z 3 An , which is yielded since it is in Z (ii) . In the other direction, if V ∈ Z 9 An , there exists a path from Y to V containing only edges ← and not containing any vertex in X ∪ Y ∪ Z (ii) except at the endvertices due to Lemma 4, so V ∈ Z 3</p><p>An . If Z 3 XY contains a vertex Z, there exists a directed proper path from X to Z containing no vertex of I ∪ (Z An \ {Z}). It also contains no vertex of Y, otherwise Z (ii) would not be an FD set since there is an unblocked path from X to Y. Algorithm 9 visits the vertices along that path since the edges are → and no non-end vertex is in</p><formula xml:id="formula_31">X ∪ Y ∪ I ∪ Z An . Z is in Z An , so it is yielded into Z 9</formula><p>XY . In the other direction, if V ∈ Z 9 XY , there exists a path from X ∈ X to Z not containing a vertex of X ∪ Y ∪ I ∪ Z An except X and Z at the end.</p><p>If Z 3 ZY contains a vertex Z, there exists a proper BD way from I ∪ Z XY to Z containing no edge Z An → with Z An ∈ I ∪ Z An and no vertex of X, and all colliders are in I ∪ Z An .</p><p>Algorithm 9 starts at I ∪ Z XY visiting the vertices along the path. If the path only contains one edge, Z is yielded in the initial rule since it is in Z An . In the case ← V ← W and ← V → W , V is not in I ∪ Z An , or the path would contain V →. W is not in X since the path contains no vertex of X. In the case ← V ← W , W is not in X as well, and W is not in I ∪ Z XY since the path is proper. In the case</p><formula xml:id="formula_32">→ V ← W , W is not in X ∪ I ∪ Z XY for the same reasons. V is in I ∪ Z An since it is a collider. The final vertex Z is yielded, once it is reached, since it is in Z An .</formula><p>For Z ∈ Z 9 ZY , Algorithm 9 finds a way π from I ∪ Z XY to Z ∈ Z An . It is a BD way since it starts with ← from the initial rule. If it contains a causal edge V →, it is either the case/rule → V → W or ← V → W , and in either case V ̸ ∈ I ∪ Z An . It contains no vertex of X since W ̸ ∈ X in all five rules. The only collider occurs in rule → V ← W and it is in I ∪ Z An . If π is not proper, there exists a subway π ′ that is proper. Suppose that subway is not a BD path. Then it starts with V → where</p><formula xml:id="formula_33">V ∈ I ∪ Z XY ⊆ I ∪ Z An . But π and π ′ cannot contain this V → because rules → V → W and ← V → W only continue or yield, if V ̸ ∈ I ∪ Z An .</formula><p>We are now able to give the proof of Theorem 3.</p><p>Proof of Theorem 3. First we show that the algorithm returns a set that is an FD set if and only if an FD set exists. If Z (ii) can be computed, an FD set exists, by correctness of Algorithm 2. Moreover, Z satisfies condition FD(1) because Z An and I ∪ Z XY block all directed paths from X to Y and Z satisfies condition FD(2) because it is a subset of Z (ii) .</p><p>Suppose FD(3) is not satisfied. There is a proper BD path π from Z to Y open given X in G Z . If π would contain a collider, the collider is opened by X, so there exists a path from Z to the collider to X, and Z violates condition FD(2). Likewise, π cannot contain a vertex of X. Furthermore, π does not contain I → or it would not be open. As π is not open in G Z (ii) , there is an edge Z → for a vertex Z ∈ Z (ii) \ Z on π. The edge is directed as Z → because Z ← would start another BD path. Since π does not contain a collider, all following edges are directed towards Y and Z is an ancestor of Y. Hence, π contains an edge Z An → with Z An ∈ Z An . We will choose the first such edge.</p><p>There exists a BD way π ′ from I ∪ Z XY to Z An : If π starts in I ∪ Z XY , π ′ is the subpath of π until Z An . If π starts in Z ZY ∈ Z XY , then there is a longer BD way π ′′ from I ∪ Z XY to Z ZY found in step 4, and π ′ is the concatenation of π ′′ and the subpath of π until Z An . Neither π ′′ nor π contain a vertex of X or a collider not in I ∪ Z An , so this is also true for π ′ . π ′′ does not contain an edge I ∪ Z An → and Z An → is the first such edge on π, so π ′ does not contain an edge I ∪ Z An →. Hence Z An ∈ Z XY , and π is blocked in G Z . Now we show that Z is minimal according to Lemma 3. Condition 1. and 2. are satisfied by the definition of Z XY and Z XY . For the latter, the BD path to V can be extended to a BD path to Y because V ∈ Z An is an ancestor of Y. All colliders in I ∪ Z An are in Z XY because there is such a way to them.</p><p>The maximal sets can be constructed in linear time by traversing the paths that need to be blocked. The first usable vertex of the path is added to the corresponding set. Thereby for the each constructed set, each edge is only visited at most once and each vertex is added at most once to the set. Algorithms 6 and 9 describe this graph traversal in more detail and formally the linear run time follows from Proposition 2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D Run-Time Comparison for Real-Life DAGs</head><p>We compare the performance of our algorithm with JTB one on real-world instances to further validate our empirical claims. We report the run-times in seconds for the graphs in the bnlearn repository in Table <ref type="table">1</ref>. The stated times are averages over 10 runs. In each, variables X and Y were randomly chosen, moreover half of the remaining variables, chosen again randomly, were included in R.</p><p>The experiments show that JTB is significantly slower compared to our algorithms FIND and MIN on all instances. For larger graphs, this results in run-times above one minute for JTB, while the our algorithms take fractions of milliseconds. In practice, Table <ref type="table">1</ref>: Run-time in seconds of Python implementations of FIND and MIN (Algorithms 2 and 3 from the main paper) compared to JTB <ref type="bibr">(Jeong et al.)</ref>  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>E Further Experimental Results</head><p>In the experimental setup of this section, we consider Erdős-Rényi random graphs with 1.5n, 2.5n and 5n edges, which correspond to expected degree (i.e., number of neighbors) 3, 5 and 10. For the number of vertices, we choose powers of 2 (as this gives us a wide range of graph sizes), namely 2 4 up to 2 17 , which corresponds to 131072 vertices. Furthermore, we consider two settings for choosing the size of X and Y: (i) we choose both sizes randomly between 1 and 3 and (ii) we let X and Y grow logarithmically in the number of vertices (more precisely, we have |X| = |Y| = log 2 (n) -3; we subtract 3 such that |X| = |Y| = 1 for our starting case of 2 4 vertices). Finally, we consider two sizes of |R|: (a) |R| = 0.5n and (b) |R| = 0.25n. Our experimental setup is limited in that we only consider the case I = ∅ (which is the most natural setting; moreover, at least for FIND (Algorithm 2) and JTB <ref type="bibr" target="#b9">((Jeong, Tian, and Bareinboim 2022)</ref>), this set plays no significant algorithmic role) and that we only consider Erdős-Rényi random graphs (and not other classes of random graphs). However, the setting above already yields 14 • 3 • 2 • 2 = 168 different parameter choices and every further junction at least doubles it.</p><p>We aim to corroborate two empirical claims in this section: • Our algorithms FIND and MIN can be implemented efficiently and scale to graphs with a large number of variables.</p><p>• The size of the maximal FD set (returned by FIND and JTB) is often significantly larger compared to the minimal FD set returned by (MIN). As we will see, the run time of FIND and MIN is quite robust to different choices for |X|, |Y| and |R|. While the run time naturally increases with larger n and m, it stays well-below a second even for the largest instances considered here.</p><p>Similar observations can be made with regard to the maximal and minimal FD sets. In particular, the maximal FD set is usually extremely large, way larger than necessary to intercept the causal paths from X to Y, and this also holds for all parameter choices considered in this work.</p><p>A few technical details, before the results are discussed. We ran the experiments on a single core of the AMD Ryzen Threadripper 3970X 32-core processor on a 256GB RAM machine. The final run of the experiments took about four days, but trial runs were done before that (overall computation time was around one to two weeks). The experiments, however, do not need the large RAM provided and can be performed on average desktop computers in a similar timeframe.</p><p>We implement our algorithms FIND and MIN in Python, Julia, and JavaScript and make our code publically available. For more clarity, we show only a selection of results on the following pages, but will offer the remaining plots online. They can be accessed at <ref type="url" target="https://github.com/mwien/frontdoor-adjustment">https://github.com/mwien/frontdoor-adjustment</ref>.</p><p>Figure <ref type="figure">5</ref> shows additional run time comparisons between FIND, MIN, and JTB. In contrast to Fig. <ref type="figure" target="#fig_4">4</ref> in the main paper, the number of edges is chosen as |E| = 2.5n and the choices of |X|, |Y|, and |R| are varied.</p><p>The overall results differ only slightly. Unsurprisingly, the run time of the algorithms mainly depends on the size of the graph (i.e., n and m). For 256 variables, JTB needs roughly 5-20 seconds per instance being barely within the time limit of 30 seconds. Algorithms FIND and MIN only take fractions of a second, even for the largest considered graphs with over a hundred thousand vertices.</p><p>Figure <ref type="figure">6</ref> shows a comparison over our different implementations in Python, Julia, and JavaScript for the same parameter choices as in Fig. <ref type="figure" target="#fig_4">4</ref> in the main paper. The differences between the languages are usually within one order of magnitude with Julia being the fastest of the three. Our implementations are not specifically optimized and it would likely be possible to improve the run time further (e.g. we store all sets handled during the course of the algorithms in hashtables, raw arrays could provide further performance benefits).</p><p>Summing up, these experiments demonstrate that our implementations are extremely efficient and able to handle all (currently) imaginable graph instances arising in causal inference (and likely even more than that). In the following, we analyse the properties of the randomly generated instances in more detail. In particular, with regard to the size of the found FD sets and the ratio of instances, which can be identified by FD (and BD) adjustment.</p><p>Figure <ref type="figure" target="#fig_9">7</ref> shows the average sizes of the maximal FD sets, which are returned by FIND and MIN, and the minimal FD set returned by MIN for 10 4 randomly generated instances per parameter choice (results for not FD identifiable instances are discarded).</p><p>The maximal FD set is usually extremely large, growing linearly with the number of vertices. This is not surprising as this set not only includes the vertices necessary to block the causal paths between X and Y, but all vertices which can be used for the FD set (e.g., in the case of an empty graph, this set would still contain all vertices in R).</p><p>For the same instances, MIN gives extremely small FD sets, many of them actually having size zero, which corresponds to the case that there is no causal path from X to Y (there is bias introduced to the experiments, by the fact that graphs without such a causal path are always identified by FD, whereas those with such a path are often not). Generally, in the random graph model, it is hard to generate instance with large minimal FD sets and this is an interesting topic for future work. In the context of this work, the result demonstrates the stark contrast between FIND, respectively JTB, and MIN, as the former algorithm clearly produce unnecessarily large FD sets.</p><p>Finally, in Fig. <ref type="figure" target="#fig_10">8</ref>, we report the ratio of identified instances for the case of |R| = 0.25n and the settings in Fig. <ref type="figure" target="#fig_9">7</ref> using (i) the FD criterion, (ii) the (BD) adjustment criterion <ref type="bibr" target="#b19">(Shpitser, VanderWeele, and Robins 2010;</ref><ref type="bibr" target="#b21">van der Zander, Liśkiewicz, and Textor 2014)</ref>, here denoted by BD, (iii) the FD criterion only allowing FD sets of size zero (FDZERO) and (iv) the (BD) adjustment criterion together with FDZERO, which we denote by BDPLUS. This setup (with the addition of the FD criterion) is similar to the one studied in (van der Zander, Liśkiewicz, and Textor 2019) (Table <ref type="table">6</ref>).</p><p>As indicated already in Fig. <ref type="figure" target="#fig_9">7</ref>, for Erdős-Rényi random graphs, the difference between FD and FDZERO is quite small. However, the results nicely show the orthogonal nature of FD and BD, as can be seen for example in the plot on the top right (|E| = 2.5 and |X|, |Y| = log 2 (n) -3), where BD and FD alone identify significantly less instances than BDPLUS.  <ref type="bibr">FIND and MIN)</ref> in the programming languages Python (PY), Julia (JL), and JavaScript (JS). The parameter choices are the same as in Fig. <ref type="figure" target="#fig_4">4</ref> in the main paper. Generally, the Julia implementation is fastest and Python is second fastest. The differences, however, are comparably small (usually less than one order of magnitude).   For the case of maximal FD sets, log-log plots are necessary to adequately show the results, whereas the average size of the minimal FD sets is extremely close to zero for many of the parameter choices. The averages are obtained as the mean of the FD set sizes for all identified instances from 10 4 repetitions. Error bars are omitted for the sake of readability, but standard deviations are reported in the online supplement.   <ref type="figure" target="#fig_9">7</ref>. For identification, we consider the FD criterion (FD), the adjustment criterion <ref type="bibr" target="#b19">(Shpitser, VanderWeele, and Robins 2010;</ref><ref type="bibr" target="#b21">van der Zander, Liśkiewicz, and Textor 2014</ref>) (BD), the FD criterion for Z = ∅ (FDZERO) and BD combined with FDZERO (BDPLUS). The set up (with the addition of FD) is similar to the results presented in Table <ref type="table">6</ref> of (van der Zander, Liśkiewicz, and Textor 2019).</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>and, for any non-collider Y , we have Y ̸ ∈ C. In this work, we sometimes consider ways instead of paths. A way may contain a vertex up to two times and is open given C if, for any collider Y , we have Y ∈ C and, for any non-collider Y , we have Y ̸ ∈ C. In case there is an open way between two sets of vertices, there is also an open path and vice versa (see Appendix A for details).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>Figure 1 (iii) shows a DAG with a front-door adjustment set Z = {A, B, C}. The BD path B ← D → C → Y does not violate condition FD(3), since it is not proper (in other words, ({A, B, C} ⊥ ⊥ {Y } | {X}) G {A,B,C} holds as the path disconnects without the outgoing edges from C, which are ignored in FD(</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Example graph for finding a minimal FD set.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Log-Log plot of the average run time in seconds for (Jeong, Tian, and Bareinboim 2022) (JTB), Algorithm 2 (FIND) and Algorithm 3 (MIN) on Erdős-Rényi graphs with 1.5n (left) and 5n (right) edges, corresponding to expected vertex degree 3 and 10. |X|, |Y| are random integers between 1 and 3; |I| = 0 and |R| = 0.5n. For each choice of n, we average over 50 graphs.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>= inc and V ∈ Z) or (edgetype = out and V ̸ ∈ Z)then 10 foreach W ∈ Pa(V ) do 11 if not visited[W, out] then visit(G, W , out) visited[X, out] then visit(G, X, out) 17 end 18 return {V | visited[V, inc] or visited[V, out] = true}As function visit is called at most twice for each vertex, each edge is considered a constant number (more precisely, three) of times as well. Hence, the algorithm has run time O(n + m).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>2</head><label></label><figDesc>function visit(G, V , edgetype) visited[W, e] and continue ∈ τ (edgetype, V, e, W ) then 16 visit(G, W , e)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 5 :Figure 6 :</head><label>56</label><figDesc>Figure 5: Run time comparison between FIND (Algorithm 2), MIN (Algorithm 3) and JTB ((Jeong, Tian, and Bareinboim 2022)) for additional parameter choices. In particular, we choose |E| = 2.5n (corresponding to expected degree 5) and vary the choices of |R| and |X|, |Y|. As can be seen the run time differences are minor.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head></head><label></label><figDesc>set; |X|, |Y| ∈ rand [1, 3] |R| = 0.25n; |E| = 1.5n |R| = 0.25n; |E| = 2.5n |R| = 0.25n; |E| = 5n |R| = 0.5n; |E| = 1.5n |R| = 0.5n; |E| = 2.5n |R| = 0.5n; set; |X|, |Y| = log 2 (n) -3 |R| = 0.25n; |E| = 1.5n |R| = 0.25n; |E| = 2.5n |R| = 0.25n; |E| = 5n |R| = 0.5n; |E| = 1.5n |R| = 0.5n; |E| = 2.5n |R| = 0.5n; |E| = 5n</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: Average size of the maximal FD set found by FIND and JTB (top) as well as the minimal FD set returned by MIN (bottom). On the left instances for |X|, |Y| chosen randomly between 1 and 3 are shown, on the right those with |X| = |Y| = log 2 (n) -3.For the case of maximal FD sets, log-log plots are necessary to adequately show the results, whereas the average size of the minimal FD sets is extremely close to zero for many of the parameter choices. The averages are obtained as the mean of the FD set sizes for all identified instances from 10 4 repetitions. Error bars are omitted for the sake of readability, but standard deviations are reported in the online supplement.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 8 :</head><label>8</label><figDesc>Figure8: Ratio of identified instances for |R| = 0.25n and the same parameter choices as in Fig.7. For identification, we consider the FD criterion (FD), the adjustment criterion<ref type="bibr" target="#b19">(Shpitser, VanderWeele, and Robins 2010</ref>; van der Zander, Liśkiewicz, and Textor 2014) (BD), the FD criterion for Z = ∅ (FDZERO) and BD combined with FDZERO (BDPLUS). The set up (with the addition of FD) is similar to the results presented in Table6of (van der Zander, Liśkiewicz, and Textor 2019).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>on the bnlearn instances. In the table, n denotes the number of variables and m the number of edges of the instance.</figDesc><table><row><cell cols="2">Instance</cell><cell></cell><cell cols="3">Run-time in seconds</cell></row><row><cell>Name</cell><cell>n</cell><cell>m</cell><cell>FIND</cell><cell>MIN</cell><cell>JTB</cell></row><row><cell>asia</cell><cell>8</cell><cell>8</cell><cell cols="2">0.00004 0.00005</cell><cell>0.00187</cell></row><row><cell>cancer</cell><cell>5</cell><cell>4</cell><cell cols="2">0.00003 0.00004</cell><cell>0.00098</cell></row><row><cell>earthquake</cell><cell>5</cell><cell>4</cell><cell cols="2">0.00003 0.00005</cell><cell>0.00157</cell></row><row><cell>sachs</cell><cell>11</cell><cell>17</cell><cell cols="2">0.00003 0.00005</cell><cell>0.00667</cell></row><row><cell>survey</cell><cell>6</cell><cell>6</cell><cell cols="2">0.00004 0.00005</cell><cell>0.00131</cell></row><row><cell>alarm</cell><cell>37</cell><cell>46</cell><cell cols="2">0.00005 0.00010</cell><cell>0.10388</cell></row><row><cell>barley</cell><cell>48</cell><cell>84</cell><cell cols="2">0.00009 0.00013</cell><cell>0.14188</cell></row><row><cell>child</cell><cell>20</cell><cell>25</cell><cell cols="2">0.00004 0.00007</cell><cell>0.01717</cell></row><row><cell>insurance</cell><cell>27</cell><cell>52</cell><cell cols="2">0.00006 0.00010</cell><cell>0.04396</cell></row><row><cell>mildew</cell><cell>35</cell><cell>46</cell><cell cols="2">0.00007 0.00011</cell><cell>0.04161</cell></row><row><cell>water</cell><cell>32</cell><cell>66</cell><cell cols="2">0.00005 0.00011</cell><cell>0.07481</cell></row><row><cell>hailfinder</cell><cell>56</cell><cell>66</cell><cell cols="2">0.00008 0.00011</cell><cell>0.18193</cell></row><row><cell>hepar2</cell><cell>70</cell><cell cols="3">123 0.00006 0.00011</cell><cell>0.64581</cell></row><row><cell>win95pts</cell><cell>76</cell><cell cols="3">112 0.00006 0.00009</cell><cell>0.35280</cell></row><row><cell>andes</cell><cell>223</cell><cell cols="3">338 0.00029 0.00042</cell><cell>11.27554</cell></row><row><cell>diabetes</cell><cell>413</cell><cell cols="3">602 0.00074 0.00107</cell><cell>42.71703</cell></row><row><cell>link</cell><cell cols="5">724 1125 0.00030 0.00040 194.19350</cell></row><row><cell>munin1</cell><cell>186</cell><cell cols="3">273 0.00011 0.00016</cell><cell>3.41474</cell></row><row><cell>pathfinder</cell><cell>109</cell><cell cols="3">195 0.00005 0.00012</cell><cell>1.75494</cell></row><row><cell>pigs</cell><cell>441</cell><cell cols="3">592 0.00014 0.00019</cell><cell>10.54953</cell></row><row><cell>munin</cell><cell cols="5">1041 1397 0.00028 0.00043 145.71717</cell></row><row><cell>munin2</cell><cell cols="5">1003 1244 0.00028 0.00039 128.43397</cell></row><row><cell>munin3</cell><cell cols="5">1041 1306 0.00030 0.00044 236.72920</cell></row><row><cell>munin4</cell><cell cols="5">1038 1388 0.00030 0.00044 179.49700</cell></row><row><cell cols="6">this difference matters, especially when the procedure is called many times (e.g. searching for front-door sets in multiple graphs</cell></row><row><cell>or for many pairs of variables).</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>|E| = 1.5n; |R| = 0.25n; |X|, |Y| ∈ rand [1, 3] |E| = 1.5n; |R| = 0.25n; |X|, |Y| = log 2 (n) -3 |R| = 0.25n; |X|, |Y| ∈ rand [1, 3] |R| = 0.25n; |X|, |Y| = log 2 (n) -3</figDesc><table><row><cell></cell><cell>1</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>1</cell><cell></cell><cell></cell><cell></cell></row><row><cell>Ratio of identified instances</cell><cell>0.4 0.6 0.8</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="2">fd bd fdzero bdplus</cell><cell>Ratio of identified instances</cell><cell>0.2 0.4 0.6 0.8</cell><cell></cell><cell></cell><cell></cell><cell>fd bd fdzero bdplus</cell></row><row><cell></cell><cell></cell><cell>2 5</cell><cell>2 7</cell><cell>2 9</cell><cell>2 11</cell><cell>2 13</cell><cell>2 15</cell><cell>2 17</cell><cell></cell><cell>2 5</cell><cell>2 7</cell><cell>2 9</cell><cell>2 11</cell><cell>2 13</cell><cell>2 15</cell><cell>2 17</cell></row><row><cell></cell><cell></cell><cell></cell><cell cols="4">Number of Variables</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="3">Number of Variables</cell></row><row><cell>Ratio of identified instances</cell><cell>0.2 0.4 0.6 0.8 1</cell><cell cols="7">|E| = 2.5n; fd bd fdzero bdplus</cell><cell>Ratio of identified instances</cell><cell cols="5">0 0.2 0.4 0.6 0.8 1 |E| = 2.5n; fd bd fdzero bdplus</cell></row><row><cell></cell><cell></cell><cell>2 5</cell><cell>2 7</cell><cell>2 9</cell><cell>2 11</cell><cell>2 13</cell><cell>2 15</cell><cell>2 17</cell><cell></cell><cell>2 5</cell><cell>2 7</cell><cell>2 9</cell><cell>2 11</cell><cell>2 13</cell><cell>2 15</cell><cell>2 17</cell></row><row><cell></cell><cell></cell><cell></cell><cell cols="4">Number of Variables</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="3">Number of Variables</cell></row><row><cell></cell><cell></cell><cell cols="7">|E| = 5n; |R| = 0.25n; |X|, |Y| ∈ rand [1, 3]</cell><cell></cell><cell cols="5">|E| = 5n; |R| = 0.25n; |X|, |Y| = log 2 (n) -3</cell></row><row><cell>Ratio of identified instances</cell><cell>0.2 0.4 0.6 0.8 1</cell><cell></cell><cell>fd bd fdzero bdplus</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>Ratio of identified instances</cell><cell>0.2 0.4 0.6</cell><cell></cell><cell>fd bd fdzero bdplus</cell><cell></cell></row><row><cell></cell><cell>0</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>0</cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell>2 5</cell><cell>2 7</cell><cell>2 9</cell><cell>2 11</cell><cell>2 13</cell><cell>2 15</cell><cell>2 17</cell><cell></cell><cell>2 5</cell><cell>2 7</cell><cell>2 9</cell><cell>2 11</cell><cell>2 13</cell><cell>2 15</cell><cell>2 17</cell></row><row><cell></cell><cell></cell><cell></cell><cell cols="4">Number of Variables</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="3">Number of Variables</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>Following convention, for a random variable X, we use P (x) as a shorthand for P (X = x). By bold capital letters X, Y, etc., we denote sets of variables, and the corresponding sets of values are denoted by bold lowercase letters x, y, etc.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>By n, we denote the number of variables/vertices, by m the number of edges in the causal graph.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2"><p>For a definition of the front-door criterion, see Sec. 2. We term sets satisfying this criterion FD sets.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_3"><p>We defer some proofs to the appendix. Theorem 1 is proved in Appendix B.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_4"><p>In the majority of cases, we only speak of minimal FD sets and omit the word inclusion for I = ∅.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="8" xml:id="foot_5"><p>The implementations and code to reproduce the experiments are available at https://github.com/mwien/frontdoor-adjustment.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_6"><p>Let Z ZY be given by Algorithm 6 from vertices I ∪ Z XY with rule table</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div><head>Acknowledgements</head><p>This work was supported by the <rs type="funder">Deutsche Forschungsgemeinschaft (DFG)</rs> grant <rs type="grantNumber">471183316</rs> (<rs type="grantNumber">ZA 1244/1-1</rs>).</p></div>
			</div>
			<listOrg type="funding">
				<org type="funding" xml:id="_qAfRvXT">
					<idno type="grant-number">471183316</idno>
				</org>
				<org type="funding" xml:id="_KVuB8X8">
					<idno type="grant-number">ZA 1244/1-1</idno>
				</org>
			</listOrg>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendix A Introduction to the Bayes-Ball Algorithm</head><p>In the main paper, we often utilize the fact that testing d-separation statements and similar tasks can be performed in linear-time. E.g., in Lemma 1 it is necessary to find all variables d-separated from X in the graph with outgoing edges from X removed. The underlying algorithm to achieve such results is the well-known Bayes-Ball Algorithm <ref type="bibr" target="#b15">(Shachter 1998)</ref>.</p><p>As this algorithm plays a major role this work and the more involved algorithms (such as Algorithm 1 and 6) are conceptually build on top of it, we give a brief summary.</p><p>The main idea is similar to a classical graph search (in this work, we use algorithms stylistically close to depth-first-search (DFS)). The standard DFS is started at a certain vertex (say X) and a recursive visit function is called for every neighbor, which has not been visited before.</p><p>For comparison, we briefly state DFS in Algorithm 4 for directed graphs under the classical definition of a path (causal paths in causal inference terminology) and for a set of vertices X.</p><p>Algorithm 4: Depth-First-Search started at vertex set X. The set of all vertices visited during the search is returned.</p><p>input :A DAG G = (V, E) and set of vertices X. output :Set of vertices reachable from X via directed paths in G.</p><p>Note that the search is started for each vertex X ∈ X separately in the for-loop in line 8, unless this vertex was already visited during an earlier search. The latter guarantees the run time of O(n + m), because visit is called at most once for each vertex and hence each edge is visited at most once.</p><p>The Bayes-Ball algorithm is a generalization of this approach to allow for the more complicated path definition used in d-connectedness, given a set Z. In particular, which neighbors of V have to be considered depends on the direction of the edge with which</p><p>To check the latter, it would, however, be inconvenient (and costly with regard to the run time) to check all descendants of V for membership in Z. One insight of the Bayes-Ball search is that this is not necessary. Indeed, the algorithm will only check whether V ∈ Z and if it is and V is a collider the search continues.</p><p>This suffices because assume there is such a Z which is in Z and a descendant of V . This means, we have → V ← W and</p><p>A way allows for vertices to be visited more than once (compared to a path). It holds that two vertices are d-connected by an open path given Z if, and, only if there is an open way. Here, a way is open if every non-collider is not in Z and every collider is in Z (in contrast to a path where the latter holds with regards to the descendants of a collider).</p><p>The implementation of Bayes-Ball is given in Algorithm 5. It stores for each vertex separately whether it was visited through an incoming and whether it was visited through an outgoing edge. As the neighbors for continuing the search are different in the two cases, both have to be considered and a vertex may be visited twice. More precisely, the neighbors considered when visiting V depend on the membership of V ∈ Z and the direction of the edge through which V was discovered in the manner described above.</p><p>Algorithm 7: Bayes-Ball Search as special case of Algorithm 6. It returns the same set as Algorithm 5.</p><p>input :A DAG G = (V, E) and vertex sets X and Z. output :Set of vertices d-connected to X in G given Z.</p><p>1 Return the vertices yielded by Algorithm 6 starting from vertices X with rule table</p><p>Algorithm 8: Using Algorithm 6 to find the forbidden vertices. It returns the same set as Algorithm 1. input :A DAG G = (V, E) and sets X, Y, Z (i) ⊆ V. output :Set Z (ii) .</p><p>1 A := An(Y) 2 Let Z ′ be the vertices yielded by Algorithm 6 starting from vertices Y with rule table</p><p>Algorithm 7 illustrates how the Bayes-Ball Algorithm 5 can be given as a special case of Algorithm 6. Algorithm 8 shows how Algorithm 1 can be implemented using Algorithm 6. In Proposition 1, we show these two algorithms are equivalent. Most of the old algorithm can be directly translated into table rules. However, the vertices marked as continuelater need to be handled differently since the table rules are static and do not change, so it would not be possible to encode that a vertex first cannot be visited from its children before it is in continuelater, but later can be visited from a child after it is in continuelater. We resolve this problem by utilizing the set of ancestors of Y (these have to be computed beforehand, making this implementation slightly less efficient from a practical point-of-view; the asymptotic run time is unaltered).</p><p>Proposition 1. Algorithm 1 and Algorithm 8 are equivalent.</p><p>Proof. The "visit()" function of Algorithm 1 has two foreach loops. The first loop visits all descendants of each visited vertex. This corresponds to the three rules of cases ending with → W . The second loop visits all ancestors until the first non-forbidden vertex. This corresponds to the rules init V ← W and ← V ← W .</p><p>The "visit()" function only moves from an incoming to an outgoing edge when the vertex has been marked as continuelater (line 21). This corresponds to the rule → V ← W because only the ancestors of Y can be marked as continuelater. They are only marked by the second loop, which only visits ancestors. First the ancestors of Y, and then the ancestors of vertices already marked as continuelater. Inductively, it follows that only ancestors of Y are ever marked. In the other direction, each ancestor W of Y can be treated as if it was marked as continuelater. Either it is marked there, or it is visited by an incoming edge from its parent, so all vertices on the path from W to Y will be marked as forbidden. Thus all parents of the vertices on that path can be visited, and the parents of W , too.</p><p>Algorithm 9 gives the rules to implement the minimal FD search. Proposition 2 shows that those rules match the conditions given in Algorithm 3. Proposition 2. Algorithm 3 and Algorithm 9 are equivalent.</p><p>Algorithm 9: Finding a minimal front-door adjustment set Z relative to (X, Y) in time O(n + m). The tables give for each case of possible edge types, the conditions under which the rule table should return continue or yield.</p><p>input :A DAG G = (V, E) and sets X, Y, I ⊆ R ⊆ V. output :Minimal FD set Z with I ⊆ Z ⊆ R or ⊥. </p><p>5 Let Z XY be given by Algorithm 6 from vertices X with rule table</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">The paper of how: Estimating treatment effects using the frontdoor criterion</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">F</forename><surname>Bellemare</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Bloem</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Wexler</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
	<note type="report_type">Technical report</note>
	<note>Working paper</note>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Misinformed speculators and mispricing in the housing market</title>
		<author>
			<persName><forename type="first">A</forename><surname>Chinco</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Mayer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The Review of Financial Studies</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="486" to="522" />
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Friends in high places</title>
		<author>
			<persName><forename type="first">L</forename><surname>Cohen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">J</forename><surname>Malloy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">American Economic Journal: Economic Policy</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="63" to="91" />
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Design of experiments</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">A</forename><surname>Fisher</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">British Medical Journal</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">3923</biblScope>
			<biblScope unit="page">554</biblScope>
			<date type="published" when="1936">1936</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Robust inference on population indirect causal effects: the generalized front door criterion</title>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">R</forename><surname>Fulcher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Shpitser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Marealle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">J</forename><surname>Tchetgen Tchetgen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the Royal Statistical Society: Series B (Statistical Methodology)</title>
		<imprint>
			<biblScope unit="volume">82</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="199" to="214" />
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Front-door versus backdoor adjustment with unmeasured confounding: Bias formulas for front-door and hybrid adjustments with application to a job training program</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">N</forename><surname>Glynn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Kashin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the American Statistical Association</title>
		<imprint>
			<biblScope unit="volume">113</biblScope>
			<biblScope unit="issue">523</biblScope>
			<biblScope unit="page" from="1040" to="1049" />
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Estimating treatment effects with observed confounders and mediators</title>
		<author>
			<persName><forename type="first">S</forename><surname>Gupta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Lipton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Childers</surname></persName>
		</author>
		<idno>PMLR</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Thirty-Seventh Conference on Uncertainty in Artificial Intelligence</title>
		<meeting>the Thirty-Seventh Conference on Uncertainty in Artificial Intelligence</meeting>
		<imprint>
			<date type="published" when="2021">2021</date>
			<biblScope unit="page" from="982" to="991" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Pearl&apos;s calculus of intervention is complete</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Valtorta</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twenty-Second Conference on Uncertainty in Artificial Intelligence</title>
		<meeting>the Twenty-Second Conference on Uncertainty in Artificial Intelligence</meeting>
		<imprint>
			<publisher>AUAI Press</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="217" to="224" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<author>
			<persName><forename type="first">P</forename><surname>Hünermund</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Bareinboim</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1912.09104</idno>
		<title level="m">Causal inference and data fusion in econometrics</title>
		<imprint>
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Finding and Listing Front-door Adjustment Sets</title>
		<author>
			<persName><forename type="first">H</forename><surname>Jeong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Tian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Bareinboim</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Thirty-Sixth Conference on Neural Information Processing Systems (NeurIPS)</title>
		<meeting>the Thirty-Sixth Conference on Neural Information Processing Systems (NeurIPS)</meeting>
		<imprint>
			<date type="published" when="2022">2022</date>
			<biblScope unit="page" from="33173" to="33185" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Selection of post-treatment variables for estimating total effect from empirical research</title>
		<author>
			<persName><forename type="first">M</forename><surname>Kuroki</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the Japan Statistical Society</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="115" to="128" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Causal diagrams for empirical research</title>
		<author>
			<persName><forename type="first">J</forename><surname>Pearl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Biometrika</title>
		<imprint>
			<biblScope unit="volume">82</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="669" to="688" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Causality</title>
		<author>
			<persName><forename type="first">J</forename><surname>Pearl</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009">2009</date>
			<publisher>Cambridge University Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<author>
			<persName><forename type="first">M</forename><surname>Schauer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Keller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Wienöbst</surname></persName>
		</author>
		<ptr target="https://github.com/mschauer/CausalInference.jl" />
		<title level="m">CausalInference.jl</title>
		<imprint>
			<date type="published" when="2023">2023</date>
			<biblScope unit="page" from="2023" to="2028" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Learning Bayesian Networks with the bnlearn R Package</title>
		<author>
			<persName><forename type="first">M</forename><surname>Scutari</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Statistical Software</title>
		<imprint>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="1" to="22" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Bayes-Ball: The Rational Pastime (for Determining Irrelevance and Requisite Information in Belief Networks and Influence Diagrams)</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">D</forename><surname>Shachter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Fourteenth Conference on Uncertainty in Artificial Intelligence, UAI&apos;98</title>
		<meeting>the Fourteenth Conference on Uncertainty in Artificial Intelligence, UAI&apos;98</meeting>
		<imprint>
			<publisher>Morgan Kaufmann</publisher>
			<date type="published" when="1998">1998</date>
			<biblScope unit="page" from="480" to="487" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">DoWhy: A Python package for causal inference</title>
		<author>
			<persName><forename type="first">A</forename><surname>Sharma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Kiciman</surname></persName>
		</author>
		<ptr target="https://github.com/microsoft/dowhy" />
		<imprint>
			<date type="published" when="2019">2019</date>
			<biblScope unit="page" from="2023" to="2028" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Identification of Conditional Interventional Distributions</title>
		<author>
			<persName><forename type="first">I</forename><surname>Shpitser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Pearl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twenty-Second Conference on Uncertainty in Artificial Intelligence</title>
		<meeting>the Twenty-Second Conference on Uncertainty in Artificial Intelligence</meeting>
		<imprint>
			<publisher>AUAI Press</publisher>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="437" to="444" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Identification of joint interventional distributions in recursive semi-Markovian causal models</title>
		<author>
			<persName><forename type="first">I</forename><surname>Shpitser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Pearl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twenty-First National Conference on Artificial Intelligence</title>
		<meeting>the Twenty-First National Conference on Artificial Intelligence<address><addrLine>Menlo Park, CA; Cambridge, MA; London</addrLine></address></meeting>
		<imprint>
			<publisher>AAAI Press; MIT Press</publisher>
			<date type="published" when="1999">2006. 1999</date>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="1219" to="1226" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">On the Validity of Covariate Adjustment for Estimating Causal Effects</title>
		<author>
			<persName><forename type="first">I</forename><surname>Shpitser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Vanderweele</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Robins</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twenty-Sixth Conference on Uncertainty in Artificial Intelligence</title>
		<meeting>the Twenty-Sixth Conference on Uncertainty in Artificial Intelligence</meeting>
		<imprint>
			<publisher>AUAI Press</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="527" to="536" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Robust causal inference using directed acyclic graphs: the R package &apos;dagitty</title>
		<author>
			<persName><forename type="first">J</forename><surname>Textor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Van Der Zander</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">S</forename><surname>Gilthorpe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Liśkiewicz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">T</forename><surname>Ellison</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International journal of epidemiology</title>
		<imprint>
			<biblScope unit="volume">45</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="1887" to="1894" />
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Constructing Separators and Adjustment Sets in Ancestral Graphs</title>
		<author>
			<persName><forename type="first">B</forename><surname>Van Der Zander</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Liśkiewicz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Textor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Thirtieth Conference on Uncertainty in Artificial Intelligence, UAI&apos;14</title>
		<meeting>the Thirtieth Conference on Uncertainty in Artificial Intelligence, UAI&apos;14</meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="907" to="916" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Separators and adjustment sets in causal graphs: Complete criteria and an algorithmic framework</title>
		<author>
			<persName><forename type="first">B</forename><surname>Van Der Zander</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Liśkiewicz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Textor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Artificial Intelligence</title>
		<imprint>
			<biblScope unit="volume">270</biblScope>
			<biblScope unit="page" from="1" to="40" />
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
