<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Minimal TestCase Generation for Object-Oriented Software with State Charts</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Ranjita</forename><forename type="middle">Kumari</forename><surname>Swain</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Rourkela Institute of Mgt. Studies</orgName>
								<address>
									<settlement>Rourkela</settlement>
								</address>
							</affiliation>
						</author>
						<author role="corresp">
							<persName><forename type="first">Prafulla</forename><forename type="middle">Kumar</forename><surname>Behera</surname></persName>
							<email>p_behera@hotmail.com</email>
							<affiliation key="aff1">
								<orgName type="department">Dept. of Comp. Sc</orgName>
								<orgName type="institution">Utkal University</orgName>
								<address>
									<settlement>Bhubaneswar</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Durga</forename><forename type="middle">Prasad</forename><surname>Mohapatra</surname></persName>
							<affiliation key="aff2">
								<orgName type="department">Dept. of Comp. Sc. and Engg</orgName>
								<orgName type="institution">National Institute of Technology</orgName>
								<address>
									<settlement>Rourkela</settlement>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Minimal TestCase Generation for Object-Oriented Software with State Charts</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="DOI">10.5121/ijsea.2012.3404</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.1" ident="GROBID" when="2025-10-14T18:14+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Test generation technique</term>
					<term>Test sequence generation</term>
					<term>State chart diagram / State charts</term>
					<term>Test Case Generation</term>
					<term>Test Coverage</term>
					<term>Test Optimization</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Today statecharts are a de facto standard in industry for modeling system behavior. Test data generation is one of the key issues in software testing. This paper proposes an reduction approach to test data generation for the state-based software testing. In this paper, first state transition graph is derived from state chart diagram. Then, all the required information are extracted from the state chart diagram. Then, test cases are generated. Lastly, a set of test cases are minimized by calculating the node coverage for each test case. It is also determined that which test cases are covered by other test cases. The advantage of our test generation technique is that it optimizes test coverage by minimizing time and cost. The present test data generation scheme generates test cases which satisfy transition path coverage criteria, path coverage criteria and action coverage criteria. A case study on Railway Ticket Vending Machine (RTVM) has been presented to illustrate our approach.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>With continually increasing system sizes, the issue of automatic design of system test cases is assuming prime importance <ref type="bibr" target="#b26">[28]</ref>. A properly generated test suite may not only locate the errors in a software system, but also help in reducing the high cost associated with software testing <ref type="bibr" target="#b15">[17]</ref>. Many present day software solutions are state based. In such systems, the system behavior is determined by its state. In other words, a system can respond differently to the same event in different states. Therefore, unless a system is made to assume all its possible states and tested, it would not be possible to uncover state-based bugs. Adequate system testing of such software requires satisfactory coverage of system states and transitions. Generation of test specifications to meet these coverage criteria can be accomplished by using the state model of a system. However, it is a non-trivial task to manually construct the state model of a system. The state model of an actual system is usually extremely complex and comprises of a large number of states and transitions. Possibly for this reason, state models of complete systems are rarely constructed by system developers <ref type="bibr" target="#b26">[28]</ref>.</p><p>Testing of object-oriented software is a traditional activity that is part of the process of software quality assurance. Model-based testing technique has grown in importance. The models used represent the relevant features of the system under tests (SUT), and can also be used as a basis for generating test cases. The time and required effort to do sufficient testing grow, as the size and complexity of the software grows. Typical models that are used for representing system behavior are for instance the unified modeling language, finite statemachines and statecharts. Testing can be carried out earlier in the development process so that the developer will be able to find the inconsistencies and ambiguities in the specification. Hence it will be able to improve the specification before the progam is written <ref type="bibr" target="#b10">[12]</ref>. Testing activities consist of designing test cases that are sequences of inputs, executing the program with test cases, and examining the results produced by this execution. Unified modelling language (UML) has emerged as the de facto standard for modelling software systems and has received significant attention from researchers as well as practitioners.</p><p>UML models are popular not only for designing and documenting systems, the importance of UML models in designing test cases has also been well recognized. Even though UML models are intended to help reduce the complexity of a problem, with the increase in product sizes and complexities, the UML models themselves become large and complex involving thousands of interactions across hundreds of objects <ref type="bibr" target="#b14">[16]</ref>. The important part of quality control in the software life-cycle is testing. As the complexity and size of software increase, the time and effort required to do sufficient testing grow. Manual testing is time-consuming and error-prone. So, there is a pressing to automate the testing process. The testing process can be divided into three parts: test case generation, test execution, and test evaluation. The latter two parts are relatively easy to automate provided that the criteria for passing the tests are available. However, to determine which tests are required to achieve a certain level of confidence is not trivial <ref type="bibr" target="#b16">[18]</ref>. Model-based testing <ref type="bibr" target="#b4">[6]</ref> has grown in importance. Models are specified to represent the relevant, desirable features of the system under consideration (SUC). These models are used as a basis for (automatically) generating test cases to be applied to the SUC. Typical models that are used for representing system behavior are unified modeling language, finite state machines, statecharts etc. <ref type="bibr" target="#b2">[4]</ref>. It is often desired that test data in the form of test sequences within a test suite can be automatically generated to achieve required test coverage. It helps mankind to save on time, money and helps in handling better situations in real time.</p><p>With this motivation, we aim our work at deriving the test sequence from state transition diagram and maximizing state or node coverage. Also our method minimizes the size of test, time and cost, while preserving test coverage. The rest of the paper is structured as follows: A brief discussion on UML diagrams, which are relevant to our paper is described in the Section 2. Then, we discuss some testing coverage criteria in Section 3. section 4 represents some concepts, notations and definitions of state chart diagram. In Section 5, we explain the overview of our proposed method for construction of state-transition graph, generation of test sequence using state charts and how node coverage is calculated for each test case. Section 6 provides the working of our methodology with the RTVM (Railway Ticket Vending Machine) case study and implementation of our example. Section 7 discusses some comparison with related work. Finally, Section 8 presents the conclusion and future work of this paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">AN OVERVIEW OF RELEVANT UML 2.0 DIAGRAMS</head><p>In this section, we discuss an overview of the UML diagrams, which will be used subsequently in our paper.</p><p>UML is a modeling language using text and graphical notation and used for documenting specification, analysis, design, and implementation. It is a de-facto standard in industrial software development UML, Unified Modelling Language is a visual language that has been developed to support the design of complex object-oriented systems. Since its introduction in the late 90s, it has undergone several revisions. The latest release being UML version 2.0, which adds several new capabilities to UML 1.x. In this section, we restrict our review to only those developments that are directly relevant to our work. A typical software procedure incorporates all the three aspects: It uses data structure (class model), it sequences operations in time (state model), and it passes data and control among objects (interaction model). The three kinds of models separate a system into different views. The different models are not completely independent but a system is more than a collection of these independent parts. UML specification defines two major kinds of UML diagram: structural diagrams and behavioral diagrams.</p><p>The elements in a structural diagram represent the meaningful concepts of a system, and may include abstract, real world and implementation concepts. Behavioral diagrams show the dynamic behavior of the objects in a system, which can be described as a series of changes to the system over time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.">UML state chart diagram</head><p>In this section, we explain the few fundamentals on state chart diagram. The name of the diagram itself clarifies the purpose of the diagram and other details. It describes different states of a component in a system. The states are specific to a component or object of a system. A statechart diagram describes a state machine. Now to clarify it state machine can be defined as a machine which defines different states of an object and these states are controlled by external or internal events. Statechart diagram is one of the five UML diagrams used to model dynamic nature of a system. They define different states of an object during its lifetime. And these states are changed by events. So, Statechart diagrams are useful to model reactive systems. Reactive systems can be defined as systems that respond to external or internal events. Statechart diagram describes the flow of control from one state to another state. States are defined as a condition in which an object exists and it changes when some event is triggered. So, the most important purpose of Statechart diagram is to model life time of an object from creation to termination. Statechart diagrams are also used for forward and reverse engineering of a system. But the main purpose is to model reactive system. State diagrams are used to give an abstract description of the behavior of a system. This behavior is analyzed and represented in series of events, that could occur in one or more possible states. Hereby "each diagram usually represents objects of a single class and track the different states of its objects through the system". State diagrams can be used to graphically represent finite state machines. Followings are the main purposes of using statechart diagrams: (a) To model dynamic aspect of a system, (b) To model life time of a reactive system and (c) To describe different states of an object during its life time. The fundamental components of a state chart diagram are -events, states and transitions. But it has some distinguishing characteristics for modeling dynamic nature. State chart diagram defines the states of a component and these state changes are dynamic in nature. So, its specific purpose is to represent the state changes triggered by events. Events are internal or external factors influencing the system. If we look into the practical implementation of Statechart diagram then it is mainly used to analyze the object states influenced by events. This analysis is helpful to understand the system behavior during its execution. The following are the basic notational elements that can be used to make up a diagram:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.1.">State:</head><p>The state of an object is shown by rectangle with rounded corners. Top of the rectangle contains a name of the state. It can contain a horizontal line in the middle, below which the activities that are done in that state are indicated. A state in a state chart diagram can either be simple or composite type. A simple state does not have any sub-states.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.2.">Initial state:</head><p>A transition leading from an initial event shows the state that an object goes into when it is created or initialized. This is shown as a small black disk or filled circle. A state-chart can have only one initial state.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.3.">Final state:</head><p>Like initial state the state diagram shows final state. It represents the state reached when an object is destroyed, switched off or stops responding to events. This is shown as a hollow circle containing a smaller filled circle or small black disk within a large circle. A state-chart may have more than one final state <ref type="bibr" target="#b22">[24]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.4.">Transition:</head><p>Arrows, denote transitions. The name of the event (if any) causing this transition is written as the labels with the transition names or event names. A guard expression may be added before a "/" and enclosed in square-brackets ( eventName[guardExpression] ), denoting that this expression must be true for the transition to take place.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.5.">An event:</head><p>We call the event that causes the state transition the trigger. An event is an occurrence at a point of time. Events often correspond to verbs in the past tense e.g. (power turned on, alarm set) <ref type="bibr" target="#b3">[5]</ref>. There are four types of events that can trigger a state transition:</p><p>Signal event (when the system receives a signal from an external agent) Call event (when a system operation is invoked) Timing event (when a timneout occurs) Change event (when a system property is changed by an external agent)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.6.">Choice and Junction Points:</head><p>A choice point allows a transition to branch to several different states depending on the value of a guard. A junction point indicates that several states can transition to the same state on a given event.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">SOME BASIC DEFINITIONS</head><p>Here, in this section, we introduce a few basic concepts and definitions which we use while describing our aproach in the subsequent sections. There are many forms of state diagrams, which differ slightly and have different semantics. For a deterministic finite state machine (DFA), nondeterministic finite state machine (NFA), generalized nondeterministic finite state machine (GNFA), Mealy machine or Moore machine, the input is denoted on each edge. For a Mealy machine, input and output are signified on each edge, separated with a slash "/": "1/0" denotes the state change upon encountering the symbol "1" causing the symbol "0" to be output. For a Moore machine the state's output is usually written inside the state's circle, also separated from the state's designator with a slash "/". There are also variants that combine these two notations.</p><p>It is assumed that a state chart STc is correct in the sense that for each state s ∈ S simple there exists a sequence of transitions t 1 , t 2 ..., t k so that source(t 1 ) ∈ Si and target(t k ) = s and for each state s ∈ S simple there exists a sequence of transitions t 1 , t 2 ..., t k so that source(t 1 ) = s and target(t k ) ∈ S f . The following terms will be used to describe our technique. Definition 1. A statechart can be a quadruple S c = (E, S t , H, T), where E is a finite set of events and St = (S, S i , S f ) is a triple of set of states with S as a finite set of states, S i ⊆ S denoting the entries (initial states) and S f ⊆ S the exits (final states), H ⊆ S × S is a hierarchy relation, a binary relation on the set S forming a tree. For an element (s, s′ ) ∈ H holds, that a state s is an immediate sub state of state S′.</p><p>T ⊆ S × E × S is a finite set T of transitions. The set of states S is composed of disjoint sets of simple states S simple and composite states S comp .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Scenario-intermediate state:</head><p>A scenario is executed, when the system is at a state (Si) may cause the system to transit from its current state (Si) to a next state (Sj ). Since a scenario may consist of a number of message exchanges among objects, a system may even change its state during the execution of a step (a message) in a scenario. Hence, execution of a single scenario may cause traversal of several states and transitions. All system states other than Si and Sj , through which the system transits during the execution of a scenario are considered to be scenariointermediate state. We can say, execution of a scenario may cause a system to transit from one , where I is the initial state of the system at which the test data is input, S is the test data input to the system and O is the expected output of the system <ref type="bibr" target="#b16">[18]</ref>, <ref type="bibr" target="#b17">[19]</ref>. The output produced by the execution of the software with a particular test case provides a specification of the actual software behavior. A test case is also characterized by an ordered pair of an input and an expected output of the SUC.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 7.</head><p>A test suite is a set of test cases. A single test case in most cases may satisfy more than one test obligation. For instance, a test case used to cover a certain state of interest may also cover other states during its execution. This then provides for a way to reduce the size of the final test suite by choosing a subset of test cases that preserves the coverage obtained by the full test suite <ref type="bibr" target="#b7">[9]</ref>. Definition 8. k-transition coverage (k-TC) generates complete transition sequences that sequentially conduct all legal transition sequences of length k ∈ N. Definition 9. A single testcase in most cases may satisfy more than one test obligation. For instance, a testcase used to cover a certain state of interest may also cover other states during its execution. This then provides for a way to reduce the size of the final testsuite by choosing a subset of testcases that preserves the coverage obtained by the full testsuite <ref type="bibr" target="#b8">[10]</ref>. A test suite is a set of test cases. Definition 8 guarantees that all possible (legal) transition sequences of length k will be tested. A test suite consisting of all transition sequences of a fixed length k does not necessarily cover a set of all sequences of length i ∈ 1, ... , k-1 as there may exist sequences of length i that cannot be expanded to length k. Typically, state based test generation methods focus on some form of coverage, for instance on covering transitions <ref type="bibr" target="#b17">[19]</ref>, <ref type="bibr" target="#b18">[20]</ref> or on transition coverage and state identification <ref type="bibr" target="#b4">[6]</ref>, <ref type="bibr" target="#b12">[14]</ref>. Our approach creates all transition sequences of length k including all shorter sequences of length 1, ..., k -1 that cannot be found in longer sequences.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">TEST ADEQUECY CRITERIA</head><p>Typically, state based test generation methods focus on some form of coverage, for instance on covering transitions <ref type="bibr" target="#b18">[20]</ref>, <ref type="bibr" target="#b19">[21]</ref> or on transition coverage and state identification <ref type="bibr" target="#b5">[7]</ref>, <ref type="bibr" target="#b13">[15]</ref>. Our approach creates all transition sequences of length k including all shorter sequences of length 1, ..., k -1 that cannot be found in longer sequences. Testing coverage/adequacy criterion specifies the requirement of a particular testing and can be used as an objective measurement of the test case. In traditional software code testing, the definition of testing adequacy is defined as a measurement function. The case of UML state chart diagrams is different because it is in the form of model instead of code. Especially the coverage of state chart diagram is little bit complex. In our paper, we propose different types of coverage metrics as follows:</p><p>• State Coverage Criterion : The value of state coverage is the ratio between the covered states and all the states in the statechart diagram. It requires that all the state nodes in a state chart graph to be covered at least once. • Action Coverage: To generate test cases with respect to action coverage we construct as many marked specifications as there are actions within the specification. • Transition Coverage : Given a graph and a test suite TS, s is said to achieve transition coverage, if it causes each transition t of the state graph to be exercised at least once. The value of transition coverage is the ratio between the checked transitions and all the transitions in the statechart graph. • Transition Path Coverage: Given a graph and a test suite TS, s is said to achieve transition path coverage, if it causes each elementary transition path p of the state graph to be exercised at least once. The value of path coverage is the ratio between the traversed paths and all the paths in the graph. • Condition coverage. A single condition is covered, if it evaluates to both true and false at some point during test execution. Decision coverage has also been called branch coverage or predicate coverage. This means that 100% condition/decision coverage is achieved if all conditions evaluate to true and to false and if every decision also evaluates to true and to false during the test execution. A decision consists of conditions separated by logical operators (e.g. and, or).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">TEGEMIOOSC-OUR PROPOSED APPROACH TO GENERATE AND MINIMIZE TEST SEQUENCE WITH STATECHARTS</head><p>In this section we discuss the overview of our proposed approach to generate test sequence from UML state chart diagram and then, we optimize the test node coverage while minimizing time and cost. We have named our approach, Test Generation and Minimization for O-O software with State Charts (TeGeMiOOSc).</p><p>The schematic representation of our approach is shown in Fig. <ref type="figure" target="#fig_1">2</ref>. Our proposed methodology involves the following steps.</p><p>• Step-1. Analyze the real system which is to be tested and accepted by user. In the next section, we discuss each step in detail, by using different algorithms for each step in different sections. Before that, we present some related definitions. In the next section, we discuss each step in detail, by using different algorithms for each step in different sections. Before that we present some related definitions. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.">Analyze the real system which is to be tested</head><p>A Railway Ticket Vending System (RTVM) dispenses tickets to passengers at a railway station. passengers use the front panel to specify their Boarding and destination place, details of passengers(number of adults and children) and date of travel. The machine displays the fare for the requested ticket. The passengers deposits cash in the bin provided and presses 'accept cash'. The machine checks the cash, if it is more; the balance cash is paid out. And the ticket requested is printed. And the report options also include the detailed report of transactions, summary report of the number of tickets sold for each destination, opening balance, each collected, cash dispensed and current balance in the machine. The total functionalities are shown by the use case diagram as shown in Fig. <ref type="figure" target="#fig_2">3</ref>. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.">Construct the model of the SUT using state chart diagram</head><p>State chart diagram is a graph where nodes represent states end the directed arcs that interconnect states represent transitions. It also models dynamic behavior, and captures the different states that an object can be in, and its response to various events that may arise in each of its states. Statechart diagram is one of the 13 UML diagrams used to model dynamic nature of a system. They define different states of an object during its lifetime. The notation and semantics of UML state diagrams are substantially based on Statecharts modified to include object-oriented features <ref type="bibr" target="#b11">[13]</ref>. The states and the transition of a system are important to set up a state diagrams from system. Fig. <ref type="figure">4</ref> shows a UML state diagram for a railway ticket vending machine system.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3.">Convert the state chart diagram into state transition graph</head><p>Here, we convert the state diagram into state transition graph. A state transition graph TG = (V t , E d ).</p><p>Definition 10: A transition graph TG = (V t , E d ) represents a directed graph consisting of a set of vertices (V t ), a set of directed edges (E d ). In TG, nodes represent states and edges represent transitions between states. Without any loss of generality, we assume that there is a unique node that corresponds to the initial state and that one or more nodes represent the final states. The initial state is represented as the root of the tree. States at each level of nesting are considered as a sub graph. We represent this step through an algorithm. Set V = {t| t Tlegal} consists of vertices representing the legal transitions of statechart Sc. For each (legal) transition pair (t, t′) of the statechart, a directed edge is created. Vertex ti has to be connected with all transitions that may be triggered from the state belonging to the initial configuration. Transitions leading into a final state have to be connected with vertex tj . A simple transition coverage may be reached by visiting all vertices of the graph, based on a transition graph at least once by starting in vertex ti and ending in vertex tj . The problem of computing a route for visiting all vertices of a graph by minimizing the length of the route is well known as the traveling salesman problem (TSP). If visiting vertices and traversing edges more than once is allowed, it is called the graphical traveling salesman problem (GTSP) <ref type="bibr" target="#b23">[25]</ref>. Also, by computing all complete transition sequences whose length is smaller than k and that cannot be expanded to longer sequences, a minimal test case set fulfilling k-transition coverage for all k 1, . . . , n is achieved. This procedure is described in Algorithm-1, in the next section.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4.">Generating test cases</head><p>After, a transition graph is constructed based on a state chart Sc. If n = l, the graphical traveling salesman problem can be applied directly. If n is greater than 1 the transition graph has to be transformed k -1 times. The resulting graph represents all possible sequences of transitions of length k. Additionally, all sequences of length k-1 are computed that cannot be expanded to longer sequences. These sequences are characterized by the fact that the corresponding vertex representing that sequence is solely connected with vertices t i and t j. The functions indeg(v) := v′,(v′, v)</p><p>A and outdeg(v) := v′(v, v′) A are used to compute these vertices. As these sequences are already complete, they can be added to the set TS. For k := 2 to n do 15.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm</head><p>Foreach v ϵ V do <ref type="bibr" target="#b14">16</ref>.</p><formula xml:id="formula_0">If (ti, v) ϵ Ed (v, tj ) ϵ Ed indeg(v) = outdeg(v) = 1 then 17.</formula><p>TS := TS U v 18.</p><p>Ed := Ed U (ti, tj ) 19.</p><p>Add them to set TS </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.6.">Minimizing the test cases</head><p>Here, in this section , we discuss how the generated test cases are reduced while maximizing test coverage. Though Wang's algorithm <ref type="bibr" target="#b15">[17]</ref> is widely used, but it does not cover other critical attributes, like defect id, dependency and automated test case indicator. In order to generate an effective size of generated test cases, this step contains two sub activities, which are</p><p>• calculate node coverage for each test case. Let NC(tc) = t 1 , t 2 ,...t n for NC(tc) to be a set of test cases that tc is covered by t 1 , t 2 ,...t n . Hence, if a number of testset tc is zero, then tc is included in the effective set of test cases. • select effective test cases. Now, we present this step through an algorithm. Now, we select the effective testcases, which contains no testset. We present this step through an algorithm. Foreach t′ ϵ out(s) ∩T faulty do 10.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm-3 (Minimization of Test cases)</head><formula xml:id="formula_1">Input: Sc = (E,</formula><p>ANC := ANC U (t, t′) 11.</p><p>Foreach (t, t′) ϵ ANC do 12.</p><p>(t1, ..., ti) := STARTSEQUENCE(t) 13.</p><p>RTs := RTs U (t1, ...ti, t, t′ ) 14.</p><p>If in(inital(root())) = Ø then 15.</p><p>RTs := RTs U (t) </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">CASE STUDY</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1.">Problem statement</head><p>Buying ticket in RTVM (Railway Ticket Information Systems) is a system which receives the cash from the customer and returns back the balance and the ticket. The system has five components: Front panel, Ticket Transacter, Cash Transacter, Cash Handler and Ticket. Entire functions of the system are represented in the form of a usecase diagram. The customer deposits the cash. The system then passes the cash deposit intimation to ticket transacter. The ticket transacter then accepts cash and passes it to cash transacter and the cash transacter then transacts the cash to the cash handler. After receiving the cash, the cash handler sends an acknowledgment to the cash transacter. The cash transacter gives cash confirmation acknowledgement to the ticket transacter and also gives the balance amount to cash transacter. The cash transacter sends the acknowledgment for the cash received to the ticket transacter. Finally the ticket transacter prints the ticket with the help of ticket component and issues the ticket to the customer. The state diagram for the buy ticket in RTVM system is shown in Fig. <ref type="figure">4</ref>.</p><p>Here, the object enters into idle state, when the power switch is on. Once the user selects a tickettype button in the menu, the object enters the ticketselected state. The user can select the destination, ticket type and the number of persons (n) to travel. The condition n ≤ 6 is inserted for the event tickettypeselected, as the ticket machine is not expected to issue a ticket for more than 6 persons in one transaction. Once the ticket and number of persons required are selected, the object enters the collectmoney state. In this state, the object collects the amount of money (totalfair) the user has to enter into the ticket machine. Note that totalfair = ticket fare × number of persons. As the user inserts money (amount) into the machine, the machine object changes its state to busy. In the busy state, it calculates how much balance or change (chng) has to be returned to the user if any, where chng = (amount -totalfair). If the change balance is less than zero, the machine object changes its state again from busy to collectmoney as the money inserted is insufficient. If the change balance is equal to zero, the machine object goes to exactlypaid state and dispenses the ticket for requested number of persons. If the change balance is more than zero, then the machine object changes its state to overpaid state and then dispenses ticket as well as dispenses change. After constructing state chart diagram, we construct transition graph as shown in Fig <ref type="figure">5</ref>.</p><p>In next step, we traverse the graph and extract all required information from the state transition graph as described below.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2.">Working Of the proposed Algorithm</head><p>The state model application saved as .mdl file is provided as input to the parser. The parser analyses and collects all the information about object states, actions / guards and transitions, which are represented as nodes and edges in a directed graph as shown in Fig. <ref type="figure">5</ref>. In Table <ref type="table">I</ref>, we represent the mapping of object states to its corresponding nodes in the graph and Table <ref type="table">II</ref> shows actions or guard conditions to corresponding edges in the graph. Then, by using traversal algorithm we find all possible test sequences generated and are shown in Table <ref type="table">III</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>TABLE I MAPPING INFORMATION TABLE FOR OBJECT STATES</head><p>Hence, the set of states are ST = {IN, IDL, TS, CM, OP, EP}, each ST i is a state or node Therefore, the following test cases such as tc1, tc2, tc3, tc4, tc6, tc8, tc9, tc10, tc11, tc12, tc15, tc16 should be ignored. Hence, the remaining effective test sequence is TS = {tc14, tc17, tc19}. The node coverage of the above test sequence are shown below in Table <ref type="table">IV</ref>. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3.">Implementation</head><p>In this section, we present some experimental results in order to verify the effectiveness of our approach. We have carried out a series of experiments. In our experiments we have considered different types of applications. All these systems are designed in UML 2.0 using Rational Rose Sostware. Here, we consider the example of Railway Ticket Vending Machine (RTVM). We can experiment with other applicatins namely Library Information System (LIS), Cell Phone System (CPS), Trading House Automation System (TAS) etc.</p><p>First, the usecase diagram of RTVM is modelled using RationalRose software. then considering only the Purchase Ticket or Buy ticket usecase, we model it with State chart diagram and saved with .mdl extension. Next, the state chart diagram is converted into state chart graph. Now, the statechart graph is traversed applying DFS technique, considering pre and post conditions. Then, the graph is transformed into the sourcecode in JAVA. Hence, the designs are also implemented using JAVA and NetBeans IDE version 7.1.2. The screenshot of our Java sourcecode is shown in Fig. <ref type="figure" target="#fig_5">6</ref>.  The source and destination states as well as the prefix path conditions are displayed along with the test data. In our implementation, we have restricted the conditional expressions in state diagrams to have only integer and Boolean variables as these occur commonly. The GUI provides a friendly and efficient user interface to user to generate testing code and shows test coverages as shown in Fig. <ref type="figure" target="#fig_7">8</ref>. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.4.">Test Reduction</head><p>There is hardly sufficient time for thorough testing activities within industrial projects, in practical situations. Hence, it is reasonable to try to reduce the size of generated test suites. However, the effect of the reduction on the fault detection ability of the test suites should be small. The techniques proposed in our paper can be used to apply reduction during test case generation. A single test case may cover more than the coverage item it has been generated for. When using a probe based technique as described in our paper it is easy to identify all items covered by a particular test case.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">COMPARISON WITH RELATED WORK</head><p>A lot of research work have been investigated the effect of testset reduction on the size and fault finding capability of a test-set. In an early study, Wong et al. address the question of the effect on fault detection of reducing the size of a test set while holding coverage constant <ref type="bibr" target="#b27">[29]</ref>, <ref type="bibr" target="#b28">[30]</ref>. They randomly generated a large collection of test sets that achieved block and all-uses data flow coverage for each subject program. For each test set they created a minimal subset that preserved the coverage of the original set. They then compared the fault finding capability of the reduced test-set to that of the original set. Their data shows that test minimization keeping coverage constant results in little or no reduction in its fault detection effectiveness. This observation leads to the conclusion that test cases that do not contribute to additional coverage are likely to be ineffective in detecting additional faults.</p><p>To confirm or refute the results in the Wong study, Rothermel et al. performed a similar experiment using seven sets of C programs with manually seeded faults <ref type="bibr" target="#b24">[26]</ref>. For their experiment they used edge-coverage <ref type="bibr" target="#b6">[8]</ref> adequate test suites containing redundant tests and compared the fault finding of the reduced sets to the full test sets. In this experiment, they found that <ref type="bibr" target="#b1">[3]</ref> the fault-finding capability was significantly compromised when the test-sets were reduced and <ref type="bibr" target="#b25">[27]</ref> there was little correlation between test-set size and fault finding capability.</p><p>The results of the Rothermel study were also observed by Jones and Harrold in a similar experiment <ref type="bibr" target="#b9">[11]</ref>.</p><p>Prasanna M, et al. <ref type="bibr" target="#b21">[23]</ref> proposed a technique for generating test cases using collaboration diagrams. They converted the diagram into an intermediate graph and from the graph, by applying Prim's and Dijkstra's algorithm, generated a set of test cases.</p><p>Offutt and Abdurazik <ref type="bibr" target="#b18">[20]</ref>, <ref type="bibr" target="#b19">[21]</ref> proposes a technique for generating test cases from UML state diagrams. They have highlighted several useful test coverage criteria for UML state charts such as: (1) full predicate coverage, (2) transition coverage etc. Kansomkeat and Rivepiboon <ref type="bibr" target="#b10">[12]</ref> introduce a method for generating test sequences using UML state chart diagrams. They transformed the state chart diagram into a flattened structure of states called testing flow graph (TFG). From the TFG, they listed possible event sequences which they considered as test sequences. The testing criterion they used to guide the generation of test sequences is the coverage of the states and transitions of TFG. Kim et al. <ref type="bibr" target="#b11">[13]</ref> proposes a method for generating test cases for class testing using UML state chart diagrams. They transformed state charts to extended FSMs (EFSMs) to derive test cases. In the resulting EFSMs, the hierarchical and concurrent structure of states are flattened and broadcast communications are eliminated. Then data flow is identified by transforming the EFSMs into flow graphs, to which conventional data flow analysis techniques are applied.</p><p>In the experiment discussed in our paper, we attempt to highlight some additional issues. These different results are difficult to reconcile and the relationship among coverage criteria, testsuite size, and fault finding capability clearly needs more study.</p><p>Our work is different in some respects. First, we are not studying testing of traditional programs. We generate testcases for object oriented software. we are interested in test case generation as well as testcase minimization by calculating node coverage for each test case and testing of specifications. A single test-case in most cases may satisfy more than one test obligation. For instance, a testcase used to cover a certain state of interest may also cover other states during its execution. It provides a way to reduce the size of the final test-suite by choosing a subset of testcases that preserves the coverage obtained by the full testsuite.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">CONCLUSSION AND FUTURE WORK</head><p>In our approach, first, we built a state chart model of our system under test. Next, we derived state transition graph from state chart diagram. Then, all required information are extracted from the graph. Next, the test cases are generated by our algorithm. Lastly, a set of test cases are minimized by calculating node coverage for each test case. It is determined that which test cases are covered by other test cases. In this way, our paper introduces an efficient test generation approach to optimize the test coverage by minimizing time and cost. In our opinion, there is almost no degradation in terms of testsuite quality.</p><p>Further, we plan into testcase generation techniques by using any other UML diagram such as activity diagram. Experimental studies required to determine if such techniques can more reliably reduce the burden of the testing effort.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>Figure. 1. Simple state chart for an order object in Order Management System</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 2. Schematic representation of our approach</figDesc><graphic coords="8,126.42,447.73,365.57,182.38" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure. 3 .</head><label>3</label><figDesc>Figure. 3. Use case diagram for SUT</figDesc><graphic coords="9,105.89,226.53,378.18,181.66" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure. 3 .Fig. 5 .</head><label>35</label><figDesc>Figure. 3. State chart diagram for Railway Ticket Vending Machine</figDesc><graphic coords="10,137.82,294.47,342.76,161.29" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>-1: Generation of a test case set for k-transition coverage for k ϵ 1, ..., n Input: A state transition graph from Sc = (E,St,H, T), n ϵ N Output: A test case set TS fulfilling k-transition coverage 1. For k ϵ 1, ..., n 2. Begin 3. i:= 0; j:= 1; TS = null; s = null; visited NSt = 0 4. Do while NSt [i] = NULL 5. push ( NSt [i], s); 6. visited NSt [ NSt [i] ] = visited NSt [ NSt [i] ] + 1; 7. Do while s not = NULL 8. t = pop(s); NSt[i] = pop(s); 9. If enabled ( NSt[i]) not = NULL 10</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 6 .</head><label>6</label><figDesc>Fig. 6. Screenshot of JAVA source code of State chart graph We have implemented our approach by using ModelJunit tool. ModelJUnit [1] is a Java library that extends JUnit to support model-based testing. It allows us to write simple FSM or EFSM models as Java classes, then generate tests from those models and measure various model coverage metrics. System models are extended finite state machines that are written in a familiar and expressive language: JAVA. ModelJUnit is an open source tool, which is released under the GNU GPL license. ModelJUnit is an openly available test case generation tool, using an extended finite state chart diagram. ModelJUnit searches the graph of an EFSM at runtime. It generates EFSM (Extended Finite State Machine) from source code. The screenshot of the generated EFSM for different conditions are shown in Fig. 7. EFSM models are graphically represented as graphs where states are represented as nodes and transitions as directed edges between states.</figDesc><graphic coords="16,111.65,285.85,395.22,258.95" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure. 7 .</head><label>7</label><figDesc>Figure. 7. EFSM generated for different conditions</figDesc><graphic coords="17,139.62,84.05,339.28,225.40" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 8 .</head><label>8</label><figDesc>Figure 8. Test coverage through our implementationWe have implemented the sytem model by providing several inputs. Fig.9shows some coverage results for different values of input data. The used abbreviations have these following meanings:</figDesc><graphic coords="17,130.86,415.02,356.81,209.10" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0"><head></head><label></label><figDesc></figDesc><graphic coords="15,138.66,163.26,341.20,223.72" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0"><head></head><label></label><figDesc></figDesc><graphic coords="15,175.64,398.24,267.12,278.12" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0"><head></head><label></label><figDesc></figDesc><graphic coords="18,165.08,155.23,288.37,326.65" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>state to another state, and all other intermediate states reached during execution of the scenario are scenario-intermediate states. It may be important that a scenario-intermediate state reached during execution of a scenario can also be a normal state, if it is either the initial or final state for execution of some scenario. Definition 2. A transition pair TP = (t, t′ ) with t, t′ belongs to T legal is a sequence of a legal incoming transition to a legal outgoing transition of a (simple) state so that ∃ s ∈ S simple : t ∈ in(s) U t′ ∈ out(s). and scenario-intermediate transitions: Let S = St 1 , St 2 , . . . , St n be the set of all possible system states of an SUT. We define a transition tij to be a tuple (St i , S*, St j ), where t ij represents a transition from the current state St i ∈ S to a next state S tj ∈ S, S* is an ordered set of all he scenario-intermediate states reached during the transition from state St i to St j . A transition for which either the source or destination state is a scenario-intermediate state, is known as a scenario-intermediate transition. A sequence of n legal transitions (t 1 , t 2 ..., t n ) with t i ∈ T legal where (t i , t i+1 ) denotesa valid transition pair for all i ∈ 1, ..., n -1 is called a transition sequence (T seq ) of length n. A transition sequence (t 1 , t 2 ..., t n ) is complete if it starts at the initial state of the state chart that is entered firstly and ends at a final state. In this case it is called a complete transition sequence (T sqcom ). A fault transition sequence T sqfault = (t 1 , t 2, ..., t n ) of length n consists of n -1 subsequent transitions, forming a (legal) transition sequence of the length n -1 plus a concluding, faulty transition t n ∈ T faulty . A faulty transition sequence is called complete if it starts at the initial state of the statechart, abbreviated as CFTS. The sequence (t 1 , t 2, ..., t n-1 ) is called a start sequence.</figDesc><table><row><cell>Transitions Definition 4. Definition 5. Definition 6. A test case is the triplet [I, S, O]</cell></row></table><note><p><p>Definition 3.</p>A false transition pair FP = (t, t′ ) with t ∈ T legal and t ′ ∈ T faulty is a sequence of a legal incoming transition to a faulty outgoing transition of a (simple) state so that ∃ s ∈ S simple : t ∈ in(s) U t′ ∈ out(s).</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>20.   </figDesc><table><row><cell></cell><cell>Endif</cell></row><row><cell>21.</cell><cell>Endfor</cell></row><row><cell>22.</cell><cell>Enddo</cell></row><row><cell>23.</cell><cell>Enddo</cell></row><row><cell cols="2">24. End</cell></row><row><cell cols="2">25. Endfor</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>TABLE III TESTCASE GENERATED TABLE FOR RTVM</head><label>IIIGENERATEDFOR</label><figDesc></figDesc><table /></figure>
		</body>
		<back>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>ID = {ID 1 , ID 2 , ID 3 , ID 4 , ID 5 , ID 6 }, each ID i is an input data OD = {OD 1 , OD 2 , OD 3 , OD 4 , OD 5 , OD 6 }, each OD i is an output value TR = {TR 1 , TR 2 , TR 3 , TR 4 , TR 5 , TR 6 , TR 7 }, each TR i is a transition between source and destination state, where each TR i = {ST p , ST q }, STp is a source state and ST q is a destination state. Hence, each transition can be extracted as follows:   </p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Unified Modeling Language specification, version 2.0, object management group</title>
		<author>
			<persName><surname>Omg</surname></persName>
		</author>
		<ptr target="www.omg.org" />
		<imprint>
			<date type="published" when="2005-08">August 2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">TAME: A PVS interface to simplify proofs for automata models</title>
		<author>
			<persName><forename type="first">M</forename><surname>Archer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Heitmeyer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Sims</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">User Interfaces for Theorem Provers</title>
		<imprint>
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Test generation and minimization with basic statecharts</title>
		<author>
			<persName><forename type="first">Fevzi</forename><surname>Belli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Axel</forename><surname>Hollmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SAC-08</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2008-03">March 2008</date>
			<biblScope unit="page" from="718" to="723" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Object-Oriented Modeling and Design with UML</title>
		<author>
			<persName><forename type="first">R</forename><surname>Michel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">James</forename><forename type="middle">R</forename><surname>Blaha</surname></persName>
		</author>
		<author>
			<persName><surname>Rumbaugh</surname></persName>
		</author>
		<imprint>
			<publisher>Pearson</publisher>
		</imprint>
	</monogr>
	<note>second edition</note>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Model-based testing of reactive systems</title>
		<author>
			<persName><forename type="first">M</forename><surname>Broy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Advanced Lectures</title>
		<imprint>
			<date type="published" when="2005-06">June 2005</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Testing software design modeled by finite-state machines</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">S</forename><surname>Chow</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE TSE</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="178" to="187" />
			<date type="published" when="1978">1978</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">An experimental comparison of the effectiveness of the all-uses and alledges adequacy criteria</title>
		<author>
			<persName><forename type="first">P</forename><surname>Frankl</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">N</forename><surname>Weiss</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the symposium on Testing, analysis, and verification</title>
		<meeting>the symposium on Testing, analysis, and verification</meeting>
		<imprint>
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Statecharts: A visual formulation for complex systems</title>
		<author>
			<persName><forename type="first">D</forename><surname>Harel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Sci. Comp. Prog</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page" from="231" to="274" />
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Test-suite reduction for model based tests: Effects on test quality and implications for testing</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">E</forename><surname>Mats</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Devaraj</forename><surname>Heimdahl</surname></persName>
		</author>
		<author>
			<persName><surname>George</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Test-suite reduction and prioritization for modified condition/decision coverage</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Jones</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Harrold</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Software Emgineering</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="195" to="209" />
			<date type="published" when="2003-03">March 2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Automated-generating test case using UML statechart diagrams</title>
		<author>
			<persName><forename type="first">S</forename><surname>Kansomkeat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Rivepiboon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SAICSIT 2003,ACM</title>
		<meeting>SAICSIT 2003,ACM</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="296" to="300" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Test cases generation from UML state diagram, Software Testing Verification and Reliability</title>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">G</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">S</forename><surname>Hong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">H</forename><surname>Bae</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">D</forename><surname>Cha</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="187" to="192" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">A test generation method based on state diagram</title>
		<author>
			<persName><forename type="first">N</forename><surname>Kosindrecha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Daengdej</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">journal of Theoritical and Applied Information Technology</title>
		<imprint>
			<biblScope unit="page" from="28" to="44" />
			<date type="published" when="2005">2005 -2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">A survey of communication protocol testing</title>
		<author>
			<persName><forename type="first">R</forename><surname>Lai</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Systems and Software</title>
		<imprint>
			<biblScope unit="volume">62</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="21" to="46" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Integrated state-based dynamic slicing technique for UML models</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">T</forename><surname>Lallchandani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Mall</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IET Software</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="55" to="78" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Software test data generation using ant colony optimization</title>
		<author>
			<persName><forename type="first">H</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">C</forename><surname>Peng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of World Academy of Science, Engineeing and Technology</title>
		<meeting>World Academy of Science, Engineeing and Technology</meeting>
		<imprint>
			<date type="published" when="2005-01">January 2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Generating test cases from UML activity diagram based on gray-box method</title>
		<author>
			<persName><forename type="first">Wang</forename><surname>Linzhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yuan</forename><surname>Jiesong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yu</forename><surname>Xiaofeng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hu</forename><surname>Ju</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Li</forename><surname>Xuandong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zheng</forename><surname>Guoliang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 11th Asia-Pacific Software Engineering Conference</title>
		<meeting>the 11th Asia-Pacific Software Engineering Conference</meeting>
		<imprint/>
	</monogr>
	<note>APSEC04</note>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<author>
			<persName><forename type="first">R</forename><surname>Mall</surname></persName>
		</author>
		<title level="m">Fundamentals of Software Engineering</title>
		<imprint>
			<publisher>Prentice Hall</publisher>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
	<note>3rd edition</note>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Generating tests from uml specifications</title>
		<author>
			<persName><forename type="first">J</forename><surname>Offutt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Abdurazik</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of 2nd International Conference. UML, Lecture Notes in Computer Science</title>
		<meeting>2nd International Conference. UML, Lecture Notes in Computer Science</meeting>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="416" to="429" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">Generating test data from state-based specifications. Software Testing Verification Reliability</title>
		<author>
			<persName><forename type="first">J</forename><surname>Offutt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Abdurazik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Ammann</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page" from="25" to="53" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">UML 2.0 in a Nutshell</title>
		<author>
			<persName><forename type="first">D</forename><surname>Pilone</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Pitman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2005">2005</date>
			<pubPlace>NY. O&apos;Reilly, USA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Automatic testcase generation for UML collaboration diagram</title>
		<author>
			<persName><forename type="first">M</forename><surname>Prasanna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">R</forename><surname>Chandran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Thiruvenkadam</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IETE Journal of Research</title>
		<imprint>
			<biblScope unit="volume">57</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="77" to="81" />
			<date type="published" when="2011-02">Jan-Feb 2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">Practical Object-Oriented Design with UML</title>
		<author>
			<persName><forename type="first">M</forename><surname>Priestley</surname></persName>
		</author>
		<imprint>
			<publisher>Tata McGraw-Hill</publisher>
		</imprint>
	</monogr>
	<note>second edition</note>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">In the traveling salesman: Computational solutions for tsp applications</title>
		<author>
			<persName><forename type="first">G</forename><surname>Reinelt</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1994">1994</date>
			<publisher>Springer Berlin / Heidelberg</publisher>
			<biblScope unit="page">840</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">An empirical study of the effects of minimization on the fault detection capabilities of test suites</title>
		<author>
			<persName><forename type="first">G</forename><surname>Rothermel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Harrold</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Ostrin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Hong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Conference on Software Maintenance</title>
		<meeting>the International Conference on Software Maintenance</meeting>
		<imprint>
			<date type="published" when="1998-11">November 1998</date>
			<biblScope unit="page" from="34" to="43" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">A methodology for proving control systems with lustre and pvs</title>
		<author>
			<persName><forename type="first">C</forename><surname>Parent-Vigouroux</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Bensalem</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Caspi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Dumas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Seventh Working Conference on Dependable Computing for Critical Applications (DCCA 7)</title>
		<meeting>the Seventh Working Conference on Dependable Computing for Critical Applications (DCCA 7)</meeting>
		<imprint>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Automatic generation of test specifications for coverage of system state transitions</title>
		<author>
			<persName><forename type="first">M</forename><surname>Sharma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Mall</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information and SoftwareTechnology</title>
		<imprint>
			<biblScope unit="issue">51</biblScope>
			<biblScope unit="page" from="418" to="432" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<title level="m" type="main">Effect of test set minimization on fault detection effectiveness. Software Practice and Experience</title>
		<author>
			<persName><forename type="first">W</forename><surname>Wong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Horgan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>London</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Mathur</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1998-04">April 1998</date>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="page" from="347" to="369" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Test set size minimization and fault detection effectiveness: A case study in a space application</title>
		<author>
			<persName><forename type="first">W</forename><surname>Wong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Horgan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Mathur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Pasquini</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 21st Annual International Computer Software and Applications Conference</title>
		<meeting>the 21st Annual International Computer Software and Applications Conference</meeting>
		<imprint>
			<date type="published" when="1997-08">August 1997</date>
			<biblScope unit="page" from="522" to="528" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<title level="m" type="main">Swain completed her MCA from College of Engg.And Technology, OUAT, Bhubaneswar, India. She is pursuing her Ph</title>
		<author>
			<persName><forename type="first">Ranjita</forename><surname>Authors</surname></persName>
		</author>
		<author>
			<persName><surname>Ku</surname></persName>
		</author>
		<imprint>
			<pubPlace>Bhubaneswar, India; Rourkela, India</pubPlace>
		</imprint>
		<respStmt>
			<orgName>D degree from Utkal University, Vani vihar ; Rourkela Institute of Management Studies</orgName>
		</respStmt>
	</monogr>
	<note>She has 11years of teaching experience and her fields of. interest are Software Engg., Discrete, Mathematical Structure and Numerical Methods.</note>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">He is currently working as a reader at Dept. of Computer Science &amp; Application</title>
		<author>
			<persName><forename type="first">Prafulla</forename><surname>Ku</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">His special fields of interest include Mobile Computing, Software Engineering</title>
		<meeting><address><addrLine>Bhubaneswar, India; Bhubaneswar, India</addrLine></address></meeting>
		<imprint/>
		<respStmt>
			<orgName>D degree from Utkal University, Vani vihar ; Utkal University, Vani vihar</orgName>
		</respStmt>
	</monogr>
	<note>Behera has received his Ph. He is a member of CSI</note>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<title level="m" type="main">He joined the faculty of the Department of Computer Science and Engineering at the National Institute of Technology, Rourkela in 1996, where he is now Associate Professor. His research interests include software engineering, real-time systems, discrete mathematics and distributed computing and published more than forty papers in these fields. He has received many awards including Young Scientist Award for the year 2006 by Orissa Bigyan Academy, Prof. K. Arumugam award for innovative research for the year 2009 and Maharasthra State National Award for outstanding research for the year 2010 by ISTE, NewDelhi. He has also received three research projects from DST and UGC. Currently, he is a member of IEEE</title>
		<imprint>
			<publisher>Durga Prasad Mohapatra received his Ph. D. from Indian Institute of Technology Kharagpur and M. E. from Regional Engineering College (now NIT</publisher>
			<pubPlace>Rourkela</pubPlace>
		</imprint>
	</monogr>
	<note>Dr. Mohapatra has co-authored the book Elements of Discrete Mathematics: A computer Oriented Approach published by Tata Mc-Graw Hill</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
