<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Automated Generation of Functional Test Cases and Use Case Diagram using SRS Analysis</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Arjinder</forename><surname>Singh</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Chandigarh University Amritsar</orgName>
								<address>
									<country key="IN">India</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">P</forename><forename type="middle">G</forename><surname>Student</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Chandigarh University Amritsar</orgName>
								<address>
									<country key="IN">India</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Sumit</forename><surname>Sharma</surname></persName>
							<affiliation key="aff1">
								<orgName type="institution">Chandigarh University Ludhiana</orgName>
								<address>
									<country key="IN">India</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Automated Generation of Functional Test Cases and Use Case Diagram using SRS Analysis</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.1" ident="GROBID" when="2025-10-14T17:57+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>SRS</term>
					<term>Use Case Diagram</term>
					<term>Activity Diagram</term>
					<term>DFS</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Software testing mainly consists of three types of approaches i.e. specification based testing, model based testing and coding based testing. In specification based testing, major concern is to find the missing logic defects that cannot be find by using other types of testing. Specification testing mainly uncovers the specification problems in Software Requirement Specification (SRS). An approach for the generation of functional test cases from SRS has been presented in this paper. This approach will help to achieve the early detection of faults and will reduce the time, cost and effort of the developer. Proposed model will automatically generate the functional requirements from the SRS. Template for Use Case diagram will be automatically generated from the functional requirements. Activity diagram will be used to generate the Activity Dependent Table (ADT) and hence Activity Dependent Graph (ADG) will be generated from ADT. Functional test paths will be generated by applying the Depth First Search Algorithm (DFS) as a searching algorithm. Finally we will generate the test cases from the functional test paths.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Software testing is one of the most salient parts of software development process. Testing is liable for assuring the reliability and quality of the software system. Software products size and complexity is growing with the growing demands of users, hence time and effort needed for appropriate testing is increasing at an expeditious rate. Test cases are designed for every software application. Test cases can be generated in two ways either automatic or manual. Manual generation of test cases have number of shortcomings like time consuming, error prone and high probability of uncovering the important scenarios of the system <ref type="bibr" target="#b1">[1]</ref>. Whereas automatic generation of test cases overcome the problems faced by the manual testing. Prior generation of test cases, results in finding ambiguities and inconsistencies in the software requirement specification and various other design documents. Hence it will leads towards letting down the cost of developing the software systems as number of errors are reduced at early stages of software development <ref type="bibr" target="#b2">[2]</ref>. Test cases generation can be done on the basis of three testing strategies i.e. specification based testing, model based testing and coding based testing. Code based testing ensures the detection and correction of errors in the software system but it does find the missing logic defects in the software system. Code based testing does not guarantee the availability of all features in the software system that are specified by the users. Design based testing starts from the design of the software system. With the development of UML diagrams it becomes easy for the software tester to tests the system, whether the system is fulfilling the requirements specified. But design based testing also have some flaws as it does not start from the root level i.e. the specification level as it totally dependent on the design document of the software system. Specification based testing starts from the root of the testing process i.e. by analyzing the software requirement specification document that is generated at the time of requirements gathering. Specification testing approach is also known as functional testing. Specification based approach has following benefits</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head></head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Unveils specification problems </head><p>Best for missing logic defects  Applies at all granularity levels of software system  Also responsible for improving schedule and budget problems in software testing <ref type="bibr" target="#b3">[3]</ref> Mostly test case generation uses code based or design based testing strategies. Specification based testing also incorporates the design based testing but at the second level. Firstly it generates the functional requirements from the software requirement specification and after identifying all the actors and use cases from the software requirement specification, it generates the use case diagram. Unified modeling language has facilitated us with the number of UML diagrams. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">PRELIMINARIES AND BASIC CONCEPTS</head><p>In this section we will discuss the basic concepts and definitions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Functional Testing</head><p>Functional Testing also have other names referred as black box testing and specification based testing <ref type="bibr" target="#b4">[4]</ref>. It is named as black box because in this approach tester sees the program as a black box i.e. tester ignores the way how it is written. Tester just considered about the requirement of the software.</p><p>Functional testing is not similar with white box testing where internal behavior of the system is needed. It is complementary approach that is related with uncovering the class of errors that with code based testing cannot be done.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Test Case Generation</head><p>Test case generation is mainly focused on the programming portion of the system. Test cases based on source code does not resolve the specification problems. It only handles the coding problems so it is necessary to generate the test cases from the software requirement specification available for developing the software. Generation of test cases from the specification also provide the advantage of shifting highly needed modules earlier in the development process. If test cases are generated from the specifications then test engineers will also be able to find inconsistencies in specifications and design of the system, allowing the improvements in specification and design of the system. Test cases generation can be possible in two ways either manually or automatically. Manual generation of test cases leads towards many problems like time consuming, effort etc. Automatic generation of test cases are benefited to software industry as it is responsible for generating relevant and reliable test cases ensuring the possible coverage criteria.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Software Requirement Specification</head><p>Software requirement specification is one of the most important components of software. This component includes all requirements specified by the users. This component is prepared after the requirement gathering phase of the software development life cycle. This component can also be serving as a legal document. Functional requirement specified in the SRS is of major concern. The SRS documents contain the entire necessary requirements that are needed for the development of any software project. Complete understanding of the product being developed or to be developed is required to better obtain the requirements from thee customers or users. And this can be achieved by having detailed and continuous meeting between project team and customer.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">UML Diagrams</head><p>Use case diagram is a one of the simple diagram of the UML. Use case diagram mainly shows the interaction of different users with the system. Use case diagram associates possible functionality of the system with its appropriate user.</p><p>In use case diagram users are represented as an actor and the numbers of functions are represented as a use cases. An actor has number of functions to be performed. Use case diagram is used to associate each with their corresponding appropriate functions. Activity diagram provides the graphical representations of different stepwise activities carried in a system. Activity diagrams depict the complete flow of the system. In activity diagram all activities are arranged in a stepwise manner so that each task can be easily executed. Different symbols used in activity diagrams are represented as below. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">RELATED WORK</head><p>Test cases are mostly generated from activity diagram but there are also some other alternatives available for the generation of functional test cases.</p><p>Noraida Ismail et al. <ref type="bibr" target="#b5">[5]</ref>, presented an approach for generation of test cases from the use case diagram based on specification based testing. Test cases from use cases are driven automatically in this approach. This approach mainly considers two steps i.e. generation of use case diagrams from the software requirement specification of the system and then generating test cases from the use case diagram.</p><p>Ajay kumar jena et al. <ref type="bibr">[6]</ref>, presented an approach for the generation of test cases from the activity diagram which is design based testing. Test cases from the activity diagrams are generated by using the coverage criteria method. This paper has considered the case study of ATM cash withdrawal and generated test cases are further optimized sing genetic algorithm.</p><p>Andreou et al. <ref type="bibr" target="#b7">[7]</ref>, presented an approach for the generation of test data using data flow graph. This paper proposes the integrated approach of data flow module with existing testing framework. The performance of this approach is tested on the basis on number of different samples of programs having different size and complexity.</p><p>Nebut et al. <ref type="bibr" target="#b8">[8]</ref>, presented an approach for test case generation by considering the UML use case diagram. It also addresses the problems associated between major views and execution of test cases. This approach uses the statement coverage criteria for test cases development. This approach is divided into two parts i.e. handling high levels concerns and data complexity is taken into account with the use case scenarios.</p><p>Kundu et al. <ref type="bibr" target="#b9">[9]</ref>, the main scope of this paper is to consider use case as a base for the generation of test cases. This approach has used the activity path coverage criteria for the generation of test cases. This approach is also able to handle the faults like synchronization and loop faults.</p><p>Tripathy et al. <ref type="bibr" target="#b10">[10]</ref>, presented an approach for the generation of test cases with the togetherness of UML activity diagram and Sequence diagram. Activity graph from the activity diagram and sequence graph from the sequence diagrams are derived first and these theses are integrated together to form a new graph and then traversing is applied on that graph for the generation of test cases.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Mingsong et al. [11]</head><p>, presented an approach for test case generation using activity diagram by considering a design as a specification. Rather than generating test cases from activity diagram, it is using some randomly generated test cases based on certain coverage criteria.</p><p>From the previous work it is concluded that the most of the work is done in the field of design based testing by using the activity diagrams. Test cases generation from the specification based testing is very important as it disclose the specifications problems and responsible for the delivery of software with its complete specifications.</p><p>It is also observed that no work of automated analysis of software requirement specification has been done. And also there is no automated framework for the generation of use case diagrams. Use case diagrams are manually drawn by users in various UML tools.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">PROPOSED FRAMEWORK</head><p>An approach is introduced to perform the specification based testing to unveil the specifications problems in the system. This approach mainly deals with the automated analysis of software requirement specification to find the appropriate input for the use case diagram. As use case diagrams needs input like various actors and use cases, our motive is to find the actors and use cases from SRS automatically. Another goal of our approach is to automatically generate the use case diagram from the refined input generated from the SRS. Then automatically generated use case diagram are used to generate the activity diagram. Hence functional test cases from activity diagrams are created.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Proposed Framework</head><p>A framework that we are proposing will work as mentioned below and the framework is shown in Fig. <ref type="figure" target="#fig_0">1</ref> </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Analysis of Software Requirement Specification</head><p>Software requirement specification for a software application is analyzed by automatically and manually. SRS is analyzed to find the input for the use case diagrams. So functional requirement of the SRS is analyzed to obtain the appropriate input i.e. use cases and actors for the use case diagram by both way.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Generation of Use Case Diagrams</head><p>Use case diagrams are generated by three ways i.e. fullyautomated, semi-automated and complete user based input approach. In fully automated approach, use case diagram are generated from the input provided by automated analysis of SRS. In semi-automated approach, use case diagrams are generated from the input provided by automated analysis of SRS but with human invention. In complete user based input approach, use case diagrams are generated from the input provided by manual analysis of SRS.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Analysis of Developed Use Case Diagram</head><p>Analysis of use case diagram involves the manual checking of use case diagram generated by all three approaches. In this software engineer or user will check the use case diagram to ensure that whether it is according to the specified requirements. If any changes found, then use case diagrams are modified to ensure the better covering of functional requirements mentioned in the system specification. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Developing Use case Activity Diagrams (UAD)</head><p>Activity diagrams from the use case diagrams are generated.</p><p>Various tools can be used to generate the activity diagrams. Activity diagrams clearly depict the flow of one activity to another activity to easily understand the working of system.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>4.5Checking the uniformity of UAD</head><p>Uniformity of activity diagrams are checked to ensure the flow of one action to another. Consistencies of modules are checked in this step. It ensures that all units of activity diagrams are placed at their position and according to their roles. Once the uniformity is checked, XML files of activity diagrams are generated.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.6">Parsing of XML Files</head><p>Parsing of XML files of different activity diagrams are performed to find the relevant information needed for the generation of Activity Dependent Table (ADT), Activity Dependent Graph (ADG) and for traversing the graph.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.7">Activity Dependent Table (ADT)</head><p>ADTs are generated from parsed content provided by the parsing step. Activity Dependent Table contains the information like vertex name, dependency nodes, dependent nodes, in degree and out degree of the activity diagram.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.8">Activty Dependent Graph (ADG)</head><p>Activity Dependent Graph is of tree like structure which has one root node and all other nodes are child nodes. ADT is defined as G (V,E) where G represents the graph, V represents the vertices i.e. set of nodes (activities) and E represents the edges i.e. flow from one activity to another.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.9">Traversing Technique</head><p>Depth First Search (DFS) algorithm is used to traverse the ADG to show all possible functional test paths in the ADG. DFS ensures the proper coverage of all paths available in the graph. DFS starts traversing the graph with one as a root node and traverse it as far as possible before backtracking</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.10">Developing Functional Test Cases</head><p>By using all the functional test paths, functional test cases are generated. Test case represents some conditions, by following these conditions tester checks that whether a software system or one of its modules is working accordingly as it was specified to do.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.11">Comparing the Results</head><p>Functional test cases generated by all three approaches are compared to measure the number of functional test cases produced. Results are also compared to know which approach is covering all specifications specified in the SRS. And also time complexities of these approaches are analyzed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">CONCLUSION AND FUTURE WORK</head><p>Functional test cases from software requirement specification are generated by developing use case diagram and activity diagram. Automation approach for the analysis of SRS, generation of use case diagram and generation of functional test cases has been introduced. Automation results in saving maximum effort consumed in analysis of SRS and drawing of use case diagram manually in any UML tool or by using pen or paper. Automation also results in saving cost included in the testing of the software application. Mostly in code based testing, we are able to find errors in coding or logics, we are not able to ensure the covering of all requirements specified in the SRS. Our automation approach ensures the maximum coverage of all requirements specified in the SRS. Hence possibility of reliable system delivery to the customer increases. An approach for automated analysis of SRS must be improved to identify the composite words. And this approach can be further extended for the other UML diagrams.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 :</head><label>1</label><figDesc>Fig. 1: Proposed Framework</figDesc><graphic coords="4,74.98,127.19,446.65,602.69" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 1 . Control Nodes of Use Case Diagram</head><label>1</label><figDesc></figDesc><table><row><cell>Names</cell><cell>Symbols Used</cell><cell cols="2">Description</cell></row><row><cell>Actor</cell><cell cols="3">It is a stick</cell></row><row><cell></cell><cell cols="2">persons</cell><cell>which</cell></row><row><cell></cell><cell cols="3">represents</cell><cell>the</cell></row><row><cell></cell><cell cols="3">various types of</cell></row><row><cell></cell><cell cols="2">users</cell><cell>of</cell><cell>the</cell></row><row><cell></cell><cell cols="2">system</cell></row><row><cell>Use case</cell><cell cols="3">It is of oval</cell></row><row><cell></cell><cell cols="3">shaped which is</cell></row><row><cell></cell><cell cols="3">used to represents</cell></row><row><cell></cell><cell>the</cell><cell></cell><cell>various</cell></row><row><cell></cell><cell cols="3">functionality</cell><cell>of</cell></row><row><cell></cell><cell cols="3">the system</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 2 . Control Nodes of Activity Diagram</head><label>2</label><figDesc></figDesc><table><row><cell>Names</cell><cell>Symbols used</cell><cell>Description</cell></row><row><cell>Start</cell><cell></cell><cell>It is start symbol</cell></row><row><cell></cell><cell></cell><cell>which represents</cell></row><row><cell></cell><cell></cell><cell>start of the activity</cell></row><row><cell>Action node</cell><cell></cell><cell>Action node is</cell></row><row><cell></cell><cell></cell><cell>used to represents</cell></row><row><cell></cell><cell></cell><cell>the every action</cell></row><row><cell>Arrow</cell><cell></cell><cell>Arrow symbol is</cell></row><row><cell></cell><cell></cell><cell>used to show the</cell></row><row><cell></cell><cell></cell><cell>activity moving</cell></row><row><cell></cell><cell></cell><cell>from one action to</cell></row><row><cell></cell><cell></cell><cell>another</cell></row><row><cell>Decision node</cell><cell></cell><cell>Decision node</cell></row><row><cell></cell><cell></cell><cell>contains one</cell></row><row><cell></cell><cell></cell><cell>incoming and</cell></row><row><cell></cell><cell></cell><cell>multiple outing</cell></row><row><cell></cell><cell></cell><cell>nodes</cell></row><row><cell>Merge node</cell><cell></cell><cell>Merge node</cell></row><row><cell></cell><cell></cell><cell>contains multiple</cell></row><row><cell></cell><cell></cell><cell>incoming nodes</cell></row><row><cell></cell><cell></cell><cell>and one outgoing</cell></row><row><cell></cell><cell></cell><cell>node</cell></row><row><cell>Fork</cell><cell></cell><cell>Fork node is used</cell></row><row><cell></cell><cell></cell><cell>to split the activity</cell></row><row><cell></cell><cell></cell><cell>into multiple parts</cell></row><row><cell></cell><cell></cell><cell>Join node is used</cell></row><row><cell></cell><cell></cell><cell>to join the multiple</cell></row><row><cell>Join</cell><cell></cell><cell>activities</cell></row><row><cell>Final node</cell><cell></cell><cell>Final node</cell></row><row><cell></cell><cell></cell><cell>indicates the end</cell></row><row><cell></cell><cell></cell><cell>point of the</cell></row><row><cell></cell><cell></cell><cell>activities</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>: i. Analyze the software requirement specification (SRS) to find the appropriate use cases and actors. Analysis of SRS is of two types automated analysis and manual analysis ii. In automated analysis, two types of use case diagrams are generated i.e. fully automated and semi-automated. iii. In manual analysis complete user based input use case diagrams are generated. iv. Users have to choose the each way to generate use case diagrams. v. Analyze the use case diagrams developed by fully automated, semi-automated and complete user based input approach. vi. Develop one or more Use Case Activity Diagram (UAD) based on fully automated, semi-automated and complete user based input approach. vii. Checks the uniformity of the UADs. viii. Perform parsing of XML files of different UADs. ix. Generate Use Case Activity Dependent Table (UADT) based on UADs. x. Generate Use Case Activity Dependent Graph (UADG) based on UADTs. xi. Apply traversing technique to generate functional test cases. xii. Develop one or more functional test cases. xiii. Finally compare the results of all three approaches.</figDesc><table /></figure>
		</body>
		<back>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0" />			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName><surname>References</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Study Paper on Test Case generation for GUI Based Testing</title>
		<author>
			<persName><forename type="first">A</forename><surname>Isabella</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Emi</forename><surname>Retna</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1202.4527</idno>
		<imprint>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">A survey on automatic test case generation</title>
		<author>
			<persName><forename type="first">M</forename><surname>Prasanna</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Academic Open Internet Journal 15.part</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Software testing and analysis: process, principles, and techniques</title>
		<author>
			<persName><forename type="first">Michal</forename><surname>Young</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2008">2008</date>
			<publisher>John Wiley &amp; Sons</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Software engineering: software reliability, testing and quality assurance</title>
		<author>
			<persName><forename type="first">Nasib</forename><surname>Gill</surname></persName>
		</author>
		<author>
			<persName><surname>Singh</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2007">2007</date>
			<publisher>Khanna Book Publishing</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">A Novel Approach to Generate Test Cases from UML Activity Diagrams</title>
		<author>
			<persName><forename type="first">Debasish</forename><surname>Kundu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Debasis</forename><surname>Samanta</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Object Technology</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="65" to="83" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">A novel approach for test case generation from UML activity diagram</title>
		<author>
			<persName><forename type="first">Ajay</forename><surname>Jena</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Santosh</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Durga</forename><surname>Kumar Swain</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mohapatra</forename><surname>Prasad</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Issues and Challenges in Intelligent Computing Techniques (ICICT), 2014 International Conference</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Test Case Generation Using Activity Diagram and Sequence Diagram</title>
		<author>
			<persName><forename type="first">Abinash</forename><surname>Tripathy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Anirban</forename><surname>Mitra</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of International Conference on Advances in Computing</title>
		<meeting>International Conference on Advances in Computing</meeting>
		<imprint>
			<publisher>Springer India</publisher>
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Automatic test generation: A use case driven approach</title>
		<author>
			<persName><forename type="first">Clementine</forename><surname>Nebut</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="140" to="155" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
	<note>Software Engineering</note>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Automatic test case generation for UML activity diagrams</title>
		<author>
			<persName><forename type="first">Chen</forename><surname>Mingsong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Qiu</forename><surname>Xiaokang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Li</forename><surname>Xuandong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2006 international workshop on Automation of software test</title>
		<meeting>the 2006 international workshop on Automation of software test</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">An automatic software testdata generation scheme based on data flow criteria and genetic algorithms</title>
		<author>
			<persName><forename type="first">Andreas</forename><forename type="middle">S</forename><surname>Andreou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Kypros</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Anastasis</forename><forename type="middle">A</forename><surname>Economides</surname></persName>
		</author>
		<author>
			<persName><surname>Sofokleous</surname></persName>
		</author>
		<imprint/>
		<respStmt>
			<orgName>Computer and</orgName>
		</respStmt>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
