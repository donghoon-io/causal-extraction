<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Evaluation of Spatial Keyword Queries with Partial Result Support on Spatial Networks</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Ji</forename><surname>Zhang</surname></persName>
							<email>jizhang@auburn.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Dept. of Computer Science and Software Engineering</orgName>
								<orgName type="institution">Auburn University</orgName>
								<address>
									<settlement>Auburn</settlement>
									<region>AL</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Wei-Shinn</forename><surname>Ku</surname></persName>
							<email>weishinn@auburn.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Dept. of Computer Science and Software Engineering</orgName>
								<orgName type="institution">Auburn University</orgName>
								<address>
									<settlement>Auburn</settlement>
									<region>AL</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Xiao</forename><surname>Qin</surname></persName>
							<email>xqin@auburn.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Dept. of Computer Science and Software Engineering</orgName>
								<orgName type="institution">Auburn University</orgName>
								<address>
									<settlement>Auburn</settlement>
									<region>AL</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Evaluation of Spatial Keyword Queries with Partial Result Support on Spatial Networks</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.1" ident="GROBID" when="2025-10-14T18:14+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Numerous geographic information system applications need to retrieve spatial objects which bear user specified keywords close to a given location. For example, users can search for hotels in a certain city with preferred features and amenities by using hotel reservation websites. In this research, we present efficient approaches to answer spatial keyword queries on spatial networks. In particular, we systematically introduce formal definitions of Spatial Keyword k Nearest Neighbor (SKkNN) and Spatial Keyword Range (SKR) queries. Then, we present the framework of a spatial keyword query evaluation system which is comprised of Keyword Constraint Filter (KCF), Keyword and Spatial Refinement (KSR), and the spatial keyword ranker. KCF employs an inverted index to calculate keyword relevancy of spatial objects, and KSR refines intermediate results by considering both spatial and keyword constraints with the spatial keyword ranker. In addition, we design novel algorithms for evaluating SKkNN and SKR queries. These algorithms employ the inverted index technique, shortest path search algorithms, and network Voronoi diagrams. Finally, we apply both realworld and synthetic data sets to evaluate the performance of the proposed solutions. Our extensive simulations show that the proposed SKkNN and SKR algorithms can answer spatial keyword queries effectively and efficiently.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I. INTRODUCTION</head><p>A Spatial Keyword (SK) query is an approach of searching qualified spatial objects by considering both the query requester's location and user specified keywords. Taking both spatial and keyword requirements into account, the goal of a spatial keyword query is to efficiently find results that satisfy all the conditions of a search. However, most existing solutions for SK queries are designed based on Euclidean distance <ref type="bibr" target="#b5">[6]</ref>, <ref type="bibr" target="#b7">[8]</ref>, <ref type="bibr" target="#b19">[20]</ref>, <ref type="bibr" target="#b18">[19]</ref>, which is not realistic since most users move on spatial networks. Moreover, most current approaches of SK queries are limited to finding objects that fully match the given keywords. Nevertheless, the objects with fully matched keywords could be far away from the query point. In this research, we design novel SK query techniques based on spatial networks. In addition, we take both fully and partially matched query results into account in the process of keyword searching. This new SK query mechanism enables users to not only retrieve qualified results on spatial networks, but also obtain partially matched objects when there are not enough fully matched results in the vicinity of the requester. Figure <ref type="figure" target="#fig_0">1</ref> illustrates an example: a tourist who flies to Atlanta may want to search for two hotels which provide both "Internet" and "Breakfast" amenities and have the shortest driving distance to the Atlanta airport. In addition, the tourist may also search for all the hotels which are within 10 miles of the airport and provide the two amenities in order to compare the hotels' reviews and prices. For retrieving the qualified hotels, the tourist will launch a Spatial Keyword k Nearest Neighbor (SKkNN) query with ranking parameters for the first search; the query results are hotels 1 and 3. A Spatial Keyword Range (SKR) query will be executed for the second inquiry, and the answers are hotels 1, 3, and 6. In this paper, we focus on solving the two aforementioned spatial query types by devising three novel solutions which employ the inverted index technique, shortest path search algorithms, and network Voronoi diagrams. Particularly, the inverted index is used to maintain the relationships between spatial objects and their attached keywords for quickly retrieving spatial objects whose features match the given keywords. In addition, we propose both a network expansion-based approach and a Voronoi diagram-based approach to efficiently answer SKkNN queries on spatial networks. The contributions of this study are as follows:</p><p>1) We provide formal definitions of spatial keyword kNN and range queries on spatial networks. 2) We develop three novel approaches for efficiently processing SKkNN and SKR queries on spatial networks. 3) Our SKkNN solution is able to return partially matched query results based on the output of the spatial keyword ranker. 4) We evaluate the performance of the proposed SKkNN and SKR algorithms through extensive experiments with both real-world and synthetic data sets.</p><p>The rest of this paper is organized as follows. Section II surveys related works. The proposed query types are formally defined in Section III. In Section IV, we introduce the spatial keyword query evaluation algorithms. The experimental validation of our design is presented in Section V. Section VI concludes the paper with a discussion of future work.</p><note type="other">Parking Fitness Breakfast</note></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>II. RELATED WORK</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. k Nearest Neighbor Queries</head><p>In spatial databases, k nearest neighbor (kNN) and range queries are fundamental query types. These two types of spatial queries have been extensively studied and applied in various location-based services (LBS) applications. For answering spatial queries on road networks, Papadias et al. <ref type="bibr" target="#b14">[15]</ref> developed a Euclidean restriction and a network expansion framework to efficiently prune the search space. Based on the proposed frameworks, solutions for nearest neighbor queries are designed in the context of spatial network databases. In addition, a network Voronoi diagram-based solution for kNN searches in spatial network databases is presented in <ref type="bibr" target="#b9">[10]</ref> by partitioning a large network to small Voronoi regions and pre-computing distances both within and across the regions. Because most Dijkstra's algorithm-based kNN solutions have been shown to be efficient only for short distances, Hu et al. <ref type="bibr" target="#b8">[9]</ref> proposed an efficient index (distance signature) for distance computation and query processing over long distances. Their technique discretizes the distances between objects and network nodes into categories and then encodes these categories to accelerate the kNN search process. Furthermore, in order to speed up kNN searches, Samet et al. <ref type="bibr" target="#b16">[17]</ref> designed an algorithm to explore the entire network by pre-computing the shortest paths between all the vertices in the network and employing a shortest path quadtree to capture spatial coherence. With the algorithm, the shortest paths between all possible vertices can be computed only once to answer various kNN queries on a given spatial network. Nevertheless, all the aforementioned techniques mainly focused on the distance metric. They did not consider text description (keywords) of spatial objects in their query evaluation processes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Text Retrieval</head><p>Text retrieval is another important topic related to spatial keyword queries. There are two main indexing techniques, inverted files and signature files, widely utilized in text retrieval systems. According to experiments made by Zobel et al. <ref type="bibr" target="#b21">[22]</ref>, <ref type="bibr" target="#b20">[21]</ref>, signature files require a much larger space to store index structures, and are more expensive to construct and update than inverted files. In addition, Baeza-Yates and Ribeiro-Neto <ref type="bibr" target="#b0">[1]</ref> also stated that inverted files outperform signature files in most cases.</p><p>Although these aforesaid methods perform quite well in text retrieval applications, none of them can efficiently process spatial keyword queries. In other words, it is impractical to answer spatial keyword queries by simply employing approaches introduced in this or the previous subsection. An effective way to handle spatial keyword queries is to combine the two groups of techniques as discussed in the following subsection.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Spatial Keyword Query</head><p>As local search services become more and more popular, many solutions <ref type="bibr" target="#b1">[2]</ref>, <ref type="bibr" target="#b3">[4]</ref>, <ref type="bibr" target="#b5">[6]</ref>, <ref type="bibr" target="#b7">[8]</ref>, <ref type="bibr" target="#b2">[3]</ref>, <ref type="bibr" target="#b19">[20]</ref>, <ref type="bibr" target="#b18">[19]</ref>, <ref type="bibr" target="#b15">[16]</ref> have been developed to evaluate spatial keyword queries by integrating index techniques previously used in spatial queries and text search.</p><p>Location-based web search is studied by Zhou et al. <ref type="bibr" target="#b19">[20]</ref> to find web pages related to a spatial region. They described three different hybrid indexing structures of integrating inverted files and R*-trees together. According to their experiments, the best scheme is to build an inverted index on the top of R*-trees. In other words, the algorithm first sets up an inverted index for all keywords, and then creates an R*-tree for each keyword. This method performs well in spatial keyword queries in their experiments; however, its maintenance cost is high. When an object insertion or deletion occurs, the solution has to update the R*-trees of all the keywords of the object. Cong et al. <ref type="bibr" target="#b3">[4]</ref> illustrated a hybrid index structure, the IR-tree, which is a combination of an R-tree and inverted files to process location-aware text retrieval and provide k best candidates according to a rank system. They also proposed the DIR-tree and the CIR-tree, two extensions of the IR-tree, which take both minimizing areas of enclosing rectangles and maximizing text similarities into account during construction procedures. Recently, Cary et al. <ref type="bibr" target="#b1">[2]</ref> proposed an efficient approach of answering top-k spatial boolean queries. They combined an R-tree with an inverted index to search the k best candidates which satisfy a group of boolean constraints. However, with their method, only candidates which completely meet boolean constraints will be found. The ones merely matching part of the constraints will be discarded because of strict constraints or an input error.</p><p>Felipe et al. <ref type="bibr" target="#b5">[6]</ref> developed a novel index, IR 2 -Tree which integrates an R-tree and signature files together, to answer topk spatial keyword queries. They record signature information in each node of R-trees in order to decide whether there is any object which satisfies both spatial and keyword constraints simultaneously. However, the size of space for storing signatures in each node is decided before IR 2 -Tree construction. Once the IR 2 -Tree has been built, it is impossible to enlarge the space unless the tree is reconstructed. If the number of keywords grows quickly, a system will spend a lot of time repeatedly rebuilding the IR 2 -Tree. Hariharan et al. <ref type="bibr" target="#b7">[8]</ref> proposed an indexing mechanism, KR*-tree, which combines an R*-tree and an inverted index. The difference between their solution and <ref type="bibr" target="#b5">[6]</ref> is that they only store related keywords in each node of an R*-tree in order to avoid merging operations to find candidates containing all keywords. Consequently, the number of keywords that appear in each node varies. However, such a complicated indexing technique has a high maintenance cost as well. If an object with new keywords is inserted, the method not only has to add new keywords to corresponding nodes from leaf to root of the R*-tree, but also update the inverted index (KR*-tree List).</p><p>Although there are a number of previous studies on spatial keyword queries, most of their solutions can only evaluate queries in Euclidean spaces. This limitation is due to the adoption of the R-tree (or its variants), which cannot index spatial objects based on network distances, into their hybrid index structures. The work in <ref type="bibr" target="#b15">[16]</ref> is the most relevant research to this paper. However, it is infeasible to provide partial results with the solution in <ref type="bibr" target="#b15">[16]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>III. QUERY TYPE DEFINITION AND BACKGROUND</head><p>In order to explain definitions and algorithms in the following sections, we prepare a sample data set of hotels in Table <ref type="table" target="#tab_0">I</ref> and an example spatial network in Figure <ref type="figure" target="#fig_2">2</ref>. All the hotels have three attributes which include their names, amenities, and distances from a specific location q. In Figure <ref type="figure" target="#fig_2">2</ref>, road segments are assigned weights that stand for their individual costs (e.g., distance or time). The location q and hotels are symbolized with a triangle and squares on road segments, respectively.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Foundation</head><p>In this subsection, we introduce the foundation of spatial keyword queries. In a SK query, a spatial object p is defined as a pair &lt;l, t&gt;, where l is a location in the search space and t is a text description (e.g., amenities and features of a hotel) of the corresponding object. Table <ref type="table" target="#tab_1">II</ref> summarizes notations used in this paper.</p><p>1) Distance on Spatial Networks: Spatial networks are composed by undirected weighted graphs G = (V, E), where V is a set of vertices and E is a set of edges. In general, the weight of each edge is determined by a metric measured in physical distance or time cost for traveling the road segment <ref type="bibr" target="#b11">[12]</ref>, <ref type="bibr" target="#b10">[11]</ref>. The distance between two objects D n (., .) on spatial networks is the summation of all segment weights on the shortest path connecting the two objects. For example, in Figure <ref type="figure" target="#fig_2">2,</ref><ref type="figure">D</ref> </p><formula xml:id="formula_0">n (H 6 , H 7 ) = D n (H 6 , n 8 ) + D n (n 8 , H 7 ) = 7.</formula><p>2) Matched Keywords: Matched-keywords is a set of keywords which are in both sets of p.t and K, where p.t is the text description of a given spatial object, and K is a set of keywords specified by a user. For example, given a hotel H 2 with keywords {"Pool", "Parking", "Room Service"}   The location of a requester I An inverted index k</p><p>The requested number of objects in the result of a SKkNN query r</p><p>The search range of a SKR query s</p><p>The ranking score of an object</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>|S|</head><p>The number of elements in set S d(., .)</p><p>The Euclidean distance between two points Dn(., .) The shortest network distance between two points R The result set of a query E</p><p>The explored region of a VDkNN query C</p><p>The set of candidate spatial objects and a set of keywords K {"Pool", "Parking", "Breakfast"},</p><formula xml:id="formula_1">M K(H 2 , K) is an intersection of H 2 .t and K, {"Pool", "Parking"}. The formal definition of the M K function is shown in Equation (1). M K(p, K) = { k i ∈ K | k i ∈ p.t } (1)</formula><p>3) Fully Matched Keyword Search: With a given data set, the purpose of Fully Matched Keyword Search (FMKS) is to find objects whose descriptions completely match with a set of keywords K specified by a requester. As shown in Equation ( <ref type="formula">2</ref>), the descriptions of search results of FMKS may be either identical to K or a superset of K. For example, given the keywords "Internet" and "Pets Allowed" and the data set in Table <ref type="table" target="#tab_0">I</ref>, the result set of the FMKS is {H 1 , H 3 , H 6 }.</p><formula xml:id="formula_2">F M KS(P, K) = { p i ∈ P | K ⊆ p i .t }</formula><p>(2) 4) Partially Matched Keyword Search: With a given data set, the purpose of Partially Matched Keyword Search (PMKS) is to retrieve objects which match at least one keyword in the user defined keyword set as shown in Equation (3). For example, given the keywords "Internet" and "Pets Allowed" and the data set in Table <ref type="table" target="#tab_0">I</ref>, the results of the PMKS are {H 1 , H 3 , H 5 , H 6 }. The difference in search results from the previous FMKS is H 5 , which matches only one keyword ("Pets Allowed") and is a valid answer of this PMKS.</p><formula xml:id="formula_3">P M KS(P, K) = { p i ∈ P | ∃k j ∈ p i .t and k j ∈ K } (3) 5)</formula><p>Weighted Keyword Relevancy: We use a weight function T R to calculate keyword relevancy of a specific spatial object p <ref type="bibr" target="#b17">[18]</ref>. We assume that each keyword k i in a keyword set K is assigned with a weight w(k i ), which indicates its importance in queries. Consequently, given an object p and a keyword set K, we have the following equation:</p><formula xml:id="formula_4">T R(p, K) = ki∈M K(p,K) w(k i )<label>(4)</label></formula><p>For special cases where all keywords share identical weight, Equation ( <ref type="formula" target="#formula_5">5</ref>) can be derived from Equation (4) where w(k</p><formula xml:id="formula_5">i ) = 1 and |M K(p, K)| is the number of keywords in M K(p, K). T R(p, K) = ki∈M K(p,K) 1 = |M K(p, K)|<label>(5)</label></formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Spatial Keyword Ranker</head><p>A spatial keyword ranker is designed to determine the ranking of a given spatial object in a SKkNN query by employing both metrics, spatial network distance and keyword relevancy. We utilize a ranking function RK to compute how well an object matches a SKkNN query. Given a query Q &lt;l, K&gt; and an object p &lt;l, t&gt;, the ranking function is defined as follows:</p><formula xml:id="formula_6">RK(Q, p) = θ 1 • T R(p.t, Q.K) -θ 2 • D n (p.l, Q.l)<label>(6)</label></formula><p>In Equation ( <ref type="formula" target="#formula_6">6</ref>), θ 1 and θ 2 are parameters of each part of the function <ref type="bibr" target="#b7">[8]</ref>, and their values depend on user preferences. For example, if a user is more concerned about keyword match, θ 1 can be set to a larger value than θ 2 in order to make keyword relevancy dominant in the RK function. Moreover, intuitively, an object with either a shorter distance or a higher keyword relevancy would have a higher ranking in query results. Therefore, T R has a positive influence on the RK function while D n has a negative one.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Spatial Keyword kNN Queries</head><p>Based on the spatial keyword ranker, the purpose of a spatial keyword kNN query is to retrieve k objects which have top k ranking values.</p><p>Definition Given a SKkNN query Q and an object set P , we define SKkNN(P , Q, k) as follows:</p><formula xml:id="formula_7">RK(p i ) ≥ RK(p j ) where p i ∈ SKkN N (P, Q, k) ∧ p j ∈ P \{SKkN N (P, Q, k)} ∧ |SKkN N (P, Q, k)| = k (7)</formula><p>We utilize the data set in Table <ref type="table" target="#tab_0">I</ref> and spatial network in Figure <ref type="figure" target="#fig_2">2</ref> to demonstrate a SKkNN query example. Assume a visitor wants to find the two nearest hotels that have the amenities, "Internet" and "Pets Allowed" from q. Partially matched results are acceptable when there are not enough fully matched objects in the vicinity. In addition, all keywords have identical weight and the values of θ 1 and θ 2 are 0.8 and 0.2, respectively. The result set for this query is {H 1 , H 5 } where H 5 has only one matched keyword. If 4 hotels are requested instead of 2, the result set will be {H 1 , H 5 , H 3 , H 6 }.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D. Spatial Keyword Range Queries</head><p>The purpose of an SK Range query is to find all the objects that fully match the given keywords within a user specified distance.</p><p>Definition Let P be a set of objects. Given a query location q, a search range r, and a set of keywords K, an SK range query is defined as follows:</p><formula xml:id="formula_8">SKR(P, q, r, K) = {p i ∈ P |K ⊆ p i .t ∧ D n (p i , q) ≤ r}<label>(8)</label></formula><p>Assume a tourist wants to find all the hotels bearing the keywords "Internet" and "Pets Allowed" within 10 miles of q on the sample spatial network. The answer is {H 1 } based on the example data set (Table <ref type="table" target="#tab_2">1</ref>). Furthermore, if the range is extended to 20 miles, the result set will be {H 1 , H 3 , H 6 }.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>E. Network Voronoi Diagram</head><p>We employ network Voronoi diagrams in our approach for efficiently evaluating spatial keyword queries. A Voronoi diagram divides a metric space into disjoint polygons (Voronoi polygons) based on the distances to a specified set of points (generators) in the space. The nearest neighbor of any point inside a polygon is the generator of the polygon. The Voronoi Polygon (VP) and the Voronoi Diagram (VD) in the Euclidean plane can be formally defined as follows. Given a set of generators P = {p 1 , . . . , p n } ⊂ R 2 , where 2 ≤ n &lt; ∞ and p i = p j for i = j, i, j ∈ I n = {1, . . . , n}. The region given by:</p><formula xml:id="formula_9">V P (p i ) = {p | d(p, p i ) ≤ d(p, p j )} f or j = i, j ∈ I n } (9)</formula><p>is called the Voronoi polygon associated with p i where d(p, p i ) denotes the minimum Euclidean distance between p and p i . In addition, the set given by: The Network Voronoi Diagram (NVD) is defined based on a planar geometric graph where the locations of objects are restricted to the links that connect the nodes of the graph. Distances between objects are defined as the length of the shortest path in the graph (network distance) <ref type="bibr" target="#b13">[14]</ref>. In our problem, spatial networks can be modeled as a geometric graph where the intersections are symbolized by nodes of the graph and edges are represented by the links connecting the nodes. Furthermore, the weights of links are the distances between corresponding nodes.</p><formula xml:id="formula_10">V D(P ) = {V P (p 1 ), . . . , V P (p n )}<label>(</label></formula><p>The network Voronoi diagram can be formally defined as follows. Consider a geometric graph G(N, L) consisting of a set of nodes N = {p 1 , . . . , p n , p n+1 , . . . , p l }, where the first n elements are the generators (i.e., P = {p 1 , . . . , p n }), and a set of links L = {l 1 , . . . , l k } which form a connected network. We define the distance from a point p on a link in L to a node p i in N , D n (p, p i ), by the length of the shortest path from p to p i . For all j ∈ I n \{i}, let</p><formula xml:id="formula_11">Dom(p i , p j ) = {p|p ∈ k i=1 l i , D n (p, p i ) ≤ D n (p, p j )} (11) b(p i , p j ) = {p|p ∈ k i=1 l i , D n (p, p i ) = D n (p, p j )}<label>(12)</label></formula><p>We call the set Dom(p i , p j ) the dominance region of p i over p j on links in L, and the set b(p i , p j ) the bisector (border) points between p i and p j on links in L. Accordingly, the Voronoi link set associated with p i and the network Voronoi diagram are defined as follows, respectively:</p><formula xml:id="formula_12">V link (p i ) = j∈In\{i} Dom(p i , p j )<label>(13)</label></formula><p>N V D(P ) = {V link (p 1 ), . . . , V link (p n )} (14) where V link (p i ) specifies all the points in all the links in L that are closer to p i than any other generator point in N . By properly connecting adjacent bisector points of a generator to each other without crossing any of the links, we can generate a bounding polygon, named Network Voronoi Polygon (NVP) <ref type="bibr" target="#b13">[14]</ref>, <ref type="bibr" target="#b9">[10]</ref>. Figure <ref type="figure" target="#fig_4">3</ref>(b) shows an NVD example where each line style corresponds to a Voronoi link set of a generator (NVPs are created by connecting adjacent bisector points).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IV. SYSTEM DESIGN</head><p>In this section, we design a spatial keyword query evaluation system which is comprised of Keyword Constraint Filter (KCF), Keyword and Spatial Refinement (KSR), and the spatial keyword ranker. For the proposed spatial keyword query algorithms, if two or more objects have the same ranking score, our algorithms will sort the objects based on their distances to the query point (i.e., in an ascending order). In addition, in order to simplify the explanation, we assume all keywords have the same weight.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Framework of Query Evaluation</head><p>Before presenting the details of our spatial keyword query algorithms, we briefly introduce the framework of our system. As illustrated in Figure <ref type="figure" target="#fig_6">4</ref>, the spatial keyword query evaluation system comprises three main components which are Keyword Constrain Filter (KCF), Keyword and Spatial Refinement (KSR) and the spatial keyword ranker. This system receives both spatial data sets and spatial keyword constraints as inputs and produces results after a two-step computation.</p><p>The system employs a filter-and-refine strategy to answer SK queries. The two key steps are KCF and KSR. KCF receives spatial data sets and keyword constraints and filters out objects that do not match any user specified keyword. Because spatial network distance computation is expensive, we do not take spatial constraints into account in this step. The main purpose of KCF is to reduce the number of candidate objects in order to decrease computation costs in the next step. In the second step, KSR receives inputs from KCF and refines the intermediate results based on both keyword and spatial constraints. Afterward, KSR returns the qualified objects sorted by their ranking scores provided by the ranker.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Keyword Constraint Filter</head><p>1) Inverted Indexing Structure: Inverted indexes are primarily designed to support keyword searches from a set of text files. In our system, we utilize inverted indexes to search for objects related to specific keywords from spatial databases. An index of terms is maintained in our system where each term is a unique keyword, and each postings list contains a number of object identifiers. Each postings list is in sorted order (based on object identifiers) to facilitate the efficient search of objects related to a specific keyword. If an object has multiple keywords, its identifier will appear in each corresponding postings list. In addition, inverted indexes are independent of other dedicated index structures, such as R-trees or grids, in spatial databases.</p><p>2) Keyword Match Algorithm: Based on the proposed problem, we design a keyword match algorithm by employing the inverted index-based merge technique <ref type="bibr" target="#b12">[13]</ref> to calculate the keyword relevancy of spatial objects. With the keyword match algorithm, we measure the keyword relevancy of a spatial object by counting the number of matched-keywords. The more matched-keywords the object has, the higher its keyword relevancy is. This algorithm receives an inverted index and a set of keywords as input parameters, and then returns the keyword relevancy of objects which match with at least one keyword.</p><p>In Algorithm 1, mergeList is a list, of which each element comprises a pair &lt;id, occurrence&gt; where id is an object identifier and occurrence is the corresponding keyword relevancy. With the f or loop in line 1, the algorithm iteratively retrieves object lists of matched-keywords from the inverted index structure and merges these object lists into mergeList. This merge process, illustrated in lines 5 to 22, is an essential part which supports partially-matched-keyword searches. The worst-case time complexity of Algorithm 1 is O(|K| * |P |), where |P | is the number of spatial objects in the data set and |K| stands for the number of search keywords.</p><p>Figure <ref type="figure" target="#fig_7">5</ref> illustrates how KeywordMatch works. We utilize the data set in Table <ref type="table" target="#tab_0">I</ref> and spatial network in Figure <ref type="figure" target="#fig_2">2</ref> for explanation. Assume a query with keywords "Internet", "Pets Allowed", and "Parking" is evaluated. Algorithm 1 first finds object lists that are related to these keywords by searching the inverted index. As shown in Figure <ref type="figure" target="#fig_7">5</ref>, three object lists,</p><formula xml:id="formula_13">{H 1 , H 3 , H 6 }, {H 1 , H 3 , H 5 , H 6 } and {H 1 , H 2 , H 3 , H 4 , H 7 },</formula><p>are retrieved from the inverted index. Then the algorithm merges these lists into a mergeList.</p><p>In the first round, KeywordMatch simply copies objects in the "Internet" list to mergeList, and each object is marked by one occurrence. Then, in the second round, KeywordMatch compares objects in the "Pets Allowed" list with mergeList. If an object appears in the "Pets Allowed" list but does not exist in mergeList, it will be inserted into mergeList with occurrence marked by one. However, if an object already exists in mergeList, its counter will be increased by one. The third round of merging the "Parking" list is processed in the same Algorithm 1 KeywordMatch(I, K) end if 24: end for 25: return mergeList way. After the iterations, mergeList contains the final result with seven objects and their keyword relevancy shown at the bottom of the dashed rectangle in Figure <ref type="figure" target="#fig_7">5</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Network Expansion-Based SKkNN Query Algorithm</head><p>In this section, we explain our algorithm for processing spatial keyword k nearest neighbor queries based on network expansion techniques <ref type="bibr" target="#b14">[15]</ref>, <ref type="bibr" target="#b4">[5]</ref>. As present in Section 3.3, the algorithm receives an inverted index I, a query point q, the value of k, and a set of keywords K as input parameters and returns the top k objects by considering both keyword and spatial constraints.</p><p>For searching the shortest path between objects on spatial networks, Dijkstra's algorithm-based approaches <ref type="bibr" target="#b4">[5]</ref>, <ref type="bibr" target="#b6">[7]</ref> have been widely utilized in various applications. Given a source point and a group of destinations, the algorithm recursively expands the unvisited paths and records distances of intermediate nodes. During the search, a distance record of a node will be updated if there is a shorter path than the present one. Such a process is continued until all the destinations have arrived, and the distances of all other possible paths are longer than their current distances. In addition, a solution named Incremental Network Expansion (INE) is presented in <ref type="bibr" target="#b14">[15]</ref> by extending Dijkstra's algorithm to compute k nearest neighbors in a network space. Specifically, INE first locates the network segment e i , which covers the query point q, and retrieves all objects on e i . If any object p i is found on e i , p i will be inserted into the result set. Furthermore, the endpoint of e i , which is closer to q, will be expanded while the second endpoint of e i will be placed in a priority queue Q p . INE repeats the process by iteratively expanding the first node in Q p and inserting newly discovered nodes into Q p until k objects are retrieved.</p><p>Algorithm 2 NEkNN(I, q, k, K)</p><formula xml:id="formula_14">1. mergeList = KeywordMatch(I, K) 2. if mergeList == ∅ then 3.</formula><p>return ∅ 4. end if 5. mark each object in mergeList in the spatial network 6. ninj = the segment covers q 7. if ninj covers candidate objects then 8.</p><p>calculate their ranking scores and insert them into R 9. end if 10. {p1, . . . , p k } are the top k objects in R sorted in descending order of their ranking scores 11. smin = p k .s // if p k = N U LL, smin = -∞ 12. Qp = &lt;(ni, Dn(q, ni)), (nj, Dn(q, nj))&gt; // sorted in ascending order of their distance to q 13. de-queue the first node n f in Qp solution by leveraging INE. There are two main steps in the NEkNN algorithm. The first step is to filter out objects which do not match any user specified keywords by employing Algorithm 1. Then, we mark all the objects in mergeList in the spatial network as candidates (e.g., set a bit of these points of interest). The next step is to expand the network from q with INE and the ranking function (Section 3.2). When an object p i is discovered, NEkNN verifies that p i is a candidate object. If p i is a candidate object, NEkNN calculates its ranking score s by executing the ranking function (otherwise the algorithm ignores p i ). Meanwhile, NEkNN keeps a result set R which is sorted in descending order based on the ranking score. If R has fewer than k objects and p i is a candidate object, p i is inserted into R. Otherwise, NEkNN compares the ranking score of p i with the last object p j in R. p j will be replaced by p i if p i .s &gt; p j .s. In addition, when |R| ≥ k, NEkNN calculates ranking scores for network nodes as well by assuming that they match all the search keywords to restrict the search space. In other words, any spatial object p i , which is further away from q than a network node n i , must have a lower ranking score than n i even if p i matches all the search keywords. Consequently, NEkNN iterates the search process until R contains k objects and the next network node to be expanded in Q p has an equal or lower ranking score than the last object in R.</p><p>By employing the data set in Table <ref type="table" target="#tab_0">I</ref> and spatial network in Figure <ref type="figure" target="#fig_2">2</ref>, we demonstrate an example to retrieve the two nearest hotels that have the amenities, "Internet" and "Pets Allowed" from q with NEkNN. We assume that all keywords have an identical weight and the values of θ 1 and θ 2 are 0.5 and 0.5, respectively. First, NEkNN executes Algorithm 1 and marks candidate hotels H 1 , H 3 , H 5 , and H 6 on the network. Then, NEkNN locates the segment n 5 n 7 that covers q. Since no hotel is covered by n 5 n 7 , the node (n 5 ) closer to q is expanded and the other endpoint n 7 is placed in Q p . On n 2 n 5 , H 1 is discovered and inserted into R with s = -0.5. Meanwhile, n 2 is inserted into Q p = &lt;(n 7 , 3), (n 2 , 4)&gt;. The expansion of n 7 reaches n 9 and Q p = &lt;(n 2 , 4), (n 9 , 6)&gt;. Next, the expansion of n 2 reaches n 1 and n 3 , after which Q p = &lt;(n 9 , 6), (n 1 , 11), (n 3 , 13)&gt; and H 5 is found on n 2 n 3 . Afterward, H 5 is inserted into R with s = -3.5. Subsequently, n 9 is expanded and Q p = &lt;(n 1 , 11), (n 3 , 13), (n 8 , 13), (n 10 , 14)&gt;. The ranking score of the next node in Q p (n 1 ) is -4.5; the algorithm terminates because R contains two hotels and H 5 .s &gt; n 1 .s. The complete algorithm of NEkNN is formalized in Algorithm 2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D. Voronoi Diagram-Based SKkNN Query Algorithm</head><p>Although NEkNN is able to restrict the search space and retrieve the top k objects based on their ranking scores, the main limitation of NEkNN is that it has to explore a large portion of the network when candidate objects are not densely distributed in the network. Therefore, we propose a Voronoi diagrambased SKkNN (VDkNN) solution by leveraging the network Voronoi diagram (NVD) <ref type="bibr" target="#b9">[10]</ref> to improve performance. In order to be independent of the density and distribution of candidate objects, we first partition the spatial network into small regions by generating a network Voronoi diagram over all the spatial objects (points of interest). Each cell of the NVD is centered by one spatial object and contains the nodes that are closest to that object in network distance. Afterward for each NVD cell, we pre-compute the distances between all the edges of the cell to its center as well as the distances only across the border points of the adjacent cells. Consequently, for a new cell, we can quickly extend the searched region to the border points without expanding all the internal network segments.</p><p>With the NVD of the search space, for a SKkNN query, VDkNN first filters out unqualified objects with Algorithm 1 and marks all the objects in mergeList in the NVD as candidates. Then, VDkNN finds the network Voronoi polygon NVP(p i ) that contains q where p i is the generator of the polygon. This step can be accomplished by employing a spatial index (e.g., the R-tree), which is generated based on the NVD cells. Next, we verify that p i is a candidate object. If p i is a candidate object, VDkNN calculates its ranking score by running the ranking function. In addition, VDkNN maintains a result set R which is sorted in descending order according to the ranking score. When R contains fewer than k objects, newly discovered candidate objects are inserted into R. However, if R already includes k objects, VDkNN replaces the k th object p k of R when a newly retrieved candidate object has a higher s than p k . Also, VDkNN keeps a queue Q n which stores the neighbors (adjacent cells) of p i and a set E which consists of all the searched cells (i.e., E covers the current explored region).</p><p>Subsequently, VDkNN searches the adjacent cells of E (i.e., NVP(p i )) stored in Q n for the next candidate object. Every time after a cell NVP(p j ) been explored, the neighboring generators of p j are unioned with Q n , NVP(p j ) is unioned with E, and R is updated according to the aforementioned rules if p j is a candidate object. Moreover, when |R| ≥ k, VDkNN calculates the ranking score of all the border points of the current explored region by assuming that they match all the search keywords to restrict the search space. VDkNN iterates the search process until R contains k objects and the ranking scores of all the border points of E are equal or worse than the ranking score of the k th object in R (i.e., there will not be any changes in R even if we search further). Figure <ref type="figure" target="#fig_8">6</ref> illustrates an example of retrieving the two nearest points of interest (POI) which match keywords in K from q with VDkNN. First, VDkNN executes Algorithm 1 and marks candidate POIs on the NVD. Then, VDkNN locates the network Voronoi polygon, NVP(p 1 ), which contains q. Next, VDkNN verifies that p 1 is a candidate POI and inserts the Algorithm 3 SKR(I, q, r, K)  <ref type="figure" target="#fig_8">6</ref>), and Q n comprises nine generators (p 3 to p 11 ). Since R covers two POIs, VDkNN computes the ranking score of all the border points of E (b 1 to b 12 ) by assuming that they match all the search keywords in K. Here we suppose that s min &gt; b max and the algorithm terminates. The algorithm of VDkNN is similar to Algorithm 2 except for the underlying index. We skip the algorithm here because of the space limit.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>E. Spatial Keyword Range Query Algorithm</head><p>As defined in Section 3.4, given a query point q, a search range r and a set of keywords K, SKR query is to retrieve all the objects which fully match all the keywords within r. SKR query first calculates the keyword relevancy of objects by utilizing KeywordMatch (Algorithm 1). Then, it retrieves objects which fully match all the given keywords and stores the qualified objects in C. Afterward, it calls Dijkstra's algorithm for calculating distances from q to all the candidate objects. Finally, SKR query removes objects which are out of the search range from R. The complete SKR query algorithm is illustrated in Algorithm 3.</p><p>The worst-case running time of Algorithms 2 and 3 on a spatial network with a set of nodes</p><formula xml:id="formula_15">N is O(|K| * |P | + |N | 2 )</formula><p>by considering both the keyword match and spatial network search subroutines.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>V. EXPERIMENTAL VALIDATION</head><p>In this section, we evaluate the performance of our spatial keyword query solutions with both real-world and synthetic data sets. We implemented the proposed algorithms and related experimental components in C++. The inverted index structure was loaded into the main memory during the execution of simulations. All the experiments were conducted on an Ubuntu Linux server equipped with an Intel Xeon 2.4GHz processor and 2GB memory. All simulation results were recorded after the system model reached a steady state. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Experimental Data Sets</head><p>In our experiments, a real-world data set was downloaded from edigitalz <ref type="foot" target="#foot_0">1</ref> , which provides a wide range of general data sets for free. We retrieved 9,483 restaurants in the state of California and collected 34,091 keywords from their menus (e.g., pizza, steak, etc.) and cuisine (e.g., American, French, etc.) for searches. The data sets of road networks in both the state of California (containing 21,692 roads and 21,047 intersections) and the continental United States (containing 179,178 roads and 175,812 intersections) were downloaded from the US Census Bureau (TIGER/Line Shapefiles) <ref type="foot" target="#foot_1">2</ref> .</p><p>For the synthetic data set, we generated around 160,000 restaurants, of which the density follows the real-world data set in order to investigate the scalability of our algorithms. In addition, each restaurant has a similar number of keywords (totally 575,200 keywords) to the real-world data set. The network of the continental United States is used with the synthetic data set.</p><p>Table <ref type="table" target="#tab_5">III</ref> displays the default values of parameters in our experiments. We varied an essential parameter in each experiment set in order to evaluate its impact on the performance of the proposed algorithms. Other parameters were kept constant during all the experiments in the same set. The default values of parameters are used in experiments if we do not explicitly specify other values. The selection of θ 1 and θ 2 values depends on preference for keyword relevancy and distance of users. We fixed the ratio of θ 1 to θ 2 (1/20) in all the experiments.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Data Set Size Experiment</head><p>In this experiment, we evaluate NEkNN, VDkNN, and SKR queries with various data set sizes. The main purpose of this experiment is to analyze the influence of different data set sizes on query execution time. For both real-world and synthetic data sets, we generate five subsets of restaurants with an increasing number of data objects. The number of restaurants in consecutive subsets is increased by 2,000 for real-world data sets and 35,000 for synthetic data sets. Objects in smaller subsets are included in bigger ones.</p><p>The results of real-world and synthetic data sets are demonstrated in Figure <ref type="figure" target="#fig_9">7</ref>(a) and Figure <ref type="figure" target="#fig_9">7</ref>(b), respectively. VDkNN always outperforms NEkNN with the default parameters in all the experiments. From Figure <ref type="figure" target="#fig_9">7</ref>, we observe that the execution time of most queries increases linearly with the increment of data set size. The reason is that more POIs and keywords have to be processed in these queries. In addition, the difference of execution time between NEkNN and VDkNN queries decreases gradually as the data set size grows. In other words, the time costs of these two solutions become close with a larger data set. The reason for rapid performance degradation in VDkNN is that it has an extra overhead of searching on Voronoi diagrams in addition to the cost of processing POIs, which is suffered by both solutions. The higher density of POIs on spatial networks, the more border nodes are generated in Voronoi polygons. Hence, VDkNN has to spend more time on border node related calculation when it tests its stopping condition.</p><p>Another observation is that queries run faster on a bigger synthetic data set (e.g., 20,000 data objects) than a smaller real-world data set (e.g., 9,483 data objects). The reason is that the density of POIs is a dominant factor in these queries. Although there are more POIs involved in the keyword-match process in the synthetic data set, there are fewer candidates which are discovered in the search area due to lower POI density.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Number of Keywords Experiment</head><p>The number of keywords is an essential parameter of both NEkNN and VDkNN queries. In order to investigate the impact of the number of keywords on query performance, we vary the number of specified keywords on both data sets. We conduct experiments from queries with one keyword to ones with five keywords by adding a new keyword after each experiment. Figure <ref type="figure" target="#fig_10">8</ref> shows that the execution time of queries increases when more keywords are specified by users. In order to retrieve partially matched query results, POIs that match any of the given keywords have to be taken into account. Consequently, more keywords will increase the number of POIs to be processed in the keyword match and query evaluation processes.</p><p>The difference in execution time between NEkNN and VDkNN remains nearly constant in all queries. As the number of keywords becomes larger, more POIs are considered in the keyword match process in both solutions. Moreover, varying the number of keywords does not directly enlarge or shrink the search area of both methods (i.e., the score of a POI is determined by the ranking function). Therefore, no apparent change of the difference in query performance between the two methods is observed. However, VDkNN always exceeds NEkNN in execution time in this experiment.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D. Number of k Experiment</head><p>Next, we evaluate the impact of k on the performance of NEkNN and VDkNN queries with the two data sets. We vary the value of k from 5 to 30 with an increment of five. Figure <ref type="figure" target="#fig_11">9</ref>   NEkNN and VDkNN, a larger search area has to be processed in order to retrieve more qualified results when we increase the k value. The performance difference between NEkNN and VDkNN becomes clear when k increases. Such a difference is proportional to the k value if POIs and networks are equally distributed. Apparently, given specific keywords, the cost of the keyword match process of NEkNN and VDkNN is identical. Therefore, the performance gain of VDkNN queries is from searches on the NVD where VDkNN can retrieve the top k candidates faster than NEkNN. When k increases, the search area is enlarged correspondingly and VDkNN is able to achieve more performance gains in the expanded search region.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>E. Query Range Experiment</head><p>We examine the effect that varying the query range would have on the performance of SKR queries. In the experiments, SKR queries with various query ranges are evaluated in three different cases, which are queries with one (SKR-1), two (SKR-2), and three (SKR-3) keywords. Both Figures <ref type="figure" target="#fig_12">10(a</ref>) and 10(b) illustrate that the execution time of queries grows exponentially with increasing query range. This is because the search area expands equally in all directions.</p><p>Interestingly, the execution time of the queries on real data sets are very close. Two factors mainly affect SKR. The first one is the number of POIs involved in the keyword match step. More POIs will be processed if more keywords are given. Furthermore, POIs that are fully keyword-matched are qualified candidates in SKR and a large number of partially keyword-matched POIs are filtered out by KCF. Consequently, fewer candidate POIs need to be processed in the range search phase. The two factors offset each other in range queries with relatively small search distances and data sets. However, when large amounts of POIs are searched with SKR, the overhead of the keyword match process becomes dominant in execution  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>F. Page Access Experiment</head><p>Finally, we evaluate the number of page accesses by our proposed solutions. In these tests, we mainly focus on the comparison of NEkNN and VDkNN queries. Given a specific query, both solutions have the keyword match process. An identical number of keywords are retrieved from data sets. In addition, the POIs detected by NEkNN are required to be processed in VDkNN as well, and vice versa. The only difference is that NEkNN searches on spatial networks, whereas VDkNN explores on NVDs. Therefore, we evaluate the page access regarding network retrieval in these experiments. The page size is set to be 4 KB. The size of intersections or border nodes is 20 Bytes, containing their identifiers and coordinates. The road segments have a size of 20 Bytes as well, encompassing their identifiers, the identifiers of two endpoints, and the length of the road segment. A single page can accommodate either 200 nodes or road segments. The nodes and segments are stored continuously in pages. During a query process, each page is loaded only once.</p><p>Figure <ref type="figure" target="#fig_13">11</ref>(a) and Figure <ref type="figure" target="#fig_13">11</ref>(b) display the number of page accesses of NEkNN and VDkNN queries in real-world and synthetic data sets, respectively. The trend shared by the two figures is that as the data set size grows, the number of page accesses decreases in NEkNN, whereas it increases in VDkNN. The main reason is that NEkNN searches in a smaller area for qualified results in a larger dataset. Fewer intersections and road segments are retrieved by NEkNN. On the other hand, NVD becomes more complex when more border nodes and connections between borders are generated. Therefore, more page access is required in VDkNN with a larger POI data set. VI. CONCLUSION Geographic information systems are becoming increasingly sophisticated, and spatial keyword search represents an important class of queries. Most existing solutions for evaluating spatial keyword queries are based on Euclidean distance and cannot provide partially matched results. In this research, we introduce efficient techniques to answer spatial keyword k nearest neighbor and spatial keyword range queries on spatial networks. We demonstrate the excellent performance of the proposed algorithms through extensive simulations.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. A sample spatial network of hotels close to an airport.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 2 .</head><label>2</label><figDesc>Fig.2. An example spatial network.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>(a) Ordinary VD. (b) Network VD.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. Voronoi diagram examples.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>10) is called the Voronoi diagram generated by P . Figure 3(a) demonstrates a Voronoi diagram in the Euclidean plane.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig. 4 .</head><label>4</label><figDesc>Fig. 4. Framework of the proposed system.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig. 5 .</head><label>5</label><figDesc>Fig. 5. An example of KeywordMatch.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Fig. 6 .</head><label>6</label><figDesc>Fig. 6. A VDkNN query example.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Fig. 7 .</head><label>7</label><figDesc>Fig. 7. Execution time over data set size.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Fig. 8 .</head><label>8</label><figDesc>Fig. 8. Execution time over keyword number.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Fig. 9 .</head><label>9</label><figDesc>Fig. 9. Execution time over k.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Fig. 10 .</head><label>10</label><figDesc>Fig. 10. Execution time over query range.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Fig. 11 .</head><label>11</label><figDesc>Fig. 11. Page Access over data set size.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>TABLE I A</head><label>I</label><figDesc>sample data set of hotels.</figDesc><table><row><cell cols="3">Name Dn(q, .) Amenities</cell></row><row><cell>H1</cell><cell>3</cell><cell>Internet, Fitness Center, Pets Allowed,</cell></row><row><cell></cell><cell></cell><cell>Parking</cell></row><row><cell>H2</cell><cell>8</cell><cell>Pool, Parking, Room Service</cell></row><row><cell>H3</cell><cell>13</cell><cell>Internet, Fitness Center, Pets Allowed,</cell></row><row><cell></cell><cell></cell><cell>Parking</cell></row><row><cell>H4</cell><cell>10</cell><cell>Parking, Airport Shuttle</cell></row><row><cell>H5</cell><cell>8</cell><cell>Pets Allowed, Breakfast, Hot Tub,</cell></row><row><cell></cell><cell></cell><cell>Restaurant Onsite</cell></row><row><cell>H6</cell><cell>15</cell><cell>Internet, Pets Allowed, Restaurant On-</cell></row><row><cell></cell><cell></cell><cell>site</cell></row><row><cell>H7</cell><cell>8</cell><cell>Fitness Center, Hot Tub, Parking</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>TABLE II Symbolic notations.</head><label>II</label><figDesc></figDesc><table><row><cell cols="2">Symbol Meaning</cell></row><row><cell>P</cell><cell>A set of spatial objects</cell></row><row><cell>Q</cell><cell>A spatial keyword query</cell></row><row><cell>K</cell><cell>A set of search keywords</cell></row><row><cell>q</cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>1 :</head><label>1</label><figDesc>for each term in the input inverted index I do</figDesc><table><row><cell>2:</cell><cell cols="2">if (term ∈ K) then</cell></row><row><cell>3:</cell><cell cols="2">iterator iterA = mergeList.begin</cell></row><row><cell>4:</cell><cell cols="2">iterator iterB = term.idList.begin</cell></row><row><cell>5:</cell><cell>while</cell><cell>(iterA != mergeList.end and iterB !=</cell></row><row><cell></cell><cell cols="2">term.idList.end) do</cell></row><row><cell>6:</cell><cell cols="2">if (iterA.id &gt; iterB.id) then</cell></row><row><cell>7:</cell><cell cols="2">newNode ← {iterB.id, 1}</cell></row><row><cell>8:</cell><cell cols="2">insert newNode at previous position of iterA</cell></row><row><cell>9:</cell><cell cols="2">iterB++</cell></row><row><cell>10:</cell><cell cols="2">else if (iterA.id == iterB.id) then</cell></row><row><cell>11:</cell><cell cols="2">iterA.occurrence += 1</cell></row><row><cell>12:</cell><cell cols="2">iterA++</cell></row><row><cell>13:</cell><cell cols="2">iterB++</cell></row><row><cell>14:</cell><cell>else</cell><cell></cell></row><row><cell>15:</cell><cell cols="2">iterA++</cell></row><row><cell>16:</cell><cell>end if</cell><cell></cell></row><row><cell>17:</cell><cell>end while</cell><cell></cell></row><row><cell>18:</cell><cell cols="2">while (iterB != term.idList.end) do</cell></row><row><cell>19:</cell><cell cols="2">newNode ← {iterB.id, 1}</cell></row><row><cell>20:</cell><cell cols="2">append newNode to the end of mergeList</cell></row><row><cell>21:</cell><cell>iterB++</cell><cell></cell></row><row><cell>22:</cell><cell>end while</cell><cell></cell></row><row><cell>23:</cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head></head><label></label><figDesc>neighboring generators, p 2 , p 5 , p 6 , p 7 , p 8 , p 9 , and p 10 into Q n . Also, E covers NVP(p 1 ). Afterward VDkNN searches the objects in Q n for the next candidate POI. Assume that NVP(p 2 ) is the second explored NVP and both p 1 and p 2 are candidate POIs. Then, R contains p 1 and p 2 , E covers NVP(p 1 ) and NVP(p 2 ) (the shaded region in Figure</figDesc><table><row><cell cols="2">1. mergeList = KeywordMatch(I, K)</cell></row><row><cell cols="2">2. for each object o in mergeList do</cell></row><row><cell>3.</cell><cell>if o.occurrence == |K| then</cell></row><row><cell>4.</cell><cell>C.append(o)</cell></row><row><cell>5.</cell><cell>end if</cell></row><row><cell cols="2">6. end for</cell></row><row><cell cols="2">7. if (|C| != 0 ) then</cell></row><row><cell>8.</cell><cell>R = ShortestPath(q, C)</cell></row><row><cell cols="2">9. end if</cell></row><row><cell cols="2">10. filter out objects beyond r in R</cell></row><row><cell cols="2">11. return R</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>TABLE III</head><label>III</label><figDesc>Default values of parameters.</figDesc><table><row><cell>Parameters</cell><cell>θ1</cell><cell>θ2</cell><cell cols="2">k |K|</cell><cell>r</cell><cell>q</cell></row><row><cell>Value</cell><cell cols="3">0.048 0.952 5</cell><cell>2</cell><cell cols="2">20 km random</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>http://www.edigitalz.com/</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>http://www.census.gov/geo/www/tiger/</p></note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">A</forename><surname>Baeza-Yates</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">A</forename><surname>Ribeiro-Neto</surname></persName>
		</author>
		<title level="m">Modern Information Retrieval -the concepts and technology behind search</title>
		<imprint>
			<publisher>Pearson Education Ltd., Harlow, England</publisher>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
	<note>Second edition</note>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Efficient and Scalable Method for Processing Top-k Spatial Boolean Queries</title>
		<author>
			<persName><forename type="first">A</forename><surname>Cary</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Wolfson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Rishe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SSDBM</title>
		<imprint>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="87" to="95" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Efficient query processing in geographic web search engines</title>
		<author>
			<persName><forename type="first">Y.-Y</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Suel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Markowetz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGMOD Conference</title>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="277" to="288" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Efficient Retrieval of the Top-k Most Relevant Spatial Web Objects</title>
		<author>
			<persName><forename type="first">G</forename><surname>Cong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">S</forename><surname>Jensen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Wu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PVLDB</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="337" to="348" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">A note on two problems in connexion with graphs</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">W</forename><surname>Dijkstra</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Numerische Mathematik</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="269" to="271" />
			<date type="published" when="1959">1959</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Keyword Search on Spatial Databases</title>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">D</forename><surname>Felipe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Hristidis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Rishe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICDE</title>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="656" to="665" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Fibonacci heaps and their uses in improved network optimization algorithms</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">L</forename><surname>Fredman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">E</forename><surname>Tarjan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">34</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="596" to="615" />
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Processing Spatial-Keyword (SK) Queries in Geographic Information Retrieval (GIR) Systems</title>
		<author>
			<persName><forename type="first">R</forename><surname>Hariharan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Hore</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Mehrotra</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SSDBM</title>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page">16</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Distance Indexing on Road Networks</title>
		<author>
			<persName><forename type="first">H</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">L</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">C S</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VLDB</title>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="894" to="905" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Voronoi-Based K Nearest Neighbor Search for Spatial Network Databases</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">R</forename><surname>Kolahdouzan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Shahabi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VLDB</title>
		<imprint>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="840" to="851" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Annatto: Adaptive nearest neighbor queries in travel time networks</title>
		<author>
			<persName><forename type="first">W.-S</forename><surname>Ku</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Zimmermann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Nguyen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">MDM</title>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page">50</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Adaptive nearest neighbor queries in travel time networks</title>
		<author>
			<persName><forename type="first">W.-S</forename><surname>Ku</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Zimmermann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C.-N</forename><surname>Wan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">GIS</title>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="210" to="219" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Introduction to information retrieval</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">D</forename><surname>Manning</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Raghavan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Schütze</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2008">2008</date>
			<publisher>Cambridge University Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Spatial Tessellations: Concepts and Applications of Voronoi Diagrams</title>
		<author>
			<persName><forename type="first">A</forename><surname>Okabe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Boots</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Sugihara</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">N</forename><surname>Chiu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Wiley Series in Probability and Statistics</title>
		<imprint>
			<publisher>John Wiley &amp; Sons, Inc</publisher>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
	<note>2 nd edition</note>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Query Processing in Spatial Network Databases</title>
		<author>
			<persName><forename type="first">D</forename><surname>Papadias</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Mamoulis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Tao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VLDB</title>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="802" to="813" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Top-k spatial keyword queries on road networks</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">B</forename><surname>Rocha-Junior</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Nørvåg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EDBT</title>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="page" from="168" to="179" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Scalable network distance browsing in spatial databases</title>
		<author>
			<persName><forename type="first">H</forename><surname>Samet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Sankaranarayanan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Alborzi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGMOD Conference</title>
		<imprint>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="43" to="54" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Efficient Continuously Moving Top-K Spatial Keyword Query Processing</title>
		<author>
			<persName><forename type="first">D</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">L</forename><surname>Yiu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">S</forename><surname>Jensen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Cong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICDE</title>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Keyword Search in Spatial Databases: Towards Searching by Document</title>
		<author>
			<persName><forename type="first">D</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">M</forename><surname>Chee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Mondal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">K H</forename><surname>Tung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Kitsuregawa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICDE</title>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="688" to="699" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Hybrid Index Structures for Location-based Web Search</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Xie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Gong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W.-Y</forename><surname>Ma</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CIKM</title>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="155" to="162" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Inverted files for text search engines</title>
		<author>
			<persName><forename type="first">J</forename><surname>Zobel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Moffat</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Comput. Surv</title>
		<imprint>
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="issue">2</biblScope>
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Inverted Files Versus Signature Files for Text Indexing</title>
		<author>
			<persName><forename type="first">J</forename><surname>Zobel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Moffat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Ramamohanarao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Database Syst</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="453" to="490" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
