<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">The UNC-method: a problem-based software development method UNC-Method: un método de desarrollo de software basado en problemas</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Carlos</forename><surname>Mario</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Zapata</forename><surname>Jaramillo</surname></persName>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">Ingeniero civil</orgName>
								<orgName type="department" key="dep2">Especialista en Gerencia de Sistemas Informáticos</orgName>
								<orgName type="institution">en Sistemas</orgName>
								<address>
									<addrLine>M.Sc</addrLine>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="department">Ph.D., en Ingeniería</orgName>
								<orgName type="institution">Universidad Nacional de Colombia</orgName>
								<address>
									<addrLine>Profesor asociado, Escuela de Sistemas</addrLine>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Fernando</forename><surname>Arango Isaza</surname></persName>
							<affiliation key="aff2">
								<orgName type="department" key="dep1">Facultad de Minas</orgName>
								<orgName type="department" key="dep2">Ingeniero civil</orgName>
								<orgName type="department" key="dep3">en Water Resources Planning and Management</orgName>
								<orgName type="institution" key="instit1">Universidad Nacional de Colombia</orgName>
								<orgName type="institution" key="instit2">Universidad Nacional de Colombia. M.Sc</orgName>
								<orgName type="institution" key="instit3">Colorado State University</orgName>
								<address>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff3">
								<orgName type="department">Ph.D., en Informática</orgName>
								<orgName type="institution">Universidad Politécnica de Valencia</orgName>
								<address>
									<addrLine>España. Profesor asociado</addrLine>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff4">
								<orgName type="department" key="dep1">Escuela de Sistemas</orgName>
								<orgName type="department" key="dep2">Facultad de Minas</orgName>
								<orgName type="institution">Universidad Nacional de Colombia</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">The UNC-method: a problem-based software development method UNC-Method: un método de desarrollo de software basado en problemas</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<note type="submission">Recibido: junio 18 de 2008 Aceptado: marzo 2 de 2009</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.1" ident="GROBID" when="2025-10-14T18:34+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>software development method</term>
					<term>problem</term>
					<term>goal</term>
					<term>problem domain</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Software engineers use development methods to guarantee on-time delivery, keeping to budget and quality in their software applications. There are two kinds of development methods: plan-driven and agile methods. Both of them still have problems; these refer to resolving problems instead of thinking about them, they use informal or semi-formal artefacts and they leave consistency management to the analysts. The UNC-method (a problem-based software development method) is defined in this paper. The UNC-method is currently being developed in the Universidad Nacional de Colombia; it has been used by students from the School of Systems as part of their training in methodological software development during the last five years. The UNC-method is a mixture of well-known artefacts (i.e. UML diagrams and graphical user interfaces) and non-traditional approaches (e.g. causeand-effect diagram, KAOS goal diagrams and pre-conceptual schemas) used in trying to overcome the aforementioned problems. A case study is also used for exemplification purposes.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Introduction</head> <ref type="bibr" target="#b3">Gibbs (1994)</ref> <p>described what happened to software at the end of the 1960s; budgets were insufficient for development and delivery dates were postponed over and over again. Gibbs used the term "Software Crisis" for this situation. As a response, a special NATO committee <ref type="bibr">(Naur and Randell, Eds., 1969</ref>) created Software Engineering which was a disciplined effort aimed at overcoming the said software crisis. Software Engineering's main principle was quite simply to give software development a methodological approach aimed at ensuring software accuracy and quality.</p><p>Software development still has problems forty years later. Despite many software development initiatives coming onto the market, budgets are still over-quoted and delivery dates are still not complied with. However, software engineers are more conscious of this situation nowadays. The use of software development methods has grown throughout the years and people are beginning to use these methods systematically.</p><p>There are two types of software development methods according to <ref type="bibr" target="#b1">Boehm (2002)</ref>: plan-driven and agile methods. Plan-driven methods consist of large sets of documental artefacts intended for carefully modelling a problem's solution by means of a software application. Agile methods try to use software developers' experience for increasing software development speed and quality.</p><p>Both of these approaches consider software development to be a disciplined and documented effort in the search for better, on-time and within-budget delivered software applications. Both of them share common problems:</p><p>-They employ solution-based artefacts instead of problem-based artefacts. This means that software engineers must conceive a solution before using the required artefacts. The solution results from a careful analysis of the problem; software development methods do not help to conceive the solution; -They use informal or semi-formal modelling languages. When formalisms are absent from a software specification, problems regarding ambiguity arise; and -They exhibit consistency problems. These methods do not usually define rules for consistency checking and, consequently, they leave consistency management to the analysts. This paper defines the UNC-method (a special software development method for analysing a problem) in an attempt to alleviate some of the problems mentioned above; it is linked to organisational goals and a solution is then proposed for it. The UNC-method is slightly different from previous development methods in the sense that it helps analysts to determine a solution to a problem, according to how such problem has been analysed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Software development methods: the state-ofthe-art</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Plan-driven methods</head><p>Plan-driven methods are suitable for large-scale projects; they use documentation artefacts for every aspect of the solution. The artefacts can be UML models, conceptual schemas, tables and informal stories. The purpose is to discuss, model, exemplify and specify the stakeholder's needs and expectations before starting to prepare the code. Plan-driven methods commonly use a waterfall model and they define a set of deliverables to be validated by the stakeholders when every phase of the waterfall model has been concluded. Two of the most used plan-driven methods are Oracle Corporation's Custom Development Method <ref type="bibr">(CDM, 2000)</ref> and Rational Unified Process (RUP) <ref type="bibr" target="#b7">(Kruchten, 1999)</ref>, a UML-based software development method.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>CDM:</head><p>Besides developing different tools for database management, Oracle <ref type="bibr">Corporation (2000)</ref> has created CDM, a development method based on applying its own tools and diagrams. CDM was designed for modelling software applications during every phase of the software development lifecycle; these phases include defining, analysing, designing, building, transition and production. The models used by CDM are grouped into tasks and tasks are grouped into processes. Every process belongs to a particular development phase and it is reported by using a special document called "deliverable." CDM has exhaustive documentation and every deliverable has defined standards. CDM is suitable for largescale data-oriented software projects. Figure <ref type="figure" target="#fig_0">1</ref> shows the complete CDM method; rows are processes and columns are phases in this Figure . Though the amount of documentation required depends on the size of the project, the deliverables commonly contain too much information and they constantly need stakeholder validation. These deliverables' validation is sometimes difficult to achieve and the reason is that stakeholders do not know what technical languages deliverables are written in.</p><p>The first CDM model is the process diagram, a model describing the functions of the organisation when the software is being implemented. The use of this diagram represents a contradiction for software development; it tries to represent the solution and the solution is not completely defined during the first phases of software development.</p><p>RUP: Unified modelling language (UML) <ref type="bibr" target="#b8">(OMG, 2008)</ref> was born in the mid-1990s and is considered the de-facto standard for software modelling; RUP was created at the same time <ref type="bibr" target="#b7">(Kruchten, 1999)</ref>. RUP consists of UML diagrams for modelling the solution to a problem throughout the software development life-cycle. RUP is also a documentation-based software development method and it has been declared to be iterative and incremental. Differing from CDM, RUP is based on UML (the standard modelling language adopted by OMG). RUP's starting point is the elicitation process which uses case diagrams. An analyst must build a complete set of UML-based artefacts from these diagrams to iteratively refine the software application.</p><p>Figure <ref type="figure">2</ref> shows RUP architecture. Rows represent flows of processes and columns represent phases (inception, elaboration, construction and transition) and iterations throughout the process.</p><p>Use cases are, again, descriptions of the solution to a problem by means of information systems and the solution result from a careful analysis of the available information concerning the problem.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Agile methods</head><p>The most common agile methods for software development are suitable for low-to-medium size projects. Agile methods rely on the programmers' experience for making software having the required quality. Programmers work together with stakeholders on this task. Agile methods use an iterative approach, with few artefacts for software modelling. Two of the most used agile methods are extreme programming (XP) <ref type="bibr" target="#b0">(Beck, 2000)</ref> and feature-driven development (FDD) <ref type="bibr" target="#b2">(Coad et al., 1999)</ref>.</p><p>XP: XP was created by <ref type="bibr" target="#b0">Beck (2000)</ref> as an alternative method to plan-driven methods. Software development in XP is completed by means of establishing a close relationship between programmers, stakeholders (called "customers" in this method) and managers.</p><p>The documentation required for developing software is restricted to comments (added to the source code) and user stories. User stories are short descriptions of the system's behavior from the system user's point of view. User stories are descriptions of the solution and must be jointly developed by the programmers and the stakeholders. Figure <ref type="figure">3</ref> shows the XP circle of life which is the process followed by programmers and customers in a successful XP project; the actors' duties are defined in this Figure . It should be noted that the process is conducted by a special dialogue; stakeholders express their needs through user stories and developers exhibit results by means of prototypes. User stories need stakeholders who know the solution's domain and this kind of stakeholder is difficult to find, given that they need technical knowledge about software development.</p><p>FDD: FDD <ref type="bibr" target="#b2">(Coad et al., 1999)</ref> is a software development method based on software features. FDD has a lower documentation level than plan-driven methods. This method also needs experienced analysts and programmers for establishing future software functionality with the help of stakeholders. Figure <ref type="figure">4</ref> presents the typical phases of an FDD project. FDD is also an iterative method but it only covers a software development life cycle's design and building phases.</p><p>The first FDD phase (developing an overall model) must be made by the stakeholders. A description of the model in terms of use cases or functional specs is required during this phase. Such descriptions can only be made by stakeholders having profound knowledge of modelling languages, and this kind of stakeholder is difficult to find. -Software development methods use informal or semi-formal modelling languages. Use cases and process diagrams are semi-formal diagrams and user stories and functional specifications are informal artefacts. Lack of formalism leads to problems of ambiguity, in turn leading to difficulties in translating specifications to code.</p><p>-Software development methods exhibit consistency problems; these methods do not usually define precise rules for consistency-betweenartefacts and they leave consistency management to the analysts.</p><p>-Agile methods require highly-experienced programmers and documentation is located within the software.</p><p>-Plan-driven methods are documentation-extensive, recommended for large-scale projects, but is not suitable for intermediate or small-scale projects.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>UNC-method artefacts</head><p>The UNC-method (Universidad Nacional de Colombia -software development method) tries to surpass the disadvantages listed above for plan-based and agile software development methods. UNC-method is a combination of artefacts aimed at implementing a smooth transition from the organisational context (in which software takes place) to the formal specification of the conceptual schema. The UNC-method has four phases: software context, problem analysis, solution proposals and conceptual schema.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Software context</head><p>The first step towards achieving agreement between analysts and stakeholders lies in selecting a common vocabulary. The UNCmethod employs pre-conceptual schemas <ref type="bibr">(Zapata et al., 2006)</ref> and domain models <ref type="bibr">(Larman, 2002)</ref> to establish this common ground. Differing from traditional software development methods, the UNC-method begins the use of its phases with a detailed description of the problem domain. We do not need to know a thing about the solution but we do need to carefully represent the organisational domain in which stakeholders are completing functions and processes to begin using the method.</p><p>A pre-conceptual schema <ref type="bibr">(Zapata et al., 2006)</ref> is a representation of concepts, relationships, conditionals and implications of the real world in a graphical controlled language. Pre-conceptual schemas must be constructed by analysts with the help and validation provided by stakeholders. A domain model <ref type="bibr">(Larman, 2002)</ref> shows a set of meaningful conceptual classes, their attributes and associations with each other. According to Larman ( <ref type="formula">2002</ref>), a domain model inspires designing the objects in a future software application and is intended to be developed by analysts. Both diagrams are complementary and are helpful for the analyst to understand and capture the domain vocabulary.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Problem analysis</head><p>Whilst analysts and stakeholders have a common ground for expressing their ideas, the UNC-method uses diagrams to express an organisation's goals, processes and problems.</p><p>Goals are organised in a hierarchical structure, ranging from highlevel organisational goals to low-level software goals (represented by software requirements and stakeholder expectations). These goals are presented in a goal diagram <ref type="bibr">(Lamsweerde, 2000)</ref>.</p><p>Organisational processes are depicted in a process diagram <ref type="bibr">(ORACLE, 2000)</ref>, the first of the CDM diagrams; the UNC-method has a special version of the process diagram, just belonging to a description of the stakeholders' functions.</p><p>Organisational analysis provides the fishbone chart <ref type="bibr" target="#b4">(Ishikawa, 1986)</ref>, a special cause-and-effect diagram for establishing an organisation's main problems and relate them to their causes.</p><p>The UNC-method links each of these diagrams by means of a special artefact: the Process Explanatory Table . Analysts can list an organisation's processes, the goals it must achieve and the causes of its problems on this Table . The UNC-method also includes two more artefacts (the Business Rules Table and the Data Dictionary) for representing some of the constraints linked to the process and organisational information structure.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Solution proposals</head><p>One particular problem can have many solutions and some of these solutions can be obtained from information systems. The UNC-method uses three artefacts to represent the set of possible solutions: the process diagram, the use case diagram and the graphical user interface model. The process diagram representing the solution is slightly different from the same one representing organisational processes. The changes are fewer but meaningful; automated processes and stores are represented by means of the same symbols, but the borders are thick-lined. Furthermore, changes in organisational context and functions are also represented in the process diagram. Automated processes lead to the second diagram to represent the solution: the use case diagram <ref type="bibr" target="#b8">(OMG, 2008)</ref>. The actors from a particular organisation are linked (in this diagram) to the functions they will execute when the new software becomes implemented; actors and interactions give a stakeholder a special idea about the software's future functioning. This diagram is commonly explained by means of a use case description, a special chart with the detailed functioning of the use case. The aforementioned description leads to the third of the diagrams for representing the solution: the graphical user interface model. There are formularies and dialogue windows representing (in the future software application) the interactions included in the use case diagram. The UNC-method also defines a tree-based chart for linking graphical user interfaces: the interface navigation chart.</p><p>The artefacts for representing the solution are complemented by appraisal of software value and cost. Software value is estimated by following <ref type="bibr">Zapata and Arango's approach (2004)</ref>. Software cost is valued in terms of use case points <ref type="bibr" target="#b6">(Karner, 1993)</ref>. These estimations are followed by the success of every solution's critical factors which include lists of possible problems occurring when implementing the future software solution.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Conceptual schema</head><p>The final step in the elicitation process is the specification of the solution by means of formal or semi-formal methods. The UNCmethod uses a combination of semi-formal methods (class diagram, communication diagram, state machine diagram and sequence diagram, OMG, 2008) and formal methods (the expression of queries, transactions, derivations, constraints, events and operations, in terms of predicate logic). The graphical user interface model is the artefact selected for linking the use cases presented in the solution to the class diagram drawn up in the conceptual schema. The analyst must specify (in predicate logic) every element of the graphical user interface, for example buttons, text boxes, lists, etc. The specification must be consistent with class diagram elements (classes, attributes, operations and relationships). Actions defined by buttons must be specified in the form of class diagram operations, or transactions of the use case diagram. Derivations are special calculations from class diagram attributes and constraints are special rules covering business rules, software or hardware restrictions, special formulas and many other things expressed by means of different UML diagrams. Several elements have the same specification (operations and transactions, in conjunction with derivations and constraints) and they are woven together by means of UML diagrams.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Case study</head><p>A previous example, reported <ref type="bibr" target="#b5">by Juristo et al., (1999)</ref> was modified from its source to be represented by the UNC-method. A brief description of this example in the controlled UN-Lencep language <ref type="bibr">(Zapata et al., 2006)</ref> would be as follows:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Sales_employee is a kind of vendor Company is a kind of vendor Sales_employee has a base_salary A vendor has a commission</head><p>An order has a number An order has a customer An order has a vendor When a vendor makes a sale, a vendor reports the order When the vendor reports the order, the assistant confirms the order When the assistant confirms the order, the company delivers the order When day=Friday, the company delivers the order    The explanatory process diagram table, the goal diagram and the fishbone chart require additional information to be acquired from the stakeholder. Table <ref type="table" target="#tab_0">1</ref> shows the explanatory process diagram table, Figure <ref type="figure" target="#fig_6">8</ref> shows the goal diagram and Figure <ref type="figure" target="#fig_7">9</ref> shows the fishbone chart. For the sake of simplicity, we can assume that the UN-Lencep discourse about the case study also represents the solution to the problem. In the real world, a solution commonly differs from the domain discourse. Figure <ref type="figure" target="#fig_4">7</ref> processes can be represented by thicklined boxes in such cases. The solution is also represented in the UNC-method by means of use case diagrams (see Figure <ref type="figure" target="#fig_9">10</ref>) and graphical user interfaces (see Figure <ref type="figure" target="#fig_0">11</ref>). Some expressions were added to Figure <ref type="figure" target="#fig_0">11</ref> (in predicate logic) for exemplification purposes.   It should be noted that all the diagrams and artefacts descrybed for the case study are consistent. Some of the artefact consistency rules are given below:</p><p>- -Conditionals in pre-conceptual schemas are represented by guard conditions in communication diagrams and state machine diagrams.</p><p>-The main problem of every fishbone chart must be related to a goal diagram objective.</p><p>Other consistency rules can be consulted in <ref type="bibr">Zapata et al., (2006)</ref>. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Conclusions and future work</head><p>Well-known software development methods exhibit some problems from scratch; the starting point is related to the solution instead of the problem itself and leaves consistency management to analysts who must manually complete consistency analysis. The UNC-method is defined and presented in this paper as an effort to overcome problems related to both plan-driven and agile software development methods.</p><p>The UNC-method uses an analysis of problems and causes and a summary of the organisational goals as a starting point for an informal description of the domain; other methods (like CDM, RUP, XP and FDD) use descriptions of the solution to a problem as a starting point and they do not assist the analyst in obtaining a solution.</p><p>Furthermore, the UNC-method sets out some consistency rules to guarantee that the elements in the discourse will be preserved during the requirement elicitation process and they will be carefully integrated into the different diagrams. We have presented an example of how the UNC-method may be used, as it has been used by students from the Universidad Nacional de Colombia's School of Systems during the last five years. Some of these UNC-method users are currently spreading the main ideas implicit in this method throughout the Colombian software industry since they are useful as a good approach to software requirement elicitation when consistent and refined artefacts are concerned. Some issues still need to be dealt with by analysts for improving the UNC-method. For example:</p><p>-Incorporating metrics into the UNC-method which will be used in the measuring artefact quality; -Developing new processes to be included in the UNC-method. For example, we need a special process for calculating the importance of certain problems within a particular organisation; -Defining the diagrams belonging to design and implementation phases; and -Constructing a special tool for managing all the artefacts and consistency rules involved in the UNC-method. This tool can be engineered to help in creating artefacts and monitoring fulfillment of consistency rules.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 .</head><label>1</label><figDesc>Figure 1. An overview of CDM</figDesc><graphic coords="3,54.36,56.70,318.54,145.38" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 5</head><label>5</label><figDesc>Figure 5 depicts the pre-conceptual schema generated from the above UN-Lencep description.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 5 .</head><label>5</label><figDesc>Figure 5. Pre-conceptual schema for the case study</figDesc><graphic coords="4,319.32,412.62,239.10,164.28" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 6</head><label>6</label><figDesc>Figure 6 shows the domain model automatically obtained from Figure 5's pre-conceptual schema.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 7</head><label>7</label><figDesc>Figure 7 shows the translation of Figure 5 pre-conceptual schema into the process diagram andTable 1 summarises the explanatory process diagram Table.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 6 .Figure 7 .</head><label>67</label><figDesc>Figure 6. Domain model of the pre-conceptual schema shown in Figure 5</figDesc><graphic coords="5,55.14,202.80,236.94,158.28" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 8 .</head><label>8</label><figDesc>Figure 8. Case study goal diagram</figDesc><graphic coords="5,54.36,486.78,377.64,161.70" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 9 .</head><label>9</label><figDesc>Figure 9. Case study fishbone chart</figDesc><graphic coords="5,324.60,57.18,222.24,112.50" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head></head><label></label><figDesc>Concepts in pre-conceptual schemas are represented by stores in the process diagram, classes or attributes in the class diagram, classes of objects or message arguments in the communication diagrams, objects of use cases in the use case diagram and state machine names in state machine diagrams. -Dynamic relationships in pre-conceptual schemas are represented by processes in the process diagram, operations in the class diagram and messages in the communication diagrams. They are also represented by use cases in the use case diagram and states (expressed using the past participle) in state machine diagrams.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 10 .</head><label>10</label><figDesc>Figure 10. Use case diagrams of the case study</figDesc><graphic coords="6,76.38,285.18,217.86,80.22" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 14 .</head><label>14</label><figDesc>Figure 14. Case study state machine diagrams</figDesc><graphic coords="6,355.86,94.44,183.18,94.32" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 .</head><label>1</label><figDesc>Explanatory Process Diagram Table</figDesc><table><row><cell>Process</cell><cell>Goal</cell><cell>Where and how it is used</cell><cell>Problems</cell><cell>Business rules</cell></row><row><cell>Makes a sale</cell><cell>O5 guaranteeing completion of sale</cell><cell>In the company. Every time an agreement occurs</cell><cell>Stock is not available to cover the demand</cell><cell>BR01 the company only sells what it produces</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell>BR02 every</cell></row><row><cell>Reports order</cell><cell>O6 fostering the monitoring of the sales' process</cell><cell>In the company. Every time an agreement occurs</cell><cell>Reporting orders is done by hand</cell><cell>order must be reported so that commissions may be paid</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell>to vendors</cell></row><row><cell></cell><cell></cell><cell></cell><cell>There are</cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell>often</cell><cell></cell></row><row><cell>Confirms order</cell><cell>O5 guaranteeing completion of sale</cell><cell>In the company. Every time an agreement occurs</cell><cell>differences between confirmed orders and products</cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell>to be</cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell>dispatched</cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell>Dispatches</cell><cell></cell></row><row><cell>Delivers orders</cell><cell>O5 guaranteeing completion of sale</cell><cell>Every Friday</cell><cell>are taking longer than they were expected</cell><cell>BR03 all dispatches are made by an external company</cell></row><row><cell></cell><cell></cell><cell></cell><cell>to do</cell><cell></cell></row></table></figure>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Extreme Programming Explained: Embrace Change, Reading</title>
		<author>
			<persName><forename type="first">K</forename><surname>Beck</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2000">2000</date>
			<publisher>Addison-Wesley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Get ready for agile methods</title>
		<author>
			<persName><forename type="first">B</forename><surname>Boehm</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer</title>
		<imprint>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="64" to="69" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
	<note>with care.</note>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<author>
			<persName><forename type="first">P</forename><surname>Coad</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Lefebvre</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>De Luca</surname></persName>
		</author>
		<title level="m">Java Modeling in Color with UML-Enterprise Components and Process</title>
		<meeting><address><addrLine>Upper Saddle River</addrLine></address></meeting>
		<imprint>
			<publisher>Prentice Hall</publisher>
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Software&apos;s chronic crisis</title>
		<author>
			<persName><forename type="first">W</forename><surname>Gibbs</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Scientific American</title>
		<imprint>
			<biblScope unit="page" from="86" to="101" />
			<date type="published" when="1994-09">Sept. 1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Guide to quality control</title>
		<author>
			<persName><forename type="first">K</forename><surname>Ishikawa</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Asian Productivity Organization</title>
		<meeting><address><addrLine>Tokyo</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">A formal approach for generating oo specifications from natural language</title>
		<author>
			<persName><forename type="first">N</forename><surname>Juristo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Morant</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Moreno</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Systems and Software</title>
		<imprint>
			<biblScope unit="volume">48</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="139" to="153" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">G</forename><surname>Karner</surname></persName>
		</author>
		<author>
			<persName><surname>Metrics For Objectory</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1993">1993</date>
			<biblScope unit="volume">9344</biblScope>
		</imprint>
		<respStmt>
			<orgName>University of Linköping, Sweden. No. LiTH-IDA-Ex</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Diploma thesis</note>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Rational Unified Process-An Introduction</title>
		<author>
			<persName><forename type="first">Ph</forename><surname>Kruchten</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999">1999</date>
			<publisher>Addison-Wesley-Longman</publisher>
			<pubPlace>Reading</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<author>
			<persName><surname>Omg</surname></persName>
		</author>
		<ptr target="http://www.omg.org/uml/" />
		<title level="m">UML 2.0 Superestructure Specification</title>
		<imprint>
			<date type="published" when="2008-05">May 2008</date>
		</imprint>
	</monogr>
	<note>last access</note>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Alineación entre Metas Organizacionales y Elicitación de Requisitos del Software</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">M</forename><surname>Zapata</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Arango</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">DYNA</title>
		<imprint>
			<biblScope unit="issue">143</biblScope>
			<biblScope unit="page" from="101" to="110" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<author>
			<persName><forename type="first">P</forename><surname>Naur</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Randell</surname></persName>
		</author>
		<title level="m">Software Engineering: Report of a conference sponsored by the NATO Science Committee</title>
		<meeting><address><addrLine>Garmisch, Germany; Brussels</addrLine></address></meeting>
		<imprint>
			<publisher>NATO</publisher>
			<date type="published" when="1968-10-11">7-11 Oct. 1968. 1969</date>
		</imprint>
	</monogr>
	<note>Scientific Affairs Division</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
