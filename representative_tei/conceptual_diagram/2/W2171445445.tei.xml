<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Pattern-Based Modeling and Analysis of Failsafe Fault-Tolerance in UML *</title>
				<funder>
					<orgName type="full">Michigan State University&apos;s Quality Fund</orgName>
				</funder>
				<funder ref="#_zwdWV9p">
					<orgName type="full">DARPA</orgName>
				</funder>
				<funder ref="#_fX43hNj #_4NBTzBH #_TenMuaV #_ngC8baK #_8wsCqa6 #_2ef6KSB #_8DhEGdX">
					<orgName type="full">National Science Foundation</orgName>
					<orgName type="abbreviated">NSF</orgName>
				</funder>
				<funder>
					<orgName type="full">Siemens Corporate Research</orgName>
				</funder>
				<funder>
					<orgName type="full">Michigan Technological University</orgName>
				</funder>
				<funder ref="#_qcR3cNP">
					<orgName type="full">ONR</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Ali</forename><surname>Ebnenasir</surname></persName>
							<email>aebnenas@mtu.edu</email>
						</author>
						<author>
							<persName><forename type="first">Betty</forename><forename type="middle">H C</forename><surname>Cheng</surname></persName>
							<email>chengb@cse.msu.edu</email>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Michigan Technological University Houghton MI</orgName>
								<address>
									<postCode>49931</postCode>
									<country key="US">U.S.A</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="department">Computer Science and Engineering Department</orgName>
								<orgName type="institution">Michigan State University East</orgName>
								<address>
									<postCode>48824</postCode>
									<settlement>Lansing</settlement>
									<region>MI</region>
									<country key="US">U.S.A</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Pattern-Based Modeling and Analysis of Failsafe Fault-Tolerance in UML *</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.1" ident="GROBID" when="2025-10-14T18:35+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Requirements Analysis</term>
					<term>Fault-Tolerance</term>
					<term>Formal Methods</term>
					<term>Detector</term>
					<term>UML</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>In order to facilitate incremental modeling and analysis of fault-tolerant embedded systems, we introduce an object analysis pattern, called the detector pattern, that provides a reusable strategy for capturing the requirements of failsafe fault-tolerance in an existing conceptual model, where a failsafe system satisfies its safety requirements even when faults occur. We also present a method that (i) uses the detector pattern to help create a behavioral model of a failsafe fault-tolerant system in UML, (ii) generates and model checks formal models of UML state diagrams of the faulttolerant system, and (iii) visualizes the model checking results in terms of the UML diagrams to facilitate model refinement. We demonstrate our analysis method in the context of an industrial automotive application.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>The complexity of developing fault-tolerant systems is, in part, due to the crosscutting and evolving nature of faulttolerance requirements. Since it is difficult to anticipate all types of faults<ref type="foot" target="#foot_0">foot_0</ref> at early stages of development, it is better to have techniques that enable existing analysis artifacts to be revised once a new type of fault is detected. Such a revision would potentially crosscut all components of the conceptual model of an existing system. As such, developers need rigorous techniques and reusable artifacts for adding faulttolerance concerns to conceptual models. This paper introduces a pattern-based approach for adding failsafe faulttolerance to an existing conceptual model (in UML <ref type="bibr" target="#b6">[7]</ref>), where a failsafe fault-tolerant system is expected to meet its safety requirements even when faults occur.</p><p>Numerous approaches exist to support fault-tolerance <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b4">5,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b29">30,</ref><ref type="bibr" target="#b31">32,</ref><ref type="bibr" target="#b32">33]</ref> and to analyze system safety in the presence of failures <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b22">23,</ref><ref type="bibr" target="#b26">27]</ref>, most of which (i) rely on a specific fault-tolerance design/implementation mechanism; (ii) do not emphasize on reuse in analysis phases, and (iii) lack sufficient support for formal analysis of the potential interferences between fault-tolerance and functional concerns. For example, Saridakis <ref type="bibr" target="#b31">[32]</ref> presents a set of design patterns based on existing recovery mechanisms <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b29">30]</ref>. Bondavalli et al. <ref type="bibr" target="#b5">[6]</ref> translate UML structural and behavioral diagrams to Stochastic Petri Nets in order to provide quantitative predictions for system dependability/reliability. <ref type="bibr">Leveson</ref> and Stolzy <ref type="bibr" target="#b26">[27]</ref> present a formal framework based on Timed Petri Nets to model and analyze fault-tolerance in real-time systems. The UML profile for fault-tolerance <ref type="bibr" target="#b0">[1]</ref> and several aspect-oriented approaches <ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b33">34]</ref> use redundancy of services <ref type="bibr" target="#b32">[33]</ref> to mask faults, which is sometimes impractical and costly <ref type="bibr" target="#b1">[2]</ref>. Approaches based on safety cases <ref type="bibr" target="#b22">[23]</ref> present a framework for goal-based failure analysis and systematic specification of lessons and recommendations for post-failure corrections of safety-critical systems. Furthermore, some existing analysis methods for fault-tolerance <ref type="bibr" target="#b21">[22,</ref><ref type="bibr" target="#b30">31]</ref> assume that a specific fault-tolerance design mechanism (e.g., exception handling, redundancy) will be used and specify analysis requirements within those design constraints, which may overly constrain and preclude useful fault-tolerance solutions. (For example, it is difficult to specify and model self-stabilization <ref type="bibr" target="#b8">[9]</ref> solely based on exception handling.) While all aforementioned approaches present useful and important techniques for modeling and analyzing fault-tolerance concerns, three important features distinguish our approach from existing work: (1) providing reusable modeling artifacts for incremental modeling of fault-tolerance; <ref type="bibr" target="#b1">(2)</ref> ensuring the fault-tolerance of the modeling elements added for fault-tolerance purposes, and (3) facilitating automated reasoning (coupled with visualization) in analyzing the mutual impact of fault-tolerance and functional concerns.</p><p>We introduce an object analysis pattern, called the detector pattern, that provides a reusable strategy for eliciting and specifying the requirements of error detection in UML object models for embedded systems. Our focus on capturing error detection requirements is an extension of Arora and Kulkarni's <ref type="bibr" target="#b2">[3]</ref> results where they show that detection is necessary and sufficient for developing a rich class of failsafe fault-tolerant systems. As such, the detector pattern is intended to provide a generic artifact in model-driven development of failsafe systems. Object analysis patterns apply a similar approach to that used by design patterns <ref type="bibr" target="#b18">[19]</ref>, but instead of focusing on design they address the construction of the conceptual model of a system <ref type="bibr" target="#b9">[10]</ref>. Patterns for the analysis stage of software development are not new (see <ref type="bibr" target="#b16">[17,</ref><ref type="bibr" target="#b23">24]</ref>). For example, Fowler <ref type="bibr" target="#b16">[17]</ref> presents a method for characterizing recurring ideas in business modeling as reusable analysis patterns. Konrad et al. <ref type="bibr" target="#b23">[24]</ref> present domain-specific object analysis patterns for analyzing the conceptual models of embedded systems. The proposed detector pattern in this paper provides a reusable building block for the construction of the conceptual models of failsafe systems.</p><p>Our pattern-based method comprises fault modeling, fault-tolerance modeling, and automated analysis of the UML models of fault-tolerant embedded systems. Specifically, to construct the UML model of a Fault-Tolerant System (FTS), we start with the UML model of its faultintolerant version, where a Fault-Intolerant System (FIS) meets its functional requirements in the absence of faults (i.e., when no faults occur) and provides no guarantees in the presence of faults (i.e., when faults occur). Then we model faults in the UML model of the FIS to produce a model with faults. We use the notion of state perturbation to model different types of faults in UML state diagrams <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b8">9]</ref>. Next, we specify error states that are reached due to the occurrence of faults. Subsequently, we add instances of the detector pattern to the model with faults to capture the requirements of error detection and to generate a candidate UML model of a failsafe FTS. To create a valid UML model of the failsafe FTS, we have to ensure that the candidate UML model is interference-free. That is, in the absence of faults, the candidate model meets all functional requirements of the FIS, and in the presence of faults, the candidate model at least meets the safety requirements of the FIS and the instances of the detector pattern. To ensure interferencefreedom, we extend McUmber and Cheng's formalization framework <ref type="bibr" target="#b27">[28]</ref> to generate formal specifications of faults, fault-tolerance and functional concerns in the Promela modeling language <ref type="bibr" target="#b20">[21]</ref>. Subsequently, we use the Spin model checker <ref type="bibr" target="#b20">[21]</ref> to detect inconsistencies between the detector pattern instances and the functional model of the FIS. The automated analysis with the Spin model checker coupled with a new visualization tool, called Theseus <ref type="bibr" target="#b19">[20]</ref>, that animates counterexample traces enables a roundtrip engineering process for modeling and analyzing failsafe FTSs.</p><p>We demonstrate our approach by modeling and analyzing an adaptive cruise control (ACC) system in UML. We have also validated our approach for several other examples from industry <ref type="bibr" target="#b11">[12]</ref>, including a diesel filter system for reducing soot from diesel truck exhaust. The remainder of this paper is organized as follows. Section 2 introduces an approach to modeling faults in UML state diagrams. Section 3 discusses the relation between failsafe fault-tolerance and error detection. Section 4 presents the detector pattern. Section 5 focuses on formal analysis of UML models of FTSs using Spin <ref type="bibr" target="#b20">[21]</ref>. Finally, Section 6 gives concluding remarks and discusses future work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Modeling</head><p>In this section, we present the basic concepts of modeling FISs, faults, and failsafe fault-tolerance in UML. We reiterate the definitions of faults and fault-tolerance from <ref type="bibr" target="#b1">[2]</ref>. The motivation behind using UML is two-fold. First, UML is the de facto standard for object-oriented modeling. Second, UML state diagrams enable us to capture any form of fault-tolerance that can be expressed in a state machinebased formalism.</p><p>UML Models.</p><p>We use conventional UML notations <ref type="bibr" target="#b6">[7]</ref> to represent the UML-based conceptual models of FISs (respectively, FTSs). Since our focus is on modeling and analyzing fault-tolerant embedded systems, we follow Douglass <ref type="bibr" target="#b9">[10]</ref> in using UML class diagrams to model structural constraints of (software and hardware components of) embedded systems during the object analysis phase. We use state diagrams to capture high-level behavioral information of UML object models. The combination of class and state diagrams yields an object analysis model.</p><p>Depending on the semantics of object interactions, the complexity of automatic analysis of a FTS varies from polynomial (in a shared memory model <ref type="bibr" target="#b24">[25]</ref>) to undecidable (in an asynchronous message-passing model <ref type="bibr" target="#b15">[16]</ref>). To facilitate an automated analysis method with a manageable complexity, in this paper, we consider a high atomicity model where transitions of UML state diagrams are executed atomically, and any instance of message passing between two objects takes place in an atomic step. Another motivation behind this assumption is that modeling fault-tolerance in a high atomicity model provides an impossibility test in early stages of development (which could potentially reduce development costs). That is, if a conceptual model of an FTS cannot be derived from the conceptual model of its faultintolerant version in the high atomicity model, then it would be impossible to derive a model of the FTS in a lower atomicity level. <ref type="foot" target="#foot_1">3</ref>Underlying Computational Model. In an UML ob- </p><formula xml:id="formula_0">ject model M = O 1 , • • • , O n , where each O i (1 ≤ i ≤ n) is an object, we denote the state transition diagram of each object O i by SD i = &lt; S i , δ i &gt;,</formula><formula xml:id="formula_1">(i.e., S i ). A computa- tion of an object O j (1 ≤ j ≤ n) is a sequence s 0 , s 1 , • • • such that ∀s i : i ≥ 0 : (s i ∈ S j ) ∧ (s i , s i+1 ) ∈ δ j . A com- putation of an UML object model M = O 1 , • • • , O n is a sequence of states s 0 , s 1 , • • • , where ∀s i : i ≥ 0 : (∃O j : 1 ≤ j ≤ n : (s i ∈ S j ) ∧ ((s i , s i+1 ) ∈ δ j )).</formula><p>Modeling Functional Requirements. We consider the set of functional requirements as a conjunction of a set of safety requirements and a set of liveness requirements. Intuitively, safety requirements stipulate that nothing bad ever happens, and the liveness requirements specify that something good will eventually occur in a finite amount of time. For example, in a cruise control system, the actual speed of the car must not exceed 1% of the desired speed set by the driver (i.e., safety), and when the driver applies the brakes, the cruise control system will eventually be deactivated (i.e., liveness). We represent safety requirements by a set of transitions, say B, that must not occur in the computations of any object. We do not explicitly specify liveness requirements, instead, since we want to derive a model of an FTS from a valid model of its faultintolerant version, we stipulate that during such transformations no deadlock states (states with no outgoing transitions) should be introduced in the absence of faults. The deadlock freedom requirement captures the fact that, in the absence of faults, fault-tolerant embedded systems have nonterminating computations and always react to their environment. We say a computation s</p><formula xml:id="formula_2">0 , s 1 , • • • meets safety re- quirements iff (if and only if) ∀i : i ≥ 0 : (s i , s i+1 ) / ∈ B. A computation σ = s 0 , s 1 , • • • meets functional require- ments if</formula><p>and only if σ meets safety requirements and does not deadlock. A computation of an UML model M that meets the functional requirements of M is a formal representation of a functional scenario.</p><p>Running Example: Adaptive Cruise Control (ACC). The ACC system comprises a standard cruise control system and a radar system to control the distance between the car and the front vehicle, called the target vehicle. The ACC system has different modes of operation (see Figure <ref type="figure" target="#fig_0">1</ref>), namely closing, coasting and matching. When the radar detects a target vehicle, the ACC system enters the closing mode. In the closing mode, the goal is to control the way that the car approaches the target vehicle, and to keep the car in a fixed trail distance from the target vehicle with a zero relative speed. The trail distance is the distance that the target vehicle travels in a fixed amount of time (e.g., 2 seconds). The distance to the target vehicle must not be less than a safety zone, which is 90% of the trail distance. The ACC system calculates a coasting distance that is the distance at which the car should start decelerating in order to achieve the trail distance; i.e., the car enters the coasting zone. When the car reaches the trail distance, the relative speed of the car should be zero; i.e., the ACC system is in the matching mode. The safety requirements of the ACC system state that the car is never in the safety zone and it will never accelerate in the coasting or matching modes. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Modeling Faults in State Diagrams</head><p>We systematically model a fault-type as a set of transitions in UML state diagrams (see Figure <ref type="figure" target="#fig_1">2</ref>). Representing faults as a set of transitions has already appeared in previous work <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b8">9]</ref>, and it is known that state perturbation is sufficiently expressive to represent different types of faults, such as crash, input-corruption and Byzantine, from different behavioral categories; i.e., transient, intermittent, permanent <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b8">9]</ref>. To model a fault-type f in a UML model</p><formula xml:id="formula_3">M = O 1 , • • • , O n ,</formula><p>we model the effect of f on the state diagram SD i of each object O i by introducing a new set of transitions in SD i denoted f i , for 1 ≤ i ≤ n (see dashed arrows in Figure <ref type="figure" target="#fig_1">2</ref>). We denote the set of transitions of SD i in the presence of faults f i by δ i ∪ f i . An object O i does not have control over the execution of faults f i , whereas the execution of regular transitions is controlled by the thread of execution in O i (see solid arrows in Figure <ref type="figure" target="#fig_1">2</ref>). Modeling a fault-type f in all state diagrams of the UML model M creates a model with faults f . In a computation with faults s 0 , s 1 , • • • , there exists a fault transition (s i , s i+1 ), for some i ≥ 0. A computation with faults is a formal representation of a scenario with faults.</p><formula xml:id="formula_4">State1 State2 State4 State3 ErrorState_1 ErrorState_2 ErrorState_3 ErrorState_5 ErrorState_4</formula><p>Object transitions Transitions of fault-type</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Legend:</head><p>Object transitions in the fault-span f i When modeling a fault type f i in a state diagram SD i of the UML model of the FIS, modelers should identify the effect of f i on the behavior of O i . In the absence of faults, an object O i of the FIS is in a set of normal states from where it meets its functional requirements. When f i occurs, O i may reach error states that are outside of the set of normal states. The set of states reachable from the normal states by a combination of fault and regular transitions is the faultspan of O i for fault f i , denoted f i -span of O i <ref type="bibr" target="#b24">[25]</ref>. For example, in Figure <ref type="figure" target="#fig_1">2</ref>, all error states are only reachable when faults occur. Thus, modeling faults in a state diagram may introduce new states and transitions in that state diagram. A computation of an object that in its fault-span outside the set of normal states may lead to a failure scenario in which it may (i) violate safety requirements, (ii) fall into non-progress cycles, or (iii) reach a deadlock state. For example, in Figure <ref type="figure" target="#fig_1">2</ref>, if the object is in State1 then the faults f i may non-deterministically transition to ErrorState 1 from where the object may either be trapped in a non-progress cycle (comprising ErrorState 1 and ErrorState 2) or be deadlocked in ErrorState 5. Since manual identification of f ispan is a tedious task, we use our previously develop Fault-Tolerance Synthesizer (FTSyn) <ref type="bibr" target="#b12">[13]</ref> to automatically generate the fault-span.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Fault-Span</head><note type="other">Normal_States</note><p>ACC Example: The object model of the ACC system includes three main objects, namely Control, Car and Radar (see Figure <ref type="figure" target="#fig_4">5</ref>). (We use Sans Serif font to denote system variables, objects and states.) The Control object captures the controlling activities that set the mode of the ACC system. The Car object models the engine management functionalities such as acceleration and deceleration. The Radar object samples the speed and the distance of the car to the target vehicle. Figure <ref type="figure" target="#fig_2">3</ref>   </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Failsafe Fault-Tolerance</head><p>Intuitively, failsafe fault-tolerance requires that nothing bad ever happens even in the presence of faults <ref type="bibr" target="#b1">[2]</ref>. For a fault-type f and a UML model M of an FIS that is subject to f , we want to derive a UML model M from M such that M satisfies the following conditions: (1) in the absence of f , the set of computations of M is non-empty and is a subset of the set of computations of M , and (2) all computations of M , including the set of computations with faults f , meet safety requirements.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Necessity and Sufficiency of Detection</head><p>In this section, we intuitively explain the relation between error detection in the presence of faults and failsafe fault-tolerance. Specifically, to preserve safety requirements even if faults occur, a failsafe fault-tolerant system should ensure that none of its computations would reach a state from where faults may directly violate safety. Moreover, after faults perturb the state of a failsafe system outside its set of normal states, the system must not execute transitions that violate safety. To enable such functionalities, a failsafe system should be able to detect its current state and take necessary actions that will not lead to the violation of safety requirements. Hence, we define two categories of states that should be detected by a failsafe system, namely fault-unsafe and at-risk states. The set of fault-unsafe states, represented by a state predicate S unsaf e , captures the set of states in the fault-span from where a sequence of fault transitions alone may violate safety requirements. A failsafe FTS must never reach a state in S unsaf e . In the set of at-risk states, denoted as a state predicate S at-risk , a FIS itself may execute actions that violate safety requirements. (FTSyn <ref type="bibr" target="#b12">[13]</ref> automatically identifies these state predicates.) For example, in the ACC system, a global state where the control is in the coasting mode and the car is in the Accelerating state is an at-risk state since the car may accelerate and violate the requirement of no acceleration while coasting. (A soundness proof of the above argument about necessity and sufficiency of detection for failsafe fault-tolerance can be found in <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b24">25]</ref>.)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Detector Pattern</head><p>In this section, we introduce the detector pattern that we use to augment the FIS conceptual model to derive a conceptual model of a failsafe FTS while preserving the safety and liveness requirements of the FIS in the absence of faults. In order to facilitate its use, we define a template for the detector pattern based on the fields used in the design patterns presented by Gamma et al. <ref type="bibr" target="#b18">[19]</ref>, with modifications to reflect analysis-level information. For example, we do not use the Implementation and Sample Code fields. The Structure field captures structural constraints of the detector pattern represented by UML class diagrams. The detector pattern also includes several new fields that are added for the purpose of specifying and analyzing fault-tolerance concerns. For example, the detector pattern includes the Detection Re- quirements field that specifies a set of requirements that must be met by the resulting UML model to guarantee that the detection occurs correctly. Next, we describe the fields of the detector pattern. Example application of each field to the ACC system is denoted in italics.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Detection Predicate.</head><p>In a UML model</p><formula xml:id="formula_5">M = O 1 , • • • , O n ,</formula><p>a detection predicate is a global/local state predicate. In a distributed system, it is difficult for an object to detect a global detection predicate X in an atomic step <ref type="bibr" target="#b28">[29]</ref>. Thus, we decompose X into a set of local predicates X 1 , • • • , X n , and specify the detection of X based on the detection of X 1 , • • • , X n , where each X i is a local state predicate specified for object O i . Since the state predicate S unsaf e captures the local unsafe states of each object, S unsaf e is often specified as a conjunction of a set of local state predicates. For the same reason, S at-risk most often has a conjunctive form. Hence, we limit the scope of the application of the detector pattern to the detection of conjunctive predicates. Moreover, since embedded systems frequently detect the conditions of their underlying physical system, the corresponding conditions remain stable relative to the processing speed of the embedded computing system until the embedded system detects them and takes necessary actions. Hence, in this section, we focus on stable global predicates that once hold remain true until detected.</p><p>ACC Example: In order to preserve safety requirements in the presence of fault f ACC , the ACC system should detect if it is in the coasting or matching mode before accelerating the car. The corresponding detection predicate in the ACC system is the predicate X ACC ≡ X car ∧ X control , where X car ≡ (Car is in the accelerating state) and X control ≡ ((Control is in the coasting mode) ∨ (Control is in the matching mode)). Detector Elements (Participants). A detector element d i , 1 ≤ i ≤ n, captures the detection of a local state predicate X i in a functional object O i . Each detector element d i , for 1 ≤ i ≤ n, is indeed a participant of the detector pattern and has its own detection predicate X i . <ref type="foot" target="#foot_2">4</ref>Distinguished Element. An element</p><formula xml:id="formula_6">d index (1 ≤ index ≤ n) that finalizes the detection of X based on the detection of X 1 , • • • , X n is called the distinguished element.</formula><p>Structure. The choice of the structure of the detector pattern depends on the inter-object associations in a UML object model. For example, if one needs to detect a global predicate over a set of functional objects that are associated with each other in a tree-like structure, then it is appropriate to use an instance of the detector pattern with a hierarchical (parallel) structure. Due to space constraints, we omit the presentation of sequential and compositional detector patterns (see <ref type="bibr" target="#b11">[12]</ref> for details). In a parallel detector (see Figure <ref type="figure" target="#fig_3">4</ref>), the detection of X can be done in parallel, where all elements d i , 1 ≤ i ≤ n, detect their detection predicates concurrently. The shadowed objects represent the elements of the detector pattern encapsulated in a dashed box that denotes an instance of the detector pattern. The distinguished element of the detector pattern is depicted by the dark shading. Each detector participant d i is associated with an object <ref type="figure" target="#fig_3">4</ref>, the distinguished element is associated with all participants d i .</p><formula xml:id="formula_7">O i (1 ≤ i ≤ n). In Figure</formula><p>ACC Example: Figure <ref type="figure" target="#fig_4">5</ref> depicts an excerpted class diagram of the ACC system in which an instance of the parallel detector pattern has been instantiated. Such an instantiation is performed manually as a modeling activity. The instance of the detector pattern applied to the ACC system comprises two elements d control and d car modeled as two new objects in the class diagram of the ACC system. The element d control is responsible for detecting X control and the element d car should detect X car . Witness Predicate. Since we decompose the global detection predicate X into a set of local detection predicates X 1 , • • • , X n , we should specify what implies the truth value of X. Towards this end, we introduce the notion of a witness predicate Z that is a local condition belonging to the distinguished element, which implies that the detection is complete by just communicating with detector elements. We also consider a witness predicate Z i for each element d i . We say d i witnesses X i iff Z i is true. The distinguished element d index sets the value of Z to true if all d i have witnessed their detection predicates. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACC Example:</head><p>The distinguished element should set Z ACC (i.e., the witness predicate) to true if the elements d control and d car witness their detection predicates X control and X car , thus indicating that the global detection predicate X ACC has become true. Such a detection functionality enables the FTS to accelerate only if X ACC does not hold. Detection Requirements. In order to ensure that the detection occurs correctly, the detector pattern should meet the following requirements (adapted from <ref type="bibr" target="#b2">[3]</ref>): (1) Safeness. It is never the case that the witness predicate Z is true when the detection predicate X is false; i.e., the detector pattern never lies. (2) Progress. It is always the case that if X is true then Z will eventually hold. (3) Stability. It is always the case that once Z becomes true, it will remain true as long as predicate X is true (i.e., Z remains stable). Each participant d i should also meet the above requirements for Z i and X i .</p><p>The safeness and stability are safety requirements that can be specified in Linear Temporal Logic (LTL) <ref type="bibr" target="#b14">[15]</ref> using (i) the universal operator 2, where 2Y means that the state predicate Y always holds, and (ii) the next state operator , where Y means that in the next state Y holds. We respectively specify safeness and stability as 2(Z ⇒ X) and 2(Z ⇒ ( (Z ∨¬X))). Using the eventuality operator 3, where 3Y means that the state predicate Y eventually holds, we specify progress as 2(X ⇒ 3Z). <ref type="foot" target="#foot_3">5</ref>Behavior. The state diagram of each detector element d i in Figure <ref type="figure" target="#fig_3">4</ref> is composed with the state diagram of each object O i in a concurrent fashion. The state machine of a detector element d i monitors X i by reading the state of O i . The distinguished element can witness if all the detector participants d i have already witnessed their detection predicates. ACC Example: Before accelerating, the Car object communicates with the distinguished element to check whether the witness predicate Z ACC holds (see Figure <ref type="figure" target="#fig_5">6</ref>). Even though in the case of the ACC system, such detection can also be done by calling a method of the Control object to check its mode, the use of the detector pattern separates the concerns of fault-tolerance from functional concerns and enables developers to easily trace and reason about faulttolerance. Moreover, in cases where more than two objects are involved in the detection of a global predicate, it is difficult to use functional method calls for providing faulttolerance. Failsafe fault-tolerance of the Detector pattern. Since the instances of the detector pattern are also subject to faults, we ensure that the detector pattern is itself failsafe fault-tolerant. To this end, we verify that the composition of the UML model M of an FIS, and an instance of the detector pattern meet the following requirements: <ref type="bibr" target="#b0">(1)</ref> In the absence of faults, the functional requirements of M are met (i.e., safety is not violated and no deadlock is reached), and (2) In the presence of faults, the safeness and the stability of the detector pattern and the safety requirements of M are satisfied. Note that when faults occur, the only requirement for a failsafe FTS is to preserve its safety requirements. Thus, the detector pattern need not meet its progress requirement when faults occur. For example, in the ACC example, if X ACC holds but Z ACC never becomes true, then safety requirements are still met since the Car object never accelerates if Z ACC is false. However, the liveness of the ACC system may be violated. Remark. While the ACC example is small, the number of the elements of an instance of the detector pattern cannot go beyond the number of system components. Moreover, even though composing an instance of the detector pattern with the functional model of an FIS may add a layer of complexity, the modularity provided by the detector pattern facilitates the management of such complexity. (Other patterndriven methods may also suffer from this additional layer of complexity introduced by pattern instantiation.)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Model Analysis</head><p>In order to verify whether composing an instance of the detector pattern with the conceptual model of a FIS generates a valid model of a failsafe system, we extend the Hydra formalization framework <ref type="bibr" target="#b27">[28]</ref> to generate a Promela specification of a candidate UML model of an FTS. Subsequently, we use the Spin model checker <ref type="bibr" target="#b20">[21]</ref> to detect potential inconsistencies between the instances of the detector pattern and the functional model of the FIS. The general UMLto-Promela formalization approach of Hydra is to map objects to processes in Spin that exchange messages via channels. Nested and concurrent states are also formalized as processes. Additional details on the modeling and analysis process, and the underlying formalization framework can be found in <ref type="bibr" target="#b27">[28]</ref>. We use the current Hydra formalization directly to generate Promela specifications of the functional objects of the FIS and each d i element as a separate process.</p><p>We extend Hydra to include a number of new formalization rules that treat the transitions of a fault-type f differently than other transitions. As we distinguish fault transitions from regular transitions by defining a &lt;&lt;Fault&gt;&gt; stereotype <ref type="bibr" target="#b6">[7]</ref>, the extended Hydra integrates the transitions of f modeled in different state diagrams in a separate process Fault f in Promela that is concurrently run with all other processes. Such a formalization is advantageous in that the resulting Promela model separates faults from the functional part of the Promela specifications so that the effect of faults on system behaviors can easily be simulated and analyzed.</p><p>We use Spin to simulate and verify the Promela specifications generated by Hydra. For example, while verifying the UML model of a FTS against detection requirements, we may find counterexamples that represent the inconsistencies of the detector pattern and the functional objects. To analyze such inconsistencies, we use Theseus <ref type="bibr" target="#b19">[20]</ref> to visualize each step of the Spin simulation in UML state diagrams. Such a visualization of counterexamples facilitates the analysis and refinement of the UML models.</p><p>ACC Example: In the UML model of the ACC system, we verified the safeness of the detector pattern to ensure that the detector pattern is itself failsafe f detector -tolerant, where f detector represents the effect of f ACC on d car , which is the resetting of Z car . We specified the safeness requirements as the LTL property 2(Z car ⇒ X car ); i.e., it is always the case that if d car has witnessed then the Car object is in the Accelerating state. A sample counterexample that we found was for the case where d car witnessed that its detection predicate X car holds, but the state of the Car object had been changed to another state without resetting Z car (i.e., X car was no longer true). In this case, the safeness of d car was violated. The Theseus visualization tool highlighted all transitions that leave the Accelerating state of the Car object as the transitions that would violate the safeness of the detector pattern. To remedy this inconsistency, we manually revised the object model so that any transition originating from the Accelerating state would be accompanied with the simultaneous reset of Z car (i.e., Z car := f alse). Notice that, in this case, resolving the inconsistencies of the detector pattern and the functional model required a change in the functional model. We note that this change does not affect the computations of the functional UML model in the absence of faults.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Conclusions and Future Work</head><p>In this paper, we introduced an object analysis pattern, called the detector pattern, for modeling and analyzing failsafe fault-tolerance, where instances of the detector pattern are added to the UML model of a system to create the UML model of its failsafe fault-tolerant version. The detector pattern also provides a set of constraints for verifying the consistency of functional and fault-tolerance requirements and the fault-tolerance of the detector pattern itself. We extended McUmber and Cheng's formalization framework <ref type="bibr" target="#b27">[28]</ref> to generate formal specifications of the UML model of fault-tolerant systems in Promela <ref type="bibr" target="#b20">[21]</ref>. Subsequently, we used the Spin model checker <ref type="bibr" target="#b20">[21]</ref> to detect the inconsistencies between fault-tolerance and functional requirements. To facilitate the automated analysis of failsafe fault-tolerance, we employed the Theseus visualization tool <ref type="bibr" target="#b19">[20]</ref> that animates counterexample traces and generates corresponding diagrams at the UML level. As an extension of this work, we are currently investigating the incorporation of timing issues in the detector pattern.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 .</head><label>1</label><figDesc>Figure 1. The adaptive cruise control system.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 .</head><label>2</label><figDesc>Figure 2. Modeling faults in UML state diagrams.When modeling a fault type f i in a state diagram SD i of the UML model of the FIS, modelers should identify the effect of f i on the behavior of O i . In the absence of faults, an object O i of the FIS is in a set of normal states from where it meets its functional requirements. When f i occurs, O i may reach error states that are outside of the set of normal states. The set of states reachable from the normal states by a combination of fault and regular transitions is the faultspan of O i for fault f i , denoted f i -span of O i<ref type="bibr" target="#b24">[25]</ref>. For example, in Figure2, all error states are only reachable when faults occur. Thus, modeling faults in a state diagram may introduce new states and transitions in that state diagram. A computation of an object that in its fault-span outside the set of normal states may lead to a failure scenario in which it may (i) violate safety requirements, (ii) fall into non-progress cycles, or (iii) reach a deadlock state. For example, in Figure2, if the object is in State1 then the faults f i may non-deterministically transition to ErrorState 1 from where the object may either be trapped in a non-progress cycle (comprising ErrorState 1 and ErrorState 2) or be deadlocked in ErrorState 5. Since manual identification of f ispan is a tedious task, we use our previously develop Fault-Tolerance Synthesizer (FTSyn)<ref type="bibr" target="#b12">[13]</ref> to automatically generate the fault-span.ACC Example: The object model of the ACC system includes three main objects, namely Control, Car and Radar (see Figure5). (We use Sans Serif font to denote system variables, objects and states.) The Control object captures the controlling activities that set the mode of the ACC system. The Car object models the engine management functionalities such as acceleration and deceleration. The</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 .</head><label>3</label><figDesc>Figure 3. Modeling faults in the state transition diagram of the car.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4 .</head><label>4</label><figDesc>Figure 4. The structure of the parallel detector.ACC Example:The distinguished element should set Z ACC (i.e., the witness predicate) to true if the elements d control and d car witness their detection predicates X control and X car , thus indicating that the global detection predicate X ACC has become true. Such a detection functionality enables the FTS to accelerate only if X ACC does not hold. Detection Requirements. In order to ensure that the detection occurs correctly, the detector pattern should meet the following requirements (adapted from<ref type="bibr" target="#b2">[3]</ref>): (1) Safeness. It is never the case that the witness predicate Z is true when the detection predicate X is false; i.e., the detector pattern never lies. (2) Progress. It is always the case that if X is true then Z will eventually hold. (3) Stability. It is always the case that once Z becomes true, it will remain true as long as predicate X is true (i.e., Z remains stable). Each participant d i should also meet the above requirements for Z i and X i .The safeness and stability are safety requirements that can be specified in Linear Temporal Logic (LTL)<ref type="bibr" target="#b14">[15]</ref> using (i) the universal operator 2, where 2Y means that the state predicate Y always holds, and (ii) the next state operator , where Y means that in the next state Y holds. We respectively specify safeness and stability as 2(Z ⇒ X) and 2(Z ⇒ ( (Z ∨¬X))). Using the eventuality operator</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 5 .</head><label>5</label><figDesc>Figure 5. Composition of a parallel detector pattern with the ACC system.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 6 .</head><label>6</label><figDesc>Figure 6. The excerpted state diagram of the Car after applying the parallel detector pattern.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>where S i is the set of states in the state diagram SD i and δ i denotes the set of transitions of SD i . A state of an object O i is a valuation of its state variables (i.e., attributes). A transition of an object O i is of the form (a, evt[grd]/act, b), by which O i transitions from state a to state b if a triggering event evt occurs and a condition grd holds. During such a transition, O i executes an action act. A global state predicate is a Boolean expression defined over a set of states of multiple objects. A local state predicate is a Boolean expression specified over the set of states of only one object O i</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>illustrates an excerpted state diagram of the Car object in the ACC system. The Car object continuously compares the real speed of the car, saved in the variable RealV, with respect to the setpoint, which is the desired speed determined by the driver. If the setpoint is less than the real speed of the car, then the Car object transitions to the Decelerating state. If the setpoint is greater than the real speed of the car, then the Car object transitions to the Accelerating state. The ACC system is subject to a transient fault-type f ACC that causes the Car object to transition to the Accelerating state non-deterministically. Hence, we model the effect of f ACC on the Car object as a set of transitions f car that perturb the state of Car to the Accelerating state. In this case, the fault-type f car does not introduce any new states.</figDesc><table><row><cell>Excerpted state machine</cell><cell></cell><cell></cell><cell></cell></row><row><cell>of the car object</cell><cell cols="2">[RealV = setpoint]/</cell><cell>[RealV &gt; setpoint]/</cell></row><row><cell></cell><cell cols="2">CalculatingRealV</cell><cell>[RealV = setpoint]/</cell></row><row><cell cols="2">[RealV &lt; setpoint]/</cell><cell></cell><cell></cell></row><row><cell>f car</cell><cell>f car</cell><cell>[RealV = setpoint]/</cell><cell></cell></row><row><cell cols="2">Accelerating</cell><cell>f car</cell><cell>Decelerating</cell></row><row><cell>Legend: Event[guard]/action</cell><cell>Event[guard]/action</cell><cell>State</cell><cell>RealV: Real speed of car Setpoint: desired</cell></row><row><cell>Fault transition</cell><cell>System transition</cell><cell></cell><cell>speed set by driver</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_0"><p>A fault-type is a representation of the hypothesized cause of an error. An error is characterized by a (set of) state(s) from where failures may occur. A failure is a behavioral deviation from system specifications<ref type="bibr" target="#b3">[4]</ref>.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_1"><p>A theoretical investigation of this claim can be found in<ref type="bibr" target="#b25">[26]</ref>. Also, in cases such atomicity assumptions do not hold (e.g., distributed systems), one can use existing fault-tolerance-preserving refinements (e.g.,<ref type="bibr" target="#b7">[8]</ref>) to generate a refined model from a high atomicity model developed using our proposed approach.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_2"><p>In the design and implementation phases, the detector elements may be realized as independent software/hardware components that execute concurrently with other components of an embedded system. We conjecture that any additional execution overhead on system performance incurred by adding detector elements would not be worse than the use of conventional redundancy mechanisms.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_3"><p>Note that the detection requirements can also be represented in terms of Dwyer's specification patterns<ref type="bibr" target="#b10">[11]</ref>.</p></note>
		</body>
		<back>

			<div type="funding">
<div><p>* This work was partially sponsored by <rs type="funder">NSF</rs> grants <rs type="grantNumber">EIA-0000433</rs>, <rs type="grantNumber">EIA-0130724</rs>, <rs type="grantNumber">CDA-9700732</rs>, <rs type="grantNumber">CCR-9901017</rs>, <rs type="grantNumber">CNS-0551622</rs>, <rs type="grantNumber">CCF-0541131</rs>, <rs type="funder">NSF</rs> <rs type="grantNumber">CAREER CCR-0092724</rs>, <rs type="funder">ONR</rs> grant <rs type="grantNumber">N00014-011-0744</rs>, <rs type="funder">DARPA</rs> Grant <rs type="grantNumber">OSURS01-C-1901</rs>, <rs type="funder">Siemens Corporate Research</rs>, a grant from the <rs type="funder">Michigan State University's Quality Fund</rs>, and a grant from <rs type="funder">Michigan Technological University</rs>. † The work presented here was performed largely while this author was a postdoctoral researcher at <rs type="institution">Michigan State University</rs> with support from <rs type="funder">NSF</rs> and <rs type="funder">ONR</rs>.</p></div>
			</div>
			<listOrg type="funding">
				<org type="funding" xml:id="_fX43hNj">
					<idno type="grant-number">EIA-0000433</idno>
				</org>
				<org type="funding" xml:id="_4NBTzBH">
					<idno type="grant-number">EIA-0130724</idno>
				</org>
				<org type="funding" xml:id="_TenMuaV">
					<idno type="grant-number">CDA-9700732</idno>
				</org>
				<org type="funding" xml:id="_ngC8baK">
					<idno type="grant-number">CCR-9901017</idno>
				</org>
				<org type="funding" xml:id="_8wsCqa6">
					<idno type="grant-number">CNS-0551622</idno>
				</org>
				<org type="funding" xml:id="_2ef6KSB">
					<idno type="grant-number">CCF-0541131</idno>
				</org>
				<org type="funding" xml:id="_8DhEGdX">
					<idno type="grant-number">CAREER CCR-0092724</idno>
				</org>
				<org type="funding" xml:id="_qcR3cNP">
					<idno type="grant-number">N00014-011-0744</idno>
				</org>
				<org type="funding" xml:id="_zwdWV9p">
					<idno type="grant-number">OSURS01-C-1901</idno>
				</org>
			</listOrg>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">UML profile for modeling quality of service and fault tolerance characteristics and mechanisms</title>
		<ptr target="www.omg.org/docs/ptc/04-06-01.pdf" />
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Closure and convergence: A foundation of fault-tolerant computing</title>
		<author>
			<persName><forename type="first">A</forename><surname>Arora</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">G</forename><surname>Gouda</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Software Engineering</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page" from="1015" to="1027" />
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Detectors and Correctors: A theory of fault-tolerance components</title>
		<author>
			<persName><forename type="first">A</forename><surname>Arora</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">S</forename><surname>Kulkarni</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE International Conference on Distributed Computing Systems (ICDCS)</title>
		<imprint>
			<date type="published" when="1998-05">May 1998</date>
			<biblScope unit="page" from="436" to="443" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Basic concepts and taxonomy of dependable and secure computing</title>
		<author>
			<persName><forename type="first">A</forename><surname>Avizienis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Laprie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Randell</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Landwehr</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Dependable and Secure Computing</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="11" to="33" />
			<date type="published" when="2004-03">January -March 2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">An application of fault-tolerance patterns and coordinated atomic actions to a problem in railway scheduling</title>
		<author>
			<persName><forename type="first">D</forename><surname>Beder</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">R A</forename><surname>Romanovsky</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Snow</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Stroud</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGOPS Operating System Review</title>
		<imprint>
			<biblScope unit="volume">34</biblScope>
			<biblScope unit="issue">4</biblScope>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Automatic dependability analysis for supporting design decisions in UML</title>
		<author>
			<persName><forename type="first">A</forename><surname>Bondavalli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Majzik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Mura</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE International Symposium on High-Assurance Systems Engineering</title>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="64" to="71" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">The Unified Modeling Language User Guide</title>
		<author>
			<persName><forename type="first">G</forename><surname>Booch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Rumbaugh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Jacobson</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999">1999</date>
			<publisher>Addison-Wesley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<author>
			<persName><forename type="first">M</forename><surname>Demirbas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Arora</surname></persName>
		</author>
		<title level="m">Convergence refinement. International Conference on Distributed Computing Systems</title>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="589" to="597" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Self-stabilizing systems in spite of distributed control</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">W</forename><surname>Dijkstra</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">11</biblScope>
			<date type="published" when="1974">1974</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Doing Hard Time: Developing Real-Time Systems with UML, Objects, Frameworks and Patterns</title>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">P</forename><surname>Douglass</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1999">1999</date>
			<publisher>Addison-Wesley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Patterns in property specifications for finite-state verification</title>
		<author>
			<persName><forename type="first">M</forename><surname>Dwyer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Avrunin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Corbett</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 21st International Conference on Software Engineering (ICSE99)</title>
		<meeting>the 21st International Conference on Software Engineering (ICSE99)<address><addrLine>Los Angeles, CA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="411" to="420" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">A framework for modeling and analyzing fault-tolerance</title>
		<author>
			<persName><forename type="first">A</forename><surname>Ebnenasir</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">H C</forename><surname>Cheng</surname></persName>
		</author>
		<idno>MSU- CSE-06-5</idno>
		<imprint>
			<date type="published" when="2006-01">January 2006</date>
			<pubPlace>East Lansing, Michigan</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Computer Science and Engineering, Michigan State University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">FTSyn: A framework for automatic synthesis of fault-tolerance</title>
		<author>
			<persName><forename type="first">A</forename><surname>Ebnenasir</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">S</forename><surname>Kulkarni</surname></persName>
		</author>
		<ptr target="http://www.cs.mtu.edu/aebnenas/research/tools/ftsyn.htm" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">A survey of rollback-recovery protocols in message-passing systems</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">N</forename><surname>Elnozahy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Alvisi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y.-M</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">B</forename><surname>Johnson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Computing Surveys</title>
		<imprint>
			<biblScope unit="volume">34</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="375" to="408" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Handbook of Theoretical Computer Science: Chapter 16</title>
		<author>
			<persName><forename type="first">E</forename><surname>Emerson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Temporal and Modal Logic</title>
		<imprint>
			<publisher>Elsevier Science Publishers B. V</publisher>
			<date type="published" when="1990">1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Impossibility of distributed consensus with one faulty processor</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Fischer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">A</forename><surname>Lynch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">S</forename><surname>Peterson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the ACM</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="373" to="382" />
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Analysis Patterns: Reusable Object Models</title>
		<author>
			<persName><forename type="first">M</forename><surname>Fowler</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1997">1997</date>
			<publisher>Addison-Wesley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">An aspect-based approach to modeling fault-tolerance concerns</title>
		<author>
			<persName><forename type="first">R</forename><surname>France</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Georg</surname></persName>
		</author>
		<idno>02-102</idno>
		<imprint>
			<date type="published" when="2002">2002</date>
		</imprint>
		<respStmt>
			<orgName>Computer Science Department, Colorado State University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">Design Patterns: Elements of Reusable Object-Oriented Software</title>
		<author>
			<persName><forename type="first">E</forename><surname>Gamma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Helm</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Johnson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Vlissides</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1995">1995</date>
			<publisher>Addison-Wesley Publishing Company</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Enabling a roundtrip engineering process for the modeling and analysis of embedded systems</title>
		<author>
			<persName><forename type="first">H</forename><surname>Goldsby</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Konrad</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">H</forename><surname>Cheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Kamdoum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM/IEEE International Conference on Model Driven Engineering Languages and Systems (MODELS)</title>
		<meeting>the ACM/IEEE International Conference on Model Driven Engineering Languages and Systems (MODELS)<address><addrLine>Genova, Italy</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2006-10">October 2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">The model checker SPIN</title>
		<author>
			<persName><forename type="first">G</forename><surname>Holzmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Software Engineering</title>
		<imprint>
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Modeling fault tolerance of transient faults</title>
		<author>
			<persName><forename type="first">D</forename><surname>Ilic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Troubitsyna</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Rigorous Engineering of Fault-Tolerant Systems</title>
		<meeting>Rigorous Engineering of Fault-Tolerant Systems</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="84" to="92" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">A systematic approach to safety case maintenance</title>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">P</forename><surname>Kelly</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Mcdermid</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SAFECOMP</title>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="13" to="26" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Object analysis patterns for embedded systems</title>
		<author>
			<persName><forename type="first">S</forename><surname>Konrad</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">H C</forename><surname>Cheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">A</forename><surname>Campbell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Software Engineering</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="970" to="992" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Automating the addition of fault-tolerance</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">S</forename><surname>Kulkarni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Arora</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 6th International Symposium on Formal Techniques in Real-Time and Fault-Tolerant Systems</title>
		<meeting>the 6th International Symposium on Formal Techniques in Real-Time and Fault-Tolerant Systems</meeting>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="82" to="93" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Enhancing the faulttolerance of nonmasking programs</title>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">S</forename><surname>Kulkarni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Ebnenasir</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 23rd IEEE International Conference on Distributed Computing Systems (ICDCS)</title>
		<meeting>the 23rd IEEE International Conference on Distributed Computing Systems (ICDCS)</meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="441" to="449" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Safety analysis using petri nets</title>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">G</forename><surname>Leveson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">L</forename><surname>Stolzy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Software Engineering</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="386" to="397" />
			<date type="published" when="1987">1987</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">A general framework for formalizing UML with formal languages</title>
		<author>
			<persName><forename type="first">W</forename><surname>Mcumber</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">H C</forename><surname>Cheng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">the proceedings of 23rd International Conference of Software Engineering</title>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="433" to="442" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">On detecting global predicates in distributed computations</title>
		<author>
			<persName><forename type="first">N</forename><surname>Mittal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><forename type="middle">K</forename><surname>Garg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 21st IEEE International Conference on Distributed Computing Systems (ICDCS)</title>
		<meeting>the 21st IEEE International Conference on Distributed Computing Systems (ICDCS)<address><addrLine>Phoenix, Arizona, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2001-04">April 2001</date>
			<biblScope unit="page" from="3" to="10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">System structure for software fault-tolerance</title>
		<author>
			<persName><forename type="first">B</forename><surname>Randall</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Software Engineering</title>
		<imprint>
			<biblScope unit="page" from="220" to="232" />
			<date type="published" when="1975">1975</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<monogr>
		<title level="m" type="main">Exception handling in the development of dependable component-based systems. Software Practice and Experience</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">M F</forename><surname>Rubira</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>De Lemos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">R M</forename><surname>Ferreira</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">C</forename><surname>Filho</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="page" from="195" to="236" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">A system of patterns for fault-tolerance</title>
		<author>
			<persName><forename type="first">T</forename><surname>Saridakis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The 7th European Conference on Pattern Languages of Programs (EuroPLoP)</title>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="535" to="582" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Implementing fault-tolerant services using the state machine approach: A tutorial</title>
		<author>
			<persName><forename type="first">F</forename><forename type="middle">B</forename><surname>Schneider</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Comput. Surv</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="299" to="319" />
			<date type="published" when="1990-12">Dec. 1990</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Uniform support for modeling crosscutting structure</title>
		<author>
			<persName><forename type="first">M</forename><surname>Tkatchenko</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Kiczales</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Appeared in AOM Workshop held in conjunction with AOSD</title>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
