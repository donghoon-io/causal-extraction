<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Automated Prototype Generation from Formal Requirements Model</title>
				<funder ref="#_9uTqaqE">
					<orgName type="full">National Natural Science Foundation of China</orgName>
					<orgName type="abbreviated">NSFC</orgName>
				</funder>
				<funder ref="#_APTPfHm">
					<orgName type="full">University of Macau</orgName>
				</funder>
				<funder ref="#_W6XAv8k">
					<orgName type="full">Macau Science and Technology Development Fund (FDCT)</orgName>
				</funder>
				<funder ref="#_uvem6BQ #_fkDJ64c #_bTVWqyw">
					<orgName type="full">unknown</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability  status="unknown">
					<licence/>
				</availability>
				<date type="published" when="2018-08-31">31 Aug 2018</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Yilong</forename><surname>Yang</surname></persName>
							<affiliation key="aff0">
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Xiaoshan</forename><surname>Li</surname></persName>
							<affiliation key="aff0">
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Zhiming</forename><surname>Liu</surname></persName>
							<affiliation key="aff0">
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Wei</forename><surname>Ke</surname></persName>
							<affiliation key="aff0">
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Quan</forename><surname>Zu</surname></persName>
							<affiliation key="aff0">
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Xiaohong</forename><surname>Chen</surname></persName>
							<affiliation key="aff0">
							</affiliation>
						</author>
						<title level="a" type="main">Automated Prototype Generation from Formal Requirements Model</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2018-08-31">31 Aug 2018</date>
						</imprint>
					</monogr>
					<idno type="arXiv">arXiv:1808.10657v1[cs.SE]</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.1" ident="GROBID" when="2025-10-14T18:33+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Code Generation</term>
					<term>Prototype</term>
					<term>Formal Requirements Model</term>
					<term>Requirement Validation</term>
					<term>Executable Specification</term>
					<term>UML</term>
					<term>OCL</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Prototyping is an effective and efficient way of requirement validation to avoid introducing errors in the early stage of software development. However, manually developing a prototype of a software system requires additional efforts, which would increase the overall cost of software development. In this paper, we present an approach with a developed tool to automatic generation of prototypes from formal requirements models. A requirements model consists of a use case diagram, a conceptual class diagram, use case definitions specified by system sequence diagrams and the contracts of their system operations. A system operation contract is formally specified by a pair of pre-and post-conditions in OCL. We propose a method to decompose a contract into executable parts and non-executable parts. A set of transformation rules is given to decompose the executable part into pre-implemented primitive operations. A non-executable part is usually realized by significant algorithms such as sorting a list, finding the shortest path or domainspecific computation. It can be implemented manually or by using existing code. A CASE tool is developed that provides an interface for developers to develop a program for each non-executable part of a contract, and automatically transforms the executables into sequences of pre-implemented primitive operations. We have conducted four cases studies with over 50 use cases. The experimental result shows that the 93.65% of requirement specifications are executable, and only 6.35% are non-executable such as sorting and event-call, which can be implemented by developers manually or invoking the APIs of advanced algorithms in Java library. The one second generated the prototype of a case study requires approximate nine hours' manual implementation by a skilled programmer. Overall, the result is satisfiable, and the proposed approach with the developed CASE tool can be applied to the software industry for requirements engineering.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>R EQUIREMENTS error is one of the causes leading failings in software projects <ref type="bibr" target="#b0">[1]</ref>. Careful requirements modeling along with systematic validation helps to reduce the uncertainty about target systems <ref type="bibr" target="#b1">[2]</ref>  <ref type="bibr" target="#b2">[3]</ref>. The goal of requirements validation and evolution is to construct the consistent requirements for the needs of target users <ref type="bibr" target="#b3">[4]</ref>. However, this process is complicated, and it can be hard to produce a correct and complete requirements specification. The complexity is due to the following interrelated attributes: 1) the complexity of application domains and business processes; 2) the uncertainty of clients and domain experts about their needs; 3) the lack of the understanding of system developers about application domains; 4) the difficulties of the understanding between system developers and clients <ref type="bibr" target="#b4">[5]</ref>.</p><p>Rapid prototyping is an effective approach to requirements validation and evolution via an executable model of a software system to demonstrate concepts, discover requirements errors and find possible fixing solutions, and discover missing requirements <ref type="bibr" target="#b5">[6]</ref>. Besides the implementation of main system functionalities, a prototype has a User Interface (UI) <ref type="bibr" target="#b6">[7]</ref> that allows the client to validate their requirements visually, make it easy to find out faults in the requirements, and then fix them <ref type="bibr" target="#b7">[8]</ref>. In practice, it is very desirable to have a tool that generates prototypes directly from requirements automatically. However, state-of-the-art research and Computer-Aided Software Engineering (CASE) tools still have long distances to reach the goal <ref type="bibr" target="#b8">[9]</ref>. Unified Modeling Language (UML) is the de facto standard for requirement modeling and system design. Current UML modeling tools, such as Rational Rose, SmartDraw, MagicDraw, Papyrus UML, can only generate skeleton code, where classes only contain attributes and signatures of operations, not their implementations <ref type="bibr" target="#b9">[10]</ref>. Even when design models (e.g., sequence diagrams) are provided, only less than 48% correct source code can be generated <ref type="bibr" target="#b10">[11]</ref> by AndroMDA 1 and MasterCraft <ref type="bibr" target="#b11">[12]</ref> from design models.</p><p>In this paper, we present an approach to automatically prototype generation from a requirements model in UML diagrams complemented by formal contracts of system operations. Compared with other related work, our approach does not require design models but rely on a requirements model <ref type="bibr" target="#b12">[13]</ref>  <ref type="bibr" target="#b13">[14]</ref>  <ref type="bibr" target="#b14">[15]</ref> in Figure <ref type="figure" target="#fig_1">1</ref>, which contains: • A use case diagram: A use case diagram captures domain processes as use cases in terms of interactions between the system and its users. It contains a set of use cases for a system, the actors represented a type of users of the  system or external systems that the system interacts with, the relations between the actors and these use cases, and the relations among the use cases. It helps customers and domain experts specify functional requirements of the target system, and it assists in generating the operation list to hold system operation in prototypes, which is shown in Figure <ref type="figure" target="#fig_5">4</ref>.</p><note type="other">Requirements Model</note><p>• System sequence diagrams. A system sequence diagram describes a particular domain process of a use case. It contains the actors that interact with the system, the system and the system events that the actors generate, their order, and inter-system events. Compared with the sequence diagram, a system sequence diagram treats all systems as a black box and contains system events across the system boundary between actors and systems without object lifelines and internal interactions between objects. It helps customers to find system operations and provides the sequences to interact with the prototype for requirements validation. • Contracts of system operations: The contract of a system operation <ref type="bibr" target="#b15">[16]</ref>  <ref type="bibr" target="#b16">[17]</ref> specifies the conditions that the state of the system is assumed to satisfy before the execution of the system operation, called the pre-condition and the conditions that the system state is required to satisfy after the execution (if it terminated), called the post-condition of the system operation. Typically, the pre-condition specifies the properties of the system state that need to be checked when system operation is to be executed, and the postcondition defines the possible changes that the execution of the system operation is to realize. A state of an objectoriented system is about the existing objects together with their properties/states and relations/links. The state is an object diagram defined by a conceptual class diagram plus the input and returns parameters of the operations. The changes of system states are classified into i) new objects created (together with initial values of attributes and links of associations), ii) attributes of existing objects (in the current state) modified, iii) new links among existing objects formed, and iv) existing objects and/or links are removed. The basic operations of changing the state are defined as the primitive operations in our approach. We will see, the decomposition from system operation into primitive operations is the theoretical foundation of our approach to automatic generation of an abstract and yet executable model from a requirements model.</p><p>• A conceptual class diagram. A conceptual class diagram illustrates abstract and meaningful concepts and their relations in the problem domain, in which the concepts are specified as classes, the relations of the concepts are specified as the associations between the classes, and the properties of the concepts are specified as the attributes of the classes. The proposed approach can directly generate to Java classes that represent domain concepts and encapsulates the primitive operations such as getting and setting the values of attributes, adding and remove links, and finding an object through links in the prototypes.</p><p>The idea of automated prototype generation from a requirements model is presented in our earlier work <ref type="bibr" target="#b17">[18]</ref>  <ref type="bibr" target="#b18">[19]</ref>. There, the feasibility is demonstrated with a small example. In this paper, we extend original methods and propose new algorithms to 1) automated decomposition of the system operations into primitive operations, and encapsulation them into the classes based on object-oriented design patterns <ref type="bibr" target="#b19">[20]</ref> [21] <ref type="bibr" target="#b21">[22]</ref> [23], 2) non-executable analysis of system operation contract, and wrap the non-executable parts of contract into a interface, it further can be implemented by developers and third-party APIs, 3) requirements validation and revolution based on the prototype mechanisms of object state observation and pre-condition and invariant checking. The evaluation result from four case studies shows that our approach can correctly generate 93.65% code from requirements models, the remaining non-executable 6.35% requirements can be recognized and wrapped as an interface, which can be manually implemented or matched with thirdparty APIs libraries.</p><p>The remainder of this paper is organized as follows: Section 2 presents the preliminary of our approach. Section 3 introduces how to decompose a system operation into primitive operations. Section 4 presents how to generate the prototype. Section 5 provides how to use the generated prototype for requirement validation and refinement. Section 6 presents the experiments result of our approach on the four case studies of a Library Management System, CoCoME, ATM and a Loan Processing System. Section 7 and 8 discuss the related work, conclude this paper, and outline the future work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">PRELIMINARY</head><p>In this section, we introduce the terminology used in the requirements model and prototypes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Terminology</head><p>The terminology related to the proposed approach except the terminology introduced in the previous section are listed as follows:</p><p>• Association and link. An association is a relationship between two classes in a conceptual class diagram that specifies how instances of the classes can be linked to work together. A link is an instance of an association, which is a relationship between two objects in an object diagram.</p><p>• Entity class and fabricated class. To indicate the classes are from domain concepts or fabrications in the prototype, we divide classes into two type: entity classes are Java classes generated in prototypes from conceptual class diagrams, the others are fabricated classes. For example, Java class Item is entity class generated from the conceptual class diagram in CoCoME, and Java class EntityManager is a fabricated class that helps to find, create, and release the objects in the system.</p><p>• Object reference and reference list. In object-oriented programming such as Java, the value of a variable which has a type of a class is an object reference, which provides a way to access an object in the heap of a system. A reference list is a list of object references to access objects with the same type of a class. We will see, reference lists are used to record and access the objects of the prototype.</p><p>• System operation. System operation is an operation that the system executes in response to a system input event in system sequence diagrams.</p><p>• Primitive operation. Primitive operations are the operations introduced in our approach to covers all actions to manipulate objects, the attributes of objects, and the links of objects in Table <ref type="table" target="#tab_2">1</ref>. The details are shown in Section 3.1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Object Constraint Language</head><p>Object Constraint Language 2 (OCL) is a part of UML. It is used mainly for specifying constraints of UML diagrams, such as pre and post conditions of operations and invariants. In this paper, we adopt OCL in the latest version v2.4 to specify the contracts of system operations. It not only can specify the pre-condition and post-condition of system operation but also allows to specify shared specifications from pre-condition and post-condition in the definition section. The following example shows how OCL specify the contract Definition Section: In the definition section, we find the object item of the class Item with the attribute Barcode equal to the input variable barcode. We will see that the object item is used in both the pre-and post-conditions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Pre-condition Section:</head><p>The pre-condition of enterItem specifies that the current sale object currentSale is existed, and the value of attribute IsComplete of currentSale is equal to false, the object item with the scanned barcode is existed in the system, and the stock number is greater than zero.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Post-condition Section:</head><p>The post-condition of enterItem specifies that 1) a new object sli of class SalesLineItem was created, 2) the currentSaleLine was linked to the new created object sli, 3) the links among currentSale, sli and item were formed, 4) the attributes Quantity and Subamount of sli were set to the value of input variable quantity and item.Price*quantity, 5) the attribute StockNumber of item was reduced by the number of quantity, 6) the new created object sli was added in the object list SaleLineItem, 7) the output of system operation enterItem() was true.</p><p>Note that system operations may manipulate the same objects in a system sequence diagram of a use case. OCL allows to access the new created object in the same use case. For example, the object currentSale of the class Sale is created by system operation makeNewSale() of the use case processSale. It can be reused in the contract of the system operation enterItem().</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">SYSTEM OPERATION DECOMPOSITION</head><p>In this section, we first present a collection of primitive object-oriented operations and then introduce transformation rules and algorithms that automatically decompose a system operation to primitive operations. Finally, we present an example to show how the transformation rules and algorithms work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Primitive Operations</head><p>Referring to atomic actions for manipulation tables in relational databases, we introduce a collection of primitive object-oriented operations of the object-oriented system for system operation decomposition in Table <ref type="table" target="#tab_2">1</ref>, which covers all  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Objects:</head><p>The following primitive operations are used to manipulate objects. An object or objects can be retrieved through primitive operation findObject() or findObjects() with a class name and a query condition. An object can be created by primitive operation createObject() with a class name, and then the created object can be added to the system through primitive operation addObject() with providing a class name and an object reference ob. Primitive operation releaseObject() can be used to delete an object from the system by providing a class name and an object reference ob.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Attributes of Objects:</head><p>The next two primitive operations are used for getting and setting the value of an attribute.</p><p>Primitive operation getAttribute() can retrieve the value of an attribute of an object by providing an object reference ob and the name of attribute. The value of an attribute of an object can be changed by the primitive operation setAttribute() with an object reference ob, the name attriName of an attribute, and a math expression mathExp.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Links of Objects:</head><p>The links can be used to find the linked objects. Note that we use different primitive operations to manipulate links corresponding with two different types of the association of classes (one-to-one and one-to-many relation). By providing an object reference ob, an association name assoName, and an condition, primitive operations find-LinkedObject() and findLinkedObjects() can retrieve the linked object or objects. An link from object ob to object addOb can be formed by invoking primitive operation addLinkOneto-Many() or addLinkOnetoOne() with the name of the association, and the object reference ob and addOb. Primitive operation removeLinkOnetoMany() or removeLinkOnetoOne() can be used to break the link by providing an object reference ob, and the name of the association assoName. Primitive operation removeLinkOnetoMany() requires providing a reference to the target object removeOb, and the reference indicates which link will be removed from the object.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Transformation Rules</head><p>We have introduced the contract of system operation and primitive operations. In this subsection, we present how to transform an OCL contract to primitive operations. Transformation rules will be presented in this form:</p><p>Rule :</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>OCL Expression Primitive Operation in Java Code</head><p>The transformation rule contains two parts: the above section is an OCL Expression, and the bottom part is a primitive operation in Java code. The transformation rules form OCL expressions and primitive operations as pairs, and those pairs are the foundation of the transformation algorithm for automatic system operation decomposition. In short, we refine the original ten transformation rules in the previous work <ref type="bibr" target="#b17">[18]</ref> [19] to twenty-five transformation rules that cover all the primitive operations corresponding in the contract sections of definition, pre-condition, and post-condition. The difference from our previous work is discussed in the related work section. Follow the convention of OCL contract, we present those transformation rules into three parts: a) definition transformation, b) pre-condition transformation, and c) post-condition transformation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.1">Definition Section Transformation</head><p>The definition section of the contract specifies that the objects are further used in pre-condition and post-condition. In object-oriented system, objects can be reached through the links of objects, which are defined by the associations of the classes. In our approach, we build pure fabricated class En-tityManager (EM) to record all the references of objects in the system. Therefore, objects can be found through EntityManager with a query condition, and then other related objects can be reached through the links of the founded objects. In definition section, seven transformation rules are presented, which involve the primitive operations findObject(), findObjects(), findAssociationObject(), and findAssociationObjects() of Table <ref type="table" target="#tab_2">1</ref>. The rule R 1 shows finding all the objects obs of the class named ClassName in the system. This OCL expression is mapped to the primitive operation findObjects(), and the found objects are assigned to a list reference obs of the class ClassName. Based on rule R 1 , the rules R 2 and R 3 are introduced to find objects obs or an object ob from all the instances of the class named ClassName with the constraints condition(o) by using select or any OCL keywords. condition(o) is a logic formula about object o, which composites atomic formulae of pre-condition with the logical operators and and or. The OCL expressions of R 2 and R 3 are mapped to the primitive operation findObjects() or findObject(), and then assign the found objects or object to a reference list obs or a reference ob of class ClassName.</p><p>For example, when a cashier scans the product by invoking the system operation enterItem(), the system will find the object item with the specific barcode, which has the same value retrieved from the scanner. This part functional semantics are specified in the definition section of contract enterItem(). It will map to the primitive operation findObject() by R 3 as follows:</p><p>item:Item = Item.allInstances()→any(o | i.Barcode = barcode) Item ob = EM.findObject("Item", "i.Barcode = barcode")</p><p>Note that the condition i.Barcode = barcode will be further mapped by R 12 . Once we find the target objects, the related objects can be found through the links of the target objects. Those transformations present in the next four rules: The rules R 4 and R 5 show finding the linked object through ob.assoName, where the association may be one-to-one or one-to-many relationship. If assoName is one-to-one association, ob.assoName will return a object reference o to the object linked with object ob; otherwise ob.assoName returns a reference list obs. Therefore, the OCL expressions of R 4 and R 5 are mapped to primitive operations findLinkedObject() and findLinkedObjects() with the input variables: an object reference ob and an association name assoName of object ob, and then assign the found object or object list to the reference o or reference list obs correspondingly. Based on the rule R 5 , the rules R 6 and R 7 apply OCL expression select and any with a query condition condition(o) to ob.assoName with navigation → to filter the specific objects from the associated objects.</p><p>For example, we find a SaleLineItem object under current sale s with quantity number great than 2. The corresponding OCL contract and R 7 transformation are: sli:SaleLineItem = s.ContainedSaleLine→any(sl | sl.Quantity &gt; 2) SaleLineItem sli = EM.findLinkedObject(s, "ContainedSaleLine", "sl.Quantity &gt; 2")</p><p>The same as the previous example, the condition sl.Quantity &gt; 2 will make a further transformation by rule R 12 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.2">Pre-condition Transformation</head><p>The pre-condition section of the contract specifies the status of the objects before execution of system operation. The related objects have been specified in the definition section of the contract. The pre-condition section specifies the constraints on those objects before execution of system operation. The pre-condition transformation maps those constraints to the primitive operations, which involves get-Attribute() and a set of basic checking operations under the fabricated class StandardOPs. In short, eight transformation rules from R 8 to R 15 are presented in the pre-condition section. The rules R 8 , R 9 , and R 10 map the basic OCL checking expression about object and object list to the primitive operations. The contract of R 8 checks that the reference ob does not refer to an object. The OCL expression of R 9 is used to check that the variable var conforms the specific type, in which the var is a variable of primitive type, an object reference, or a reference list. The contract of R 10 is to check the object list obs is empty. The rules R 11 and R 12 map the logic expression from OCL to Java. The op is an infix comparison operator in OCL. «op» represents the corresponding Java code of op after compilation. Most operators of OCL and Java are the same, except equal operator = and non-equal &lt;&gt; of OCL. Those operators will be compiled to Java operators == and !=. Furthermore, when we compare between two variables s1 and s2 of String type, the above operators will be compiled to Java code s1.equals(s2) and !s1.equals(s2) respectively. The rule R 11 gets the size of list, and then checks the constraint of the list size against a math expression mathExp. The mathExp may contain numbers, variables, operators, functions and brackets. The rule R 12 firstly retrieves the value of the attribute attriName of the object ob by transforming ob.attribute to the primitive operation getAttribute, and checks the constraint on the value of the attribute through the expression op varPM. The varPM is a variable of primitive type or a math expression.</p><p>For example, the pre-condition item.StockNunmber &gt; 0 of contract enterItem. "&gt;" is the op expression. "0" is the varPM expression. This pre-condition will be compiled to Java code item.getStockNumber() &gt; 0 by rule R 12 :</p><p>sl.Quantity &gt; 2 getAttribute(sl, "Quantity") &gt; 2</p><p>The rules R 13 and R 14 use the OCL expression Class-Name.allInstances() of the definition section to find all objects of class ClassName, and to check whether the specific object ob is included in or excluded from the object list. Therefore, ClassName.allInstances() is mapped to EM.findObjects(ClassName), and then the founded object will be passed to the operations includes() or excludes() of the class StandardOPs. The last rule R 15 of precondition section maps the unique detection expression to the operation isUnique() of class StandardOPs. This opeartion will get all the objects of class ClassName, and check the specific attribute AttriName has the unique value or not. Note that 1) OCL expressions of precondition section can also be used to specify the invariants of the system. Therefore, the transformation rules related pre-condition can also apply to the invariants transformation.</p><p>2) The implementation of class StandardOPs is not presented in this paper, the details can be found on the GitHub repository 3 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.3">Post-condition Transformation</head><p>The post-condition section of the contract specifies the status of objects after execution of the operation. Concretely, the post-condition specifies that the object was created, added, and released, the association was formed and broken, the state of attribute was updated. The related primitive operations are createObject(), addObject(), releaseObject(), addOnetoManyAssociation(), addOnetoOneAssociation(), remo-veOnetoManyAssociation(), removeOnetoOneAssociation(), and setAttribute(). Ten transformation rules of the post-condition are presented in post-condition section. The first rule R 16 is The OCL expression let..in of the rule R 16 describes the scope of object ob. The ob.oclIsNew() specifies that the object ob was created after the execution of system operation. In order to make system into this state, the rule R 16 maps let..in and oclIsNew() to the primitive operation createObject(), and then assigns the created object to the reference ob of the class named as ClassName. For example, the post-condition of system operation enterItem() specifies that object sli of class SaleLineItem was created. By applying the rule R 16 , this OCL expressions are mapped to:</p><formula xml:id="formula_0">let sli:SaleLineItem in sli.oclIsNew() SaleLineItem sli = EM.createObject("SaleLineItem")</formula><p>The OCL expression of the rules R 17 and R 18 have already been used in the pre-condition to check whether the instance list of class ClassName includes or excludes the object ob or not. Those OCL expressions in the post-condition indicate that the object list of class ClassName includes and excludes the object ob after the execution of the system operation. It is necessary to add or delete the object ob to or from the object list to make the system status conforming the post-condition. Therefore, the includes() and excludes() with 3. <ref type="url" target="https://github.com/RM2PT/CaseStudies/wiki/StandardOP">https://github.com/RM2PT/CaseStudies/wiki/StandardOP</ref> allInstances() expression in the post-condition are mapped to the primitive operations addOjbect() and releaseObject().</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>SalesLineItem.allInstances()→includes(sli)</head><p>EM.addObject("SalesLineItem", "sli")</p><p>For example, if we apply the rule R 17 to post-condition of system operation enterItem(), the post-condition specifies that the created object sli was included in object list of class SalesLineItem will be mapped to primitive operation addObject() with parameter class name SalesLineItem and object name sli. OCL expression includes and excludes can also be applied for the association ob.assoName. That means the link has been formed or broken after executing the system operation. Therefore, the above rules R 19 and R 20 map those expressions to the primitive operations addLinkOnetoOne() and removeLinkOnetoMany(). The one-to-one association is implemented as an attribute of the class. The rule R 21 describes if the post-condition specifies that the one-to-one association ob.assoName has an linked object addOb. The primitive operation addLinkOn-etoOne() will be executed to make system to satisfy this post-condition. For examples, the links between current sale and the created object SalesLineItem object were formed in following transformations: currentSale.ContainedSalesLine→includes(sli) addLinkOnetoMany(currentSale, "ContainedSalesLine", sli) sli.BelongedSale = currentSale addLinkOnetoOne(sli, "BelongedSale", currentSale)</p><p>Note that the association from class Sale to SalesLineItem is multiple, and the reversed association is a one-to-one association. Therefore, the rule R 19 will be triggered for transformating OCL expression to primitive operation ad-dLinkOneToMany() with an object currentSale, the association name ContainedSalesLine, and the created object sli of class SalesLineItem. The rule R 21 is trigger for transformation OCL expression to primitive operation addLinkOneToOne() with the object reference sli of class SalesLineItem, the association name BelongedSale, and the reference currentSale to current sale object. The rule R 22 presents if the post-condition specifies that one-to-one association ob.assoName has no associated object, the primitive operation removeLinkOnetoOne() will be executed to broke the link that makes the system state conforming this post-condition. The rule R 23 indicates that the attribute of the object ob.attriName is equal to the math expression mathExp in the post-condition. The primitive operation setAttribute should be executed to conform this condition. For example, post-condition of enterItem() specifies the sub-amount of SalesLineItem is computed from the price of the item and the quantity of the item.</p><p>sli.Subamount = item.Price * quantity setAttribute(sli, "Subamount", getAttribute(item, "Price")*quantity)</p><p>This OCL expression is mapped to primitive operations setAttribute() and getAttribute(). Primitive operation getAttribute() is used to get the price of the item, then the price is multiplied with quantity. Finally, the evaluated result is set to the attribute Subamount of object SalesLineItem named sli. We can use forAll to literately specify the state of the objects in the post-condition. The rule R 24 extends the rule R 23 from specifying the state of a single object to a list of objects, that maps the OCL expression forAll to Java for loop expression.</p><p>R 25 : return = var return «var»;</p><p>The rule R 25 specifies the state of return variables after system operation execution. The return variable var can be a variable of prime type, a reference to a instances of class, or to a instance list of class. It will be mapped to the Java code correspondingly.</p><p>R 26 : ThirdPartyServices.opName(vars)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>service.opName(«vars»)</head><p>The rule R 26 is a special transformation rule that specifies the third-party APIs such as cardPayment() and sorting() used in the post-condition. This rule makes our approach extensible to invoking the third-party API library. It will transform the operation opName and parameters vars into the operation invoking in Java code.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Transformation Algorithm</head><p>We have already presented all transformation rules for system operation decomposition. It is time to introduce the transformation algorithm that transforms the contract of system operation into primitive operations. Transformation algorithm is presented in Algorithm 1. It requires an OCL expression and a tag as input parameters, and return the mapped primitive operations. Note that the tag marks which section of the contract OCL expression comes from. The details of transformation algorithm are that initializing the result set rs as empty set and index i to zero, and then parsing input OCLExpression as a set of sub OCL expressions sub-formulas and a set of logic connectors connectors, and using lastn to record the last element of sub-formulas, and iterating each formula s of the sub-formulas set. In each iteration, algorithm initializes num to zero, which indicates whether the appropriate rule is found. According to the value of the tag, different rules are used to check whether the formula s is matched, then assign the match rule number to num if any rule matched the formula s. The formula s will be mapped to primitive operation according to the rule. The transformation result is saved in r. Note that the OCL expression of pre-condition is mapped into primitive operations connected with Java logic expressions. If no rule is matched to the formula s, an error message will be appended to the final result rs with the formula s. The nature of requirements model implies that, in general, a requirements model may contain non-executable elements, because it focuses on what the system should do rather than how it does it. This error message will help to validate the requirements when generating the prototype. In the end of the iteration, i is increased to point to the next sub-formula. After the iteration, the final result rs will be returned.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Transformation Example</head><p>We have already introduced the rules for transformation the contracts of system opeartions to the primitive operations. This subsection will present an example of enterItem() of use case processSale to explain how it work. Note that if a transformation rule is used more than once, we only explain the transformation at the first time. The signature of contract enterItem is compiled to the operation signature in Java.</p><p>In the definition section, the rule R 3 maps the OCL expression to the primitive operation findObject() to find  6) The rule R 25 maps the result expression to the Java return expression. All rules will be repeatedly applied for transforming until all the OCL contract are mapped to the primitive operations with Java code. This section presented the transformation rules and algorithms for system operation decomposition. Next section will introduce how to generate prototype from the requirements model.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">PROTOTYPE</head><p>Graphical User Interface (GUI) is one of the important parts of a prototype for customers and domain experts to validate their requirements. Model-View-Controller (MVC) <ref type="bibr" target="#b23">[24]</ref> is one of the most widely used GUI architecture patterns in decades. In this paper, we apply the MVC architecture pattern to prototype, which decouples views and models to make a clear division between models and GUI elements. The prototype contains three modules: view, controller, and model as shown in Figure <ref type="figure" target="#fig_18">3</ref>. View: The view module of the prototype contains UI widgets for end-users to validate system operations and observe corresponding changes in the system state. It contains two UI panels: system functionality and system state. As an example, the system functionality panel of CoCoME is shown in Figure <ref type="figure" target="#fig_5">4</ref>. It includes the widgets of system operation lists in the left side, and the operation widgets for passing the parameters to system operations and returning the result in the right side. System operation lists are generated from the use case diagram and the system sequence diagram. Moreover, the operation widgets for inputting the parameters of system operations are generated from the signatures of the contracts of system operations.</p><p>The system state panel is used to observe the state of objects of a system before and after executions of system operations. Figure <ref type="figure" target="#fig_19">5</ref>  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Controller:</head><p>The controller module links the view and model modules, which makes UI events to trigger system operations. The controller listens to the events from UI widgets. When a specific event is captured, the controller retrieves the input parameters from the UI widget, and then deliver the parameters to the corresponding system operation in the model module of the prototype. Finally, the controller will update the UI widgets with the return result. For example, when a cashier clicks the execute button on the operation widget of Figure <ref type="figure" target="#fig_5">4</ref>, the controller will capture a button clicked event generated by the UI widget, and then the controller will get the input parameters and then invoke the enterItem() operation. Finally, the controller will update the UI widgets with the return result, and then the cashier will see the result from operation return panel of Figure <ref type="figure" target="#fig_5">4</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Model:</head><p>The model module is the core of the MVC architecture pattern. This module contains 1) the classes encapsulating system operations, which can be invoked by the controller with the parameters from UI widgets, and return the result to the controller for displaying on the view widgets, and 2) the classes generated from the conceptual class model. Note that we name the classes generated from the conceptual class model as entity classes, and the others as fabricated classes. We will show how to generate fabricated and entity classes in the remaining of this section. Fabricated classes encapsulating system operations are generated from a use case diagram, system sequence diagrams, the contracts of system operations through system operation templates in Figure <ref type="figure" target="#fig_20">6</ref>. We already discussed the system operation decomposition in the previous section. To implement the decomposed system operation, we not only need to transform the contracts of system operations into primitive operations through the transformation algorithm and rules but also need to orchestrate them to be a validated system operation like the decomposition example of enter-Item() in Figure <ref type="figure" target="#fig_4">2</ref>. Moreover, the implemented system operations must be encapsulated into classes. In this subsection, we introduce system operation templates to generate the implementations of the system operations from contracts, and how to encapsulate them into classes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Fabricated Class Generation</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.1">System Operation Template</head><p>Xtend <ref type="bibr" target="#b24">[25]</ref> is a flexible and expressive template language. In this paper, we adopt Xtend to define the template. The template used to generate the implementation of system operations from the contract c is shown as follows: throw new PreconditionException(); }} Note that the template will be directly as the output result from the prototype generation, except interpolated expressions inside guillemets «». The expressions in «» will be dynamically interpreted in terms of requirements model. Accordingly, the expressions between «IF» and «ENDIF» will be interpolated when the condition is evaluated as true. The expressions between «FOR» and «ENDFOR» will be repeatedly interpolated through all the elements of the list. For example, if c represents the contract of enterItem(), «c.opSign.name» will be interpreted as the name of the system operation enterItem.</p><p>The above template helps to implement the contract signature through generating the Java operation with keyword public, the name of system operation «c.opSign.name», input variables «para.name» with type «para.type», and return type «c.opSign.returnType». Then the template helps to generate the code «c.definition.compile» for the definition section of the contract, if any. Then, the template generates the Java if-else control flow to check the pre-condition of system operation «c.precondition.compile», and executes the logic code «c.postcondition.compile» to make the system satisfying the post-condition. In detail, 1) if the evaluation result of pre-condition is true, the code of the system operation will be executed, and then return the result by Java code return «returnName», if any. 2) If the evaluation result of pre-condition is not true, an exception Precondi-tionIsNotSatified will be directly emitted without executing any code of the system operation. However, this template only helps to generate the skeleton code of system operation. The «c.definition.mapping», «c.precondition.mapping» and «c.postcondition.mapping» are interpreted by transformation rules and algorithm in section 3.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.2">System Operation Encapsulation</head><p>System operations are captured in system sequence diagrams of use cases. If we follow the suggestion of the expert pattern in GRASP, system operations should be encapsulated to the classes (experts) in the conceptual class model. For example, the class Item contains attributes of barcode and price, enterItem(barcode, quantity) should be assigned to the class Item. However, entity classes have already held primitive operations for manipulating the attributes and associations. We expect to separate concerns into a different abstract level of class to achieve high cohesion and low coupling.</p><p>The mediator pattern of GoF suggests an object that encapsulates a set of operations to promote loose coupling. That describes the situation the same as a use case, which includes high cohesion system operations related to one scenario of interactions between the actor and the system. Therefore, we generate a pure fabrication class for each use case and then encapsulate the system operations of the use case to the fabrication class to achieve high cohesion. Algorithm 2 generates the fabrication classes and encapsulates system operations into them. However, if a target problem contains many use cases, and most use cases only include one system operation, Algorithm 2 will generate many fabrication classes with just one operation. That breaks the design principle of high cohesion. The appropriate way is to define one fabrication class charging for several responsibilities to promote high cohesion. In the extreme cases, you can even specify only one pure fabrication class for all use cases. To deal with those situations, our CASE tool provides a mechanism that allows product managers and domain experts to decide how to define those fabrication classes for the use cases, and then automatically generates the implementation of those pure fabricated classes.</p><p>For example, the currentSale object of class Sale created by the system operation makeNewSale() is reused in the system operations enterItem() and endSale() of the use case processSale. Algorithm 2 generates a pure fabricated class CoCoMEProcessSale to encapsulate those system operations and the shared object currentSale. In detail, CoCoMEProcess-Sale is the pure fabrication class for encapsulating system operations enterItem(), makeNewSale(), endSale(), makeCash-Payment(), makeCardPayment() and the object reference to currentSale in Figure <ref type="figure" target="#fig_7">8</ref>.</p><p>This subsection illustrates how to generate fabricated classes and encapsulate the system operations. The next two subsections introduce how to generate entity classes from </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Entity Class Generation</head><p>Entity classes generation is a necessary procedure to achieve the auto-prototyping from requirements model, which is shown in Figure <ref type="figure" target="#fig_24">9</ref>. It not only needs to generate the attributes and associations of the entity class but also requires to generate the implementation of primitive operations for setting and getting the attributes, finding linked objects, and adding and removing the links. We will show the details in the subsection.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Conceptual Class Model</head><p>Entitiy Classes with Atomic Operations</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Generate</head><p>Primitive Operations Templates  primitive operations about getting and setting each attribute of the entity class are generated. For each association of the class, a) if the association is a one-to-many relationship, primitive operations about finding linked objects, adding and removing link of one-to-many association are generated, b) if the association is a one-to-one relationship, primitive operations about finding the linked object, adding and removing link of one-to-one association are generated. Note that above entity skeleton and primitive operations are generated through the code templates, and we will introduce those templates in the remaining of this subsection.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.2">Entity Class Template</head><p>The generation skeleton of entity classes is straightforward. Many UML tools support this feature. The template to generate an entity class c is: The template defines a public class with the keyword public and the name c.name inside of «». If the class has a superclass, the text of c.superClass.name will be replaced by the name of the super-class along with the keyword extends. The attribute is declared by the keyword private with the type attribute.type and the name attribute.name. The association is also declared by the keyword private with a) a typed list List&lt;assoc.class&gt; and association name assoc.name, if the association is a one-to-many relation, b) an attribute with the name of associated class assoc.class.name and the type of associated class assoc.class, if the association is a one-to-one relation.</p><formula xml:id="formula_1">/* Class Skeleton</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.3">Primitive Operation Templates</head><p>The templates for primitive operations getAttribute() and setAttribute() are: //Getting Attribute public «attribute.type» get«attribute.name»() { return «attribute.name»; } //Setting Attribute public void set«attribute.name» («attribute.type» «attribute.name») { this.«attribute.name» = «attribute.name»; } Getting an attribute can be defined as the public operation with the name get«attribute.name» and the type «attribute.type» of attribute, which is fulfilled by directly returning the attribute by using the keyword return. The setting attribute can be fulfilled by setting the value of attribute this.«attribute.name» with an input of typed variables.</p><p>The primitive operation templates for finding linked objects, linking a new object, and removing an linked object are: //findLinkedObjects() public List&lt;«assoc.class»&gt; get«assoc.name»() { return «assoc.name»; } //addLinkOnetoMany() public void add«assoc.name»(«assoc.class» ob) { this.«assoc.name».add(ob); } //removeLinkOnetoMany() public void remove«assoc.name»(«assoc.class» ob) { this.«assoc.name».remove(ob); }</p><p>We use a reference list to store object references for the one-to-many association. Therefore, finding objects through link can be directly implemented by returning the reference list of the association. Forming a link can be fulfilled by invoking the adding operation of the list as well as the deleting operation for breaking a link. //findLinkedObject public «assoc.class» get«assoc.name»() { return «assoc.name»; } //addLinkOnetoOne() removeLinkOnetoOne() public void set«assoc.name»(«assoc.class» ob) { this.«assoc.name» = ob; } The one-to-one association is implemented as an attribute with the type of associated class. Thus, the implementation of finding the object through a link of one-to-one association is the same as getting the value of an attribute. The implementation of adding and removing a link of an one-to-one association is the same as setting primitive operation of an attribute. For example, when removing a link of a one-toone association, we can just set null as the value of the link.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">EntityManager Generation</head><p>In object-oriented system, the object can be eventually found through the links of the objects. However, we need to locate the entrance object then to start the finding procedures. The primitive operation findObject() is used to find the first entrance object, then other objects can be reached through the primitive operation findLinkedObject() of the links of objects. To implement findObject(), a pure fabrication class named as EntityManager is required, which contains all the references to the objects of entity classes as well as the primitive operations findObject() and findLinkedObject(). Moreover, the creator pattern of GRASP suggests assigning the creating responsibility to the class recording the instances of the created objects. EntityManager records all instances of entity classes. Therefore, the primitive operations createObject() and releaseObject() are assigned to En-tityManager. In addition, EntityManager is required a global accessing point. According to the singleton pattern of GoF, we build EntityManager as a singleton class, which has the only one instance, and provide a global accessing point. In short, the generation algorithm of EntityManger is shown in Algorithm 4. This algorithm takes a conceptual class model, Entity-Manager template, the templates of object-related primitive operation as input, generates EntityManager classes. We generate EntityManager skeleton through EntityManager template, and the implementation of primitive operations findObject(), findObjects(), createObject(), addObject() and re-leaseObject() inside of EntityManager. Note that EntityManager records all the instances of entity classes, and addObject() is used for adding the object into the records. We will show those templates in the remaining of this subsection.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Input</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.1">EntityManager Template</head><p>The template for generating EntityManager skeleton is shown as follows: We use Java HashMap named AllInstances to record all the object reference lists. Each object reference list is implemented as a LinkedList of Java with name «c.name»Instances. «c.name» will be replaced by the name of classes in the conceptual class model. All references list of object are added to this HashMap AllInstance. After that, we can find the specific object reference list directly by the name of entity class.</p><formula xml:id="formula_2">/*</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.2">Primitive Operation Templates for Finding Objects</head><p>By using EntityManager, we can do fine-grained search findObject() and findObjects() with a query condition precondition(o) on the reference list. The template of finding object is: The differences is the findObjects() template initializes the targets as a linked list, adds the object o to the list targets when the object o satisfies the condition, and finally, returns the target list targets.</p><formula xml:id="formula_3">/* find</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.3">Templates for Creating, Adding and Releasing Object</head><p>The factory method pattern of GoF suggests defining an interface for object creation, but let sub-classes decide which class to instantiate. Therefore, we impact all the create object responsibilities in the EntityManager, and define a factory method that creates all objects of classes. This factory method can invoke a concrete creator that returns an instance of an entity class through the Java reflect mechanism. The primitive operation template for creating objects is: </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">REQUIREMENTS VALIDATION AND EVOLUTION</head><p>This section presents how to use the prototype to validate and evolve requirements. An overview is depicted in Figure <ref type="figure" target="#fig_26">10</ref>. It starts with requirements R 1 , from which a prototype P 1 is automatically generated using implementation CASE tool RM2PT based on the techniques presented in Section 3 and 4. Then P 1 is used to validate the requirements R 1 . If the faults of requirements or the missing requirements are found in R 1 , we evolve the requirements R 1 to a requirements R 2 by fixing the errors and elicit new requirements. Then a prototype P 2 is generated from requirements R 2 , we use prototype P 2 to validate requirements R 2 . This process repeats until no more faults and missing requirements are found. In the practice, requirements are often a moving target, and thus requirements validation and evolution can be triggered in any stage of software engineering if needed.</p><p>Customers and project managers can quickly validate functional requirements through the generated prototype without writing any code. A prototype provides two modules for requirements validation:</p><p>• System Operation Execution with Pre-condition and Invariant Checking Prototype provides a window for the customers to test system operations. For example, CoCoMe prototype includes the widgets of system operation list on the left side, the system operation panel in the middle and the contracts panel on the right side in Figure <ref type="figure" target="#fig_29">14</ref>. Moreover, the prototype involves pre-conditions and invariants checking. When executing a system operation, a warning message is prompted if pre-condition is not satisfied in Figure <ref type="figure" target="#fig_8">11</ref>. Moreover, if the execution of the system function make system state break the related invariants, the color of the invariant bar will become red from green in Figure <ref type="figure" target="#fig_17">12</ref>. That indicates the errors in the requirements. Further inspections are required to locate the errors.</p><p>• State Observation The location of the errors may be in the pre-condition, post-condition of the contract. Invariant checking can only indicate the errors. The state observation of the objects can help to locate the faults of the requirements. Figure <ref type="figure" target="#fig_19">15</ref> shows the state observation panel of CoCoME prototype. The left top side presents the name and the number of the objects for each class in the current system. For example, the number of the objects of the classes Store, CashDesk, Sale and Item in the CoCoME system. The left bottom side shows the status association, which includes the source object, the target object, the name of the association, the number of the associated objects, and whether this association is a one-to-one or one-to-many relationship. For example, the Figure <ref type="figure" target="#fig_19">15</ref> shows the state of association BelongedCashDesk of the object Sale. The middle side of the panel shows the status of the attributes of the objects. E.g, the status of the attributes Time, IsComplete, Amount of the Sale objects. When clicking a class entry on the left side, the state of the corresponding attributes and associations will display on the middle and left bottom side of the panel. Furthermore, all the invariants of the system are listed on the right side of the panel. When any invariant does not hold, it will become as red bar like in the system function panel. The remaining parts of this subsection will show how to use the generated prototype to validate the requirements.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Start-up Objects</head><p>When the prototype is opened for the first time, it does not contain any object. That means system operations except adding objects cannot be executed because the preconditions of functions are not satisfied. The start-up objects must be added into the prototype before requirements validation. The prototype provides two options to load start-up objects. 1) Load objects from the checkpoint file. The users can click the Load State button in the system state panel to load the checkpoint files into the system to restore the status of system saved before. 2) Manually create start-up object by using the Create, Read, Update, and Delete (CRUD) operations provided by prototypes. RM2PT provides mechanisms to automatically generate the contracts and implementations of CRUD operations by marking conceptual classes. The administrator can use this mechanism to add the startup objects into the prototype. For example, administrators add the Store object with the ID 1, name UMStore, and address Taipa into the system by createStore() operation in Figure <ref type="figure" target="#fig_28">13</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Pre-condition Validation</head><p>The execution of system operation containing pre-condition errors may lead system to an un-expected state that violates system invariants. It contains two cases: parameter constraint missing and constraint error. Parameter Constraint Missing: Parameter constraint missing means that the constraints of parameters are missing in the pre-condition, the execution of the system operation may lead system to an un-expected state that violates system invariants. For example, the customer makes a cash payment $20 for their $40 products in CoCoMe. If the precondition does not check the tendered money is greater than or equal to the total price of products, the invariant of CashPayment that the balance must be greater than or equal to zero may be violated. The invariant bar of the prototype will become red as in Figure <ref type="figure" target="#fig_17">12</ref>. Users should add the missed constraints into the pre-condition of cashPayment to fix this error.</p><p>Constraint Error: Constraint error means that the constraints are not correct in the pre-condition, the execution of the system operation may lead system to un-expected state that violates system invariants. For example, ATM has the invariant about the one-day maximum withdraw limitation (E.g., $2000 pre-day). When a customer intends to withdraw $500 from her account if she has already withdrawn $1800 on the same day. This request must be rejected by the precondition of withdraw operation. However, this request can be executed if the pre-condition is that the total withdrew money of one day is lesser than or equal to $2000. In this case, the execution of withdraw will make the system state violate the maximum limitation invariant due to the withdrew money $2300 is higher than the maximum limitation $2000. We need to fix this error by replacing the pre-condition to check the value of withdrawing must be lesser than or equal to the value of maximum limitation minus the total value of withdrew today (withdrawing ≤ maxV alue -withdrew).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Post-condition Validation</head><p>Post-condition errors can also lead the system to an unexpected states that violate system invariants and the precondition of the next system operations under the same use case. For examples, 1) one invariant of CoCoME system shows the final price of the current sale process must be greater than zero. The operation endSale() adds all the sub-amount of products together as the final price for the payment. If there is a typo when the plus sign '+' is typed as minus sign '-' in the post-condition, the final price will be less than zero. That will violate the price invariant after execution. 2) the post-condition of endSale() should specify the flag IsReadytoPay to true. If missing this specification in the post-condition, the pre-condition of the system operation makePayment() cannot be satisfied, and a warning message will prompt in Figure <ref type="figure" target="#fig_8">11</ref>. The product managers can validate and fix those post-condition errors without too many efforts by checking the system state before and after the execution of system operations in the prototypes.</p><p>In short, the prototype can indicate the pre-condition and invariant violations in requirements models. Although locating and fixing the errors require carefully observing and analyzing the state of objects and the contracts, the generated prototype provides an intuition way to help product managers and customer to validate their requirements. Moreover, the requirements cannot be elicited entirely at one time. After validating the requirements, the customers and product managers would fix the faults of the requirements and find new interesting functional requirements of the target system. This fixing and eliciting requirements process will make the previous requirements version from R n-1 to next version R n in Figure <ref type="figure" target="#fig_26">10</ref>. Then the evolved requirement R n will be used to generate a new prototype P n . Compared with the methods to manually implementing the prototype, customers and project managers can use RM2PT to generate new prototypes and validate the requirements without waiting for the software engineers to implement the prototype. Therefore, RM2PT shortens the timeline and boosts the software development process. Moreover, RM2PT reduces the inconsistency between the requirements and the prototype by automatically transformation rules; otherwise, errors may be involved by the green hands or careless of the human nature. In the next section, we will demonstrate the validity of the RM2PT through four classical case studies using in our daily life.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">CASE STUDIES</head><p>In this section, we use four case studies to demonstrate the validity and capacity of the proposed approach for requirements validation and evolution. Those case studies are wildly used systems in our daily life: supermarket system (CoCoME), Library Management System (LibMS), Automated Teller Machine (ATM), and Loan Processing System (LoanPS). CoCoME mainly contains the scenarios of the cashier to process sales in supermarkets, and supermarket managers to manage the storage of products. LibMS primarily involves the student to borrow and return books. ATM concerns the customer to withdraw and credit money. LoanPS touches the use cases of submitting and evaluating loan requests, booking a new loan and making the payment. Those four case studies demonstrate the different aspects of requirements modeling and prototyping of RM2PT. ATM provides a quick-start and simple demonstration of RM2PT about requirements modeling and prototyping. CoCoME demonstrates the capacity of generation and validation complex use case such as processSale. LibMS demonstrates the capacity of generation and validation of the complex system operations, that makes the case study of LibMS contains the highest number of primitive operations. The last one LoanPS demonstrates the ability to invoking thirdparty system services by including the remote operations calling from the account management system of banks and the credit management system of the governments. We will show the requirements modeling and validation results in the following parts. More details of the requirements models can be found at GitHub 4 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Evaluation Complexity of Requirements Model</head><p>Requirements complexity is measured by the dimensions of the number of the actors, use cases, system operations, entity classes, and associations of the entity classes in the requirements model. We present the requirements complexity of four case studies in Table <ref type="table" target="#tab_10">2</ref>. The requirements model of CoCoME contains three actors, sixteen use cases, forty-three system operations, two hundred-seven-three primitive operations, thirteen entity classes, twenty associations between those objects, and ten invariants. The requirements model of LibMS includes seven actors, nineteen use cases, fortyfive system operations, four hundred-thirty-three primitive operations, eleven entity classes, seventeen associations, and twenty-five invariants. The requirements model of ATM includes two actors, six use cases, fifteen system operations, one hundred and three primitive operations, three entity classes, four associations, and five invariants. The requirements model of LoanPS includes five actors, ten use cases, thirty-four system operations, one hundred and seventyone three primitive operations, twelve entity classes, eight associations, and twelve invariants. In short, we provides 17 actors, 51 use cases, 137 system operations, 980 primitive 4. <ref type="url" target="https://github.com/RM2PT/CaseStudies">https://github.com/RM2PT/CaseStudies</ref> operation, 39 entity classes, 49 associations of entity classes, and 52 invariants.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Results of Requirements Modeling and Generation</head><p>The generation results of four case studies are shown in this subsection. The failures of requirements modeling and generation can be divided into two situations: 1) the contracts of system operations cannot be correctly specified in OCL expression without invoking third-party APIs such as sorting algorithm, sending email, and etc. 2) the contracts of system operations can be correctly specified in OCL expression, but no transformation rule is matched to generate the implementation for the system operations correctly. We count both failures of those case studies by the measurements MSuccess and GenSuceess in Table <ref type="table" target="#tab_11">3</ref>. ATM is the most straightforward case study of four. It does not contain a complex workflow. All of the fifteen system operations can be successfully modeled and generated. The successful generation rate reached 100%.</p><p>CoCoME contains forty-three system operations. Forty-one can be successfully generated, in which two system operations cannot be specified correctly. The two failures of requirements modeling are 1) listing top 10 out of stock products, 2) send emailing notification to the student, who holds the book copy will be due in the next two days. Preconditions of those two system operations can be specified correctly, but the sub-expressions of post-condition, listing top 10 and sending email, can not be specified correctly in OCL expression. Therefore, the corresponding transformation and implementation cannot be generated correctly as well.</p><p>Another case is that listing almost out of stock the products with storage less than 10 in ascending order. That post-condition can be specified correctly, but the subexpression of ascending order cannot be generated because no transformation rule can be used to map that sub-expression to the primitive operations. Counting the failures of system operations modeling and generation, the successful rate of prototype CoCoME is 93.02%.</p><p>LibMS contains forty-five system operations, forty-three can be correctly modeled, and forty can be correctly generated. The two modeling failures are 1) listing the top 10 the student holding the overdue book over a week. 2) sending an email notification to the student, who holds the book copy will be due in the next two days. Like CoCoMe, the failures of modeling are also due to the expression top 10 and sending email. The failure of generation is listing the holding book records by the due day in ascending order. Counting in those failures, the successful generation rate is 91.11%.</p><p>LoanPS contains thirty-four system operations, and thirty system operations can be correctly specified and generated. Four failures of modeling include 1) listing the top 10 loan requests with loan assistant, 2) sending a notification to the applicant when her loan request is approved, 3) printing the loan agreement, 4) sending the notification to the customer when their loan is due soon. The successful generation rate of LoanPS is 88.23%.</p><p>In short, RM2PT can successfully generate average 93.65% system operations of those four case studies without any extension. There still has 6.35% errors of requirements modeling and prototype generation. As we mentioned, the errors mainly caused by the failures of specifying the postconditions of the contract such as sending email, printing document, sorting and retrieving top N elements.</p><p>To help users easier finding the failures of modeling and prototype generation, 1) our case tool RM2PT can automatically indicate the sub-expression error with red underlines in the post-conditions when generating the prototype from the requirement model and the code errors in the generated prototype. 2) RM2PT provides an extension mechanism to allow specifying the third-party APIs were invoking in OCL expression. Once errors were identified by RM2PT, we can replace the error expression in post-condition with the calling expression of the third-party service. This calling expression will be a transformation to the operation calling in the prototype. The developer can manually implement the operation, or invoking the operation system APIs (for sending email and printing document) and reusing the collection algorithm library (for sorting and top N elements retrieving). After specified the calling expression of thirdservices into the requirements model, all the system operations of four case studies can be correctly modeled and generated.</p><p>This subsection exposes the results of requirements modeling, prototype generation, and how to fix the failures of modeling and generation. Based on the techniques of requirements validation and evolution in the section 5, we will show the result of validation and evolution in next subsection.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Results of Requirements Validation and Evolution</head><p>The result of requirements validation and evolution of four case studies are shown in Table <ref type="table" target="#tab_12">4</ref> and 5, which contain the statistic of requirements errors and missing. During the three-round modeling, prototype generation, requirements validation, we found 99 requirements errors, which includes 31 errors in the pre-condition and 68 errors in the post-condition. In details, 5 pre-condition and 12 postcondition errors are founded in ATM. 8 pre-condition and 23 post-condition are founded in CoCoME case study. 12 pre-condition and 26 post-condition errors are founded in LibMS case study. 6 pre-condition and 21 post-condition are founded in LoanPS case study.</p><p>Requirement validation can help to find errors in requirements, but also can help to find missing requirements. During the requirement validations and refinements from </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.4">Performance of Prototype Generation</head><p>The advantages of the proposed approach to automated generate prototype are more efficient than the manual prototype implementation by the developers. We evaluate the RM2PT prototyping performance by comprising prototype time among RM2PT and the developers. The performance is measured on the dimensions: a) line of code, which is calculus by the tool cloc 5 , b) prototype time of RM2PT, c) generation time for the system operations, d) average coding time of ten master students from computer science, e) average coding time of ten developers from the industry with at least three year coding experiments. All the measurement are computed on the PC with 3. RM2PT auto-prototyping is much more efficient than manual prototyping (~1 second vs ~9 hours). Although the experienced developers take less prototyping time than the students, that is still much in-efficient than auto-prototyping approach. Moreover, the manual prototyping usually introduces inconsistency between prototype and requirements because of careless and not understanding of requirement model. That makes more than half of the whole prototyping time to debugging. Furthermore, if we only count the time for fulfillment of system operations, the spending time ~9 ms) is much less than the prototyping (~850 ms). In short, RM2PT is an efficient and effective approach to generate prototype without introducing inconsistency between the requirements model and prototype.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.5">Limitation</head><p>The case studies demonstrate the effective and efficient of RM2PT for requirements modeling, prototype generation, requirements validation, and evolution. However, it has some limitations. 1) The first one is that 6.91% system operations cannot be correctly specified or successfully generated without introducing third-party services, but this limitation has been solved by specified the thrid-part service is invoking in OCL expression. That is a significant extension of our previous work. 2) The second limitation that is although the formal specification OCL has short leaning cure than other formal specification, it still needs time for learning to specify the correct contract. We will try to find the better solution to alleviate this problem. 3) The third limitation is the generation performance, and it can be further optimized in the future.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">RELATED WORK</head><p>The related work contains three parts: 1) automated prototype approach, 2) requirements modelers, and 3) the comparison with our previous work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1">Automated Prototype Generation</head><p>The following approaches are the most closely related to our work. Umple <ref type="bibr" target="#b25">[26]</ref> can generate a prototype from a class model (conceptual class diagram) and state machine models. However, the state machine only contains abstract states and descriptions of actions (system operations). To generate fully functional prototypes, the actions must be implemented by programming languages. Moreover, invariant checking and requirements validation are not touched.</p><p>ActionGUI <ref type="bibr" target="#b26">[27]</ref> can generate a multi-tier application from a design model, which includes a data model (specified by ComponentUML <ref type="bibr" target="#b27">[28]</ref>), a security model (specified by SecurityUML <ref type="bibr" target="#b27">[28]</ref>) and a GUI model (specified by GUI Modelling Language). Compared with our approach, there are three main differences. ActionGUI a) requires to provide system operation design by using data actions (primitive operations) to specify statements for events (system operations) in GUI model. A statement (the workflow of primitive operations) is either an action, an iteration or a sequence of statements. Our approach only requires providing contracts (pre and post conditions in OCL) to system operations, then the implementation of system operation can be automated generated. b) ActionGUI requires GUI engineer to construct a GUI model through their specific tool manually. Our approach can be automated generate prototype from requirements model without providing any GUI design. c) the generated GUI of our approach is implemented by stateof-arts GUI architecture design, i.e., separated concerns into GUI content (XML) and GUI style (CSS). That makes prototype high reusable by only applying user-friendly styles to the same content.</p><p>The paper <ref type="bibr" target="#b28">[29]</ref> proposed an intermediate approach to generate UI prototypes from UML models. It generates state chart diagrams from a design model specified by a class diagram and collaborations diagrams for each use case, and then generate the UI prototype from a use case diagram and the intermediate state chart diagrams. Comparison with our work, we only require a requirements model, which includes a use case diagram, conceptual class diagram (without system operations), system sequence diagrams and the contracts of system operations (only including the interaction between actors and system interface without internal interactions among objects, that required in collaborations diagrams). The generated prototype contains mechanisms for pre-conditions and invariants checking.</p><p>JEM <ref type="bibr" target="#b29">[30]</ref> can generate an n-tiered prototype from a conceptual model and an execution model. The conceptual model contains a) an object model specified in a class diagram, b) functional models for the attributes of the class and c) dynamic model for each class defined in state chart diagram. Then the prototype can be generated by the derived formal specification OASIS from the conceptual model and the implementation related execution model, which includes the generation templates and details mapping about OASIS to the implementation. Compared with our approach, pre-and post-conditions only contain simple attribute checking and updating (only one attribute involved) that is hard for working on the practical requirements model and prototype generation.</p><p>SCORES <ref type="bibr" target="#b30">[31]</ref> proposed a semi-automatically approach to generating prototypes from an enhancement of the requirements specification with user interface model in FLUID <ref type="bibr" target="#b31">[32]</ref>.</p><p>Requirements specification contains a use case diagram, activities diagrams to each use case, and a class diagram (including operations). User interface model includes a specification for view widgets, their navigation, and selection or manipulations (primitive operations) of the domain objects. It does not include the specification or contract for system operations other than simple manipulations of domain objects. Therefore, the sophisticated system operations cannot be generated such as borrowBook, which includes collaborations of primitive operations such as find an object, form a link, update the attribute. Moreover, the class diagram in SCORES already contains the system operations in the activities diagram, stickily speaking, that is a design model. In short, the related works 1) require providing a design model, which contains a class diagram encapsulating system operations, the design or implementation of system operations specified in collaboration diagrams or a programming language. Moreover, SCORES, ActionGUI and JEM require a GUI design for generating prototype user interface. 2) They lack evaluations about the prototype generation, the mechanism to deal with the non-executable elements in the requirements model. 3) Requirements validation and evolution are not touched. The generated prototype does not provide mechanisms to invariants checking and object status observations in run-time for requirements validation and evolution.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2">Requirements Modelers</head><p>Most UML modeling tools support OCL-based contract and can generate skeleton code for entity classes in the conceptual class model. Moreover, Visual Paradigm (VP) <ref type="bibr" target="#b32">[33]</ref> not only supports entity class generation but also supports generating code for primitive operations of entity class such as creating, deleting, modifying, finding the entity object. And the generated entity classes can be automated mapped into tables of relational database thought ORM and the corresponding RESTFul-based web service wrappers could be automatically generated. Eclipse Foundation provides many open source CASE tools and frameworks. For example, Papyrus UML <ref type="bibr" target="#b33">[34]</ref> is well developed and widely used open source tool. EMF Forms 6 cannot only generate primitive operations (like in VP) but also can generate GUI for validating those operations. CDO 7 provides open source solutions to support ORM for EMF 8 model. Commercial CASE tool Enterprise Architect 9 supports generate system operations of objects from the presented design model. The study <ref type="bibr" target="#b10">[11]</ref> proposed sequence integration graph (SIG), which acts as an intermediate to help automatically fulfill system operations from sequence diagram. Morever, if providing design model, MasterCraft <ref type="bibr" target="#b11">[12]</ref> could generate information system prototype. AndroMDA 10 could generate Java EE and .NET system prototype. However, all the current CASE tools can not generate a prototype without 6. <ref type="url" target="http://www.eclipse.org/ecp/emfforms">http://www.eclipse.org/ecp/emfforms</ref> 7. <ref type="url" target="http://www.eclipse.org/cdo/">http://www.eclipse.org/cdo/</ref> 8. <ref type="url" target="https://eclipse.org/modeling/emf/">https://eclipse.org/modeling/emf/</ref> 9. <ref type="url" target="http://www.sparxsystems.com">http://www.sparxsystems.com</ref> 10. <ref type="url" target="http://andromda.sourceforge.net">http://andromda.sourceforge.net</ref> providing an explicit design model. USE (UML-based Specification Environment) <ref type="bibr" target="#b34">[35]</ref> supports analysts, designers, and developers in executing UML models and checking OCL constraints and thus enables them to employ modeldriven techniques for software production. The project of Eclipse OCL 11 provides an OCL parser and evaluator on UML models. Although USE and Eclipse OCL can evaluate the invariants and precondition of operation contracts, they can not generate the implementation of system operation to conform the post-condition.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.3">Compared with Our Previous Work</head><p>Our previous works about Refinement of Component and Object Systems (rCOS) modeler <ref type="bibr" target="#b35">[36]</ref> [37] <ref type="bibr" target="#b37">[38]</ref> and Automated Prototype Generation and Analysis (AutoPA) <ref type="bibr" target="#b17">[18]</ref> [19] touch object-oriented modeling and prototype generation. The rCOS supports refinement calculus for both component-based and object-oriented models. It uses firstorder logic to specify the contracts of system operations. It focuses on modeling, but can not generate the prototype. AutoPA can generate system operations from the requirements model with OCL contracts to demonstrate the feasibility of our approach. Compared with our previous works <ref type="bibr" target="#b17">[18]</ref> [19], the proposed approach and implemented RM2PT provides:</p><p>1) Extensions of transformation rules. Our previous work only cover a small subset of OCL expression that describes creating an object, adding a link, getting the value of attribute, setting an attribute, removing a link, and deleting an object, but not includes: a) finding an object with a condition such as any() and select(), b) OCL standard operations such as size() and isEmpty(), c) the iteration expression forAll() for iterating object from a list, d) invoking third-party operations, and e) the return expression.</p><p>In details, we introduce the rules from R 1 to R 3 to find the object with a condition through EntityManager, which stores all the references of objects. Moreover, the rules from R 4 to R 7 support finding the objects through the links. The rules from R 8 to R 11 support OCL standard operations. The checking of an object exists (or not exists) can be fulfilled by the combination of the rules R 8 and R 13 (or R 14 ), and checking a link exists that is supported by the composition of the rules R 4 , R 5 , and R 8 . Besides, the uniqueness of an object can be checked through the rule R 15 . The getting and setting an attribute of object is the same as the rules R 12 and R 23 . The rule of creating an object is refined to two rules, the rule R 16 is to create an object, and the rule R 17 is to add the created objects into the system (add the reference to the created object into EntityManager). The rule of releasing an object is the same as the rules R 18 . We refine the rules of adding a link to two rules: the first rule R 19 is adding a link of the one-to-one association, the second rule R 21 is for the one-to-many association. Likewise, the rules of removing a link is refined to the rules R 20 and R 22 . More general system operation such as all the objects of a class satisfy a particular constraint are common requirements in a contract (E.g., when time passed 00:00 AM, the attributes of remain days of all the students were equaled to the previous value 11. <ref type="url" target="https://projects.eclipse.org/projects/modeling.mdt.ocl">https://projects.eclipse.org/projects/modeling.mdt.ocl</ref> plus one.). We add the rule R 24 for iteration expression, the rule R 25 for the return expression, and the rule R 26 for invoking third-party APIs library.</p><p>2) Supporting requirements executable analysis and wrapping the non-executable specification into an interface. Our previous works face the problem of un-executable elements of the contract of system operation, which cannot be fulfilled by primitive operations, like sorting and filtering. RM2PT provides a mechanism to identify and un-executable parts of contract and wrapper them into an interface, which can be fulfilled by third-party APIs.</p><p>3) Requirements validation and evolution through the generated prototypes. Our previous work does not touch how to use the generated prototypes to requirements validation and evolution. In this paper, we provide mechanisms to observe the state of objects, and pre-condition and invariants checking in the prototype and show how to validate and evolve requirements through the generated prototype from RM2PT. Four case studies from different aspects demonstrate effective and efficient of our proposed approach. 4) Self-contained requirement modeler and OCL parser. RM2PT does not rely on third-party UML tools and OCL parser, RM2PT self-contains a requirement modeler and an OCL parser with bi-directionally synchronization between graphics and textual requirements models. The graphics model provides the easer-understood visualized notations for communication with customers. Textual requirement model makes developers easily define the contracts of responsibility. Furthermore, by integrating with version control tools such as SVN and Git, RM2PT can support the trackable iteration for evolutionary requirements elicitation. 5) Generated prototypes based on architecture and design patterns under GRASP guidelines and design patterns. Unlike AutoPA encapsulates all the system operations into conceptual classes, RM2PT separates concerns into a different abstract level. After generating supporting classes related to architecture, RM2PT automatically encapsulate primitive operations into entity classes and system operations into fabricated classes for separating concerns. Furthermore, different responsibilities of holding content and representation are separated through the latest Java GUI framework JavaFX. The generated prototype takes the architecture and design patterns similar to Java EE and .NET enterprise system, which is capable of extending for a practical scenario.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">CONCLUSION AND FUTURE WORK</head><p>This paper presents an approach to automated prototype generation from a formal requirements model, and the requirements model can be validated and evolved by the generated prototype. It includes executable analysis of formal specification and designs a set of transformation rules for translating the executable parts of the contract into Java source code. The non-executable parts of contract can be identified and wrapped by an interface, which can be fulfilled by third-party APIs. Four cases studies, which are library management system, ATM, CoCoME and loan processing system, have been investigated, and the experiment result is satisfactory that the 93% of use cases can be gen-erated successfully. The CASE tool: RM2PT and its tutorials are available for the public at GitHub 12 .</p><p>In the future, we will improve the current transformation algorithm to cover the more substantial subset of the executable specification. Meanwhile, we will integrate current prototyping tool with our another work on automated translating use case definitions in natural language into their corresponding formal contract in OCL. That will make this work more applicable to software industrial developers. Generally, they can read formal specification, but they have difficulties in writing a formal specification. With the tool support, their task is to confirm whether the translated formal specification is conformance with the natural language requirement description. Furthermore, after a system requirements model is validated by prototyping, we can generate the prototype into its corresponding real system with another developed transformation software tool. Besides, we will investigate how to generate test cases from the OCL specification, so that we can enhance our tool for automated prototyping and testing. Finally, the tool can be used and checked with more case studies, and hopefully, it can benefit the software industry during requirements engineering.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 1 .</head><label>1</label><figDesc>Figure 1. Requirements Model</figDesc><graphic coords="2,58.69,148.37,139.79,84.56" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>:String, ob:Class) Boolean releaseObject(ClassName:String, ob:Class) Boolean Attribute getAttribute(ob:Class, attriName:String) PrimeType setAttribute(ob:Class, attriName:String, mathExp:String) Boolean Link findLinkedObject(o:Class, assoName:String, condition:String) Object findLinkedObjects(o:Class, assoName:String, condition:String) Set(Object) addLinkOnetoMany(ob:Class, assoName:String, addOb:Class) Boolean addLinkOnetoOne(ob:Class, assoName:String, addOb:Class) Boolean removeLinkOnetoMany(ob:Class, assoName:String, removeOb:Class) Boolean removeLinkOnetoOne(ob:Class, assoName:String) Boolean manipulations to a) objects, b) the attributes of objects, and c) the links of objects.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>R 1 :</head><label>1</label><figDesc>obs:Set(ClassName)=ClassName.allInstances() List&lt;ClassName&gt; obs = EM.findObjects(ClassName:String)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>R 2 :</head><label>2</label><figDesc>obs:Set(ClassName)=ClassName.allInstances()→select(o | conditions(o)) List&lt;ClassName&gt; obs = EM.findObjects(ClassName:String, conditions(o):String) R 3 : ob:ClassName = ClassName.allInstances()→any(o | conditions(o)) ClassName ob = EM.findObject(ClassName:String, conditions(o):String)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>R 4 :</head><label>4</label><figDesc>o:ClassName = ob.assoName ClassName o = EM.findLinkedObject(ob:Class, assoName:String) R 5 : obs:Set(ClassName) = ob.assoName List&lt;ClassName&gt; obs = EM.findLinkedObjects(ob:Class, assoName:String)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>(ClassName) = ob.assoName→select(o | conditions(o)) List&lt;ClassName&gt; obs = EM.findLinkedObjects(ob:Class, assoName:String, preconditions(o):String) R 7 : o:ClassName = ob.assoName→any(o | conditions(o)) ClassName ob = EM.findLinkedObject(ob:Class, assoName:String, conditions(o):String)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>R 8 :</head><label>8</label><figDesc>ob.oclIsUndefined() = bool StandardOPs.oclIsUndefined(ob:Class, bool:Boolean) R 9 : var.oclIsTypeOf(type) StandardOPs.oclIsTypeOf(«var», type:String) R 10 : obs.isEmpty() = bool StandardOPs.isEmpty(obs:Set(Class), bool:Boolean)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>R 11 :</head><label>11</label><figDesc>obs.size() op mathExp StandardOPs.size(obs:Set(Class)) «op» «mathExp» R 12 : ob.AttriName op varPM getAttribute(ob:Class, attriName:String) «op» «varPM»</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>R 13 : 14 :</head><label>1314</label><figDesc>ClassName.allInstances()→includes(ob) StandardOPs.includes(EM.findObjects(ClassName), ob:Class) R ClassName.allInstances()→excludes(ob) StandardOPs.excludes(EM.findObjects(ClassName), ob:Class) R 15 : ClassName.allInstance()-&gt;isUnique(o:ClassName | o.AttriName) StandardOPs.isUnique(ClassName:String, AttriName:String)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>R 16 :</head><label>16</label><figDesc>let ob:ClassName in ob.oclIsNew() ClassName ob = EM.createObject(ClassName:String)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>R 17 :</head><label>17</label><figDesc>ClassName.allInstances()→includes(ob) EM.addObject(ClassName:String, ob:Class) R 18 : ClassName.allInstances()→excludes(ob) EM.releaseObject(ClassName:String, ob:Class)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>R 19 :</head><label>19</label><figDesc>ob.assoName→includes(addOb) addLinkOnetoMany(ob:Class, assoName:String, addOb:Class) R 20 : ob.assoName→excludes(removeOb) removeLinkOnetoMany(ob:Class, assoName:String, removeOb:Class)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>R 21 :</head><label>21</label><figDesc>ob.assoName = addOb addLinkOnetoOne(ob:Class, assoName:String, addOb:Class)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>R 22 :</head><label>22</label><figDesc>ob.assoName = null removeLinkOnetoOne(ob:Class, assoName:String)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>R 23 :</head><label>23</label><figDesc>ob.attriName = mathExp setAttribute(ob:Class, attriName:String, «mathExp»:PrimeType)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head>R 24 :</head><label>24</label><figDesc>obs-&gt;forAll(o:ClassName | o.AttriName = mathExp) for (ClassName o:obs) {setAttribute(o:Class, AttriName:String, «mathExp»:PrimeType);}</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_17"><head>Figure 2 .</head><label>2</label><figDesc>Figure 2. An Transformation Example for the Contract of enterItem()</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_18"><head>Figure 3 .</head><label>3</label><figDesc>Figure 3. MVC Prototype Generation from Requirements Model</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_19"><head>Figure 5 .</head><label>5</label><figDesc>Figure 4. Prototype GUI for System Function</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_20"><head>Figure 6 .</head><label>6</label><figDesc>Figure 6. Code Generation for System Operation</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_21"><head>/</head><label></label><figDesc>* operation signature */ public «c.opSign.returnType» «c.opSign.name»( «FOR para : c.opSign.parameters SEPARATOR ','» «para.type» «para.name» «ENDFOR») throws PreconditionException { /* contract definition */ «IF c.definition != null» «c.definition.mapping» «ENDIF» /* check precondition */ if («c.precondition.mapping») { /* contract post-condition*/ «c.postcondition.mapping» /* result return */ «IF c.opSign.returnType != null» return «returnName»; «ENDIF» else {</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_22"><head>Figure 7 . 2 :</head><label>72</label><figDesc>Figure 7. System Operation Encapsulation</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_23"><head>Figure 8 .</head><label>8</label><figDesc>Figure 8. System Operation Encapsulation of Use Case ProcessSale</figDesc><graphic coords="11,328.63,60.01,108.83,165.52" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_24"><head>Figure 9 .</head><label>9</label><figDesc>Figure 9. Code Generation for Primitive Operations</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_25"><head>/</head><label></label><figDesc>* create object template */ public static Object createObject(String cName) { Class c = Class.forName("EntityManager"); Method m = c.getDeclaredMethod("create" + cName + "Object"); return m.invoke(c); } «FOR c : classes» public static «c.name» create«c.name»Object() { «c.name» o = new «c.name»(); return o; } «ENDFOR» The factory method createObject provides a single-point to create object, it will invoke the concrete create«c.name»Object method to create and return the object of class «c.name». We also use this pattern to build the addObject and deleteObject template. The template for generating primitive operation addObject() is /* add object template */ public static Object addObject (String cName, Object ob) { Class c = Class.forName("EntityManager"); Method m = c.getDeclaredMethod("add" + cName + "Object", Class.forName(cName)); return (boolean) m.invoke(c, ob); } «FOR c : classes» public static boolean add«c.name»Object(«c.name» o) { return «c.name»Instances.add(o); } «ENDFOR» Object ob and the name of class are passed to the factory method addObject. Then addObject uses Java reflect to invoke the concrete method add«c.name»Object to add the object ob to the object list «c.name»Instances. We use the same pattern to build the template deleteObject: /* release object template */ public static boolean deleteObject (String cName, Object ob) { Class c = Class.forName("EntityManager"); Method m = c.getDeclaredMethod("delete" + cName + "Object", Class.forName(cName)); return (boolean) m.invoke(c, ob); } «FOR c : classes» public static boolean delete«c.name»Object («c.name» o) { return «c.name»Instances.remove(o); } «ENDFOR»</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_26"><head>Figure 10 .</head><label>10</label><figDesc>Figure 10. Requirement Validation and Evolution</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_27"><head>Figure 11 .</head><label>11</label><figDesc>Figure 11. Pre-condition Checking</figDesc><graphic coords="15,70.80,221.18,206.39,64.84" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_28"><head>Figure 13 .</head><label>13</label><figDesc>Figure 13. Start-up Objects</figDesc><graphic coords="15,312.00,187.61,258.00,193.50" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_29"><head>Figure 14 .</head><label>14</label><figDesc>Figure 14. System Operation Validation</figDesc><graphic coords="16,60.90,353.86,490.20,243.46" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0"><head></head><label></label><figDesc></figDesc><graphic coords="9,236.14,63.66,313.81,258.56" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0"><head></head><label></label><figDesc></figDesc><graphic coords="9,209.11,396.64,341.93,190.67" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>•</head><label></label><figDesc>Yilong Yang and Xiaoshan Li are with the Faculty of Science and Technology, University of Macau, Macau.</figDesc><table /><note><p>• Zhiming Liu is with School of Computer and Information Science, Southwest University, Chongqing, China. • Wei Ke is with Macau Polytechnic Institute, Macau. • Quan Zu is with School of Software Engineering, Tongji University. Shanghai, China. • Xiaohong Chen is with Department of Computer Science, University of Illinois at Urbana-Champaign, USA. • Zhiming Liu is the corresponding author of this paper. Email: zhiming-liu88@swu.edu.cn.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>the system operation enterItem (a cashier scans products in a sale process of a supermarket) of the use case processSale. The contract first specifies the signature of system operation enterItem() of use case processSale. The signature declares a String variable barcode and a Real variable quantity as input, and output variable typed Boolean.</figDesc><table><row><cell>//Signature</cell></row><row><cell>Contract CoCoMEProcessSale::enterItem</cell></row><row><cell>(barcode : String, quantity : Real) : Boolean {</cell></row><row><cell>//Definition Section</cell></row><row><cell>definition:</cell></row><row><cell>//Find Object</cell></row><row><cell>item:Item = Item.allInstance()-&gt;any(i:Item |</cell></row><row><cell>i.Barcode = barcode)</cell></row><row><cell>//Pre-condition Section</cell></row><row><cell>precondition:</cell></row><row><cell>currentSale.oclIsUndefined() = false and</cell></row><row><cell>currentSale.IsComplete = false and</cell></row><row><cell>item.oclIsUndefined() = false and</cell></row><row><cell>item.StockNumber &gt; 0</cell></row><row><cell>//Post-condition Section</cell></row><row><cell>postcondition:</cell></row><row><cell>//Create an Object</cell></row><row><cell>let sli:SalesLineItem in</cell></row><row><cell>sli.oclIsNew() and</cell></row><row><cell>//Add Links</cell></row><row><cell>self.currentSaleLine = sli and</cell></row><row><cell>sli.BelongedSale = currentSale and</cell></row><row><cell>currentSale.ContainedSalesLine-&gt;includes(sli) and</cell></row><row><cell>sli.BelongedItem = item and</cell></row><row><cell>//Modify Attributes</cell></row><row><cell>sli.Quantity = quantity and</cell></row><row><cell>sli.Subamount = item.Price * quantity and</cell></row><row><cell>item.StockNumber = item.StockNumber@pre -</cell></row><row><cell>quantity and</cell></row><row><cell>//Add an Object</cell></row><row><cell>SalesLineItem.allInstance()-&gt;includes(sli) and</cell></row><row><cell>result = true</cell></row><row><cell>}</cell></row><row><cell>Signature:</cell></row></table><note><p>2. http://www.omg.org/spec/OCL/ of</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 1</head><label>1</label><figDesc>Primitive Operations</figDesc><table><row><cell>Primitive Operation</cell><cell>Return Type</cell></row></table><note><p>Object findObject(ClassName:String, condition:String) Object</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Rule 12 Rule 19 Rule 21 Rule 23 Rule 17 Rule 25 Rule 16</head><label></label><figDesc></figDesc><table><row><cell></cell><cell></cell><cell cols="2">Signature Generation</cell></row><row><cell cols="3">Contract CoCoMEProcessSale::enterItem(barcode : Integer, quantity : Integer) : Boolean</cell><cell>public boolean enterItem(int barcode, int quantity) throws PreconditionException {</cell></row><row><cell>{</cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell>Item item = null;</cell></row><row><cell></cell><cell></cell><cell></cell><cell>for (Item i : (List&lt;Item&gt;)EntityManager.getAllInstancesOf("Item"))</cell></row><row><cell>definition:</cell><cell></cell><cell></cell><cell>{</cell></row><row><cell cols="2">item:Item = Item.allInstance()-&gt;any(i:Item | i.Barcode = barcode)</cell><cell>Rule 3</cell><cell>if (i.getBarcode() == barcode) {</cell></row><row><cell></cell><cell></cell><cell></cell><cell>item = i;</cell></row><row><cell></cell><cell></cell><cell></cell><cell>break;</cell></row><row><cell></cell><cell></cell><cell></cell><cell>}</cell></row><row><cell>precondition:</cell><cell></cell><cell></cell><cell>}</cell></row><row><cell></cell><cell></cell><cell></cell><cell>/* check precondition */</cell></row><row><cell>currentSale.oclIsUndefined() = false and</cell><cell>Rule 8</cell><cell></cell><cell>if (StandardOPs.oclIsundefined(currentSale) == false &amp;&amp;</cell></row><row><cell>currentSale.IsComplete = false and</cell><cell></cell><cell></cell><cell>currentSale.getIsComplete() == false &amp;&amp;</cell></row><row><cell>item.oclIsUndefined() = false and</cell><cell></cell><cell></cell><cell>StandardOPs.oclIsundefined(item) == false &amp;&amp;</cell></row><row><cell>item.StockNumber &gt; 0</cell><cell></cell><cell></cell><cell>item.getStockNumber() &gt; 0) {</cell></row><row><cell>postcondition:</cell><cell></cell><cell></cell><cell>/* Logic here */</cell></row><row><cell>let sli:SalesLineItem in sli.oclIsNew() and self.currentSaleLine = sli and sli.BelongedSale = currentSale and currentSale.ContainedSalesLine-&gt;includes(sli) and sli.Quantity = quantity and sli.BelongedItem = item and item.StockNumber = item.StockNumber@pre -quantity and sli.Subamount = item.Price * quantity and SalesLineItem.allInstance()-&gt;includes(sli) and result = true</cell><cell></cell><cell></cell><cell>}</cell><cell>SalesLineItem sli = (SalesLineItem) EntityManager.createObject("SalesLineItem"); this.setCurrentSaleLine(sli); sli.setBelongedSale(currentSale); currentSale.addContainedSalesLine(sli); sli.setQuantity(quantity); sli.setBelongedItem(item); item.setStockNumber(item.getStockNumber()-quantity); sli.setSubamount(item.getPrice()*quantity); EntityManager.addObject("SalesLineItem", sli); return true;</cell></row><row><cell>}</cell><cell></cell><cell></cell><cell>else { throw new PreconditionException();</cell></row><row><cell></cell><cell></cell><cell></cell><cell>}</cell></row><row><cell></cell><cell></cell><cell></cell><cell>}</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_9"><head></head><label></label><figDesc>The template initializes the object reference target as null, and then iterates the object list by getAllInstancesOf to find the object o satisfying the search condition precondition(o) (refer the details of precondition transformation to section 3.2.2), Finally, the template assigns the finding object o to object target, and returns the found object. The template findObjects is similar to findObject, which is:</figDesc><table><row><cell>/* find objects template */</cell></row><row><cell>List&lt;«c.name»&gt; targets = = new LinkedList&lt;&gt;();</cell></row><row><cell>//initialize target object lists</cell></row><row><cell>for («c.name» o:</cell></row><row><cell>EntityManager.getAllInstancesOf(«c.name»)) {</cell></row><row><cell>//finding the object satisfies the condition</cell></row><row><cell>if («precondtion(o)») {</cell></row><row><cell>targets.add(o);</cell></row><row><cell>}</cell></row><row><cell>}</cell></row><row><cell>return targets;</cell></row><row><cell>object template */</cell></row><row><cell>«cName» target = null; //initialize target object</cell></row><row><cell>for («cName» o:</cell></row><row><cell>EntityManager.getAllInstancesOf(«cName»)) {</cell></row><row><cell>//finding the object satisfies the condition</cell></row><row><cell>if («precondtion(o)») {</cell></row><row><cell>target = o;</cell></row><row><cell>return target;</cell></row><row><cell>}</cell></row><row><cell>}</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_10"><head>Table 2 The</head><label>2</label><figDesc>Complexity of Requirements Models</figDesc><table><row><cell cols="3">Case Study Actor Use Case</cell><cell>SO</cell><cell cols="4">AO Entity Class Association INV</cell></row><row><cell>ATM</cell><cell>2</cell><cell>6</cell><cell>15</cell><cell>103</cell><cell>3</cell><cell>4</cell><cell>5</cell></row><row><cell>CoCoME</cell><cell>3</cell><cell>16</cell><cell>43</cell><cell>273</cell><cell>13</cell><cell>20</cell><cell>10</cell></row><row><cell>LibMS</cell><cell>7</cell><cell>19</cell><cell>45</cell><cell>433</cell><cell>11</cell><cell>17</cell><cell>25</cell></row><row><cell>LoanPS</cell><cell>5</cell><cell>10</cell><cell>34</cell><cell>171</cell><cell>12</cell><cell>8</cell><cell>12</cell></row><row><cell>Sum</cell><cell>17</cell><cell>51</cell><cell>137</cell><cell>980</cell><cell>39</cell><cell>49</cell><cell>52</cell></row></table><note><p>* Above table shows the number of elements in the requirements model. SO and AO are the abbreviations of system and primitive operations responsibility respectively. INV is the abbreviation of invariant.</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_11"><head>Table 3</head><label>3</label><figDesc>The Generation Result of System Operations MSuccess is the number of SO which is modeled correctly without external event-call, GenSuccess is the number of SO which is successfully generated, SuccessRate = GenSuccess / NumSO.</figDesc><table><row><cell cols="5">Case Study NumSO MSuccess GenSuccess SuccessRate (%)</cell></row><row><cell>ATM</cell><cell>15</cell><cell>15</cell><cell>15</cell><cell>100</cell></row><row><cell>CoCoME</cell><cell>43</cell><cell>41</cell><cell>40</cell><cell>93.02</cell></row><row><cell>LibMS</cell><cell>45</cell><cell>43</cell><cell>42</cell><cell>93.33</cell></row><row><cell>LoanPS</cell><cell>34</cell><cell>30</cell><cell>30</cell><cell>88.23</cell></row><row><cell>Average</cell><cell>34.25</cell><cell>32.25</cell><cell>31.75</cell><cell>93.65</cell></row></table><note><p>*</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_12"><head>Table 4</head><label>4</label><figDesc></figDesc><table><row><cell></cell><cell></cell><cell cols="3">Requirements Errors</cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell cols="2">Requirements Errors</cell><cell></cell><cell></cell></row><row><cell></cell><cell>Name</cell><cell cols="4">Pre-condition Post-condition</cell><cell></cell></row><row><cell></cell><cell>ATM</cell><cell></cell><cell>5</cell><cell>12</cell><cell></cell><cell></cell></row><row><cell></cell><cell>CoCoME</cell><cell></cell><cell>8</cell><cell>23</cell><cell></cell><cell></cell></row><row><cell></cell><cell>LibMS</cell><cell></cell><cell>12</cell><cell>26</cell><cell></cell><cell></cell></row><row><cell></cell><cell>LoanPS</cell><cell></cell><cell>6</cell><cell>21</cell><cell></cell><cell></cell></row><row><cell></cell><cell>Total</cell><cell></cell><cell>31</cell><cell>68</cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell>Table 5</cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell cols="3">Requirements Missing</cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell cols="2">Requirements Missing</cell><cell></cell><cell></cell></row><row><cell>Name</cell><cell cols="6">Actor UseCase SO Entity Class Association INV</cell></row><row><cell>ATM</cell><cell>1</cell><cell>3</cell><cell>9</cell><cell>1</cell><cell>2</cell><cell>3</cell></row><row><cell>CoCoME</cell><cell>1</cell><cell>11</cell><cell>22</cell><cell>5</cell><cell>10</cell><cell>5</cell></row><row><cell>LibMS</cell><cell>4</cell><cell>12</cell><cell>14</cell><cell>11</cell><cell>15</cell><cell>12</cell></row><row><cell>LoanPS</cell><cell>2</cell><cell>3</cell><cell>15</cell><cell>4</cell><cell>2</cell><cell>8</cell></row><row><cell>Total</cell><cell>8</cell><cell>29</cell><cell>60</cell><cell>21</cell><cell>29</cell><cell>28</cell></row><row><cell cols="7">version one the version three, ATM add one actor, three</cell></row><row><cell cols="7">use cases, nine system operations, one entity class, two</cell></row><row><cell cols="7">associations of entity classes, and two invariants. CoCoME</cell></row><row><cell cols="7">adds one actor, eleven use cases, twenty-two system opera-</cell></row><row><cell cols="7">tions, five entity classes, ten associations of entity classes,</cell></row><row><cell cols="7">and five invariants. LibMS adds four actors, twelve use</cell></row><row><cell cols="7">cases, fourteen system operations, eleven entity classes, ten</cell></row><row><cell cols="7">associations of entity classes, and twelve invariants. LoanPS</cell></row><row><cell cols="7">adds two actors, three use cases, fifteen system operations,</cell></row><row><cell cols="7">four entity classes, two associations of entity classes, and</cell></row><row><cell cols="7">eight invariants. Totally, we find 173 missing requirements</cell></row><row><cell cols="7">during the requirements validations and refinements about</cell></row><row><cell cols="7">6 actors, 29 use cases, 60 system operations, 21 entity classes,</cell></row><row><cell cols="6">29 the associations of entity classes, and 28 invariants.</cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_13"><head></head><label></label><figDesc>5 GHz Intel Core i5, 16 GB 1600 MHz DDR3, and 500 GB Flash Storage. The comparison result is presented in Table 6. ATM contains 3897 lines of code, the generation of prototype spends 309.74 ms, in which system operations only spend 2.26 ms, the average coding time of students is 8.3 hours, but developers require 3.2 hours. CoCoME contains 9572 lines 5. https://github.com/AlDanial/cloc</figDesc><table><row><cell></cell><cell></cell><cell></cell><cell>Table 6</cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell cols="2">Prototyping Performance</cell><cell></cell><cell></cell></row><row><cell>Name</cell><cell cols="5">Line of Code Prototype Time (ms) SO Time(ms) Student (hour) Developer (hour)</cell></row><row><cell>ATM</cell><cell>3897</cell><cell>309.74</cell><cell>2.26</cell><cell>8.3</cell><cell>3.2</cell></row><row><cell>CoCoME</cell><cell>9572</cell><cell>788.99</cell><cell>9.78</cell><cell>19.2</cell><cell>10.6</cell></row><row><cell>LibMS</cell><cell>12017</cell><cell>1443.39</cell><cell>18.22</cell><cell>25.1</cell><cell>14.3</cell></row><row><cell>LoanPS</cell><cell>7814</cell><cell>832.78</cell><cell>5.52</cell><cell>16.2</cell><cell>8.4</cell></row><row><cell>Average</cell><cell>8325</cell><cell>843.73</cell><cell>8.95</cell><cell>17.20</cell><cell>9.14</cell></row><row><cell cols="6">of code, generation prototype spend 788.99 ms, the average</cell></row><row><cell cols="6">coding time of students is 19.2 hours, developers need</cell></row><row><cell cols="6">10.6 hours. LibMS includes 12017 lines of code, generation</cell></row><row><cell cols="6">times of prototype is 1443.39 ms, the average coding time</cell></row><row><cell cols="6">of students is 25.1 hours, and developers only spend 14.3</cell></row><row><cell cols="6">hours. LoanPS contains 7814 lines of code, the generation</cell></row><row><cell cols="6">time of prototype is 832.78 ms, the average coding time</cell></row><row><cell cols="6">of student is 16.2 hours, and the developers require only</cell></row><row><cell cols="6">8.4 hours. In average, the case studies contains 8325 lines</cell></row><row><cell cols="6">of code, generation prototype spend 843.73 ms less than 1</cell></row><row><cell cols="6">second, the system operations generations only require 8.95</cell></row><row><cell cols="6">ms, students need 17.20 hours and experienced developers</cell></row><row><cell cols="2">require 9.14 hours.</cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div><head>ACKNOWLEDGMENTS</head><p>This work was supported by <rs type="funder">Macau Science and Technology Development Fund (FDCT)</rs> (No. <rs type="grantNumber">103/2015/A3</rs>) and <rs type="funder">University of Macau</rs> (No. <rs type="grantNumber">MYRG 2017-00141-FST</rs>), <rs type="programName">1000-Expert Program</rs> Grant (No. <rs type="grantNumber">SWU116007</rs>), and <rs type="funder">National Natural Science Foundation of China (NSFC)</rs> (No. <rs type="grantNumber">61472779</rs>, <rs type="grantNumber">61672435</rs> and <rs type="grantNumber">61732019</rs>)</p></div>
			</div>
			<listOrg type="funding">
				<org type="funding" xml:id="_W6XAv8k">
					<idno type="grant-number">103/2015/A3</idno>
				</org>
				<org type="funding" xml:id="_APTPfHm">
					<idno type="grant-number">MYRG 2017-00141-FST</idno>
					<orgName type="program" subtype="full">1000-Expert Program</orgName>
				</org>
				<org type="funding" xml:id="_9uTqaqE">
					<idno type="grant-number">SWU116007</idno>
				</org>
				<org type="funding" xml:id="_uvem6BQ">
					<idno type="grant-number">61472779</idno>
				</org>
				<org type="funding" xml:id="_fkDJ64c">
					<idno type="grant-number">61672435</idno>
				</org>
				<org type="funding" xml:id="_bTVWqyw">
					<idno type="grant-number">61732019</idno>
				</org>
			</listOrg>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0" />			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Tracing requirements errors to problems in the requirements engineering process</title>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">G</forename><surname>Sutcliffe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Economou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Markis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Requirements Engineering</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="134" to="151" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Requirements engineering as a success factor in software projects</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">F</forename><surname>Hofmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Lehner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Software</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="58" to="66" />
			<date type="published" when="2001-07">Jul. 2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Software Engineering</title>
		<author>
			<persName><forename type="first">I</forename><surname>Sommerville</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2015">2015</date>
			<publisher>Addison Wesley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Comparing task practicing and prototype fidelities when applying scenario acting to elicit requirements</title>
		<author>
			<persName><forename type="first">G</forename><surname>Atladottir</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">T</forename><surname>Hvannberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Gunnarsdottir</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Requirements Engineering</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="157" to="170" />
			<date type="published" when="2012-09">Sep. 2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Prototyping in industrial software projects-bridging the gap between theory and practice</title>
		<author>
			<persName><forename type="first">H</forename><surname>Lichter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Schneider-Hufschmidt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Zullighoven</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Software Engineering</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page" from="825" to="832" />
			<date type="published" when="1994-11">Nov. 1994</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">An introduction to rapid system prototyping</title>
		<author>
			<persName><forename type="first">F</forename><surname>Kordon</surname></persName>
		</author>
		<author>
			<persName><surname>Luqi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Software Engineering</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="817" to="821" />
			<date type="published" when="2002-09">Sep. 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">User interface prototyping-concepts, tools, and experience</title>
		<author>
			<persName><forename type="first">D</forename><surname>Baumer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Bischofberger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Lichter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Zullighoven</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE 18th International Conference on Software Engineering (ICSE&apos;96)</title>
		<meeting>IEEE 18th International Conference on Software Engineering (ICSE&apos;96)</meeting>
		<imprint>
			<date type="published" when="1996-03">Mar. 1996</date>
			<biblScope unit="page" from="532" to="541" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Generating essential user interface prototypes to validate requirements</title>
		<author>
			<persName><forename type="first">M</forename><surname>Kamalrudin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Grundy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 26th IEEE/ACM International Conference on Automated Software Engineering (ASE&apos;11)</title>
		<meeting>the 26th IEEE/ACM International Conference on Automated Software Engineering (ASE&apos;11)</meeting>
		<imprint>
			<date type="published" when="2011-11">Nov. 2011</date>
			<biblScope unit="page" from="564" to="567" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Execution of UML models: a systematic review of research and practice</title>
		<author>
			<persName><forename type="first">F</forename><surname>Ciccozzi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Malavolta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Selic</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Software and Systems Modeling</title>
		<imprint>
			<date type="published" when="2018-04">Apr. 2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Using metascribe to prototype a UML to C++/Ada95 code generator</title>
		<author>
			<persName><forename type="first">D</forename><surname>Regep</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Kordon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 11th International Workshop on Rapid System Prototyping (RSP&apos;00)</title>
		<meeting>the 11th International Workshop on Rapid System Prototyping (RSP&apos;00)</meeting>
		<imprint>
			<date type="published" when="2000">2000</date>
			<biblScope unit="page" from="128" to="133" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Automatic code generation from unified modelling language sequence diagrams</title>
		<author>
			<persName><forename type="first">D</forename><surname>Kundu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Samanta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Mall</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IET Software</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="12" to="28" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Generating enterprise applications from models</title>
		<author>
			<persName><forename type="first">V</forename><surname>Kulkarni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Venkatesh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Reddy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 8th International Conference on Object-Oriented Information Systems (OOIS&apos;02)</title>
		<meeting>the 8th International Conference on Object-Oriented Information Systems (OOIS&apos;02)</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="270" to="279" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Formal and use-case driven requirement analysis in UML</title>
		<author>
			<persName><forename type="first">X</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>He</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 25th International Computer Software and Applications Conference (COMPSAC&apos;01)</title>
		<meeting>the 25th International Computer Software and Applications Conference (COMPSAC&apos;01)<address><addrLine>Chicago IL, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="215" to="224" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">A relational model for formal object-oriented requirement analysis in UML</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Jifeng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 5th International Conference on Formal Engineering Methods (ICFEM&apos;2003)</title>
		<meeting>the 5th International Conference on Formal Engineering Methods (ICFEM&apos;2003)<address><addrLine>Berlin; Heidelberg</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="641" to="664" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Refinement and verification in component-based model-driven design</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">P</forename><surname>Ravn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Stolz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Zhan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Science of Computer Programming</title>
		<imprint>
			<biblScope unit="volume">74</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="168" to="196" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Object-oriented software development in UML</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Liu</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002">2002</date>
			<publisher>UN-U/IIST, Macau, Tech. Rep</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">B</forename><surname>Meyer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002">2002</date>
			<publisher>Prentice Hall</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Validation of requirement models by automatic prototyping</title>
		<author>
			<persName><forename type="first">D</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Liu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Innovations in systems and software engineering</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="241" to="248" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">AutoPA: automatic prototyping from requirements</title>
		<author>
			<persName><forename type="first">X</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Schaf</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Yin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Leveraging Applications of Formal Methods, Verification, and Validation</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="609" to="624" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">C</forename><surname>Alexander</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Ishikawa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Silverstein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Ramió</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Jacobson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Fiksdahl-King</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1977">1977</date>
		</imprint>
	</monogr>
	<note>A pattern language. Gustavo Gili</note>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">Design patterns: Elements of reusable object-oriented software</title>
		<author>
			<persName><forename type="first">J</forename><surname>Vlissides</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Helm</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Johnson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Gamma</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1995">1995</date>
			<publisher>Addison-Wesley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">Software Architecture Patterns</title>
		<author>
			<persName><forename type="first">M</forename><surname>Richards</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2015">2015</date>
			<pubPlace>O&apos;Reilly, Sebastopol</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">Patterns of enterprise application architecture</title>
		<author>
			<persName><forename type="first">M</forename><surname>Fowler</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002">2002</date>
			<publisher>Addison-Wesley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">A cookbook for using the modelview controller user interface paradigm in Smalltalk-80</title>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">E</forename><surname>Krasner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><forename type="middle">T</forename><surname>Pope</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Object-Oriented Programming</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="26" to="49" />
			<date type="published" when="1988-08">Aug. 1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">Implementing domain-specific languages with Xtext and Xtend</title>
		<author>
			<persName><forename type="first">L</forename><surname>Bettini</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2016">2016</date>
			<publisher>Packt Publishing Ltd</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Model-driven rapid prototyping with umple</title>
		<author>
			<persName><forename type="first">A</forename><surname>Forward</surname></persName>
		</author>
		<author>
			<persName><forename type="first">O</forename><surname>Badreddin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">C</forename><surname>Lethbridge</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Solano</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Software: Practice and Experience</title>
		<imprint>
			<biblScope unit="volume">42</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="781" to="797" />
			<date type="published" when="2012-07">Jul. 2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">A model-driven methodology for developing secure datamanagement applications</title>
		<author>
			<persName><forename type="first">D</forename><surname>Basin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Clavel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Egea</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">A G</forename><surname>De Dios</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Dania</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Software Engineering</title>
		<imprint>
			<biblScope unit="volume">40</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="324" to="337" />
			<date type="published" when="2014-04">Apr. 2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Model driven security: From UML models to access control infrastructures</title>
		<author>
			<persName><forename type="first">D</forename><surname>Basin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Doser</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Lodderstedt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Software Engineering and Methodology</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="39" to="91" />
			<date type="published" when="2006-01">Jan. 2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Automated prototyping of user interfaces based on UML scenarios</title>
		<author>
			<persName><forename type="first">M</forename><surname>Elkoutbi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Khriss</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">K</forename><surname>Keller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Automated Software Engineering</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="5" to="40" />
			<date type="published" when="2006-01">Jan. 2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">The OO-method approach for information systems modeling: from object-oriented conceptual modeling to automated programming</title>
		<author>
			<persName><forename type="first">O</forename><surname>Pastor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Gómez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Insfrán</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Pelechano</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information Systems</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="507" to="534" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Round-trip prototyping based on integrated functional and user interface requirements specifications</title>
		<author>
			<persName><forename type="first">A</forename><surname>Homrighausen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H.-W</forename><surname>Six</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Winter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Requirements Engineering</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="34" to="45" />
			<date type="published" when="2002-04">Apr. 2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Combined analysis of user interface and domain requirements</title>
		<author>
			<persName><forename type="first">G</forename><surname>Kosters</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">W</forename><surname>Six</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Voss</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2th International Conference on Requirements Engineering (RE&apos;96)</title>
		<meeting>the 2th International Conference on Requirements Engineering (RE&apos;96)</meeting>
		<imprint>
			<date type="published" when="1996-04">Apr. 1996</date>
			<biblScope unit="page" from="199" to="207" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
		<title level="m" type="main">Visual Paradigm for UML -UML tool for software application development</title>
		<author>
			<persName><forename type="first">V</forename><surname>Paradigm</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
	<note>Visual paradigm for UML</note>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Papyrus UML: an open source toolset for mda</title>
		<author>
			<persName><forename type="first">A</forename><surname>Lanusse</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Tanguy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Espinoza</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Mraidha</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Gerard</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Tessier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Schnekenburger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Dubois</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Terrier</surname></persName>
		</author>
		<idno>ECMDA-FA&apos;09</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 5th European Conference on Model-Driven Architecture Foundations and Applications</title>
		<meeting>the 5th European Conference on Model-Driven Architecture Foundations and Applications</meeting>
		<imprint>
			<publisher>Citeseer</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="1" to="4" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">USE: a UML-based specification environment for validating UML and OCL</title>
		<author>
			<persName><forename type="first">M</forename><surname>Gogolla</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Büttner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Richters</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Science of Computer Programming</title>
		<imprint>
			<biblScope unit="volume">69</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="27" to="34" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">rCOS: refinement of component and object systems</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Jifeng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Li</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 3th Formal Methods for Components and Objects (FMCO&apos;04)</title>
		<meeting>the 3th Formal Methods for Components and Objects (FMCO&apos;04)</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="page" from="183" to="221" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">rCOS: a refinement calculus of object systems</title>
		<author>
			<persName><forename type="first">H</forename><surname>Jifeng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Liu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">365</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="109" to="142" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">rCOS: a formal model-driven engineering method for component-based software</title>
		<author>
			<persName><forename type="first">W</forename><surname>Ke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Stolz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Frontiers of Computer Science</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="17" to="39" />
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
