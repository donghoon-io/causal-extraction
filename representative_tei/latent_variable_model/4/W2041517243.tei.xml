<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">An Architecture for Parallel Topic Models</title>
				<funder>
					<orgName type="full">Australian Research Council</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Alexander</forename><surname>Smola</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Yahoo! Research</orgName>
								<orgName type="institution">Australian National University</orgName>
								<address>
									<settlement>Santa Clara Canberra</settlement>
									<region>CA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author role="corresp">
							<persName><forename type="first">Shravan</forename><surname>Narayanamurthy</surname></persName>
							<email>shravanm@yahoo-inc.com</email>
							<affiliation key="aff1">
								<orgName type="institution">Yahoo! Labs</orgName>
								<address>
									<addrLine>Bangalore Torrey Pines Road</addrLine>
									<settlement>Bangalore</settlement>
									<country key="IN">India</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">An Architecture for Parallel Topic Models</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.1" ident="GROBID" when="2025-10-14T17:31+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This paper describes a high performance sampling architecture for inference of latent topic models on a cluster of workstations. Our system is faster than previous work by over an order of magnitude and it is capable of dealing with hundreds of millions of documents and thousands of topics.</p><p>The algorithm relies on a novel communication structure, namely the use of a distributed (key, value) storage for synchronizing the sampler state between computers. Our architecture entirely obviates the need for separate computation and synchronization phases. Instead, disk, CPU, and network are used simultaneously to achieve high performance. We show that this architecture is entirely general and that it can be extended easily to more sophisticated latent variable models such as n-grams and hierarchies.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Latent variable models are a popular tool for encoding long-range dependencies between collections of observations. For instance, when dealing with documents it is highly desirable to go beyond a simple weighted bag-of-words representation and to take co-occurrence information between words in a document into account. Similarly for the purpose of inferring similarity in social networks and recommender systems it is desirable to obtain compact representations.</p><p>Clustering and topic models are particularly useful since they allow one to infer structure from large collections of objects without the need of (much) human intervention. Latent Dirichlet Allocation (LDA) <ref type="bibr" target="#b3">[3]</ref> and related topic models are particularly useful when it comes to infer overall groups of information (e.g. the information that a particular text contains information about an 'athlete' and a 'scandal', whereas clustering is better suited inferring that a given set of documents refers to the 'Tiger Woods scandal'. In other words, clustering attempts to model objects as one out of n possible classes, whereas topic models represent objects as a mixture of k out of n possible classes (with k being variable but small). It is easy to see from a coding theory point of view that the latter leads to a much more parsimonious representation of an object generation model.</p><p>While such models have found widespread use in academia their deployment in industry is largely hampered by limits on scalability. More specifically, the largest published work on LDA by the UC Irvine team <ref type="bibr">[7]</ref> is to use 1000 computers for 10 hours to process 8 Million documents taken from PubMed abstracts, which is equivalent to a processing speed of 6,400 documents per computer and hour. By comparison, our implementation is able to generate a model at a rate in excess of 75,000 documents per hour on a single 8-core computer and of 42,000 documents per hour when used in a multi-machine configuration. Google's LDA implementation <ref type="bibr" target="#b9">[9,</ref><ref type="bibr">Table 6b</ref>] has a throughput of less than 150 documents per hour and machine (assuming 1000 collapsed sampler iterations) in the most favorable case.</p><p>Outline: We begin with an overview over the mathematical model underlying Latent Dirichlet Allocation and a discussion of efficient sampling algorithms in Section 2. We proceed with a description of the multicore/cluster pipeline architecture in Section 3 and its implementation in Section 4. We demonstrate the efficiency in multi-machine and multicore experiments in Section 5. Related work and further implementation details are given in the appendix.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">LATENT DIRICHLET ALLOCATION</head><p>We give a brief overview of topic models in the context of text modeling (note, though, that the algorithm and our implementation are in no way limited to documents). For a much more detailed discussion see <ref type="bibr" target="#b3">[3,</ref><ref type="bibr" target="#b6">6]</ref>.</p><p>The basic idea is that each document contains a mix of topics from which words are drawn. The generative process works as follows: for a document d a multinomial distribution Θi is drawn from a Dirichlet prior with parameters α. Subsequently, for each word in the document a topic zij is drawn from the multinomial distribution Θi. Finally, the word wij is drawn from the multinomial distribution Ψz ij . To complete the mode specification we assume that Ψ itself is drawn from a Dirichlet with coefficients β. <ref type="foot" target="#foot_0">1</ref>Given the model of Figure <ref type="figure" target="#fig_0">1</ref> we may express the full joint Here p(wij|zij, ψ) and p(zij|Θi) are multinomial distributions and the remaining two distributions are Dirichlet. We could impose a hyperprior on α and β as needed. That said, empirical evidence shows that simply performing a maximum likelihood fit is sufficient.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Collapsed Representation</head><p>A direct Gibbs sampler using (1) does not mix sufficiently quickly and an improved strategy is to integrate out Θ and ψ. Moreover, collapsed sampling <ref type="bibr" target="#b10">[10,</ref><ref type="bibr" target="#b9">9,</ref><ref type="bibr">7]</ref> tends to lead to somewhat better models than a variational approach. Most importantly, it allows for a much more compact representation of the model whenever the number of parameters is large -it is only necessary to store the sparse vector of statistics for topics actually assigned to words -in the variational or non-collapsed case case dense vectors are required.</p><p>To introduce the collapsed representation we need to define a number of statistics of the topic assignments zij: n(t, w) := Here n(t, w) keeps a list of the topic assignments on a per-word basis. n(t) stores the total of number of times a word is assigned topic t. n(t, d) stores topic assignments in a given document. n(t, w) and n(t, d) are sparse. We have</p><formula xml:id="formula_0">p(w, z|α, β) (2) = m i=1 k j=1 Γ(αj + n(t = j, d = i)) Γ ( ᾱ + n(d = i)) Γ( ᾱ) k j=1 Γ(αj) topic likelihood × k i=1 W j=1 Γ(βj + n(t = i, w = j)) Γ β + n(t = i) Γ( β) W j=1 Γ(βj)</formula><p>word likelihood</p><p>Here ᾱ := i αi and β := w βw are aggregates of the Dirichlet smoothing coefficients. Quite often one sets β = β0 • N where N denotes the number of words. This corresponds to a flat probability model for words. While this design choice is quite unrealistic it turns out not to matter significantly in practice <ref type="bibr" target="#b8">[8]</ref>. Nonetheless it is easy to adjust the sampler we discuss to a more adaptive prior. Note that the factors in the products k j=1 and W j=1 only need to be evaluated whenever n(t, d) &gt; 0 and n(t, w) &gt; 0 respectively.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Inference for z via Collapsed Sampling</head><p>Following <ref type="bibr" target="#b6">[6]</ref> we can rewrite (2) to obtain the following unnormalized probabilities to resample the topic z dj for the word w dj in document d:</p><formula xml:id="formula_1">p(t|w dj , rest) ∝ [n(t, w dj ) + βw] [n(t, d) + αt] n(t) + β<label>(3)</label></formula><p>Eq. ( <ref type="formula" target="#formula_1">3</ref>) can be used in a Gibbs sampler which traverses the set of observations and resamples the values of z dj . In terms of locality, the following observations are useful, since they allow us to design parallel samplers by prioritising updates: The key idea in designing our sampler is that when resampling on a per document basis, we may defer updates to n(t, w) and n(t) until after a document has been resampled. This means that only the topic-document counts n(t, d) change. Such a strategy has been discussed by <ref type="bibr" target="#b10">[10]</ref> in the context of generating samples for a test distribution. Instead, we use it here to design a sampler for inference of the full model. We decompose (3) into</p><formula xml:id="formula_2">p(t|w dj ) ∝ βw αt n(t) + β + βw n(t, d) n(t) + β + n(t, w dj ) [n(t, d) + αt] n(t) + β</formula><p>The first term in the sum only depends on w dj in a multiplicative fashion via βw dj and it is constant throughout the document otherwise. The second term is typically sparse as it counts the distribution of topics in a document. Moreover, only two terms need updating whenever we reassign a word to a new topic. Finally, the third term is as sparse as the topic distribution per word. This shows that in order to compute a proper normalization of p(t|w dj ) one only needs to compute a normalization for each of the three terms separately. This is cheap since, besides an initial cost for computing A :=  . Here the following comes to our aid: only the frequently occurring words (which are likely to occur several times per document, hence we only need to compute the normalization once) are likely dense.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Inference for α and β</head><p>Computing p(w, z|α, β) requires one pass through the data (or at least access to n(t, d) for all documents) and one pass through the word-topic table for computation of the likelihood. In particular, the data-dependent term decomposes into a sum over terms which depend on one document at a time. The word dependent contribution decomposes into a product over terms depend on a single topic each.</p><p>Optimizing α: While in principle we could use a sampler to obtain α and β, it is much easier to employ simple (stochastic) convex optimization techniques for hyperparameter adjustment. In order for this to work we need to assume that data is provided in random order. <ref type="foot" target="#foot_1">2</ref> For convenience we denote by</p><formula xml:id="formula_3">γ(x) := ∂x log Γ(x) = Γ -1 (x)∂xΓ(x)<label>(4)</label></formula><p>the derivative of the log-gamma function, sometimes also referred to as the Digamma function. Using (2) we obtain</p><formula xml:id="formula_4">∂α j -log p(w, z|α, β)<label>(5)</label></formula><formula xml:id="formula_5">= m i=1 γ(αj) -γ(αj + n(t = j, d = i)) + γ( ᾱ + n(d = i)) -γ( ᾱ)</formula><p>Here the difference between the first two terms is nonvanishing only if n(t, d) = 0 -otherwise they are identical. This suggests a stochastic gradient descent procedure of the form</p><formula xml:id="formula_6">αi ← αi -η γ(αj)-γ(αi + n(t = i, d)) evaluate only if n(t = i, d) = 0 + γ( ᾱ + n(d))-γ( ᾱ)</formula><p>same value for all i This is obtained simply by canceling out terms in denominator and numerator where n(t, d) = 0 and n(t, w) = 0 respectively. It allows us to evaluate the normalization for sparse count tables with cost linear in the number of nonzero coefficients. Moreover, it ensures that for sufficiently large collections of documents even a single pass suffices to obtain a good value of α ([10] use gradient descent which may be slow for large collections of data). Here ηi = 1 √ const.+i is a decreasing step length.</p><p>Carrying out updates after each document is inefficient since the only meaningful signal in (5) occurs whenever a topic actually occurs in a document. To address this we aggregate gradients over a range τ of topics before carrying out updates (with a suitably rescaled step length).</p><p>Optimizing β: Unfortunately stochastic gradient descent is not applicable for optimizing β. In the simplest case we may assume a multiplicative form</p><formula xml:id="formula_7">βw = β0 • βw and hence β = β0 • B where B = w βw (6)</formula><p>where we can optimize over the overall smoothing weight β0 by gradient descent or a suitable second-order method. Since the objective is convex this is guaranteed to converge.</p><p>The computation of the gradient, though, is rather costly -we need to sum over all topics and words with nonzero n(w, t) in the topic-word table. This is best achieved at the same time as when performing likelihood computations since they, too, require a pass over β. We have</p><formula xml:id="formula_8">∂ β 0 [-log p(w, z|α, β)] = n(t,w) =0 βw [γ(βw) -γ(βw + n(t, w))] + B n(t) =0 γ( β + n(t)) -γ( β)</formula><p>Updates of β0 occur via β0 ← β0 -η∂ β 0 [-log p(w, z|α, β)] for a decreasing update rate η.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Variational Optimization</head><p>At test time (once the model has been obtained) it is often desirable to have a fast mechanism for estimating the topic probabilities for a given document. We can express the likelihood of a given document via</p><formula xml:id="formula_9">p(w, θ| ᾱ, Ψ) ∝ n j=1 k i=1 θi Ψiw j • k i=1 θ α i i (7)</formula><p>where Ψ encodes smoothed probability estimates via Ψtw = βw +n(t,w) β+n(t) . Using an exponential families θ l = exp(γ l -g(γ)) where g(γ) = log j exp γj and ∂γ j log θ l = δ l,j -θj yields the following gradients of p(w, θ| ᾱ, Ψ) with respect to γ:</p><formula xml:id="formula_10">∂γ l [. . .] = n j=1 θ l Ψlw j k i=1 θ i Ψ iw j + α l -[n + ᾱ] θ l<label>(8)</label></formula><p>which leads to the following update equations</p><formula xml:id="formula_11">θ l ← [n + ᾱ] -1 w n(d, w) θ l Ψlw k i=1 θ i Ψ iw + α l .</formula><p>Here we rearranged the summation such as to perform only one update per distinctly occurring word wj, thereby accelerating summation by a factor of 2-3. Note that the same trick can be applied to the collapsed Gibbs sampler, that is, sampling all topics for a given word in a row.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">PARALLELIZATION</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Design Considerations</head><p>In its uncollapsed form LDA is quite trivial to parallelize -simply sample from the topic assignments for all documents and subsequently (in a central pass) resample the topic priors and the word model. The problem is that this representation is slow mixing, hence the collapsed sampler. Implementations such as Mallet <ref type="bibr" target="#b10">[10]</ref> and the UCI LDA code <ref type="bibr">[7]</ref> make a key approximation: given k processors it is acceptable to partition a collection of n documents into k blocks which are processed independently. After each pass the document statistics are synchronized in a separate step. This approach has some disadvantages:</p><p>• The network remains unused while sampling proceeds.</p><p>Subsequently peak demands on bandwidth are exerted. • Due to a number of reasons (system, disk access, general job load, sampler burn-in) the time to process k documents may differ widely. Waiting for the last processor to finish before synchronization can occur, introduces potentially long idle times. • On multiprocessor systems this automatically leads to an O(k) increase in allocated memory and thereby outof-memory situations when many cores are involved. • Partitioning creates delay between synchronizations. We address this problem in two steps: firstly we introduce an approximation which allows us to decouple instant updates between different processor cores by a joint deferred update mechanism. Secondly, we introduce a blackboardstyle architecture to facilitate simultaneous communication and sampling between different computers in a cluster environment. Both approximations allow us to perform sampling, updating, disk access, and network access simultaneously without the need for synchronization delay. In particular we will see that the memory requirement for k processor cores is O(1) and that, moreover, the communications load in the cluster setting is O(1) for each workstation involved with an O(1/k) overhead in memory allocation per machine.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Pipeline Architecture for Multicore</head><p>The key idea for parallelizing the sampler in the multicore setting is that the global topic distribution and the topicword table (which we will refer to as state of the system) change only little given the changes in a single document (we may have millions of documents). Hence, we can assume that n(t) and n(t, w) are essentially constant while sampling topics for a document. This means that there is no need to update n(t) and n(t, w) during the sampling process and we can defer this action to a separate synchronization thread which takes action once a document has been entirely resampled. Consequently we can execute a large number of sampling threads simultaneously.</p><p>Figure <ref type="figure" target="#fig_3">2</ref> describes the data flow in the sampler. Words and topic assignments are stored in two separate files which are merged by the first filter. The combined documents are processed by a number of sampling threads executed in parallel. Each of these threads accesses the joint state variables n(t) and n(t, w) by acquiring a read lock before requesting their values. After processing an entire document, the list of changes in n(t, w) and n(t) is sent to the count updater filter. Since updates are considerably cheaper we found it sufficient to implement the latter in a single thread (there is no in-principle reason not to parallelize the updater thread as well, if required). While documents are being processed we can perform further diagnostics (e.g. we may compute the perplexity), and finally, a separate filter writes the new topic assignments to file. This has several advantages:</p><p>• We only need a single set of state variables n(t, w) and n(t) per computer rather than per core. This dramatically reduces the memory requirements per machine (relative to Mallet which keeps a copy per core -in our experiments Mallet reached its scalability limit at 300,000 documents and 1000 topics). </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Blackboard Architecture for Clusters</head><p>When deploying LDA on multiple machines in a cluster we face the problem that it is impossible to keep the state table entirely synchronized between different computers. However, the strategy to synchronize only after each pass through data has a number of drawbacks, most importantly that all samplers need to wait for the slowest.</p><p>An alternative is to use a blackboard architecture similar in spirit to decomposition methods from optimization <ref type="bibr" target="#b4">[4]</ref>. The key idea is to have a global consensus of the state variables and to reconcile their values one word at a time asynchronously for all samplers. The advantage is that no synchronization (short of locking the very word whose statistics are being updated) is required between samplers. Moreover, we can parallelize communication and storage by means of a distributed (key,value) storage using memcached. For n servers and n clients the network load is O(1) per server and the memory requirements for storing a given amount of information over n servers is O(n -1 ).</p><p>We now specify the communications protocol in more detail: first, there is no need to synchronize n(t) and n(t, w) separately or even to store n(t) globally at all. After all n(t) = w n(t, w) and therefore any update on n(t, w) can immediately be used to update n(t). For the purpose of the algorithm we assume that at some point all samplers have the same identical state as the global state keeper.</p><p>Denote  Note that this communications template could be used in a considerably more general context: the blackboard architecture supports any system where a common state is shared between a large number of systems whose changes affect the global value of the state. For instance, we may use it to synchronize parameters in a stochastic gradient descent scenario by asynchronously averaging local and global parameter values as is needed in dual decomposition methods. Likewise, the same architecture could be used to perform message passing <ref type="bibr" target="#b1">[1]</ref> whenever the junction tree of a graphical model has star topology. By keeping copies of the old messages local (represented by n i old ) on the nodes it is possible to scale such methods to large numbers of clients without exhausting memory on memcached.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">IMPLEMENTATION</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Basic Tools</head><p>We use Google's protobuf<ref type="foot" target="#foot_2">foot_2</ref> with optimization set to favor speed, since it provides disk-speed data serialization with little overhead. Since protobuf cannot deal well with arbitrary length messages (it tries loading them into memory entirely before parsing) we treat each document separately as a message to be parsed. To minimize write requirements we store documents and their topic assignments separately.</p><p>Data flow in terms of documents is entirely local. On each machine it is handled by Intel's Threading-Building-Blocks<ref type="foot" target="#foot_3">foot_3</ref> library since it provides a convenient pipeline structure which automatically handles parallelization and scheduling for multicore processors. Locking between samplers, updaters, and synchronizers is handled by a read-write lock (spinlock) -the samplers impose a non-exclusive read lock while the update thread imposes an exclusive write lock.</p><p>The asynchronous communication between a cluster of computers is handled by memcached<ref type="foot" target="#foot_4">foot_4</ref> servers which run standalone on each of the computers and the libmemcached client access library which is integrated into the LDA codebase. The advantage of this design is that no dedicated server code needs to be written. A downside is the high latency of memcached, in particular, when client and server are located on different racks in the server center. Given the modularity of our design it would be easy to replace it by a service with lower latency, such as RAMCloud once the latter becomes available. In particular, a versioned write would be highly preferable to the current pessimistic locking mechanism that is implemented in Algorithm 1 -collisions are far less likely than successful independent updates. Failed writes due to versioned data, as they will be provided in RAMCloud would address this problem.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Data Layout</head><p>To store the n(t, w) we use the same memory layout as Mallet. That is, we maintain a list of (topic, count) pairs for each word w sorting in order of decreasing counts. This allows us to implement a sampler efficiently (with high probability we do not reach the end of the list) since the most likely topics occur first. Random access (which occurs rarely), however, is O(k) where k is the number of topics with nonzero count. Our code requires twice the memory footprint as that of Mallet (64bit rather than 32bit per (topic, count) pair) since for millions of documents the counters would overflow.</p><p>The updater thread receives a list of messages of the form (word, old topic id, new topic id) from the sampler for every document (see Figure <ref type="figure" target="#fig_0">1</ref>). Whenever the changes in counts do not result in a reordering of the list of (topic, count) pairs and update is carried out without locking. This is possible since on modern x86 architectures updates of 32bit integers are atomic provided that the data is aligned with the bus boundaries. Whenever changes necessitate a reordering we acquire a write lock (any sampler using this word at the very moment stalls at this point) before effecting changes. Since counts change only by 1 it is unlikely that (topic, count) pairs move far within the list. This reduces lock time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Initialization and Recovery for Multicore</head><p>At initialization time no useful topic assignment exists and we want to assign topics at random to words of the documents. This can be accommodated by a random assignment sampler as described in the diagram below: In particular, the file combiner and the output routine are identical. Obviously this could be replaced with a more sophisticated initialization, e.g. by a system trained on a smaller dataset. When recovering from failure the multicore system simply loads the topic assignments from file and it rebuilds n(t, w) and n(t) with code identical to that used for initialization. The key difference is that obviously for this purpose no sampler is required.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Initialization for Cluster Parallelism</head><p>Our discussion in Section 3.3 assumed that at some point the state tables were synchronized. This requires synchronization between all clients. We use the following protocol:</p><p>Local Initialization (stage 0): We assume that initially all clients have a list of the IP numbers of all other clients involved. <ref type="foot" target="#foot_5">6</ref>  Note that while each machine locally generates a dictionary to store a tokenized version of its documents for the purpose of a compressed representation, synchronization between machines occurs by using the words directly. That is, rather than synchronizing the topic counts for token 42 we synchronize the topic counts for the word 'hitchhiker'. The reason is that the dictionaries of local machines may differ widely and we want to avoid the need to synchronize them. Moreover, this way we can control the size of each local (token, word) dictionary simply by not allocating too many documents to each computer (the size of a unified dictionary would grow with the number of documents). This is particularly useful if different computers process different corpora: the local dictionaries can be much smaller than their union.</p><p>Local State Synchronization (stage 2): After stage 1 each computer sets (IP, 'stage 2') in memcached and starts polling memcached until all other computers on the cluster also have reached stage 2. This is important since only then we have the guarantee that all counts of all computers have been merged. After that we retrieve all n(t, w) pairs that occur in the local collection and we set</p><formula xml:id="formula_12">n i old (t, w) = n i (t, w) = n(t, w)</formula><p>Sampling (stage 3): After stage 2 each computer sets (IP, 'stage 3') in memcached and starts sampling. Note that there is no need to wait for all other computers to finish their local state synchronization. After all, if any global updates occurred they did not affect any state assignments of the client and therefore the state variables remain consistent. The code concludes by setting (IP, 'stage 4') to indicate completion of the algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">EXPERIMENTS</head><p>In our experiments we investigate a number of aspects of our pipelined and memcached-based algorithm. There are three main questions that require answering: a) how well does the algorithm perform compared to existing implementations, b) does the model degrade with an increase in the number of computers, c) how scalable is the code. We begin with a competitive overview. Note that it is impossible for us to evaluate performance directly on many of the datasets used by competing algorithms since they are proprietary (e.g. Google's Orkut network). However, we compared our algorithm on Pubmed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Performance Overview</head><p>In order to obtain a fair performance comparison we need to normalize throughput between different implementations. When in doubt, we upconverted the approximation in favour of the competing algorithms (e.g. document size, number of documents, number of topics). We normalize data to 1000 collapsed Gibbs sampling iterations on a documents per machine hour basis.</p><p>PLDA: The results reported in <ref type="bibr" target="#b9">[9]</ref> were carried out on two datasets -a Wikipedia subset of 2.12 million documents, using 500 topics and 20 iterations, and the Orkut dataset of 2.45 million 'documents' using 500 topics and 10 iterations. The most favourable results were the throughput rates of <ref type="bibr" target="#b9">[9,</ref><ref type="bibr">Table 6a</ref>] in the case of 16 machines -11940s for 20 iterations on 2.12 million documents. This is equivalent to a per-machine throughput of 800 documents per hour and machine (at an average document size of 210 tokens, hence smaller than the news dataset we used in our experiments). The least favourable results are 65 documents per hour and machine (for 10 iterations on the forum dataset on 1024 machines). We (reasonably) assumed that an increase in the number of topics would only slow down the code.</p><p>UC Irvine: The results reported in <ref type="bibr">[7]</ref> cover a number of datasets. Unfortunately, the authors focus mainly on speedup via parallelization rather than raw speed. The fixed number available was that for 2000 topics and 1024 processors it took 10 hours on 8.2 million documents. Note that the documents were quite short (less than 100 words per document and with a very limited vocabulary). Assuming comparable speed (IBM Power4+ 8 core) this amounts to a throughput of 6,400 documents per computer hour. <ref type="bibr">[7,</ref><ref type="bibr">Sec. 5</ref>] also argue that their code would require 300 days on a single computer (incorporating the parallelization penalty).</p><p>Our Codebase: Since some of the datasets from <ref type="bibr" target="#b9">[9]</ref> were unavailable and others (such as the NIPS collection) were too small for our purpose we used the following data for comparison purposes: a collection of 20 million news documents, each of them containing on average over 300 words and secondly the Pubmed collection, containing 8.2 million documents with an average length of 90 words each. Minimal processing was applied to the documents (we removed all non-ASCII characters and all words of two characters or less). For our experiments we used both workstations with server grade  <ref type="table">3</ref>: Runtime for multi machine execution (1000 topics for news, 2000 topics for pubmed, 1000 Gibbs sampler iterations each) when keeping the number of documents per processor fixed at 200,000.</p><p>iments (hence we had no guarantee of exclusive ownership of the system). This is reflected in the slight fluctuations in throughput as seen in Table <ref type="table">3</ref>. Overall, on PubMed we achieved a throughput between 29k and 70k documents per hour and machine. In particular, for a comparable runtime of 9 hours our codebase is approximately 8x faster than the UCI implementation. This despite the fact that the system was being used for production work simultaneously without the guarantee of being able to use any of the nodes exclusively. On longer documents the performance results are similar. Note that document length is not as significant as expected. This is due to the decomposition of sampling effort into a document and word independent part and additional sparse parts which are cheap to compute.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Scalability</head><p>To test scalability we performed three types of experiments: a) we need to establish scalability in terms of the number of documents. b) we need to establish scalability in terms of a speedup in runtime as we increase the number of computers available. c) we need to show that as we have more computers we are able to process more data in a given time frame. The latter is the most relevant aspect in practice -as the amount of data in the server center grows we want to be able to increase our processing ability.</p><p>For the first experiment we ran LDA for 1000 Gibbs sampler iterations on Pubmed and the news dataset on a single 8 core workstation. A slight increase in per-document runtime is to be expected: as we obtain more documents the number of topics with nonzero n(t, w) per word increases and with it the time spent in sampling. In fact, we see initial gains in scalability in Table <ref type="table" target="#tab_6">1</ref> as we move to larger datasets.</p><p>A second experiment tested scalability by carrying out runtime experiments on a production Hadoop cluster. Since there was other regular activity ongoing while we ran our experiments (i.e. disk access, some background processing from other threads) we usually were not able to make full use of all 8 cores on the computers. Moreover, network connectivity between racks is less than 1Gb/s (our code was sharing the network with production jobs) and latency is increased due to the need to pass more than one switch. The latter adversely affects the synchronization time via memcached.</p><p>Finally, for the most realistic test (see Table <ref type="table">3</ref>) we fixed the number of documents per machine and measured throughput as a function of increasing sample size. The processing time per document increases considerably (by a factor of 2.5) as we increase the amount of data hundredfold and accordingly as we move from 1 computer to 100 computers. This is due to a number of reasons -the model becomes more complex (as can be seen by the increase in the initial number of topics assigned to each word). Secondly, we encounter more off-rack network traffic. To ensure sufficiently fast synchronization more threads need to be dedicated to communication with memcached rather than sampling. These additional threads increase the amount of cache misses for the samplers thus slowing them down. Thirdly, we switched from a singlemachine scheme which did not require any network I/O to one which required network I/O.  The single machine results were carried out on 1 million documents whereas the multi-machine results were obtained on 100 machines on the full datasets. From left to right: (single machine, pubmed), (single machine, news), (multi machine, pubmed), (multi machine, news).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Model Quality</head><p>Obviously there is no point in parallelizing inference if the model quality should suffer. Hence we computed the log-likelihood scores for increasing sample size. Using 2M documents (see Table <ref type="table" target="#tab_8">4</ref>) we see that the log-likelihood scores remain constant or possibly increase ever so slightly. This increase is likely due to the fact that (for reasons of convenience) we optimize over α separately for each computer, hence small changes in the distribution of topics between different chunks of data are likely exploited by slightly different optimal values of α.  We see the latter as a feature of our system (rather than a defect): in practice it is not uncommon to receive data obtained from different sources (e.g. Wikipedia vs. high quality webpages vs. general web). While we may wish to analyze all data based on the same language model, it is quite likely that the distribution of topics differs between these sources. In this case, a different prior over topic distributions per group is a natural statistical modelling choice. Figure <ref type="figure" target="#fig_6">4</ref> shows convergence in log-likelihood for single machine and multimachine runs. Note that initial convergence of the overall model is slightly slower since it takes some time to synchronize the language model between the computers -the document likelihood peaks around 25-50 documents. This is partly also due to the fact that we optimize the document model (i.e. the α parameters) only every 25 iterations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">SUMMARY AND DISCUSSION</head><p>In this work we proposed two novel parallelization paradigms for Latent Dirichlet Allocation: a decoupling between sampling and state updates for multicore and a blackboard architecture to deal with state synchronization for large clusters of workstations. We believe that of those two innovations the blackboard architecture is the more significant one as it is entirely general and can be used to address general large scale systems which share a common state. This work is complementary to recent progress on efficient inference in graphical models <ref type="bibr" target="#b5">[5]</ref>. The latter focus on message passing algorithms where the entire model is small enough to fit into (distributed) main memory whereas our approach is specifically geared towards models where only an intersection of shared state variables needs to be exchanged and where the data considerably exceeds the amount of memory available for estimation.</p><p>In this sense a combination of <ref type="bibr" target="#b5">[5]</ref> and the blackboard style approach presented in this paper are a good fit, allowing one to solve inference problems efficiently in memory whenever they are small enough to fit into main memory and to decompose the remainder via a set of tightly coupled (via asynchronous communication) cluster nodes.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Latent Dirichlet Allocation: words wij in a document i are drawn according to the topic-specific distributions ψz ij . The topic distribution per document Θi is drawn from a conjugate Dirichlet. The same applies to ψ.</figDesc><graphic coords="2,88.39,58.40,118.10,89.06" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>i,j {zij = t and wij = w} ; n(t, d) := j {z dj = t} and n(t) := w n(t, w).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>t</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: LDA Pipeline. Each module in the pipeline is implemented as a filter and executes in parallel.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Each sampler keeps on processing the subset of data associated with it. Simultaneously a synchronization thread keeps on reconciling the local and global state tables.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 4 :</head><label>4</label><figDesc>Figure4: Convergence properties for single and multi-machine LDA. The single machine results were carried out on 1 million documents whereas the multi-machine results were obtained on 100 machines on the full datasets. From left to right: (single machine, pubmed), (single machine, news), (multi machine, pubmed), (multi machine, news).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>Topic assignments z dj : The values of the variables zij are entirely local to each document and need not be shared. They can be written to disk after resampling. Topic counts for document n(t, d): These variables are local to document d. Again, they need not be shared.</figDesc><table><row><cell>Topic-word count table n(t, w): These variables change</cell></row><row><cell>slowly -for 1 million documents it is unlikely that</cell></row><row><cell>changing the topic assignments in a single document</cell></row><row><cell>will have a significant effect on n(t, w) for almost all</cell></row><row><cell>words. Hence, a modest delay in incorporating changes</cell></row><row><cell>occurring in a document into n(t, w) is acceptable.</cell></row><row><cell>Topic counts n(t): This variable is even more slowly vary-</cell></row><row><cell>ing. A delay in obtaining an up-to-date representation</cell></row><row><cell>of n(t) will not affect the sampler significantly.</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>•</head><label></label><figDesc>The state is by definition always synchronized besides a minimal delay given by the documents that are being processed and whose new topic assignments are not yet integrated into the state table. • It entirely avoids a second synchronization stage. • The samplers never need to acquire write lock -they only read n(t) and n(t, w). Since our counters are 32 bit integers updates are atomic and consequently the updater usually can avoid acquiring write locks, thus dramatically reducing the number of samplers stalled due to lock contention. More on this in Section 4.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>by n(t, w) the current global state as stored in memcached, by n i (t, w) the current local state, and by n i old (t, w) a copy of the old local state at the time of synchronization with the global state keeper. Then the following algorithm keeps the topic word counts synchronized. Algorithm 1 incorporates any local changes in n i (t, w) that occurred since the last update into its global counterpart. Subsequently it sets n i to match the new consensus state and it updates n i old = n i to take a snapshot of the state variables at the time of synchronization. Since this process Algorithm 1 State Synchronization Initialize n(t, w) = n i (t, w) = n i old (t, w) for all i. while sampling do Lock n(t, w) globally for some w. Lock ni(t, w) locally. Update n(t, w) = n(t, w) + n i (t, w) -n i old (t, w) Update n i (t, w) = n i old (t, w) = n(t, w) Update local n i (t). Release ni(t, w) locally.Release n(t, w) globally. end while is happening one word at a time the algorithm does not induce deadlocks in the sampler. Moreover, the probability of lock contention between different computers is minimal (we have &gt; 10 6 distinct words and typically 10 2 computers with less than 10 synchronization threads per computer). Note that the high number of synchronization threads (up to 10) in practice is due to the high latency of memcached.</figDesc><table><row><cell>sampler</cell><cell>sampler</cell><cell>sampler</cell><cell>sampler</cell></row><row><cell cols="4">memcached memcached memcached memcached</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head></head><label></label><figDesc>At startup the clients set (IP, 'stage 0') as a (key, value) pair in memcached. Subsequently they independently build a local topic assignment table as described in Section 4.3.State Aggregation (stage 1): Once the local statistics have been aggregated each machine proceeds by aggregating its local counts n(t, w) with memcached on a per-word basis.</figDesc><table /><note><p>Algorithm 2 Global State Aggregation Set (IP, 'stage 1') on memcached for all words w on computer do Lock word w on memcached globally Retrieve n(t, w) from memcached Add local counts via n(t, w) = n(t, w) + n local (t, w) Write n(t, w) to memcached Release lock on w end for</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head>Table 1 :</head><label>1</label><figDesc>8 core Intel CPUs of approximately 2GHz speed and a Hadoop cluster with similar configuration which was being used for production work during our exper-Runtime for single machine execution (1000 topics for news, 2000 topics for pubmed, 1000 Gibbs sampler iterations each). The experiments were carried out on a dedicated 8-core workstation.</figDesc><table><row><cell>dataset</cell><cell></cell><cell>10k</cell><cell>20k</cell><cell>50k</cell><cell>100k</cell><cell>200k</cell><cell>500k</cell><cell>1m</cell></row><row><cell cols="2">pubmed runtime (hours)</cell><cell>.28</cell><cell>.43</cell><cell>1.03</cell><cell>1.33</cell><cell>4.42</cell><cell cols="2">7.48 15.12</cell></row><row><cell></cell><cell>initial # topics/word</cell><cell>12.2</cell><cell>17.0</cell><cell>26.8</cell><cell>38.9</cell><cell>58.2</cell><cell cols="2">99.1 154.6</cell></row><row><cell></cell><cell cols="8">throughput (documents/hour) 35.3K 46.2K 48.4K 75.0K 45.3K 66.8K 66.3K</cell></row><row><cell>news</cell><cell>runtime (hours)</cell><cell>.40</cell><cell>.72</cell><cell>1.75</cell><cell>2.87</cell><cell cols="3">4.70 11.45 24.40</cell></row><row><cell></cell><cell>initial # topics/word</cell><cell>10.4</cell><cell>12.9</cell><cell>16.5</cell><cell>19.4</cell><cell>22.1</cell><cell>24.8</cell><cell>25.7</cell></row><row><cell></cell><cell cols="8">throughput (documents/hour) 25.0K 27.9K 28.6K 34.9K 42.5K 43.7K 41.0K</cell></row><row><cell></cell><cell></cell><cell>pubmed</cell><cell></cell><cell></cell><cell></cell><cell cols="2">news</cell></row><row><cell></cell><cell>computers</cell><cell>10</cell><cell>20</cell><cell></cell><cell>50</cell><cell>100</cell><cell>100</cell></row><row><cell></cell><cell>runtime (hours)</cell><cell>17.2</cell><cell>9.0</cell><cell></cell><cell>4.1</cell><cell>2.8</cell><cell>12.5</cell></row><row><cell></cell><cell>throughput (documents/hour)</cell><cell cols="6">47.6K 45.9K 40.3K 28.9K 16.3K</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head>Table 2 :</head><label>2</label><figDesc>Runtime for multi machine execution (1000 topics for news, 2000 topics for pubmed, 1000 Gibbs sampler iterations each). The experiments were carried out on a production Hadoop cluster which was executing other jobs at the same time. The timing results for news are only reported on 100 nodes since the amount of memory required to store the (topic,word) table for a larger number of documents would have exceeded the amount of memory available per machine.</figDesc><table><row><cell>computers</cell><cell></cell><cell>1</cell><cell>2</cell><cell>5</cell><cell>10</cell><cell>20</cell><cell>41</cell><cell></cell></row><row><cell>pubmed</cell><cell>runtime (hours)</cell><cell>3.2</cell><cell>4.2</cell><cell>4.1</cell><cell>4.2</cell><cell>4.4</cell><cell>4.8</cell><cell></cell></row><row><cell></cell><cell>initial # topics/word</cell><cell cols="6">58.2 107.1 209.1 318.6 472.6 679.6</cell><cell></cell></row><row><cell></cell><cell cols="7">throughput (documents/hour) 62.8K 47.4K 49.3K 47.4K 45.2K 41.7K</cell><cell></cell></row><row><cell>computers</cell><cell></cell><cell>1</cell><cell>2</cell><cell>5</cell><cell>10</cell><cell>20</cell><cell>50</cell><cell>100</cell></row><row><cell>news</cell><cell>runtime (hours)</cell><cell>4.6</cell><cell>7.5</cell><cell>7.9</cell><cell>8.1</cell><cell>9.0</cell><cell>10.9</cell><cell>12.5</cell></row><row><cell></cell><cell>initial # topics/word</cell><cell>22.1</cell><cell>39.3</cell><cell cols="5">74.7 108.9 159.4 244.2 322.4</cell></row><row><cell></cell><cell cols="8">throughput (documents/hour) 43.8K 26.8K 25.2K 24.6K 22.3K 18.3K 16.3K</cell></row><row><cell>Table</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8"><head>Table 4 :</head><label>4</label><figDesc>Log-likelihood for 2m news documents after 1000 sampling iterations.</figDesc><table /></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>In our implementation we omit using a Pitman-Yor or Dirichlet Process. The rationale is that memory allocation becomes a crucial issue and we prefer being able to have direct control over it rather than relying on a suitably chosen set of parameters of the DP to address memory allocation. That said, there is no mathematical reason for this limitation.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><p>For instance, if we were to see all documents related to politics in sequence our instantaneous parameter choice for the topic prior α would become significantly biased towards related topics, thus slowing down convergence.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2"><p>http://code.google.com/p/protobuf/</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_3"><p>http://www.threadingbuildingblocks.org/</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_4"><p>http://www.danga.com/memcached/</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_5"><p>This is easily achieved by a suitable startup script or alternatively by registering its IP number with memcached with a known server.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div><head>Acknowledgments</head><p>The authors thank <rs type="person">Wray Buntine</rs> and <rs type="person">James Petterson</rs> for valuable suggestions. This work is supported by a grant of the <rs type="funder">Australian Research Council</rs>. We plan on making our codebase available for public use.</p></div>
			</div>
			<listOrg type="funding">
			</listOrg>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName><surname>References</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">The generalized distributive law</title>
		<author>
			<persName><forename type="first">S</forename><surname>Aji</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Mceliece</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE IT</title>
		<imprint>
			<biblScope unit="volume">46</biblScope>
			<biblScope unit="page" from="325" to="343" />
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Asynchronous distributed learning of topic models</title>
		<author>
			<persName><forename type="first">A</forename><surname>Asuncion</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Smyth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Welling</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NIPS</title>
		<imprint>
			<publisher>MIT Press</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="81" to="88" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Latent Dirichlet allocation</title>
		<author>
			<persName><forename type="first">D</forename><surname>Blei</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Ng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Jordan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">JMLR</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="993" to="1022" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<author>
			<persName><forename type="first">S</forename><surname>Boyd</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Vandenberghe</surname></persName>
		</author>
		<title level="m">Convex Optimization</title>
		<meeting><address><addrLine>UK</addrLine></address></meeting>
		<imprint>
			<publisher>Cambridge University Press</publisher>
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Residual splash for optimally parallelizing belief propagation</title>
		<author>
			<persName><forename type="first">J</forename><surname>Gonzalez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Low</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Guestrin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">AISTATS</title>
		<meeting><address><addrLine>Clearwater Beach, FL</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Finding scientific topics</title>
		<author>
			<persName><forename type="first">T</forename><surname>Griffiths</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Steyvers</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PNAS</title>
		<imprint>
			<biblScope unit="volume">101</biblScope>
			<biblScope unit="page" from="5228" to="5235" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Distributed algorithms for topic models</title>
		<author>
			<persName><forename type="first">D</forename><surname>Newman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Asuncion</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Smyth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Welling</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Rethinking LDA: Why priors matter</title>
		<author>
			<persName><forename type="first">H</forename><surname>Wallach</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Mimno</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Mccallum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">NIPS</title>
		<imprint>
			<biblScope unit="page" from="1973" to="1981" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">PLDA: Parallel latent dirichlet allocation for large-scale applications</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Bai</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Stanton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Chang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of 5th International Conference on Algorithmic Aspects in Information and Management</title>
		<meeting>of 5th International Conference on Algorithmic Aspects in Information and Management</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Efficient methods for topic model inference on streaming document collections</title>
		<author>
			<persName><forename type="first">L</forename><surname>Yao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Mimno</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Mccallum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">KDD&apos;09</title>
		<imprint>
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
